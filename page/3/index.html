<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/3/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-4.5.面向对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.5.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:23:34.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.5.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象<strong>思想</strong>：面向对象是基于面向过程的编程思想。</p>
<p>​    面向过程：强调的是每一个功能的步骤</p>
<p>​    面向对象：强调的是对象，然后由对象去调用功能</p>
<p>面向对象<strong>特点</strong>：是一种更符合我们思想习惯的思想；可以将复杂的事情简单化；将我们从执行者变为指挥者。</p>
<p>面向对象<strong>开发</strong>：就是不断创建对象，使用对象，指挥对象做事情。</p>
<p>面向对象<strong>设计</strong>：管理和维护对象之间的关系。</p>
<p>面向对象<strong>特征</strong>：</p>
<ol>
<li><p>封装（encapsulation）</p>
</li>
<li><p>继承(inheritance)</p>
</li>
<li><p>多态(polymorphism)</p>
</li>
</ol>
<p>完成某个需求时：</p>
<ol>
<li><p>分析有哪些类：UML（统一建模语言），名词提取法。</p>
</li>
<li><p>每个类都有哪些东西：属性，方法</p>
</li>
<li><p>类与类之间的关系是什么：耦合</p>
</li>
</ol>
<h1 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h1><p>java中最基本的单位是类。</p>
<p>类：一组相关的属性和行为的集合，是一个抽象的概念。</p>
<p>事物就是通过类来体现出来。事物是由属性（该事务的描述信息）和行为（该事务能做什么）组成。</p>
<p>对应类中为：成员变量和成员方法。</p>
<p>对象：是该类事物的具体实现形式，具体存在的个体。</p>
<p>​    成员变量：和以前变量的定义是一样的格式，但是位置不同，在类中方法外。</p>
<p>​    成员方法：和以前的方法定义是一样的格式，但是把static去掉。</p>
<p>如何使用类及类中的属性和行为呢：创建该类的一个对象使用。</p>
<p>格式： <code>类名  对象名=new  类名（）;</code></p>
<p>如何使用成员变量：  对象名.变量名</p>
<p>如何使用成员方法：  对象名.方法名(参数…)</p>
<p>匿名对象：就是没有名字的对象。</p>
<p>应用场景：</p>
<p>A：调用方法：仅仅只调用一次的时候（若多次调用，不适合）</p>
<p>优点：匿名对象调用是在堆内存中，调用完毕就是垃圾，可以被垃圾回收器回收</p>
<p>B：匿名对象可以作为实际参数传递。（当方法中的形式参数是一个引用类型比如类的时候，实际参数可以用匿名对象当作该类的一个对象）</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>通过对象给成员变量赋值，可以赋值一些非法的数据，这是不合理的。</p>
<p>在赋值之前，应该先对数据进行判断。怎么进行判断呢？就是写一个方法对数据进行校验。但是不用方法就起不到作用了。所以要求必须使用方法，不能直接调用成员变量。</p>
<p>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p>
<p>原则：将不需要对外提供的内容都隐藏起来。把属性隐藏，提供公共方法对其访问。</p>
<p>优点：隐藏实现细节，提供公共的访问方式；提高了代码的复用性；提高安全性。</p>
<p>private：私有的，是一个权限修饰符，可以修饰成员变量和成员方法。</p>
<p>被private修饰的成员只能在本类中访问。</p>
<p>最常见的应用：把成员变量用private修饰，提供对应的getXxx（）/setXxx（）方法以使外界可以访问</p>
<p>this关键字：this代表所在当前类的一个对象引用。</p>
<p>方法被哪个对象调用，this就代表那个对象。</p>
<p>用this的场景：当局部变量隐藏成员变量时，成员变量可能被局部变量覆盖无意义，所以要用this。   super</p>
<p><strong>构造方法</strong></p>
<p>作用：给对象的数据进行初始化</p>
<p>格式：方法名和类名相同。没有返回值，连void都没有。没有具体的返回值。</p>
<p>注意事项：如果不提供构造方法，系统会给出默认的构造方法</p>
<p>如果提供了构造方法，系统将不再提供默认的构造方法。如果还想使用无参构造方法，就必须自己给出，建议永远自己给出无参构造方法。</p>
<p>构造方法也可以重载。</p>
<p>给成员变量赋值有2种方法：</p>
<p>A. 无参构造方法+setXxx();</p>
<p>B. 带参构造方法</p>
<p>类中包含有：成员变量、成员方法、构造方法。</p>
<p><strong>成员方法</strong></p>
<p>根据返回值可以分为：void类型和非void类型。</p>
<p>根据形式参数：空参方法和非空参方法。</p>
<p><code>Student s=new Student();</code>在内存中发生了什么？</p>
<ol>
<li><p>加载Student.class文件进内存</p>
</li>
<li><p>在栈内存为s开辟空间</p>
</li>
<li><p>在堆内存为学生对象开辟空间</p>
</li>
<li><p>对学生对象的成员变量进行默认初始化。null  0   0.0   \u0000</p>
</li>
<li><p>对学生对象的成员变量进行显式初始化</p>
</li>
<li><p>通过构造方法对学生对象的成员变量赋值</p>
</li>
<li><p>学生对象初始化完毕，把对象地址赋值给s变量。</p>
</li>
</ol>
<p>当一个变量是用来描述类的信息时，这个变量就应该被定义为成员变量。（成员变量不要瞎定义）</p>
<p>变量的范围是越小越好，因为能及时的被回收。</p>
<p>当多个对象有共同的成员变量值的时候，java就提供了一个关键字来修饰：static。</p>
<p>static可以修饰成员变量和成员方法。</p>
<p>static关键字的特点：随着类的加载而加载；优先于对象存在；被类的所有对象共享（这也是我们判断是否使用静态关键字的条件）；可以通过类名调用（其实本身也可以通过对象名调用，推荐使用类名调用）静态修饰的内容我们一般称为与类相关的，类成员</p>
<p>注意事项：在静态方法中是没有this关键字的（因为静态是随着类的加载而加载，而this是随着对象的创建而存在，静态比对象先存在）</p>
<p>静态方法只能访问静态的成员变量和静态的成员方法。(main方法是静态方法，不能调用非静态方法，如果想调用的话，可以先在main方法中创建一个对象，通过这个对象来调用非静态方法)</p>
<p>非静态方法可以访问静态的成员变量和成员方法，也可以访问非静态的成员变量和成员方法。</p>
<p>静态变量和成员变量的区别：</p>
<p>所属不同：静态变量属于类，也被称为类变量</p>
<p>​                    成员变量属于对象，也被称为实例变量（对象变量）</p>
<p>内存中的位置不同：静态变量存储于方法区的静态区</p>
<p>​                    成员变量存储于堆内存中</p>
<p>内存出现的时间不同：静态变量随着类的加载而加载，随着类的消失而消失</p>
<p>​                    成员变量随着对象的创建而存在，随着对象的消失而消失</p>
<p>调用不同：静态变量可以通过类名调用，也可以通过对象名调用</p>
<p>​                    成员变量只能通过对象名调用</p>
<p>main方法的格式讲解：</p>
<p>public:公共的，访问权限是最大的。由于main方法是被jvm调用的，所以权限要够大。</p>
<p>static:静态的，不需要创建对象，通过类名就可以调用，方便jvm的调用。</p>
<p>void:方法的返回值是返回给调用者，而main方法是被jvm调用的，返回给jvm无意义。</p>
<p>main：是一个常见的方法入口，所有语言都是以main方法为入口</p>
<p>String[] args:这是一个字符串数组。这个东西早期是为了接收键盘录入的数据的。</p>
<p>eg：java  类名  hello  world  java  遍历args就会发现是 hello  world  java</p>
<p>后来用java.util.Scanner代替了</p>
<p>测试类的作用：创建其他类的对象，调用其他类的功能。</p>
<p>在同一个文件夹下，类定义在两个文件中和定义在一个文件中其实一样的。</p>
<p>静态的一种用法：在工具类中，将构造方法私有化，这样外界无法创建该类的对象，然后将要调用的方法static静态化，这样main方法调用时候只能通过类名.方法名调用。</p>
<p>项目提供的都是class文件，无从得知class文件内都有哪些方法哪些属性。所以需要加说明书。</p>
<p>说明书的制作：</p>
<p>A：写一个工具类</p>
<p>B：对这个类加文档注释：</p>
<p>/**</p>
<p>*@author</p>
<p>*@version</p>
<p>*@param</p>
<p>*return</p>
<p>*/</p>
<p>C:用工具解析文档注释：javadoc工具</p>
<p>D：格式：</p>
<p>javadoc  -d  (文件夹的路径)  -author  -version  (类名).java</p>
<p>制作帮助文档出错：找不到可以文档化的公共或受保护的类。告诉我们类的权限不够。（若想权限够，在class前加public）</p>
<p>所以以后开发可以利用工具类加说明书，对该类中实现的方法的static、返回值、方法名、参数注意然后就可以调用使用，对怎么实现的方法不用在意，这就是面向对象思想。</p>
<p>.html转换为帮助文档就是.chm文档</p>
<p>使用帮助文档API（Application Progaramming Interface,应用程序编程接口）：</p>
<ol>
<li><p>打开帮助文档</p>
</li>
<li><p>点击显示，找到索引，找到输入框</p>
</li>
<li><p>明确要找什么</p>
</li>
<li><p>在输入框内输入要查找的类，回车</p>
</li>
<li><p>看包，java.lang包下的类不需要导入，其他的都需要全部导入</p>
</li>
<li><p>再简单的看看类的解释和说明，类的版本信息</p>
</li>
<li><p>看类的结构</p>
<p>成员变量：字段摘要</p>
<p>构造方法：构造方法摘要</p>
<p>成员方法：方法摘要</p>
</li>
<li><p>学习构造方法</p>
<p>有构造方法：创建对象</p>
<p>无构造方法：成员可能都是静态的</p>
</li>
<li><p>看成员方法：</p>
<p>静态、返回值类型、方法名、参数列表。</p>
</li>
</ol>
<p>代码块：在java中使用｛｝括起来的代码称为代码块，根据其声明和位置不同，可以分为局部代码块，构造代码块，静态代码块和同步代码块。</p>
<p>局部代码块：局部位置，在方法中出现，限定变量生命周期，及早释放，提高内存利用率。</p>
<p>构造代码块：在类中成员位置出现（直接｛｝括起来），每次调用构造方法都执行，并且在构造方法前执行。</p>
<p>作用：可以把多个构造方法方法中相同的代码存放到一起。</p>
<p>静态代码块：在类中成员位置出现（直接｛｝括起来），｛前面加了static修饰。在加载的时候就执行，且只执行一次。</p>
<p>作用：用于给类进行初始化。</p>
<p>一个类中的执行顺序：与书写顺序无关，执行时都是这个顺序</p>
<p>静态代码块（只执行一次，加载类的时候就执行）–构造代码块（每次调用构造方法都执行）–构造方法</p>
<p>Math类：是针对数学进行操作的类，没有构造方法，成员都是静态的。</p>
<p>产生随机数：public static double random():  [0.0,1.0)</p>
<p>产生1-100的随机数：int number=(new)(Math.random()*100)+1;</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>多个类的成员变量，成员方法等都是相同的。每一次定义的时候都需要重新定义一遍，所以要考虑改进，提高代码的复用性，用继承。</p>
<p>多个类中存在相同的属性和行为时，将这些内容抽取到单独的一个类中，那么多个类无需在定义这些属性和行为，只要继承那个类即可。</p>
<p>格式：</p>
<p>class 子类名  extends  父类名{}</p>
<p>单独的这个类称为父类，基类，超类。</p>
<p>多个类称为子类，派生类。</p>
<p>优点：提高了代码的复用性：多个类相同的成员可以放到同一个类中</p>
<p>提高了代码的维护性：如果功能的代码需要修改，修改一处即可。</p>
<p>让类与类之间产生了关系，是多态的前提。（也是继承的弊端：类的耦合性很强）</p>
<p>开发的原则：低耦合，高内聚。</p>
<p>耦合：类与类的关系</p>
<p>内聚：自己完成某件事情的能力</p>
<p>继承的特点：</p>
<p>\1. java中只支持单继承，不支持多继承。（C++支持多继承，格式：extends 类1，类2…）</p>
<p>\2. java支持多层继承（继承体系）</p>
<p>继承的注意事项：</p>
<p>\1. 子类只能继承父类所有非私有的成员（成员方法和成员变量），也体现了继承的一个弊端：打破了封装性</p>
<p>\2. 子类不能继承父类的构造方法，但是可以通过super关键字来访问父类的构造方法</p>
<p>\3. 不要为了部分功能而去继承（当类与类之间的关系是“is a”的关系时使用继承）子类is父类的a</p>
<p>子类中的成员变量和父类中的成员变量如果一样的话，再调用时候遵循就近原则。</p>
<p>在子类方法中访问一个变量的查找顺序：1.在子类方法的局部范围找，有就用</p>
<p>2.在子类的成员范围找，有就用</p>
<p>\3. 在父类的成员范围找（不可能在父类的方法局部范围找，因为方法不调用不执行，相当于没有）</p>
<p>super关键字：super代表父类存储空间的标识（父类引用，可以操作父类的成员，但不是父类的一个对象，只是父类的一个存储空间）</p>
<p>this代表本类对象的引用</p>
<p>用法：</p>
<p>A. 调用成员变量：</p>
<p>this.成员变量：调用本类的成员变量</p>
<p>super.成员变量：调用父类的成员变量</p>
<p>B. 调用构造方法：</p>
<p>this（…）：调用本类的构造方法</p>
<p>super（…）：调用父类的构造方法</p>
<p>C. 调用成员方法：</p>
<p>this.成员方法：调用本类的成员方法</p>
<p>super.成员方法：调用父类的成员方法</p>
<p>继承中构造方法的关系：子类中所有的构造方法默认都会先访问父类中空参数的构造方法。</p>
<p>因为子类会继承父类中的数据，可能还会使用父类的数据，所以，子类初始化之前，一定要先完成父类数据的初始化。每一个构造方法的第一条语句默认都是super（）;</p>
<p>如果父类没有无参构造方法，那么子类的构造方法会出现报错。（这就是为什么建议构造方法永远手动给个无参的构造方法）</p>
<p>解决方法：A.在父类中加一个无参构造方法</p>
<p>B.子类通过super(…)去显示调用父类其他的带参的构造方法。</p>
<p>C. 子类通过this去调用本类的其他构造方法,但是一定会有一个去访问了父类的构造方法。</p>
<p>子类中一定要有一个去访问了父类的构造方法，否则父类的数据就没有初始化。</p>
<p>注意事项：this（）或者super（）必须出现在第一条语句上。如果 不是放在第一条语句上，就可能会对父类数据进行了多次初始化。</p>
<p>一个类的初始化过程：成员变量进行初始化（默认初始化，显示初始化），构造方法初始化</p>
<p>子父类的初始化（分层初始化）先进行父类初始化，再进行子类初始化。虽然子类中构造方法默认有一个super() ，但是初始化的时候不是按照那个顺序的，而是按照分层初始化进行的。super()只是表示要先初始化父类数据在初始化子类数据。</p>
<p>继承中成员方法的关系：通过子类对象去访问一个方法，首先在子类中找，然后在父类中找，如果没有就报错（不会去父类的父类中找）</p>
<p>方法重写（方法覆盖，方法复写）：子类中出现了和父类中方法声明一模一样的方法。</p>
<p>方法重载：本类中出现的方法名一样，参数列表不同的方法，与返回值无关。</p>
<p>方法重写的应用：当子类需要父类的功能，而功能主体子类有自己特有的内容时，可以重写父类中的方法（重写是完全重写，如果还想用父类中的方法内容，可以用super调用），这样，既沿袭了父类的功能，又定义了子类特有的功能。</p>
<p>注意事项：父类中私有方法不能被重写。（其实父类中私有方法子类根本就无法继承，更谈不上重写）</p>
<p>子类重写父类方法时，访问权限不能更低。（最好就一致）</p>
<p>父类是静态方法，子类也必须通过静态方法进行重写。（其实不算方法重写）</p>
<p>父类不是静态，子类用static静态，会报错。</p>
<p>所以，子类重写父类方法的时候，最好声明一模一样。</p>
<p>由于继承中方法有一个方法重写，所以父类的功能会被子类覆盖，当不想让覆盖的时候，java提供了一个关键字：final</p>
<p>final：最终的意思。可以修饰类、方法、变量。</p>
<p>final可以修饰类：该类不能被继承</p>
<p>final可以修饰方法：该方法不能被重写</p>
<p>final可以修饰变量：该变量不能被重新赋值。这个变量其实是常量。</p>
<p>final修饰局部变量（一般权限修饰符修饰局部变量无意义，但是final特殊）：在方法内部，该变量不能被改变。</p>
<p>在方法声明上，基本类型是值不能被改变。引用类型是地址值不能被改变，但是该对象的堆内存的值还可以改变，注意区别。</p>
<p>final修饰变量的初始化时机：</p>
<p>1.被final修饰的变量只能赋值一次</p>
<p>2.在初始化时就给值（建议）或者在构造方法完毕前给值（非静态的常量）。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="*多态*"></a><em><strong>*多态*</strong></em></h1><p>多态：同一个对象，在不同时刻体现出不同的状态。</p>
<p>判断多态可以从左往右念：子是父？是的话可以多态，不是的话不能。</p>
<p>多态的前提：</p>
<p>A. 要有继承或者实现关系。</p>
<p>B. 要有方法重写。（如果没有方法重写也是可以的，但是就没有了意义）</p>
<p>C. 要有父类或者父接口引用指向子类对象。</p>
<p>父  f=new 子();</p>
<p>多态中的成员访问特点：</p>
<p>A. 成员变量：编译看左边（父类），运行看左边。</p>
<p>B. 构造方法：创建子类对象的时候，访问父类的构造方法，并对父类的数据进行初始化。</p>
<p>C. 成员方法：编译看左边（父类），运行看右边（方法重写相当于覆盖了）。</p>
<p>D. 静态方法：编译看左边（父类），运行看左边。（所以说静态方法的重写根本不算是重写）</p>
<p>由于成员方法存在方法重写，所以只有它运行的时候看右边。</p>
<p>多态的好处：</p>
<p>A. 提高了代码的维护性（继承保证）</p>
<p>B. 提高了代码的扩展性（由多态保证，以后如果在添加父类的子类，可以使用父类的引用调用工具类，便于代码的扩展性）</p>
<p>多态的弊端：不能使用子类的特有功能。</p>
<p>如果非要调用子类的这些功能：</p>
<p>A. 创建子类的对象调用方法。（可以，但是不合理，太占内存）</p>
<p>B. 把父类的引用强制转换为子类的引用。（向下转型）</p>
<p>Fu  f=new Zi();  (向上转型，从子到父，父类引用指向子类对象)</p>
<p>Zi  z=(Zi)f;   （向下转型，从父到子，父类引用转为子类对象） 要求f必须是能够转换为Zi的。</p>
<p>ClassCastException：类型转换异常，一般在多态的向下转型中容易出现。</p>
<p>当一个类中的东西特别多时，我们可以把这个类分成几个小类：基本类、操作类等。</p>
<p>分包：A.功能划分</p>
<p>B.模块划分</p>
<p>C.先按模块划分，再按功能划分</p>
<p>集合实现，IO实现，GUI实现，数据库实现。</p>
<p>如果一个方法传的参数是三个以上，建议传个对象。</p>
<p>如果多个地方用到了某个变量，可以把这个变量定义为成员变量，定义在成员方法外。</p>
<p>能小范围尽量不大范围，因为用完最好回收。</p>
<p>让多个对象共享同一个成员变量，用static修饰。</p>
<p>循环里面如果有switch，并且在其中有break，结束的不是循环，而是switch语句，如果想结束整体，可以用 System.exit(0);</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.5.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" data-id="ckpnvjm8q000l48wd581v9xym" data-title="面向对象" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.22.关于null" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.22.%E5%85%B3%E4%BA%8Enull/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:18:39.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.22.%E5%85%B3%E4%BA%8Enull/">关于null</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>开发原则：只要是对象，我们就要判断对象是否为null。</p>
<p>java空指针异常：java.lang.NullPointException</p>
<p> 对于每一个java程序员来说，几乎都避免不了遇到空指针异常，特别是经验不足的初学者。而且由于它的调试和查找相对其它异常来说比较困难，常常需要花费很大的精力去解决它。</p>
<p>  <strong>首先认识一下java中的null</strong></p>
<p>  null是Java中一个很重要的概念。null设计初衷是为了表示一些缺失的东西，例如缺失的用户、资源或其他东西。但是，一年后，令人头疼的空指针异常给Java程序员带来不少的骚扰。</p>
<p>  null是java中的关键字，因此，它不能写成NULL，Null，只能是null。</p>
<p>  null是所有引用类型的默认值，如果没有让一个引用指向一个实际存在的对象，它的默认值就是null。null本质上是一个值，这跟int的默认值是0，boolean的默认值是false一样。现在，我们通常都使用像eclipse等的集成开发环境进行开发，一般在定义变量的时候都会进行初始化（这也是写代码的一个良好的习惯），如果没有进行初始化，系统会进行提示。</p>
<p><strong>报空指针异常的原因有以下几种：</strong> </p>
<p>1字符串变量未初始化；<br>2接口类型的对象没有用具体的类初始化，比如：<br>List it；会报错<br>List it = new ArrayList()；则不会报错了<br>3当一个对象的值为空时，你没有判断为空的情况。你可以试着把下面的代码前加一行代码：<br>if(rb!=null &amp;&amp; rb!=””)<br>改成：<br>if(rb == null);<br>if(rb!==null&amp;&amp;rb!=””) 或者if(“”).equals(rb))<br>空指针的解决办法：<br>    重点关注报错发生的所在行，通过空指针异常产生的两条主要原因诊断具体的错误。同时为了避免空指针的发生，最好在做判断处理时将“null”或者空值放于 设定的值之前。<br>常见空指针异常的简要分析：<br>（1）空指针错误<br>  Java中的8种基本数据类型，变量的值可以有其默认值，加入没有对其正常赋值，java虚拟机是不能 正确编译通过的，因此使用基本的Java数据类型一般是不会引起空指针异常的。实际开发中，大多数的空指针异常主要与对象的操作相关。<br>  下面列出可能发生空指针异常的几种情况及相应解决方案：<br>  代码段1：<br>　　out.println(request.getParameter(“username”));<br>　　分析：代码段1的功能十分简单，就是输出用户输入”username”的值。<br>    说明：看上去，上面的语句找不出什么语法错误，而且在大多数情况下也遇不到什么问题。但是，如果某个用户在输入数据时并没有提供表单 域”username” 的值，或通过某种途径绕过表单直接输入时，此request.getParameter(“username”)的值为空（注意不是空字符串，是空对象 null。），out对象的println方法是无法直接对空对象操作的，因此代码段1所在的JSP页面将会抛出 “Java.lang.NullPointerException”异常。而且即使对象可能为空时，也调用Java.lang.Object或 Object对象本身的一些方法如toString()， equal(Object obj)等操作。<br>  代码段2：<br>　　String userName = request.getParameter(“username”);<br>　　If (userName.equals(“root”))<br>　　{….}<br>　　分析：代码段2的功能是检测用户提供的用户名，如果是用户名称为”root”的用户时，就执行一些特别的操作。<br>   说明：在代码段2中，如果有用户没有提供表单域”username”的值时，字符串对象userName为null值，不能够将一个null的对象与另一 个对象直接比较，同样，代码段2所在的JSP页面就会抛空指针错误。<br>   一个小技巧：如果要把某个方法的返回值与常量做比较，把常量放在前面，可以避免调用null对象的equals方法。譬如：<br>  If (“root”.equals(userName))<br>　 {….}<br>  即使userName对象返回了null对象，这里也不会有空指针异常，可以照常运转。<br>  代码段3：<br>　　String userName = session.getAttribute(“session.username”).toString();<br>    分析：代码段3的功能是将session中session.username的值取出，并将该值赋给字符串对象userName。<br>    说明：在一般情况下，如果在用户已经进行某个会话，则不会出现什么问题；但是，如果此时应用服务器重新启动，而用户还没有重新登录，（也可能是用户关闭浏 览器，但是仍打开原来的页面。）那么，此时该session的值就会失效，同时导致session中的session.username的值为空。对一个 为 null的对象的直接执行toString()操作，就会导致系统抛出空指针异常。<br>  代码段4：<br>public static void main(String args[]){<br>    Person p=null;<br>    p.setName(“张三”)；<br>    System.out.println(p.getName());<br>}<br>分析：声明一个Person对象，并打印出该对象的中的Name名字。<br>说明：这个时候你的p就出现空指针异常，因为你只是声明了这个Person类型的对象并没有创建对象，所以它的堆里面没有地址引用，切忌你要用对 象掉用方法的时候一定要创建对象。</p>
<p>为了避免空指针调用，我们经常会看到这样的语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...if (someobject !&#x3D; null) &#123;</span><br><span class="line">    someobject.doCalc();&#125;...</span><br></pre></td></tr></table></figure>

<p>最终，项目中会存在大量判空代码，多么丑陋繁冗！如何避免这种情况？我们是否滥用了判空呢？</p>
<p>在方法中返回null，在调用这些方法时，也不得不去判空。另外，也许受此习惯影响，他们总潜意识地认为，所有的返回都是不可信任的，为了保护自己程序，就加了大量的判空</p>
<p>进行判空前，请区分以下两种情况：</p>
<p>1、null 是一个有效有意义的返回值(Where null is a valid response in terms of the contract; and)</p>
<p>2、null是无效有误的(Where it isn’t a valid response.)</p>
<p>你可能还不明白这两句话的意思，不急，继续往下看，接下来将详细讨论这两种情况</p>
<p><strong>先说第2种情况</strong></p>
<p>null就是一个不合理的参数，就应该明确地中断程序，往外抛错误。这种情况常见于api方法。例如你开发了一个接口，id是一个必选的参数，如果调用方没传这个参数给你，当然不行。你要感知到这个情况，告诉调用方“嘿，哥们，你传个null给我做甚”。</p>
<p>相对于判空语句，更好的检查方式有两个</p>
<p>(1)assert语句，你可以把错误原因放到assert的参数中，这样不仅能保护你的程序不往下走，而且还能把错误原因返回给调用方，岂不是一举两得。（原文介绍了assert的使用，这里省略）</p>
<p>(2)也可以直接抛出空指针异常。上面说了，此时null是个不合理的参数，有问题就是有问题，就应该大大方方往外抛。</p>
<p><strong>第1种情况会更复杂一些。</strong></p>
<p>这种情况下，null是个”看上去“合理的值，例如，我查询数据库，某个查询条件下，就是没有对应值，此时null算是表达了“空”的概念。</p>
<p>这里给一些实践建议：</p>
<p><strong>1、假如方法的返回类型是collections，当返回结果是空时，你可以返回一个空的collections</strong>（empty list),而不要返回null，这样调用侧就能大胆地处理这个返回，例如调用侧拿到返回后，可以直接print list.size()，又无需担心空指针问题。（什么？想调用这个方法时，不记得之前实现该方法有没按照这个原则？所以说，代码习惯很重要！如果你养成习惯，都是这样写代码（<strong>返回空collections而不返回null</strong>)，你调用自己写的方法时，就能大胆地忽略判空）</p>
<p><strong>2、返回类型不是collections，又怎么办呢？</strong></p>
<p><strong>那就返回一个空对象（而非null对象）</strong>，下面举个“栗子”，假设有如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span> </span>&#123;</span><br><span class="line">  <span class="function">Action <span class="title">findAction</span><span class="params">(String userInput)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Parse有一个接口FindAction，这个接口会依据用户的输入，找到并执行对应的动作。假如用户输入不对，可能就找不到对应的动作（Action），因此findAction就会返回null，接下来action调用doSomething方法时,就会出现空指针。</p>
<p>解决这个问题的一个方式，就是使用Null Object pattern（空对象模式）</p>
<p>我们来改造一下</p>
<p>类定义如下，这样定义findAction方法后，确保无论用户输入什么，都不会返回null对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParser</span> <span class="keyword">implements</span> <span class="title">Parser</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Action DO_NOTHING = <span class="keyword">new</span> Action() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; <span class="comment">/* do nothing */</span> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Action <span class="title">findAction</span><span class="params">(String userInput)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">/* we can&#x27;t find any actions */</span> ) &#123;</span><br><span class="line">      <span class="keyword">return</span> DO_NOTHING;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>对比下面两份调用实例</p>
<p>1、冗余:每获取一个对象，就判一次空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Parser parser = ParserFactory.getParser();</span><br><span class="line"><span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// now what?</span></span><br><span class="line">  <span class="comment">// this would be an example of where null isn&#x27;t (or shouldn&#x27;t be) a valid response</span></span><br><span class="line">&#125;</span><br><span class="line">Action action = parser.findAction(someInput);</span><br><span class="line"><span class="keyword">if</span> (action == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// do nothing</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  action.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、精简</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserFactory.getParser().findAction(someInput).doSomething();</span><br></pre></td></tr></table></figure>

<p>因为无论什么情况，都不会返回空对象，因此通过findAction拿到action后，可以放心地调用action的方法。</p>
<p><strong>其他回答精选：</strong></p>
<p>1、如果要用equal方法，请用object&lt;不可能为空&gt;.equal(object&lt;可能为空&gt;))</p>
<p>例如：</p>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;bar&quot;.equals(foo) </span><br></pre></td></tr></table></figure>

<p>而不是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.equals(&quot;bar&quot;) </span><br></pre></td></tr></table></figure>

<p>2、Java8或者guava lib中，提供了Optional类，这是一个元素容器，通过它来封装对象，可以减少判空。不过代码量还是不少。不爽。</p>
<p>3、如果你想返回null，请挺下来想一想，这个地方是否更应该抛出一个异常</p>
<h3 id="null与””的区别"><a href="#null与””的区别" class="headerlink" title="null与””的区别"></a>null与””的区别</h3><p>null是没有地址<br>“”是有地址但是里面的内容是空的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">问题一：</span><br><span class="line">null和&quot;&quot;的区别</span><br><span class="line">String s&#x3D;null;</span><br><span class="line">string.trim()就会抛出为空的exception   </span><br><span class="line">String s&#x3D;&quot;&quot;;   </span><br><span class="line">string.trim()就不会抛,为什么? </span><br><span class="line">答：</span><br><span class="line">NULL代表声明了一个空对象，根本就不是一个字符串。   </span><br><span class="line">&quot;&quot;代表声明了一个对象实例，这个对象实例的值是一个长度为0的空字符串。</span><br><span class="line"></span><br><span class="line">NULL代表声明了一个空对象,对空对象做任何操作都不行的,除了&#x3D;和&#x3D;&#x3D;   </span><br><span class="line">&quot;&quot;是一个字符串了,只是这个字符串里面没有内容了</span><br><span class="line"></span><br><span class="line">String s&#x3D;null;只是定义了一个句柄，也就是说你有了个引用，但是这个引用未指向任何内存空间   </span><br><span class="line">String s&#x3D;&quot;&quot;;这个引用已经指向了一块是空字符串的内存空间，是一个实际的东东了，所以你可以对它操作，而不用担心什么了</span><br><span class="line"></span><br><span class="line">你说数字0和没有是不是一种概念啊？？道理一样的</span><br><span class="line"></span><br><span class="line">而且,null可以赋值给任何对象.&quot;&quot;就不行了.</span><br><span class="line"></span><br><span class="line">这里&quot;&quot;和NULL绝对是两个概念   </span><br><span class="line">&quot;&quot;代表一个字符串存在，它的值就是“”   </span><br><span class="line">NULL代表字符串根本没有实际的值，你并不知道它是什么。。。</span><br><span class="line"></span><br><span class="line">哦,我明白了,意思就是String   string   &#x3D;   null   跟String   string;是一回事儿</span><br><span class="line"></span><br><span class="line">null是空对象     &quot;&quot;是空字符串</span><br><span class="line">String s&#x3D;null;&#x2F;&#x2F;null是未分配堆内存空间   </span><br><span class="line">String   a;&#x2F;&#x2F;分配了一个内存空间,没存入任何对象   </span><br><span class="line">String   a&#x3D;&quot;&quot;;&#x2F;&#x2F;分配了一个内存空间,存了一个字符串对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题二：</span><br><span class="line">String s;和String s&#x3D;null;和String s&#x3D;&quot;a&quot;;有什么区别？   </span><br><span class="line">针对这三种情况，使用out.println(s);的时候，第一个会出现异常，第二个会输出null.第三个则会输出a.   </span><br><span class="line">这是为什么呢？这三句声明语句，各自作了什么呢？</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">第一个只是定义了一个String类型变量s，并没有给它赋初值，在Java中，默认在使用一个变量的时候必须赋予它初值（降低风险）。 </span><br><span class="line">第二个和第三个都定义了String类型变量s，并赋予它初值，只不过第二个赋予的值为null（空）罢了</span><br><span class="line"></span><br><span class="line">主要要理解的是String s; s为一个引用～～它不是对象   </span><br><span class="line">第一个是没有初始化的引用；   </span><br><span class="line">第二个为空引用；</span><br><span class="line">第三个是在字符串池里写入一个字符&#39;a&#39;,然后用s指向它。</span><br><span class="line">另外，   </span><br><span class="line">String s&#x3D;&quot;a&quot;和String s&#x3D;new String(&quot;a&quot;);是有本质上的区别的   </span><br><span class="line">前者是在字符串池里写入一个字符&#39;a&#39;,然后用s指向它；</span><br><span class="line">后者是在堆上创建一个内容为&quot;a&quot;的字符串对象。</span><br><span class="line">String   str&#x3D;&quot;aaa&quot;;                    &#x2F;&#x2F;于栈上分配内存</span><br><span class="line">String   str&#x3D;new   String(&quot;aaa&quot;);      &#x2F;&#x2F;于堆上分配内存</span><br><span class="line"></span><br><span class="line">String s; 系统会自动赋值null</span><br><span class="line"></span><br><span class="line">String s;只是给s分配一个内存空间   </span><br><span class="line">String s&#x3D;null;是分配的空间中存储的值为空值   </span><br><span class="line">String s&#x3D;&quot;a&quot;;这句就不用我多说了分配的空间的值为字符a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题三：</span><br><span class="line">声明了一个string a;变量    </span><br><span class="line">在以后的判断中，a&#x3D;&#x3D;&quot;&quot;和a&#x3D;&#x3D;null有何不同?   </span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">如果没有给a赋过值，a&#x3D;&#x3D;&quot;&quot;会导致异常。     </span><br><span class="line">在实际处理时，往往认为&quot;&quot;和null代表相同的含义，即都代表无值。   </span><br><span class="line">此时建议用如下语法：   </span><br><span class="line">if(a&#x3D;&#x3D;null   ||   a&#x3D;&#x3D;&quot;&quot;)   </span><br><span class="line">&#123;   </span><br><span class="line">&#125;   </span><br><span class="line">如果a为null，就不会执行后面的判断，直接返回true。   </span><br><span class="line"></span><br><span class="line">null是用来判断引用类型是否分配了存储空间   </span><br><span class="line">&quot;&quot;是针对字符串的；   </span><br><span class="line">string类型实际上是字符串指针，也即是一个引用类型   </span><br><span class="line">所以如果没有给a赋过值，a&#x3D;&#x3D;&quot;&quot;会导致异常   </span><br><span class="line">所以if(a&#x3D;&#x3D;null   ||   a&#x3D;&#x3D;&quot;&quot;)&#123;&#125;这种写法也是正确的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题四：</span><br><span class="line">String abc&#x3D;null;String abc&#x3D;&quot;&quot;;String abc;三种写法有什么区别？ </span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">1：创建一个空字符串对象，   </span><br><span class="line">2：创建一个字符串为空的字符串对象。   </span><br><span class="line">3：声明一个字符串对象，但并没有分配内存，而1，2已经分配了内存   </span><br><span class="line">对于最后一种表示,你不能if(abc&#x3D;&#x3D;null),或者int   length   &#x3D;   abc.length();编译的时候会提示可能没有初始化.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String   abc&#x3D;null;   </span><br><span class="line">String   abc&#x3D;&quot;&quot;;   </span><br><span class="line">一般推荐使用第二种   </span><br><span class="line">第一种abc指向null，很多时候要判断字符串是否为空时，容易漏掉这种情况，在调用String的相关方法的时候就会出错   </span><br><span class="line">第二种则相对简单，String的方法都可以用，判断的时候也不会出错</span><br><span class="line"></span><br><span class="line">1) String   abc&#x3D;null;   </span><br><span class="line">2) String   abc;    </span><br><span class="line">3）String   a&#x3D;&quot;&quot;;   </span><br><span class="line">4) String   b&#x3D;&quot;&quot;;   </span><br><span class="line">5) String   c&#x3D;new String(&quot;&quot;);   </span><br><span class="line">6) String   d&#x3D;new String(&quot;&quot;); </span><br><span class="line">&#x2F;&#x2F;1)等于2），和C语言不同，JAVA为安全原因不允许一个悬挂引用，没有赋值的引用地址一律自动赋值为NULL，以防止访问到任意内存   </span><br><span class="line">&#x2F;&#x2F;3)和4)中,变量a和b将会指向同一内存地址(&quot;&quot;的地址)   </span><br><span class="line">&#x2F;&#x2F;5)和6)中，变量c和d不会指向同一地址,而是两个&quot;&quot;内容的地址,并且和a,b不同,实际上,3)和4)相当于new String(&quot;&quot;).intern().   </span><br><span class="line">&#x2F;&#x2F;String类维护着一个字符串池,对于像3)和4)这样的赋值方法,String会在这个池中查找字符串是否已经在池中,如果在,就直接指向该地址,</span><br><span class="line"></span><br><span class="line">如果不在,生成一个实例放入池中再指向那个地址,可见对于同样内容的字符串多次引用时3)4)的方法要比5)6)的方法剩内存,之所以这样做,是</span><br><span class="line"></span><br><span class="line">因为String是一个内容不可变的量,运用的是设计模式GOF.FlyWeight   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但有个关键的一点,没有人说到，这就是:   </span><br><span class="line">String s;在什么情况下可以等同于String s&#x3D;null;而在什么情况下又不等同？！</span><br><span class="line">考虑下面的代码:   </span><br><span class="line">&#x2F;&#x2F;StringTest.java   </span><br><span class="line">public   class   StringTest   &#123;      </span><br><span class="line">    static   String   s;     &#x2F;&#x2F;*   </span><br><span class="line">    public   static   void   main(String[]   args)   &#123;   </span><br><span class="line">        &#x2F;&#x2F;String   s;         &#x2F;&#x2F;**   </span><br><span class="line">        System.out.println(s);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;     </span><br><span class="line">编译并运行上面的代码,将打印null。</span><br><span class="line">可见标有*号的行是自动初始化了的(s被自动初始化为null)。   </span><br><span class="line">而如果把标有**号的行取消注释,代码将不能通过编译,这是因为这行定义的是本地变量,而本地变量是不会自动初始化的。</span><br><span class="line">由此得出结论：</span><br><span class="line">在成员变量的定义中,String s;等同于String s&#x3D;null;</span><br><span class="line">而在本地变量(方法变量)的定义中,String s;不等同于String s&#x3D;null;,这时要使用s必须显式地赋值。</span><br><span class="line">这些虽然是小知识点,但在实际应用中很重要,也很容易被一些人忽视,特此提出。</span><br><span class="line">还有一点要说明的是：</span><br><span class="line">只要是在方法在中定义变量都要显示赋初值，main()方法也不例外，而在方法之外编译器回自动赋初值</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.22.%E5%85%B3%E4%BA%8Enull/" data-id="ckpdvjppp004dnswdflidhe1g" data-title="关于null" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.20.JDBC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.20.JDBC/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:18:28.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.20.JDBC/">JDBC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>jdbc（Java数据库连接）是一种用于执行<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=12370852&ss_c=ssc.citiao.link">SQL语句</a>的Java API，由一组用Java语言编写的类和接口组成。</p>
<p>驱动：两个设备（应用）之间通信的桥梁。</p>
<p>SUN公司提供一套统一的规范（接口）。然后各个数据库生产商提供这套接口的实现。这套接口规范就是JDBC的规范。</p>
<p>JDBC的环境准备：</p>
<p>\1. 创建数据库和表</p>
<p>\2. 创建项目，引入jar包</p>
<p>JDBC的开发步骤：</p>
<p>1.加载驱动：Class.forname</p>
<p>2.获得连接：DriverManager</p>
<p>\3. 基本操作：执行SQL：</p>
<p>获得执行SQL语句的对象：createStatement()方法，返回值是Statement</p>
<p>编写SQL语句：String sql = “select * from user”;</p>
<p>执行SQL：executeQuery(sql)方法，返回值是ResultSet</p>
<p>遍历该set集合</p>
<p>\4. 释放资源：集合、执行SQL语句的对象、获得的连接都要释放资源</p>
<p>DriverManager：驱动管理类</p>
<p>作用：1.注册驱动：DriverManager.registerDriver(Driver driver);</p>
<p>这个方法可以完成驱动的注册，但是实际开发中一般不会使用这个方法完成驱动的注册，而是使用Class.forname(“com.mysql.jdbc.Driver”);</p>
<p>因为如果需要注册驱动，就会使用DriverManager.registerDriver(new Driver());，但是查看Driver源代码发现，在代码中有一段静态代码块，静态代码块已经调用了注册驱动的方法，如果再手动调用该方法注册驱动，就会导致驱动被注册两次</p>
<p>2.获得连接：DriverManager.getConnection(String url, String username, String password);</p>
<p>url：与数据库连接的路径</p>
<p>user    ：与数据库连接的用户名</p>
<p>password：与数据库连接的密码</p>
<p>url的写法：jdbc:mysql://localhost:3306/web_test3</p>
<p>jdbc    :连接数据库的协议</p>
<p>mysql:是jdbc的子协议</p>
<p>localhost:连接的MySQL数据库服务器的主机地址。（连接是本机就可以写成localhost），如果连接不是本机的，就需要写上连接主机的IP地址。</p>
<p>3306:MySQL数据库服务器的端口号</p>
<p>web_test3:数据库名称</p>
<p>url如果连接的是本机的路径，可以简化为：jdbc:mysql:///web_test3</p>
<p>Connection：与数据库连接对象</p>
<p>作用：1.创建执行SQL语句的对象：</p>
<p>Statement:执行SQL Statement createStatement()</p>
<p>CallableStatement:执行数据库中存储过程 CallableStatement prepareCall(String sql)</p>
<p>PreparedStatement:（主要用这个）执行SQL.对SQL进行预处理。解决SQL注入漏洞 PreparedStatement preparedStatement (String sql)</p>
<p>\2. 管理事务</p>
<p>void setAutoCommit(boolean autoCommit):将此连接的自动提交模式改为给定状态</p>
<p>void commit():将所有上一次提交/回滚后进行的更改变为永久性更改，并释放此Connection对象当前持有的所有数据库锁</p>
<p>void rollback():取消在当前事务中进行的所有更改，并释放此Connection对象当前持有的所有数据库锁</p>
<p>Statement：执行SQL</p>
<p>作用：1.执行SQL</p>
<p>boolean execute(String sql); 执行查询，修改，添加，删除的SQL语句 （如果第一个结果为ResultSet对象，则返回true；如果是更新计数或者不存在任何结果，返回false）</p>
<p>ResultSet executeQuery(String sql); 执行查询（执行select语句）</p>
<p>int executeUpate(String sql);执行修改，添加，删除的SQL语句 （SQL DDL语句也可以）（返回的是影响的行数）</p>
<p>2.执行批处理</p>
<p>void addBatch(String sql)  将给定的sql命令添加到此Statement对象的当前命令列表中</p>
<p>void clearBatch()  清空此Statement对象的当前SQL命令列表</p>
<p>int[] executeBatch()  将一批命令交给数据库来执行，如果全部命令执行成功，则返回更新计数组成的数组</p>
<p>ResultSet：结果集，通过select语句的查询结果（只有select语句才有结果集）</p>
<p>结果集的遍历：</p>
<p>boolean next（）；  将光标从当前位置向下移一行（刚开始是在第一行之前的空白，调用了该方法之后会移动到第一行）</p>
<p>结果集的获取：</p>
<p>结果集获取可以使用结果集中的: getXXX(); 方法通常都会有一个重载的方法（int、long、String，Object就比较通用）</p>
<p>传递的参数可以是列号也可以是列名：</p>
<p>getXXX(int columnIndex);</p>
<p>getXXX(String columnName); （一般传的参数是列名，因为查询的话，有可能结果的列号不一样）</p>
<p>资源释放：</p>
<p>JDBC程序执行结束后，将与数据库进行交互的对象释放掉，通常是ResultSet,Statement,Connection</p>
<p>这几个对象中尤其是Connection对象是非常稀有的。这个对象一定要做到尽量晚创建，尽早释放掉。</p>
<p>将资源释放的代码写入到finally的代码块中，确保资源会释放。但是资源释放的时候仍可能出现异常，所以资源释放的代码应该写的标准：再用trycatch语句进行判空，判完之后要将对象赋值为null：因为可以让垃圾回收器尽快的将资源回收。</p>
<p>JDBC的CRUD操作：</p>
<p>添加、删除、修改操作：</p>
<p>\1. 创建Connection和Statement并赋值为null</p>
<p>\2. try语句中进行：注册驱动，获得连接，创建执行SQL语句对象，编写相应的SQL语句，执行SQL（excuteUpdate(sql)方法），对返回值进行判断。</p>
<p>\3. 释放资源（判空，抛异常，赋值为null）</p>
<p>查询操作：查询多条记录和查询一条记录</p>
<p>1.创建Connection和Statement和ResultSet并赋值为null</p>
<p>2.try语句中进行：注册驱动，获得连接，创建执行SQL语句对象，编写相应的SQL语句，执行SQL（excuteQuery（sql）方法）。多条语句进行遍历while，一条语句进行判断if，并输出</p>
<p>3.释放资源（判空，抛异常，赋值为null）</p>
<p>JDBC的工具类的抽取：因为注册驱动，获得连接，释放资源的代码都是相同的，所以可以抽取成一个工具类。</p>
<p>/**</p>
<p> * JDBC的工具类</p>
<p> * <em><strong>*@author*</strong></em> swx</p>
<p> */</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JDBCUtils {</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>driverClassName*</em>***;</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>url*</em>***;</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>username*</em>***;</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>password*</em>***;</p>
<p>​    <em><strong>*static*</strong></em>{</p>
<p>​        ****<em>driverClassName*</em>***=”com.mysql.jdbc.Driver”;</p>
<p>​        ****<em>url*</em>***=”jdbc:mysql:///web_test3”;</p>
<p>​        ****<em>username*</em>***=”root”;</p>
<p>​        ****<em>password*</em>***=”abc”;</p>
<p>​    }</p>
<p>​    /**</p>
<p>​     * 注册驱动的方法</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> loadDriver(){</p>
<p>​        <em><strong>*try*</strong></em> {</p>
<p>​            Class.<strong>forName</strong>(****<em>driverClassName*</em>***);</p>
<p>​        } <em><strong>*catch*</strong></em> (ClassNotFoundException e) {</p>
<p>​            e.printStackTrace();</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     * 获得连接的方法</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> Connection getConnection(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 将驱动一并注册:</p>
<p>​            <strong>loadDriver</strong>();</p>
<p>​            // 获得连接</p>
<p>​            conn = DriverManager.<strong>getConnection</strong>(<em><strong>*<em>url*</em>***,</strong></em>*<em>username*</em>***, ****<em>password*</em>***);</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }</p>
<p>​        <em><strong>*return*</strong></em> conn;</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     * 释放资源的方法</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> release(Statement stmt,Connection conn){</p>
<p>​        <em><strong>*if*</strong></em>(stmt != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                stmt.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            </p>
<p>​            stmt = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​        <em><strong>*if*</strong></em>(conn != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                conn.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            conn = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> release(ResultSet rs,Statement stmt,Connection conn){</p>
<p>​        // 资源释放：</p>
<p>​        <em><strong>*if*</strong></em>(rs != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                rs.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            </p>
<p>​            rs = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​        <em><strong>*if*</strong></em>(stmt != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                stmt.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            </p>
<p>​            stmt = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​        <em><strong>*if*</strong></em>(conn != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                conn.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            conn = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>静态代码块可以写成配置文件</p>
<p>配置文件：两种</p>
<p>\1. 属性文件：扩展名为.properties  内容是key=value</p>
<p>\2. XML文件</p>
<p>定义一个配置文件：写好键值对的相应配置，修改文件扩展名为.properties</p>
<p><img src="/4.20.JDBC/wps1.jpg" alt="img"> </p>
<p>在工具类中解析属性文件：依然在静态代码块中进行解析：</p>
<p><img src="/4.20.JDBC/wps2.jpg" alt="img"> </p>
<p>SQL注入漏洞：通过知道用户名，然后进行sql语句查询就可以进行登录。</p>
<p><img src="/4.20.JDBC/wps3.jpg" alt="img"> </p>
<p>“+username+”和“+password+” 是字符串拼接</p>
<p><img src="/4.20.JDBC/wps4.jpg" alt="img"> </p>
<p>当用户名输入为aaa’ or ‘1=1 ，密码随意写，就能登录成功：</p>
<p>select * from user where username = ‘ aaa’ or ‘ 1=1  ‘ and password = ‘ asdafaf ’</p>
<p>因为先进行and运算，true and false 结果为false 。再进行or运算， true or false 结果为true，所以可以成功。</p>
<p>当用户名输入为aaa’ or ‘1=1 ，密码随意写，也能登录成功：</p>
<p>select * from user where username = ‘ aaa’ –  ‘ and password = ‘ asdafaf ’</p>
<p>因为– 代表注释，相当于aaa后面的都没了，结果为true，所以可以成功。</p>
<p>出现漏洞的原因就是因为 or  和 – 都是SQL的关键字</p>
<p>解决方案：得在后台，后端解决。（因为可以绕过前端）</p>
<p>需要采用PreparedStatement对象解决SQL注入漏洞。这个对象将SQL预先进行编译，使用?作为占位符。?所代表内容是SQL所固定。再次传入变量（包含SQL的关键字）。这个时候也不会识别这些关键字。</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> UserDao {</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*boolean*</strong></em> login(String username,String password){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        // 定义一个变量:</p>
<p>​        <em><strong>*boolean*</strong></em> flag = <em><strong>*false*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接:</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            // 编写SQL语句:</p>
<p>​            String sql = “select * from user where username = ? and password = ?”;</p>
<p>​            // 预编译SQL</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setString(1, username); //1代表第一个问号</p>
<p>​            pstmt.setString(2, password); // 2代表第二个问号</p>
<p>​            // 执行SQL语句:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*if*</strong></em>(rs.next()){</p>
<p>​                // 说明根据用户名和密码可以查询到这条记录</p>
<p>​                flag = <em><strong>*true*</strong></em>;</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);//这里传的pstmt实际是stmt的子类，实际上用的是多态</p>
<p>​        }</p>
<p>​        <em><strong>*return*</strong></em> flag;</p>
<p>​    }</p>
<p>所以以后的Statement都最好用PreparedStatement</p>
<p>增加操作：String sql = “insert into user values (null,?,?,?,?)”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setString(1, “eee”);</p>
<p>​            pstmt.setString(2, “abc”);</p>
<p>​            pstmt.setString(3, “旺财”);</p>
<p>​            pstmt.setInt(4, 32);</p>
<p>​            // 执行SQL</p>
<p>​            <em><strong>*int*</strong></em> num = pstmt.executeUpdate();</p>
<p>​            <em><strong>*if*</strong></em>(num &gt; 0){</p>
<p>​                System.****<em>out*</em>***.println(“保存成功！”);</p>
<p>​            }</p>
<p>修改操作：String sql = “update user set username = ?,password =?,nickname=?,age = ? where id = ?”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setString(1, “abc”);</p>
<p>​            pstmt.setString(2, “1234”);</p>
<p>​            pstmt.setString(3, “旺旺”);</p>
<p>​            pstmt.setInt(4, 23);</p>
<p>​            pstmt.setInt(5, 6);</p>
<p>​            // 执行SQL：</p>
<p>​            <em><strong>*int*</strong></em> num = pstmt.executeUpdate();</p>
<p>​            <em><strong>*if*</strong></em>(num &gt; 0){</p>
<p>​                System.****<em>out*</em>***.println(“修改成功！”);</p>
<p>​            }</p>
<p>删除操作：String sql = “delete from user where id = ?”;</p>
<p>​            // 预编译SQL</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setInt(1, 4);</p>
<p>​            // 执行SQL:</p>
<p>​            <em><strong>*int*</strong></em> num = pstmt.executeUpdate();</p>
<p>​            <em><strong>*if*</strong></em>(num &gt; 0){</p>
<p>​                System.****<em>out*</em>***.println(“删除成功！”);</p>
<p>​            }</p>
<p>查找操作：String sql = “select * from user”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 执行SQL:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            // 遍历结果集:</p>
<p>​            while(rs.next()){</p>
<p>​                System.out.println(rs.getInt(“id”)+” “+rs.getString(“username”)+” “+rs.getString(“password”)+” “+rs.getString(“nickname”));</p>
<p>}</p>
<p>JDBC的批处理：之前进行JDBC的操作的时候，都是一条SQL语句执行。现在如果使用批处理，可以将一批SQL一起执行。</p>
<p>用Statement进行批处理：@Test</p>
<p>​    /**</p>
<p>​     * 批处理基本操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        Statement stmt = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接:</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            // 创建执行批处理对象:</p>
<p>​            stmt = conn.createStatement();</p>
<p>​            // 编写一批SQL语句：</p>
<p>​            String sql1 = “create database test1”;</p>
<p>​            String sql2 = “use test1”;</p>
<p>​            String sql3 = “create table user(id int primary key auto_increment,name varchar(20))”;</p>
<p>​            String sql4 = “insert into user values (null,’aaa’)”;</p>
<p>​            String sql5 = “insert into user values (null,’bbb’)”;</p>
<p>​            String sql6 = “insert into user values (null,’ccc’)”;</p>
<p>​            String sql7 = “update user set name = ‘mmm’ where id = 2”;</p>
<p>​            String sql8 = “delete from user where id = 1”;</p>
<p>​            // 添加到批处理</p>
<p>​            stmt.addBatch(sql1);</p>
<p>​            stmt.addBatch(sql2);</p>
<p>​            stmt.addBatch(sql3);</p>
<p>​            stmt.addBatch(sql4);</p>
<p>​            stmt.addBatch(sql5);</p>
<p>​            stmt.addBatch(sql6);</p>
<p>​            stmt.addBatch(sql7);</p>
<p>​            stmt.addBatch(sql8);</p>
<p>​            // 执行批处理:</p>
<p>​            stmt.executeBatch();</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(stmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>使用PreparedStatement进行批量插入：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 批量插入记录:</p>
<p>​     * * 默认情况下MySQL批处理没有开启的，需要在url后面拼接一个参数即可：</p>
<p>?rewriteBatchedStatements=true</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2(){</p>
<p>​        // 记录开始时间:</p>
<p>​        <em><strong>*long*</strong></em> begin = System.<strong>currentTimeMillis</strong>();</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接:</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            // 编写SQL语句：</p>
<p>​            String sql = “insert into user values (null,?)”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            <em><strong>*for*</strong></em>(<em><strong>*int*</strong></em> i=1;i&lt;=10000;i++){</p>
<p>​                pstmt.setString(1, “name”+i);</p>
<p>​                // 添加到批处理</p>
<p>​                pstmt.addBatch();</p>
<p>​                // 注意问题：</p>
<p>​                // 执行批处理：每1000次进行一次批量处理和清空，以防止内存溢出</p>
<p>​                <em><strong>*if*</strong></em>(i % 1000 == 0){</p>
<p>​                    // 执行批处理:</p>
<p>​                    pstmt.executeBatch();</p>
<p>​                    // 清空批处理:</p>
<p>​                    pstmt.clearBatch();</p>
<p>​                }</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(pstmt, conn);</p>
<p>​        }</p>
<p>​        <em><strong>*long*</strong></em> end = System.<strong>currentTimeMillis</strong>();</p>
<p>​        System.****<em>out*</em>***.println((end-begin));</p>
<p>​    }</p>
<p>JDBC的事务：</p>
<p>事务指的是逻辑上的一组操作，组成这组操作各个逻辑单元要么全都成功，要么全都失败。</p>
<p>如果写一个转账代码，没有加事务的话，可能会出现扣钱了，但是另一个账户没有加钱的情况，所以需要加事务。</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 完成转账的案例</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            /**</p>
<p>​             * 完成转账代码：</p>
<p>​             * * 扣除某个账号的钱</p>
<p>​             * * 给另外一个账号加钱</p>
<p>​             */</p>
<p>​            // 获得连接：</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            <em><strong>*// 开启事务*</strong></em></p>
<p>​            <em><strong>*conn.setAutoCommit(*</strong>***</em>*false*<strong><strong><strong>*);*</strong></strong></strong>*//设置为false是需要手动提交，设为true的话，写一条sql语句就会提交一句****</p>
<p>​            // 编写SQL语句：</p>
<p>​            String sql = “update account set money = money + ? where name = ?”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 用aaa账号给bbb账号转1000元</p>
<p>​            pstmt.setDouble(1, -1000);</p>
<p>​            pstmt.setString(2, “aaa”);</p>
<p>​            // 执行SQL：扣除aaa账号1000元</p>
<p>​            pstmt.executeUpdate();</p>
<p>​            </p>
<p>​            <em><strong>*int*</strong></em> i = 1 / 0; //假设这里出现了异常，结果账户的钱也不会发生改变</p>
<p>​            </p>
<p>​            // 给bbb账号加1000</p>
<p>​            pstmt.setDouble(1, 1000);</p>
<p>​            pstmt.setString(2, “bbb”);</p>
<p>​            pstmt.executeUpdate();</p>
<p>​            </p>
<p>​            <em><strong>*// 提交事务:*</strong></em></p>
<p>​            <em><strong>*conn.commit();*</strong></em></p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            <em><strong>*// 回滚事务:*</strong></em></p>
<p>​            <em><strong>*try*</strong></em> <em><strong>*{*</strong></em></p>
<p>​                <em><strong>*conn.rollback();*</strong></em></p>
<p>​            <em><strong>*}*</strong></em> <em><strong>*catch*</strong></em> <em><strong>*(SQLException e1) {*</strong></em></p>
<p>​                <em><strong>*e1.printStackTrace();*</strong></em></p>
<p>​            <em><strong>*}*</strong></em></p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="*连接池*"></a><em><strong>*连接池*</strong></em></h1><p>连接池是装有连接的容器，线程使用连接的话，可以从连接池中进行获取，使用完成之后将连接归还给连接池。</p>
<p>连接对象创建和销毁是需要耗费时间的，在服务器初始化的时候就初始化一些连接。把这些连接放入到内存中，使用的时候可以从内存中获取，使用完成之后将连接放入连接池中。从内存中获取和归还的效率要远远高于创建和销毁的效率。（提升性能）</p>
<p>自定义连接池：</p>
<p>\1. 编写一个类实现DataSource接口</p>
<p>\2. 重写getConnection方法</p>
<p>\3. 初始化多个连接在内存中</p>
<p>\4. 编写归还连接的方法</p>
<p><img src="/4.20.JDBC/wps5.jpg" alt="img"> </p>
<p>测试：</p>
<p><img src="/4.20.JDBC/wps6.jpg" alt="img"> </p>
<p>但是这个自定义连接池也存在两个问题：</p>
<p>使用接口的实现类完成的构造：</p>
<p>MyDataSource dataSource = new MyDataSource(); 这种写法不利于程序的扩展：</p>
<p>应该用这样的DataSource dataSource = new MyDataSource(); （多态）</p>
<p>但是这样的话，因为DataSource下没有addBack方法所以下面的调用会出错；同时因为调用了addBack方法，会对使用连接池的用户增加难度（因为要理解什么是addBack方法，额外提供了方法归还连接）</p>
<p>解决：不提供自定义的方法addBack就可以解决这个问题，所以需要改写一个方法解决归还的问题。</p>
<p>在Connection中是有一个close方法的，colse方法完成了连接的销毁。现在需要写一个方法，将原有的连接的close方法改为归还。</p>
<p>增强一个类中的方法：</p>
<p>\1. 采用继承：是最简单的一种增强某个类中的方法的方式。</p>
<p>条件：需要控制这个类的构造才能进行继承。</p>
<p>\2. 采用装饰者模式：比如：BufferedInputStream（InputStream）</p>
<p>条件：增强的类和被增强的那个类要实现同样的接口；在增强的类中要有被增强的那个类的引用。</p>
<p>\3. 动态代理</p>
<p>使用装饰者模式增强Connection中的close方法：（因为接口内的方法需要全部重写，而继承的话，可以只重写某一个或几个方法）</p>
<p>为了简化编程，提供一个模板类（模板类原封不动的将接口中的所有方法都实现，但是都没有增强）。编写一个装饰类继承模板类。在装饰类中只需要增强某一个方法即可。</p>
<p><img src="/4.20.JDBC/wps7.jpg" alt="img"> </p>
<p>连接池的代码：</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> MyDataSource <em><strong>*implements*</strong></em> DataSource {</p>
<p>​    // 将一些连接存入到内存中，可以定义一个集合，用于存储连接对象。</p>
<p>​    <em><strong>*private*</strong></em> List<Connection> connList = <em><strong>*new*</strong></em> ArrayList<Connection>();</p>
<p>​    </p>
<p>​    // 在初始化的时候提供一些连接</p>
<p>​    <em><strong>*public*</strong></em> MyDataSource() {</p>
<p>​        // 初始化连接：</p>
<p>​        <em><strong>*for*</strong></em>(<em><strong>*int*</strong></em> i = 1;i&lt;=3;i++){</p>
<p>​            // 向集合中存入连接:</p>
<p>​            connList.add(JDBCUtils.<strong>getConnection</strong>());</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    // 从连接池中获得连接的方法</p>
<p>​    @Override</p>
<p>​    <em><strong>*public*</strong></em> Connection getConnection() <em><strong>*throws*</strong></em> SQLException {</p>
<p>​        Connection conn = connList.remove(0);</p>
<p>​        <em><strong>*// 增强连接：*</strong></em></p>
<p>​        <em><strong>*MyConnectionWrapper connWrapper =*</strong></em> <em><strong>*new*</strong></em> <em><strong>*MyConnectionWrapper(conn, connList);*</strong></em></p>
<p>​        <em><strong>*return*</strong></em> connWrapper;</p>
<p>​    }</p>
<p>​    </p>
<p>​    <em><strong>*// 编写一个归还连接的方法:*</strong></em></p>
<p>​    <em><strong>*/*public void addBack(Connection*</strong></em> <em><strong>*conn*</strong>***</em>*){****</p>
<p>​        <em><strong>*connList.add(*</strong>***</em>*conn****<em><strong>*);*</strong></em></p>
<p>​    <em><strong>*}*/*</strong></em></p>
<p>}</p>
<p>测试：</p>
<p><img src="/4.20.JDBC/wps8.jpg" alt="img"> </p>
<h1 id="Druid开源连接池"><a href="#Druid开源连接池" class="headerlink" title="*Druid开源连接池*"></a><em><strong>*Druid开源连接池*</strong></em></h1><p>Druid是阿里旗下开源连接池产品，使用非常简单，可以与Spring框架进行快速整合。</p>
<p>在项目下新建一个文件夹folder名为lib，复制mysql的驱动包，druid的jar包到lib中，添加buid path。</p>
<p>/<em>可以直接添加工具类，配置文件。然后直接获得连接，执行SQL语句，释放资源。（但是最好用连接池，不用这个）</em>/</p>
<p>使用这个druid连接池可以去百度搜索它的帮助文档查看相关的API。核心类：DruidDataSource</p>
<p>利用这个核心类可以创建对象，然后手动设置数据库连接的参数：setXxx的方法，（也可以使用配置文件进行获取参数）获得连接：getConnection方法。最后释放资源中conn的释放不是销毁而是归还到连接池中（Druid连接池底层一定重写了这个方法变成了归还）</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * Druid的使用:</p>
<p>​     * * 手动设置参数的方式</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 使用连接池：</p>
<p>​            DruidDataSource dataSource = <em><strong>*new*</strong></em> DruidDataSource();</p>
<p>​            // 手动设置数据库连接的参数:</p>
<p>​            dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);</p>
<p>​            dataSource.setUrl(“jdbc:mysql:///web_test4”);</p>
<p>​            dataSource.setUsername(“root”);</p>
<p>​            dataSource.setPassword(“abc”);</p>
<p>​            // 获得连接：</p>
<p>//            conn = JDBCUtils.getConnection();</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL:</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 执行SQL:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>也可以用配置文件进行参数的获取：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * Druid的使用:</p>
<p>​     * * 配置文件方式设置参数</p>
<p>​     * Druid配置方式可以使用属性文件配置的。</p>
<p>​     * * 文件名称没有规定但是属性文件中的key要一定的。</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 使用连接池：</p>
<p>​            // 从属性文件中获取：</p>
<p>​            Properties properties = <em><strong>*new*</strong></em> Properties();</p>
<p>​            properties.load(<em><strong>*new*</strong></em> FileInputStream(“src/druid.properties”));</p>
<p>//这里()内需要传一个InputStream，现在可以这样子传，在WEB中是另一种。</p>
<p>​            DataSource dataSource = DruidDataSourceFactory.<strong>createDataSource</strong>(properties);</p>
<p>​            // 获得连接：</p>
<p>//            conn = JDBCUtils.getConnection();</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL:</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 执行SQL:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>虽然可以在这里进行配置文件的配置，但是不太好，可以放在JDBC的工具类中。</p>
<h1 id="C3P0开源连接池"><a href="#C3P0开源连接池" class="headerlink" title="*C3P0开源连接池*"></a><em><strong>*C3P0开源连接池*</strong></em></h1><p>C3P0是一个开源的JDBC<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8024867&ss_c=ssc.citiao.link">连接池</a>，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=54630&ss_c=ssc.citiao.link">Hibernate</a>，Spring等。</p>
<p>C3P0的核心类是：ComboPooledDataSource</p>
<p>手动设置参数：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 手动设置参数的方式:</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接：从连接池中获取：</p>
<p>​            // 创建连接池：</p>
<p>​            ComboPooledDataSource dataSource = <em><strong>*new*</strong></em> ComboPooledDataSource();</p>
<p>​            // 设置连接参数:</p>
<p>​            dataSource.setDriverClass(“com.mysql.jdbc.Driver”);</p>
<p>​            dataSource.setJdbcUrl(“jdbc:mysql:///web_test4”);</p>
<p>​            dataSource.setUser(“root”);</p>
<p>​            dataSource.setPassword(“abc”);</p>
<p>​            // 从连接池中获得连接:</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL：</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 执行SQL：</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>配置文件设置参数：</p>
<p>默认情况下，c3p0会在类加载的resource路径下查找一个配置文件“/c3p0-config.xml”。所以XML文件应该在应用的CLASSPATH下的一个文件夹或者jar包中，如果是WEB的话会在WEB-INF/classes下，其他的话也是类似的路径。c3p0不仅支持xml文件，也支持properties文件（以后的重点）。</p>
<p>配置连接池：</p>
<p>在src下新建一个xml文件，设置名为c3p0-config.xml，可以在帮助文档中找到xml的配置代码:</p>
<p><default-config>…… </default-config>  默认配置</p>
<p>&lt;named-config  name=” ”&gt; ……</named-config>  自定义配置</p>
<p>可以修改其中的配置key，value。</p>
<p><img src="/4.20.JDBC/wps9.jpg" alt="img"> </p>
<p>使用连接池：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 采用配置文件的方式：</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接：从连接池中获取：</p>
<p>​            // 创建连接池：//创建连接池默认去类路径下查找c3p0-config.xml，并且将其中的各种参数加载好</p>
<p>​            ComboPooledDataSource dataSource = <em><strong>*new*</strong></em> ComboPooledDataSource();</p>
<p>//()里面可以传递配置的名称从而加载不同的参数。如果名称没有匹配的，会加载默认的配置参数</p>
<p>​            // 从连接池中获得连接:</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL：</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 执行SQL：</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>参数可以设置很多个，很多种，所以其应用很灵活。</p>
<p>以上的代码都不规范，因为每次都会创建一个新的连接池，会浪费资源，所以需要对工具类进行改写和完善</p>
<p><img src="/4.20.JDBC/wps10.jpg" alt="img"> </p>
<h1 id="DBUtils"><a href="#DBUtils" class="headerlink" title="*DBUtils*"></a><em><strong>*DBUtils*</strong></em></h1><p>Commons DbUtils是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Apache/8512995">Apache</a>组织提供的一个对<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JDBC">JDBC</a>进行简单封装的开源工具类库，使用它能够简化<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JDBC">JDBC</a>应用程序的开发，同时也不会影响程序的性能。</p>
<p>因为JDBC手写比较麻烦，而且有非常多的代码是类似的。比如获得连接，预编译SQL，释放资源等..那么可以将这些代码抽取出来放到工具类中。将类似的代码进行抽取。大大简化JDBC的编程。</p>
<p>API</p>
<p>QueryRunner对象：核心运行类</p>
<p>构造方法：</p>
<p>无参构造</p>
<p><img src="/4.20.JDBC/wps11.jpg" alt="img"> </p>
<p>带参构造</p>
<p><img src="/4.20.JDBC/wps12.jpg" alt="img"> </p>
<p>方法：</p>
<p>增删改的方法</p>
<p><img src="/4.20.JDBC/wps13.jpg" alt="img"> </p>
<p><img src="/4.20.JDBC/wps14.jpg" alt="img"> </p>
<p>查找的方法</p>
<p><img src="/4.20.JDBC/wps15.jpg" alt="img"> </p>
<p><img src="/4.20.JDBC/wps16.jpg" alt="img"> </p>
<p>在一般情况下如果执行CRUD的操作：</p>
<p>构造：</p>
<p>QueryRunner(DataSource ds);</p>
<p>方法：</p>
<p>int update(String sql,Object… args);</p>
<p>T query(String sql,ResultSetHandler rsh,Object… args);</p>
<p>如果有事务管理的话使用另一套完成CRUD的操作</p>
<p>构造：</p>
<p>QueryRunner();</p>
<p>方法:</p>
<p>int update(Connection conn,String sql,Object… args);</p>
<p>T query(Connection conn,String sql,ResultSetHandler rsh,Object… args);</p>
<p>批量处理的方法</p>
<p><img src="/4.20.JDBC/wps17.jpg" alt="img"> </p>
<p>还有一个类：DbUtils</p>
<p>提交事务的方法：（这里的close不是销毁而是归还）</p>
<p><img src="/4.20.JDBC/wps18.jpg" alt="img"> </p>
<p>回滚事务的方法：</p>
<p><img src="/4.20.JDBC/wps19.jpg" alt="img"> </p>
<p>添加DBUtils的构建路径</p>
<p>DBUtils的添加操作：</p>
<p>​    @Test</p>
<p>​    /**</p>
<p>​     * 添加操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1() <em><strong>*throws*</strong></em> SQLException{</p>
<p>​        // 创建核心类：QueryRunner:</p>
<p>​        QueryRunner queryRunner = <em><strong>*new*</strong></em> QueryRunner(JDBCUtils2.<strong>getDataSource</strong>());</p>
<p>​        queryRunner.update(“insert into account values (null,?,?)”, “ddd”,10000);</p>
<p>​    }</p>
<p>DBUtils的修改操作：</p>
<p>​    @Test</p>
<p>​    /**</p>
<p>​     * 修改操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2() <em><strong>*throws*</strong></em> SQLException{</p>
<p>​        // 创建核心类:</p>
<p>​        QueryRunner queryRunner = <em><strong>*new*</strong></em> QueryRunner(JDBCUtils2.<strong>getDataSource</strong>());</p>
<p>​        queryRunner.update(“update account set name=?,money=? where id =?”, “eee”,20000,4);</p>
<p>​    }</p>
<p>DBUtils的删除操作：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 删除操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo3() <em><strong>*throws*</strong></em> SQLException{</p>
<p>​        // 创建核心类:</p>
<p>​        QueryRunner queryRunner = <em><strong>*new*</strong></em> QueryRunner(JDBCUtils2.<strong>getDataSource</strong>());</p>
<p>​        queryRunner.update(“delete from account where id = ?”, 3);</p>
<p>​    }</p>
<p>DBUtils的查询操作：</p>
<p>查询一条记录：</p>
<p>创建一个对象：Account（这个对象实例其实就是javabean）</p>
<p><img src="/4.20.JDBC/wps20.jpg" alt="img"> </p>
<p>也要重写toString方法</p>
<p>查询的代码实现：T query(String sql,ResultSetHandler rsh,Object… args);</p>
<p><img src="/4.20.JDBC/wps21.jpg" alt="img"> </p>
<p>查询多条语句：</p>
<p><img src="/4.20.JDBC/wps22.jpg" alt="img"> </p>
<p>ResultSetHandler接口的实现类：</p>
<p>\1. ArrayHandler和ArrayListHandler</p>
<p>ArrayHandler：将查询到的一条记录封装到一个数组当中，这个数组应该是Object[]</p>
<p><img src="/4.20.JDBC/wps23.jpg" alt="img"> </p>
<p>ArrayListHandler：将多条记录封装到一个装有Object[]的List集合中。</p>
<p><img src="/4.20.JDBC/wps24.jpg" alt="img"> </p>
<p>\2. BeanHandler和BeanListHandler（重要）</p>
<p>BeanHandler：将一条记录封装到一个JavaBean中。</p>
<p><img src="/4.20.JDBC/wps25.jpg" alt="img"> </p>
<p>必须保证Acoount中的变量和SQL中的列名一致</p>
<p>BeanListHandler：将多条记录封装到一个装有JavaBean的List集合中。</p>
<p><img src="/4.20.JDBC/wps26.jpg" alt="img"> </p>
<p>\3. MapHandler和MapListHandler</p>
<p>MapHandler：将一条记录封装到一个Map集合中，Map的key是列名，Map的value就是表中列的记录值。</p>
<p><img src="/4.20.JDBC/wps27.jpg" alt="img"> </p>
<p>MapListHandler：将多条记录封装到一个装有Map的List集合中。</p>
<p><img src="/4.20.JDBC/wps28.jpg" alt="img"> </p>
<p>\4. ColumnListHandler、ScalarHandler、KeyedHandler</p>
<p>ColumnListHandler：将数据库中的某列的值封装到List集合中。</p>
<p><img src="/4.20.JDBC/wps29.jpg" alt="img"> </p>
<p>ScalarHandler：将单个值封装。</p>
<p><img src="/4.20.JDBC/wps30.jpg" alt="img"> </p>
<p>KeyedHandler（了解即可，用的很少）：将一条记录封装到一个Map集合中。将多条记录封装到一个装有Map集合的Map集合中。而且外面的Map的key是可以指定的（可以指定为数据库中的某一列名）。</p>
<p><img src="/4.20.JDBC/wps31.jpg" alt="img"> </p>
<p>因为可能是不同的类型，为了通用性，一般都用Object类型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.20.JDBC/" data-id="ckpdvjpq4005mnswd7jmr7244" data-title="JDBC" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.16.泛型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.16.%E6%B3%9B%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:12:27.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.16.%E6%B3%9B%E5%9E%8B/">泛型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JDK5以后出现了自动装箱，所以在需要引用类型的时候如果是个基本类型也是可以的，是因为有自动装箱。</p>
<p>当我们往集合中存储了String和Integer两种类型时的数据时，而在遍历时都进行String类型的转化时，就会报错。但这个报错在编译期间不会出现，在编译的时候只有警告，只有执行的时候才会出现。于是集合也开始在创建对象的时候明确元素的数据类型，这就是泛型。</p>
<p>泛型：是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。参数化类型，把类型当作参数一样的传递。</p>
<p>格式：&lt;数据类型&gt;  此处的数据类型只能是引用类型</p>
<p>好处：1.运行时期的问题提取到了编译期间</p>
<p>\2. 避免了强制类型转换</p>
<p>\3. 简化了程序设计，解决了黄色警告线</p>
<p>在API中，如果类，接口，抽象类中出现了<E>，就说明要使用泛型。一般来说就是在集合中使用。</p>
<p>JDK7的新特性：泛型推断。</p>
<p>早期我们使用Object类型可以接收任意的对象类型。但是在实际的使用中，会有类型转换的问题（向上转型是没有任何问题的，但是在向下转型的时候隐含了类型转换的问题），也就存在着隐患，这样的程序是不安全的，所以在JDK5以后Java提供了泛型来解决这个问题，提高程序的安全性。</p>
<p>应用：</p>
<p>1.泛型类：把泛型定义在类上</p>
<p>格式:public class 类名&lt;泛型类型1,…&gt;</p>
<p>注意:泛型类型必须是引用类型</p>
<p>2.泛型方法：把泛型定义在方法上</p>
<p>格式:public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .)</p>
<p>方法可以接收任意的类型</p>
<p>3.泛型接口：把泛型定义在接口上</p>
<p>格式:public  interface 接口名&lt;泛型类型1…&gt;</p>
<p>实现类在实现接口的时候：</p>
<p>1.已经知道是什么类型的了：</p>
<p>public class InterImpl implements Inter<String>{}</p>
<p>\2. 还不知道是什么类型：(这种情况用的比较多)</p>
<p>public class InterImpl<T> implements Inter<T>{}</p>
<p>泛型通配符：泛型如果写的时候，前后必须一致（ArrayList<T> array=new ArrayList<T>();  这里的前后两个T必须一致，？可以表示任意）</p>
<p>\1. &lt;?&gt;:任意类型，如果没有明确，那么就是Object以及任意的Java类了</p>
<p>\2. &lt;? extends E&gt;：向下限定，E及其子类</p>
<p>\3. &lt;? super E&gt;：向上限定，E及其父类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.16.%E6%B3%9B%E5%9E%8B/" data-id="ckpdvjpos001snswd1357a60r" data-title="泛型" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.15.枚举" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.15.%E6%9E%9A%E4%B8%BE/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:12:20.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.15.%E6%9E%9A%E4%B8%BE/">枚举</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>枚举：是有限个值的集合。</p>
<p>是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内</p>
<p>如果没有枚举类，我们自己定义一个类的话，会非常麻烦。（//需要用到构造方法私有，静态方法调用，对象调用方法，匿名类重写方法等）</p>
<p>格式：</p>
<p>public enum 枚举类名 {</p>
<p>​            枚举项1，枚举项2，枚举项3…;</p>
<p>}</p>
<p>public String toString():  返回枚举常量的名称，它包含在声明中（枚举重写了toString方法，返回的是枚举项的名字）</p>
<p>注意事项</p>
<p>定义枚举类要用关键字enum</p>
<p>所有枚举类都是Enum的子类</p>
<p>枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略</p>
<p>枚举类可以有构造器，但必须是private的，它默认的也是private的。枚举项的用法比较特殊：枚举(“”);</p>
<p>枚举类也可以有抽象方法，但是枚举项必须重写该方法</p>
<p>枚举在switch语句中的使用</p>
<p>枚举类中的几个常见方法</p>
<p>int compareTo(E o) 比较此枚举与指定对象的顺序，枚举中隐含数字 1 2 3 …</p>
<p>String name() 返回此枚举常量的名称，在其枚举声明中对其进行声明</p>
<p>int ordinal()  返回枚举常量的序数（它在枚举声明中的位置，初始常量序数为0）</p>
<p>String toString() 返回枚举常量的名称，它包含在声明中</p>
<p><T> T valueOf(Class<T> type,String name)  静态方法，返回带指定名称的指定枚举类型的枚举常量</p>
<p>values()  此方法虽然在JDK文档中查找不到，但每个枚举类都具有该方法，它遍历枚举类的所有枚举值非常方便</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.15.%E6%9E%9A%E4%B8%BE/" data-id="ckpdvjpor001qnswd8cdrfhzo" data-title="枚举" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.23JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.23JVM/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:36:18.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.23JVM/">JVM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java语言是跨平台的，jvm不是跨平台的。</p>
<p>虚拟机（Virture Machine）指通过软件的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</p>
<p>Java的源代码经过编译后生成的不是特定CPU使用的本地代码，而是名为字节代码的程序。直接代码的运行环境就叫做java虚拟机（JVM），边转换边运行。</p>
<p>java中的内存分配：java程序在运行时，需要在内存中的分配空间。</p>
<p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p>
<p>\1. 栈：存储局部变量（加载的变量、方法）</p>
<p>结构：先进后出</p>
<p>特点：栈内存的数据用完（脱离数据域）就释放掉。（堆内存的数据可能要使用多次。）</p>
<p>\2. 堆：存储new出来的东西（里面含有该new类的成员变量、静态标记、方法标记）</p>
<p>特点：每一个new出来的东西都有地址值；每个变量都有默认值：</p>
<p>byte,short,int,long  0</p>
<p>float,double  0.0</p>
<p>char  \u000</p>
<p>boolean  false </p>
<p>引用类型  null</p>
<p>使用完毕就变成了垃圾，但是并没有立即回收，会在垃圾回收器空闲时候回收。</p>
<p>C++中用析构函数来回收释放空间。</p>
<p>栈内存的两个引用指向同一个堆内存空间，无论是它们谁的操作，都是针对同一个地方。</p>
<p>3.方法区：class类区（包括类的成员变量和成员方法）、静态区（static）、常量池</p>
<p>4.本地方法区：和系统相关</p>
<p>5.寄存器：CPU使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.23JVM/" data-id="ckpdvjpov0020nswdglqv6wxx" data-title="JVM" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.24.JUC并发编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.24.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:36:12.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.24.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">JUC并发编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.24.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="ckpdvjpow0023nswd9cab7xgs" data-title="JUC并发编程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.17.反射和注解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:57.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/">反射和注解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>类的加载</p>
<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。</p>
<p>加载 </p>
<p>就是指将class文件读入内存，并为之创建一个Class对象。</p>
<p>任何类被使用时系统都会建立一个Class对象。</p>
<p>连接</p>
<p>验证 是否有正确的内部结构，并和其他类协调一致</p>
<p>准备 负责为类的静态成员分配内存，并设置默认初始化值</p>
<p>解析 将类的二进制数据中的符号引用替换为直接引用</p>
<p>初始化 </p>
<p>就是我们以前讲过的初始化步骤</p>
<p>类初始化时机：</p>
<p>1.创建类的实例</p>
<p>2.访问类的静态变量，或者为静态变量赋值</p>
<p>3.调用类的静态方法</p>
<p>4.使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p>
<p>5.初始化某个类的子类</p>
<p>6.直接使用java.exe命令来运行某个主类</p>
<p>类加载器</p>
<p>负责将.class文件加载到内在中，并为之生成对应的Class对象。</p>
<p>虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行</p>
<p>类加载器的组成</p>
<p>Bootstrap ClassLoader 根类加载器 </p>
<p>也被称为引导类加载器，负责Java核心类的加载。比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</p>
<p>Extension ClassLoader 扩展类加载器</p>
<p>负责JRE的扩展目录中jar包的加载。在JDK中JRE的lib目录下ext目录</p>
<p>Sysetm ClassLoader 系统类加载器</p>
<p>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径</p>
<p>反射，一种计算机处理方式。是程序可以访问、检测和修改它本身状态或行为的一种能力。</p>
<p>反射：就是通过class文件对象，去使用该文件中的成员变量，构造方法，成员方法</p>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种****动态获取****的信息以及动态调用对象的方法的功能称为java语言的反射机制</p>
<p>//要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象</p>
<p>对于我们学习反射，我们在操作中一般会获取类的成员 Constructor  Field  Method。但是要想获取这些对象，必须首先得到其Class,通过Class再来获得其它对象</p>
<p>Java反射常用API</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps1.jpg" alt="img"> </p>
<p>Java中的Class可以代表任意的类或接口类型</p>
<p>在java.lang.reflect包下有三个类</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps2.jpg" alt="img"> </p>
<p>三种获取Class对象的方式</p>
<p>1:如果持有一个对象，可以直接从Object类继承的getClass()方法获取</p>
<p>Person p = new Person();</p>
<p> Class c = p.getClass();</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps3.jpg" alt="img"> </p>
<p>2:可以直接通过类包(接口)直接调用其静态属性.class获取</p>
<p>Class c2 = Person.class;</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps4.jpg" alt="img"> </p>
<p> 任意数据类型都具备一个class静态属性,看上去要比第一种方式简单.</p>
<p>3:可以通过Class类中提供的forName方法获取（将类名作为字符串传递给Class类中的静态方法forName即可）：</p>
<p>public static Class forName(String className)  这个类名必须是全路径：包名.类名（可以在外面写，会提示是否出错，没错的话沾过去；也可以点击类名下的类名右击copy Qualified name ）</p>
<p> Class c3 = Class.forName(“Person”);</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps5.jpg" alt="img"> </p>
<p>第三种和前两种的区别    ：前两种你必须明确Person类型；后面是一个字符串就行，而不需要是一个具体的类名.这种扩展更强.我不需要知道你的类.我只提供字符串,将这样的字符串配置到配置文件中，按照配置文件加载就可以了</p>
<p>所以开发中一般用第三种方法</p>
<p>Class类：</p>
<p>成员变量            Field</p>
<p>构造方法            Constructor</p>
<p>成员方法            Method</p>
<p>通过反射获取构造方法并使用：</p>
<p>获取构造方法：</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps6.jpg" alt="img"> </p>
<p>getConstructor它获取的是类的public构造</p>
<p>getConstructors它获取的是类的所有的public构造</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps7.jpg" alt="img"> </p>
<p>这两个方法不仅可以获取public，也可以获取其它权限的</p>
<p>获取单个构造方法</p>
<p>public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)  参数表示的是你要获取的构造方法的构造参数个数及数据类型的****class字节码****文件对象。…表示可以是0个（无参）一个（一个参数）多个（多个参数）</p>
<p>/*获取的单个构造方法实际上是一个对象，通过这个对象可以创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例</p>
<p>public T newInstance(Object… initargs)</p>
<p>反射可以获取私有的构造方法，成员方法，成员变量：</p>
<p>获取的如果是私有的构造方法，要用public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes),但是会显示非法的访问异常。所以还要用暴力访问：.setAccessible(true); 值为true指示反射的对象在使用时应该取消java语言访问检查  （XJAD软件就用到了反射）*/</p>
<p>我们得到构造器，就可以实例化对象</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps8.jpg" alt="img"> </p>
<p>如果不是public，那么我们需要构造器对象的实例调用AccessibleObject中的</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps9.jpg" alt="img"> </p>
<p>来取消语言检查</p>
<p>Reflect类继承于AccessibleObject类继承于Object类</p>
<p>通过反射获取成员变量并使用：Java.lang.reflect.Field它描述的属性对象</p>
<p>1.获取一个Field</p>
<p>获取所有成员</p>
<p>getFields  公共的</p>
<p>getDeclaredFields 所有的</p>
<p>获取单个成员</p>
<p>getField</p>
<p>getDeclaredField</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps10.jpg" alt="img"> </p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps11.jpg" alt="img"> </p>
<p>2.Field的操作</p>
<p>（1）对Field进行赋值</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps12.jpg" alt="img"> </p>
<p>赋值或修改成员的值</p>
<p>set(Object obj,Object value)<br>  将指定对象变量上此 Field 对象表示的字段设置为指定的新值。此处的obj需要通过构造方法创建一个obj对象，也可以直接通过Class的实例的newInstance方法直接获得obj对象（这个方法的底层就是使用了Class类额无参构造来实例化）</p>
<p>（2）对Field进行取值</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps13.jpg" alt="img"> </p>
<p>通过反射获取成员方法并使用：Java.lang.reflect.Method它描述的是类或接口中的方法</p>
<p>获取所有方法</p>
<p>​        getMethods 获取自己的包括父亲的公共方法</p>
<p>​        getDeclaredMethods 获取自己的所有方法</p>
<p>获取单个方法</p>
<p>​        getMethod（String name，Class&lt;?&gt;… parameterTypes）</p>
<p>​        getDeclaredMethod（String name，Class&lt;?&gt;… parameterTypes）</p>
<p>第一个参数是方法的名称，第二个参数是一个可变参数Class[]，它描述的是方法的参数Class</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps14.jpg" alt="img"> </p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps15.jpg" alt="img"> </p>
<p>Method的使用：public Object invoke (Object obj , Object… args)  返回值是Object接收，第一个参数表示对象是谁，第二个参数表示调用该方法的实际参数</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps16.jpg" alt="img"> </p>
<p>Method的invoke使用时注意事项?</p>
<p>\1. 如果方法是static，我们怎样调用？</p>
<p>如果方法是静态的，在通过invoke调用时不需要传递对象，传递null</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps17.jpg" alt="img"> </p>
<p>\2. 如果方法的参数是一个数组类型，怎样处理?</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps18.jpg" alt="img"> </p>
<p>为什么不能直接传args：因为数组也是object类型。在传递时，底层的invoke方法认为要调用的参数有四个。</p>
<p>为什么int[]直接传递args不报错，而Integer[]会报错：因为int[]数组中的每一个元素不是Object，只是基本数据类型，int[]被认为是一个对象。而Integer[]数组中的每一个元素都是Object</p>
<p>/*反射的调用和正常类的调用是恰好相反的。</p>
<p>正常类：p.show()    p.show(参数)</p>
<p>反射：show.invoke(p)   show.invoke(p，参数)</p>
<p>*/</p>
<p>案例：（这个案例可以帮助我们把集合中的值通过反射赋到一个类中）</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps19.jpg" alt="img"> </p>
<p>并提供get/set方法</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps20.jpg" alt="img"> </p>
<p>使用java中的反射技术将类中的属性与map中的key相同名称的，使用反射技术将key对应的value值赋值给属性.</p>
<p>采用两种方式完成操作：</p>
<p>1.直接操作属性 Field来完成操作（不常用）</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps21.jpg" alt="img"> </p>
<p>2.通过属性对应的setXxx方法来完成操作</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps22.jpg" alt="img"> </p>
<p>优点：</p>
<p>1、反射提高了程序的灵活性和扩展性。</p>
<p>2、降低耦合性，提高自适应能力。</p>
<p>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。<br>缺点：<br>    1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</p>
<p>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</p>
<p>反射：需要配置文件配合使用。 </p>
<p>配置文件是键值对。必须要有键，代码获取键；然后可以自己通过改变值，来使代码中的对象改变，从而获得不同的运行效果。</p>
<p>反射可以越过泛型检查。</p>
<p>真实的需求应该是在你调用方法后，每次操作前，都需要进行权限校验，在进行操作后，必须留下日志记录。</p>
<p>代理即Proxy Pattern，23种常用的面向对象软件的设计模式之一</p>
<p>代理模式的定义：为其他对象提供一种<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/24001.htm">代理</a>以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<p>组成：</p>
<p>抽象角色：通过接口或抽象类声明真实角色实现的业务方法。</p>
<p>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。</p>
<p>真实角色(目标对象)：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p>
<p>分类：</p>
<p>静态代理：是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p>
<p>动态代理：是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。</p>
<p>优点：</p>
<p>(1).职责清晰，真实的角色就是实现实际的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1642754.htm">业务逻辑</a>，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。</p>
<p>(2).代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。</p>
<p>(3).高扩展性</p>
<p>动态代理</p>
<p>代理：本来应该自己做的事情，却请了别人来做，被请的人就是代理对象。</p>
<p>动态代理：在程序运行过程中产生的这个对象</p>
<p>而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理</p>
<p>在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib（框架中学到，这个代理不仅仅是针对接口）</p>
<p>注意：在java中使用Proxy来完成动态代理对象的创建，只能为目标实现了接口的类创建代理对象。</p>
<p>Proxy类中的方法创建动态代理类对象：</p>
<p>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) </p>
<p>ClassLoader loader 是对象的字节码文件的类加载器：.getClass().getClassLoader()</p>
<p>Class&lt;?&gt;[] interfaces是对象的字节码文件的接口：.getClass().getInterfaces()</p>
<p>动态代理是在内存中直接生成代理对象。</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps23.jpg" alt="img"> </p>
<p>通过这个方法可以直接创建一个代理对象。</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps24.jpg" alt="img"> </p>
<p>//InvocationHandler应用了观察者模式，因为代理类没有实例，所以需要监听代理对象调用时，其底层实现的是目标行为</p>
<p>InvocationHandler h是一个接口，这里需要的是这个接口的实现类对象，所以需要创建一个类实现InvocationHandler接口。这个类中再重写InvocationHandler方法：public Object invoke(Object proxy,Method method,Object[] args)</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps25.jpg" alt="img"> </p>
<p>Invoke方法，它是在代理对象调用行为时，会执行的方法，而invoke方法上有三个参数：</p>
<p>proxy:代表动态代理对象</p>
<p>method:要访问的目标行为，代表要调用的方法对象</p>
<p>args:目标行为，代表调用目标方法时传入的实参</p>
<p>这个方法的主要作用是：当我们通过代理对象调用行为时，来控制目标行为是否可以被调用（可以自己写代码控制，return null 不让调，return method.invoke(target,args)控制目标对象的方法执行）。</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps26.jpg" alt="img"> </p>
<p>Proxy.newProxyInstance</p>
<p>创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。</p>
<p>System.out.println(u.getClass().getName());</p>
<p>案例:测试addUser方法的运行时间</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps27.jpg" alt="img"> </p>
<p>在开发中，在代理中通过目标来调用真实行为，我们使用动态代理可以完成性能监控（如上，进行时间的记录来监控性能），权限控制（在调用目标行为之前先判断是否有权限），日志记录（在调用方法之前，进行日志记录一些信息）等操作</p>
<p>注释（先写注释在写程序）</p>
<p>作用：用于解释说明程序的文字，提高程序的阅读性；可以帮助我们调试程序。</p>
<p>注释分类格式：</p>
<p>单行注释//  可以嵌套</p>
<p>多行注释/*   */  不能嵌套</p>
<p>文档注释/**   */</p>
<p>对于单行和多行注释，被注释的文字是不会被JVM解释执行</p>
<p>对于文档注释 是java特有的注释，其中的注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。</p>
<p>/*</p>
<p>需求：</p>
<p>分析：</p>
<p>实现：</p>
<p>*/</p>
<p>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的</p>
<p>它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。你可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现（SOURCE/CLASS/RUNTIME）。</p>
<p>作用：如果要对于元数据的作用进行分类，还没有明确的定义，不过我们可以根据它所起的作用，大致可分为三类：</p>
<p>编写文档：通过代码里标识的元数据生成文档。</p>
<p>代码分析：通过代码里标识的元数据对代码进行分析。</p>
<p>编译检查：通过代码里标识的元数据让<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/487018.htm">编译器</a>能实现基本的编译检查</p>
<p>在现在开发中使用注解，一般是用于将注解替换配置文件。（xml配置文件）</p>
<p>Java中基本内置注解:</p>
<p>1.@Override</p>
<p>它的作用是对覆盖超类中方法的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编译器会发出错误警告。</p>
<p>注意事项:</p>
<p>​    对于接口中的方法重写，<a href="mailto:在jdk1.5时@Override">在jdk1.5时@Override</a>它是会报错.</p>
<p>​    在jdk1.6后的版本就可以描述接口与类之间的重写</p>
<p>2.@Deprecated</p>
<p>它的作用是对不应该再使用的方法添加注解，当编程人员使用这些方法时，将会在编译时显示提示信息</p>
<p>问题:什么时候方法是过时的?</p>
<p>当前版本中这个方法存在隐患，在后续版本中对其进行了补充，这时前一个版本中的方法就会标注成过时的。</p>
<p>3.@SuppressWarnings</p>
<p>它的作用是去掉程序中的警告.</p>
<p>其参数有：</p>
<p>deprecation，使用了过时的类或方法时的警告</p>
<p>unchecked，执行了未检查的转换时的警告</p>
<p>fallthrough，当 switch 程序块直接通往下一种情况而没有 break 时的警告</p>
<p>path，在类路径、源文件路径等中有不存在的路径时的警告</p>
<p>serial，当在可序列化的类上缺少serialVersionUID 定义时的警告</p>
<p>finally ，任何 finally 子句不能正常完成时的警告</p>
<p>all，关于以上所有情况的警告</p>
<p>可以在方法之前加@SuppressWarnings（“rawtype”）</p>
<p>当一个类中出现了很多，可以在类上加@SuppressWarnings（“all”），一劳永逸</p>
<p>自定义注解</p>
<p>1.注解声明：声明一个注解格式：  修饰符 @interface 注解名{}</p>
<p>2.注解本质分析</p>
<p>分析一下注解的本质:将其.class文件找到，反编译.  (可以使用javap命令或反编译工具)</p>
<p>@interface MyAnnoation{}</p>
<p>反编译后的结果</p>
<p>interface MyAnnotation    extends Annotation</p>
<p>{</p>
<p>}</p>
<p>结论:注解本质上就是一个接口。它扩展了java.lang.annotation.Annotation接口;</p>
<p>在java中所有注解都是Annotation接口的子接口。</p>
<p>3.注解成员</p>
<p>注解本质上就是一个接口，那么它也可以有属性和方法。</p>
<p>但是接口中的属性是 public static final的，在注解中注解没有什么意义。</p>
<p>在开发中注解中经常存在的是方法（这个方法的返回值类型有要求）。而在注解中接口的方法叫做注解的属性.</p>
<p>4.自定义注解-属性操作</p>
<p>注解属性类型：</p>
<p>1.基本类型  byte short int long float double char boolean</p>
<p>​    2.String</p>
<p>​    3.枚举类型：可以自己创建一个枚举类，然后类名 方法名();</p>
<p>​    4.注解类型</p>
<p>​    5.Class类型</p>
<p>​    6.以上类型的一维数组类型</p>
<p>注解属性的使用</p>
<p>1.如果一个注解有属性，那么在使用注解时，要对属性进行赋值操作.</p>
<p>​    例如:@MyAnnotation(st = “aaa”)</p>
<p>2.如果一个注解的属性有多个，都需要赋值，使用”,”分开属性.</p>
<p>​    @MyAnnotation(st = “aaa”,i=10)</p>
<p>3.也可以给属性赋默认值</p>
<p>​    double d() <em><strong>*default 1.23*</strong></em>;</p>
<p>​    如果属性有默认值，在使用注解时，就可以不用为属性赋值。    </p>
<p>4.如果属性是数组类型</p>
<p>​        1.可以直接使用  属性名={值1,值2,。。。}方式,例如</p>
<p>​            @MyAnnotation(st = “aaa”,i=10,sts={“a”,”b”})</p>
<p>​        2.如果数组的值只有一个也可以写成下面方式</p>
<p>​            @MyAnnotation(st = “aaa”,i=10,sts=”a”)</p>
<p>​            注意sts属性它是数组类型，也就是说，只有一个值时，可以省略”{}”</p>
<p>​        </p>
<p>5.对于属性名称 value的操作.</p>
<p>​            1.如果属性名称叫value,那么在使用时，可以省略属性名称</p>
<p>​                @MyAnnotation(“hello”)</p>
<p>​            2.如果有多个属性，都需要赋值，其中一个叫value,这时，必须写属性名称</p>
<p>​                @MyAnnotation(value=”hello”,i=10)</p>
<p>​        </p>
<p>​            3.如果属性名称叫value,它的类型是数组类型.</p>
<p>​                1.只有这个value属性</p>
<p>​                可以直接赋值，不能写属性名称,但是，如果只有一个值</p>
<p>​                    @MyAnnotation({“abc”})或  @MyAnnotation(“abc”)</p>
<p>​                但是如果有多个值</p>
<p>​                    @MyAnnotation({“abc”,”def”})                        </p>
<p>​                2.如果有多个属性，属性名称叫value</p>
<p>​                    所有属性都需要赋值，那么必须写属性名称.</p>
<p>5.自定义注解-元注解</p>
<p>元注解及其作用：用于修饰注解的注解，可以描述注解在什么范围及在什么阶段使用等</p>
<p>四个元注解介绍：</p>
<p>@Retention</p>
<p>指定注解信息在哪个阶段存在 Source Class Runtime</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps1-1618812955705.jpg" alt="img"> </p>
<p>SOURCE它对应着编译阶段，可以帮助我们进行检查。</p>
<p>CLASS 它对应解析执行阶段</p>
<p>RUNTIME 它对应着在JVM中,在运行时结合反射技术，可以使注解具有一些功能</p>
<p>@Target</p>
<p>指定注解修饰目标对象的类型  </p>
<p>TYPE 类、接口   FIELD 成员变量   METHOD 方法</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps2-1618812955706.jpg" alt="img"> </p>
<p><a href="mailto:在接口的定义中前面进行元注解@Target(ElementType.TYPE)标注">在接口的定义中前面进行元注解@Target(ElementType.TYPE)标注</a>后，这个自定义注解只能用在TYPE即类、接口上，不能用于方法上。</p>
<p><a href="mailto:如果要求自定义的注解需要用在多个地方。可以@Target({ElementType.TYPE,ElementType.METHOD})">如果要求自定义的注解需要用在多个地方。可以@Target({ElementType.TYPE,ElementType.METHOD})</a></p>
<p>@Documented</p>
<p>使用该元注解修饰，该注解的信息可以生成到javadoc 文档中</p>
<p>@Inherited</p>
<p>如果一个注解使用该元注解修饰，应用注解目标类的子类会自动继承该注解 </p>
<p>@Retention @Target 是自定义注解必须使用两个元注解，并且，@Retention它的值应该是RUNTIME,因为我们会结合反射技术来使用。 @Target我们一般使用TYPE或METHOD</p>
<p>案例-获取Connection连接数据库</p>
<p>目的：让注解具有功能，必须结合反射技术来应用。</p>
<p>注解它可以替换配置文件。</p>
<p>第一步:创建注解</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps3-1618812955706.jpg" alt="img"> </p>
<p>第二步:使用注解</p>
<p>在方法上进行注解标注：</p>
<p>@JdbcProperty（driverClass=””,url=””,user=””,password=””）</p>
<p>我们可以通过getAnnotation()方法（这个方法在Class，Method。Field中都有）来获取注解对象</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps4-1618812955706.jpg" alt="img"> </p>
<p>通过jp.driverClass  jp.url 等就可以得到注解的值，然后在数据库连接中使用，进行数据库连接</p>
<p>这里的操作实际上相当于是以前在配置文件中写这些属性值，在代码中从配置文件中取。</p>
<p>问题:使用注解可以替换配置文件，为什么要替换?</p>
<p>​    配置文件中的信息，它会随着程序的变大，配置信息越来越多，不利于开发。而将配置信息通过注解来替换，便于开发与阅读。</p>
<p>缺点：如果需要更改，需要在源代码上修改注解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/" data-id="ckpdvjppo004bnswdgecn0usj" data-title="反射和注解" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.21.GUI编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.21.GUI%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:41.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.21.GUI%E7%BC%96%E7%A8%8B/">GUI编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>GUI(图形用户界面)</p>
<p>Java为GUI提供的对象都存在java.Awt和javax.Swing两个包中</p>
<p>GUI：Graphical User Interface(图形用户接口)。</p>
<p>用图形的方式，来显示计算机操作的界面，这样更方便更直观。</p>
<p>CLI：Command line User Interface (命令行用户接口）</p>
<p>就是常见的Dos命令行操作。</p>
<p>需要记忆一些常用的命令，操作不直观。</p>
<p>java.awt：Abstract Window ToolKit (抽象窗口工具包)，需要调用本地系统方法实现功能。属重量级控件。</p>
<p>javax.swing：在AWT的基础上，建立的一套图形界面系统，其中提供了更多的组件，而且完全由Java实现。增强了移植性，属轻量级控件。</p>
<p>javax是java扩展包</p>
<p>和本地系统相关的，就是重量级控件，因为移植性很差。完全由java实现的，移植性就很好，属于轻量级控件。（这里的轻重是与操作系统的关系）</p>
<p><img src="/4.21.GUI%E7%BC%96%E7%A8%8B/wps1.jpg" alt="img"> </p>
<p>Component（组件）</p>
<p>Container：为容器，是一个特殊的组件，该组件中可以通过add方法添加其他组件进来。</p>
<p>Window：窗体  没有边界和标题</p>
<p>Panel：面板</p>
<p>Frame：框架  有边界和标题</p>
<p>Dialog：对话框</p>
<p>FileDialog：文件对话框</p>
<p>Button：按钮</p>
<p>Label：标签</p>
<p>Checkbox：复选框</p>
<p>TextComponent：文本组件</p>
<p>TextArea：文本域  多行多列</p>
<p>TextField：文本框  单行多列</p>
<p>Frame  f = new Frame(“my window”);//构造方法命名 setTile是方法命名</p>
<p>f.setLayout(new FlowLayout());//设置为流式布局</p>
<p>f.setSize(300,400);//设置窗体大小 Dimension</p>
<p>f.setLocation(300,200);//设置窗体出现在屏幕的位置 Point</p>
<p>f.setVisible(true);//设置窗体是否可见</p>
<p>一个方法：setBounds（int x,int y,int width,int height）</p>
<p>前后是有顺序关系的，如果f.setVisible(true);在前面就会先显示再加载到指定位置。一般是这个步骤：创建窗体对象；设置窗体属性；设置窗体可见</p>
<p>事件监听机制</p>
<p>事件源：事件发生的地方</p>
<p>事件：要发生的事情</p>
<p>事件处理：针对发生的事情做出的处理方案</p>
<p>事件监听器：就是把事件源和事件关联起来</p>
<p>窗体布局：窗体中组件的排列方式</p>
<p>流式布局FlowLayout：从上到下，从左到右。</p>
<p>边界布局BorderLayout：东西南北中</p>
<p>网格布局GridLayout：网格状，标准n行n列</p>
<p>网格包布局GridBagLayout：可以将任意个相连的网格状连在一起当一个</p>
<p>卡片布局CardLayout：类似于卡片，点一个卡片会在主界面加载一个</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.21.GUI%E7%BC%96%E7%A8%8B/" data-id="ckpdvjpov001znswd0knw6jk9" data-title="GUI编程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.18.网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:31.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>计算机网络：是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<p>网络编程：就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。</p>
<p>网络模型：</p>
<p>OSI（Open System Interconnection开放系统互连）参考模型</p>
<p>TCP/IP参考模型</p>
<p><img src="/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/wps1.png" alt="img"> </p>
<p>网络模型7层概述：</p>
<p>1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 </p>
<p>\2. 数据链路层：主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 </p>
<p>\3. 网络层：主要将从下层接收到的数据进行IP地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 </p>
<p>\4. 传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 </p>
<p>5.会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） </p>
<p>6.表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 </p>
<p>7.应用层： 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。</p>
<p>网络应用程序：网络编程、IO流、多线程组成。集合</p>
<p>网络通信三要素：</p>
<p>1.IP地址:InetAddress（找到电脑）</p>
<p>​    网络中设备的标识，不易记忆，可用主机名</p>
<p>2.端口号：（区分电脑的程序）</p>
<p>​    用于标识进程的逻辑地址，不同进程的标识</p>
<p>3.传输协议：（怎么交流传输）</p>
<p>​    通讯的规则，常见协议：TCP，UDP</p>
<p>IP地址</p>
<p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接受数据的计算机和识别发送的计算机，在TCP/IP协议中，这个标识号就是IP地址</p>
<p>所谓IP地址就是给每个连接在Internet上的主机分配的一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，比特换算成字节，就是4个字节。例如一个采用二进制形式的IP地址是“00001010000000000000000000000001”，这么长的地址，人们处理起来也太费劲了。为了方便人们的使用，IP地址经常被写成十进制的形式，中间使用符号“.”分开不同的字节。于是，上面的IP地址可以表示为“10.0.0.1”。IP地址的这种把IP地址的每一个字节的数据换算成十进制，然后用.分开来表示的方法叫做“点分十进制表示法”，这显然比1和0容易记忆得多。</p>
<p>IP地址的组成：IP地址 = 网络号码+主机地址</p>
<p>A类    1.0.0.1—127.255.255.254</p>
<p>(1)10.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)        </p>
<p>(2)127.X.X.X是保留地址，用做循环测试用的。</p>
<p>B类    128.0.0.1—191.255.255.254    </p>
<p>172.16.0.0—172.31.255.255是私有地址。</p>
<p>169.254.X.X是保留地址。</p>
<p>C类    192.0.0.1—223.255.255.254    192.168.X.X是私有地址</p>
<p>D类    224.0.0.1—239.255.255.254     </p>
<p>E类    240.0.0.1—247.255.255.254    </p>
<p>DOS命令 ipconfig:查看本机IP地址</p>
<p>ping+IP地址：测试本机与指定的ip地址间的通信是否有问题</p>
<p>127.0.0.1 回环地址,可用于测试本机的网络是否有问题. ping 127.0.0.1  </p>
<p>xxx.xxx.xxx.0 网络地址</p>
<p>xxx.xxx.xxx.255 广播地址</p>
<p>A类IP地址:第一段号码为网络号码，剩下的三段号码为本地计算机的号码</p>
<p>B类IP地址:前二段号码为网络号码，剩下的二段号码为本地计算机的号码</p>
<p>C类IP地址:前三段号码为网络号码，剩下的一段号码为本地计算机的号码</p>
<p>//A类大部分在美国，中国可能有几个。B类一般是校园网之类的。C类是平常我们用的。DE类是保留地址，不用。</p>
<p>为了方便我们对IP地址的获取和操作，java提供了一个类InetAddress 供我们使用。但是这个类没有构造方法</p>
<p>如果一个类没有构造方法：</p>
<p>A：成员全部是静态的（Math，Arrays，Collections）</p>
<p>B：单例设计模式（Runtime）</p>
<p>C：类中有静态方法返回该类的对象（InetAddress）</p>
<p>class Demo{</p>
<p>private Demo(){}</p>
<p>public static Demo getXxx(){</p>
<p>return new Demo();</p>
<p>}</p>
<p>}</p>
<p>成员方法：</p>
<p>public static InetAdress getByName(String host):根据主机名或者ip地址的字符串表示得到IP地址对象</p>
<p>主机名：getHostName</p>
<p>主机Ip地址：getHostAddress</p>
<p>端口号：正在运行的程序的标识</p>
<p>物理端口 网卡口</p>
<p>逻辑端口 我们指的就是逻辑端口</p>
<p>​    A:每个网络程序都会至少有一个逻辑端口</p>
<p>​    B:用于标识进程的逻辑地址，不同进程的标识</p>
<p>​    C:有效端口：0<del>65535，其中0</del>1024系统使用或保留端口。</p>
<p>​    通过一些应用程序就可以查看端口号</p>
<p>协议</p>
<p>UDP：将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小在限制在64k；因无连接，是不可靠协议；不需要建立连接，速度快</p>
<p>TCP：建立连接，形成传输数据的通道；在连接中进行大数据量传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍低</p>
<p>Socket套接字</p>
<p>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</p>
<p>Socket原理机制：</p>
<p>通信的两端都有Socket。</p>
<p>网络通信其实就是Socket间的通信。</p>
<p>数据在两个Socket间通过IO传输。</p>
<p>原则上是先存在接收端。</p>
<p>UDP协议发送数据：</p>
<p>A：创建发送端Socket对象</p>
<p>B：创建数据，并把数据打包</p>
<p>C：调用Socket对象的发送方法发送数据包</p>
<p>D：释放资源</p>
<p>UDP协议接收数据：</p>
<p>A：创建接收端Socket对象</p>
<p>B：创建一个数据包（接收容器）</p>
<p>C：调用Socket对象的接收方法接收数据  阻塞式方法</p>
<p>D：解析数据包，并显示在控制台</p>
<p>E：释放资源</p>
<p>运行的时候先运行接收端，在运行发送端。第二次运行接收端会报错：该端口已经被占用</p>
<p>TCP协议发送数据：</p>
<p>A：创建发送端的Socket对象</p>
<p>B：获取输出流，写数据</p>
<p>C：释放资源</p>
<p>运行的话会出现连接被拒绝的错误。所以TCP协议一定要先开服务器</p>
<p>TCP协议发送数据：</p>
<p>A：创建接收端的Socket对象  ServerSocket</p>
<p>B：监听客户端连接，返回一个对应的Socket对象  阻塞式方法</p>
<p>C：获取输入流，读取数据显示在控制台</p>
<p>D：释放资源</p>
<p>TCP传输容易出现的问题：</p>
<p>客户端连接上服务端，两端都在等待，没有任何数据传输：</p>
<p>因为read方法或者readLine方法是阻塞式。</p>
<p>解决办法：A：再多写一条数据告诉服务器，读到这条就结束（不推荐）</p>
<p>B：Socket提供了一个终止功能：public void shutdownOutput()</p>
<p>shutdownInput（）方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="ckpdvjpot001unswd0mtz8ksz" data-title="网络编程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/08/%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/">搭建网站</a>
          </li>
        
          <li>
            <a href="/2021/06/03/%E6%94%BB%E7%A0%B4%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99/">攻破一个网站</a>
          </li>
        
          <li>
            <a href="/2021/05/29/1.6.%E6%8E%A8%E8%8D%90%E7%A0%94%E8%AF%BB%E4%B9%A6%E7%B1%8D/">推荐研读书籍</a>
          </li>
        
          <li>
            <a href="/2021/05/17/mqtt%E5%BC%80%E5%8F%91/">mqtt开发</a>
          </li>
        
          <li>
            <a href="/2021/04/30/16.2.Docker%E4%B9%8BPortainer-io/">Docker之Portainer.io</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>