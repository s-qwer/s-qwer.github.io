<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/3/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-19.1.git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/19.1.git/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T04:46:21.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/19.1.git/">git</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git是目前世界上最先进的分布式版本控制系统。<br>Linus在1991年创建了开源的Linux,从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux,但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，<strong>在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus,然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN,这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper,BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</strong>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个）,被BitMover公司发现了（监控工作做得不错！),于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后会严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：<br>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git!一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub,包括jQuery,PHP,Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>版本控制：可以解决多人同时开发的代码问题，也可以解决找回历史代码的问题。</p>
<p>分布式：Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。首先找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器“仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。可以自已搭建这台服务器，也可以使用GitHub网站。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>傻瓜式安装</p>
<h1 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h1><h2 id="在Windows的cmd-中使用linux的命令"><a href="#在Windows的cmd-中使用linux的命令" class="headerlink" title="在Windows的cmd 中使用linux的命令"></a>在Windows的cmd 中使用linux的命令</h2><p>cmd的命令功能肯定没有linux的命令功能好用，这点毋庸置疑。现在装好了Git，就可以在Windows的cmd中使用linux命令了。<br>关键词：环境变量 Git命令<br>怎么玩？如下2步操作：<br>假如你按照上述步骤将Git装在C盘，那么做如下操作：<br>操作1：找Git命令的【.exe文件】。</p>
<p>操作2：添加到环境变量，就可以在cmd里使用linux命令了。</p>
<p>最终效果：</p>
<p>PyCharm也可以使用linux命令。【环境变量–全局—使用】</p>
<p>备注：你可能需要关闭之前打开的cmd窗口/PyCharm窗口，重新打开新的cmd窗口//PyCharm窗口，使用命令才可能生效。<br>【效率会提高一点点】</p>
<h2 id="创建一个版本库"><a href="#创建一个版本库" class="headerlink" title="创建一个版本库"></a>创建一个版本库</h2><p>(1)新建一个目录git_test,在git_test目录下创建一个版本库，命令如下：</p>
<p>接着初始化仓库</p>
<p>说明：可以看到在git_test目录下创建了一个.git隐藏目录，这就是版本库目录。</p>
<p>4.版本的创建与回退<br>4.1 使用<br>(1)在git_test目录下创建一个文件code.txt,编辑内容如下：</p>
<p>(2)使用如下两条命令可以创建一个版本：<br>git add code.txt<br>git commit -m “版本1”</p>
<p>(3)使用如下命令可以查看版本记录：<br>git log</p>
<p>(4)继续编辑code.txt,在里面增加一行。</p>
<p>(5)使用如下命令再创建一个版本并查看版本记录：</p>
<p>(6)现在若想回到某一个版本，可以使用如下命令：</p>
<p>其中HEAD表示当前最新版本【请记死】，HEAD^表示当前版本的前一个版本，HEAD^^表示当前版本的前前个版本，也可以使用HEAD<del>1表示当前版本的前一个版本，HEAD</del>100表示当前版本的前100版本。</p>
<p>因为版本1的内容是1行：<br>this is the first line</p>
<p>因为版本2的内容是2行：<br>this is the first line<br>this is the second line</p>
<p>因为<br>$ git reset –hard HEAD^ HEAD is now at 51d36c7 版本1<br>使指针HEAD指向（倒退）到版本1，<br>因此打印的内容就是版本1的内容，即this is the first line</p>
<p>(7)假如我们现在又想回到版本2,这个时候怎么办？可以使用如下命令：<br>git reset –hard 版本号</p>
<p>（8）在终端执行如下命令：</p>
<p>版本2又回来了，内容也是原来的内容。</p>
<p>接着玩</p>
<p>退出终端，再重进：</p>
<p>这个重进终端的操作让我们看不到版本2的版本号，要回到版本2怎么办？<br>命令：git reflog来查看操作记录。</p>
<p>错误示例：<br>原因是按照当前版本1倒退的话，怎么也不会前进到版本2吧？逻辑错误。</p>
<p>正确实例：<br>要用到版本号。</p>
<p>查看版本2的内容：</p>
<p>不理解版本1，版本2有啥区别？<br>这个东西像游戏更新一样，版本2是在版本1的基础上添加新功能的，版本1内容不发生改变。例如王者荣耀版本更新，界面总会变化，但是英雄的属性（技能，名字）一般不会改变。</p>
<p>4.2 工作区和缓存区<br>4.2.1 工作区（WorkingDirectory)<br>工作区（WorkingDirectory) 电脑中的目录，比如我们的git_test,就是一个工作区。</p>
<p>4.2.2 版本库（Repository)<br>工作区有一个隐藏目录.git,这个不是工作区，而是git的版本库。git的版本库里存了很多东西，其中最重要的就是称为stage(或者叫index)的<br>暂存区，<br>还有git为我们自动创建的第一个分支master,以及指向master的一个指针叫HEAD。</p>
<p>因为我们创建git版本库时，git自动为我们创建了唯一一个master分 支，所以，现在，git commit就是往master分支上提交更改。<br>你可以简单理解为，需要提交的文件修改通通放到暂存区【计算机的缓存区】，然后，一次性提交暂存区的所有修改。</p>
<p>前面讲了我们把文件往版本库里添加的时候，是分两步执行的：<br>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区<br>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>(1)下面在git test目录下再创建一个文件code2.txt,然后编辑内容如下：</p>
<p>(2)然后编辑code.txt,操作如下：</p>
<p>注意的是创建文件和编辑文件都是在工作区里完成。<br>（3）使用如下命令查看当前工作树的状态：<br>git status</p>
<p>翻译一下：</p>
<p>上面提示我们code.txt被修改，而code2.txt没有被跟踪。</p>
<p>(4)我们使用如下命令把code.txt和code2.txt加入到暂存区，然后再执行git status命令，结果如下：</p>
<p>注意：所有的 git add 命令是把所有提交的修改存放到暂存区。</p>
<p>(5)然后，执行git commit就可以一次性把暂存区的所有修改提交到分支并创建一个版本。</p>
<p>注意：指针HEAD永远指向当前版本。此时当前版本是版本3。</p>
<p>(6)一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。执行如下命令可以发现：</p>
<p>现在我们的版本库变成了酱紫：</p>
<p>4.3 管理修改<br>git管理的文件的修改，它只会提交暂存区的修改来创建版本。<br>(1)编辑code.txt,并使用git add命令将其添加到暂存区中。</p>
<p>(2)继续编辑code.txt,并在其中添加一行。</p>
<p>(3)git commit创建一个版本，并使用git status查看，发现第二次修改code.txt内容之后，并没有将其添加的工作区，所以创建版本的时候并没有被提交。</p>
<p>注意：对于code.txt里的四行内容，每一个版本对应一行，例如版本1对应first line，以此类推。</p>
<p>4.4 撤销修改<br>(1)继续上面的操作，提示我们可使用git checkout – &lt;文件&gt;来丢弃工作区的改动。执行如下命令，发现工作区干净了，第二次的改动内容也没了。</p>
<p>(2)我们继续编辑code.txt,并在其中添加如下内容，并将其添加的暂存区。</p>
<p>(3)git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉，重新放回工作区。</p>
<p>(4)现在若想丢弃code.txt的修改，执行如下命令即可。</p>
<p>现在，如果你不但改错了东西，还从暂存区提交到了版本库，则需要进行版本回退。</p>
<p>小结：<br>场景1:当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用 命令git checkout – file<br>场景2:当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步：<br>第一步用命令git reset HEAD – file,就回到了场景1,<br>第二步按场景1操作。<br>场景3:已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节。</p>
<p>4.5 对比文件的不同<br>对比工作区和某个版本中文件的不同：</p>
<p>(1)继续编辑文件code.txt,在其中添加一行内容。</p>
<p>(2)现在要对比工作区中code.txt和HEAD版本中code.txt的不同。使用如下命令：</p>
<p>(3)使用如下命令丢弃工作区的改动。</p>
<p>对比两个版本间文件的不同：<br>(1)现在要对比HEAD和HEAD ^版本中code.txt的不同，使用如下命令：</p>
<p>反过来</p>
<p>4.6 删除文件<br>(1)我们把目录中的code2.txt删除。</p>
<p>这个时候，git知道删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻提示哪些文件被删除了。</p>
<p>(2)现在你有两个选择，一种情况是确实要从版本库中删除该文件，那就用命令 gitrm删掉【永久删除，无法撤消】，并且 git commit:</p>
<p>另一种情况是删错了，可以直接使用git checkout – code2.txt,这样文件code2.txt又回来了。<br>注意：两种情况有区别：<br>当执行第一种情况时【永久删除，无法撤消】，再执行第二种情况，会报错：</p>
<p>加长版：</p>
<p>简短版：</p>
<p>小结：<br>命令rm 删除是永久删除，要恢复数据的话可以恢复/扫描硬盘；<br>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<ol start="5">
<li>分支管理</li>
<li>1概念<br>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。<br>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了git又学会了SVN!</li>
</ol>
<p>分支在实际中有什么用呢？<br>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>5.2 创建与合并分支<br>git把我们之前每次提交的版本串成一条时间线，这条时间线就是一个分支。截止到目前只有一条时间线，在git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master,master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>(1)一开始的时候，master分支是一条线，git用master指向最新的提交，再用HEAD指向master,就能确定当前分支，以及当前分支的提交点：</p>
<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。<br>(2)当我们创建新的分支，例如dev时，git新建了一个指针叫dev,指向master相同的提交，再把HEAD指向dev,就表示当前分支在dev上：</p>
<p>git创建一个分支很快，因为除了增加一个dev指针，改变HEAD的指向，工作区的文件都没有任何变化。</p>
<p>(3)不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p>
<p>(4)假如我们在dev上的工作完成了，就可以把dev合并到master上。git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<p>git合并分支也很快，就改改指针，工作区内容也不变。<br>（5）合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<p>(1)执行如下命令可以查看当前有几个分支并且看到在哪个分支下工作。</p>
<p>(2)下面创建一个分支dev并切换到其上进行工作。</p>
<p>(3)下面我们修改code.txt内容，在里面添加一行，并进行提交。</p>
<p>(4)dev分支的工作完成，我们就可以切换回master分支：</p>
<p>查看code.txt,发现添加的内容没有了。因为那个提交是在dev分支上，而master分支此刻的提交点并没有变。【这里需要细细品味一下】</p>
<p>(5)现在，我们把dev分支的工作成果合并到master分支上：<br>git merge命令用于合并指定分支到当前分支。合并后，再查看code.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的rast-forward信息，Git告诉我们，这次合并是“快进模式“，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>(6)合并完成后，就可以放心地删除dev分支了，删除后，查看branch,就只剩下master分支了。</p>
<p>小结：<br>查看分支：git branch<br>创建分支：git branch <name><br>切换分支：git checkout <name><br>创建+切换分支：git checkout -b <name><br>合并某分支到当前分支：git merge <name><br>删除分支：git branch -d <name></p>
<p>5.3 解决冲突<br>合并分支往往也不是一帆风顺的。<br>(1)再创建一个新分支dev。</p>
<p>(2)修改code.txt内容，并进行提交。</p>
<p>(3)切换回master分支。</p>
<p>(4)在master的code.txt添加一行内容并进行提交。</p>
<p>这种情况下，git无法执行”快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。</p>
<p>(5)执行如下命令尝试将dev分支合并到master分支上来。</p>
<p>冲突原因：<br>现在，master分支和dev分支各自都分别有新的提交，并且编辑了同一个文件，变成了这样：</p>
<p>git告诉我们，code.txt文件存在冲突，必须手动解决冲突后再提交。</p>
<p>最重要的一步：</p>
<p>(6)git status也可以告诉我们冲突的文件：</p>
<p>(7)查看code.txt的内容。</p>
<p>(8)git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,========,&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记不同分支的内容，我们修改如下后保存：</p>
<p>(9)再提交。</p>
<p>(10)现在，master分支和dev分支变成了下图所示：</p>
<p>(11)用带参数的git log也可以看到分支的合并情况：</p>
<p>(12)最后工作完成，可以删除dev分支：</p>
<p>5.4 分支管理策略<br>通常，合并分支时，如果可能，git会用fast forward模式，但是有些快速合并不能成功而且合并时没有冲突，这个时候git会帮我们在合并之后做一次新的提交，但这种模式下，删除分支后，会丢掉分支信息。【弹窗说明信息】</p>
<p>(1)创建切换到dev分支下。</p>
<p>(2)新建一个文件code3.txt,编辑内容如下，并提交一个commit。</p>
<p>(3)切换回master分支，编辑code.txt并进行一个提交。</p>
<p>(4)合并dev分支的内容到master分支。</p>
<p>(5)出现如下提示时，这是因为这次不能进行快速合并，所以git提示输入合并说明信息，输入之后合并内容之后git会自动创建一次新的提交。</p>
<p>按 :x保存并退出。</p>
<p>(6)使用分支命令查看分支信息。</p>
<p>(7)删除dev分支。</p>
<p>如果要强制禁用fast forward模式，git就会在merge时生成一个新的commit,这样，从分支历史上就可以看出分支信息。<br>(1)创建并切换到dev分支。</p>
<p>(2)修改code.txt内容，并提交一个commit。</p>
<p>(3)切换回master分支。</p>
<p>（4）准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward:</p>
<p>因为本次合并要创建一个新的commit,所以加上-m参数，把commit描述写进去。</p>
<p>5.5 Bug分支<br>软件开发中，bug就像家常便饭一样，有了bug就需要修复，在git中，由于分支是如此的强大，所以，<br>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>(1)当你接到一个修复一个代号001的bug的任务时，很自然地，你想创建一个分支bug-001来修复它，但是，等等，当前正在dev上进行的工作还没有提交：<br>建议先敲clear清屏。</p>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug,怎么办？</p>
<p>(2)git还提供了一个stash功能，可以把当前工作现场“储藏“起来，等以后恢复现场后继续工作：【工作中可能会用到，在git pull之前先用这条命令。放入缓存是git stash，相对应的git stash pop从缓存中释放出来】</p>
<p>更多请参考：传送门<br>(3)首先确定要在哪个分支上修复bug,假定需要在master分支上修复，就从master创建临时分支：</p>
<p>(4)现在修复bug,这里假设把code.txt里的第9行删掉，然后提交。</p>
<p>(5)修复完成后，切换到master分支，并完成合并，最后删除bug-001分支。</p>
<p>(6)现在bug-001修复完成，是时候接着回到dev分支干活了！</p>
<p>(7)工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：【帮助我们列出保存的工作现场】</p>
<p>工作现场还在，git把stash内容存在某个地方了，需要恢复一下：</p>
<p>小结：<br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug,修复后，再git stash pop,恢复工作现场。</p>
<p>6.使用github<br>6.1 创建仓库<br>(1)注册github账户</p>
<p>登录后，点击”New respository”</p>
<p>(2)在新页面中，输入项目的名称【如2020】，勾选’readme.md’,点击’Create repository’</p>
<p>这里完成。</p>
<p>6.2 添加ssh账户<br>(1)点击账户头像后的下拉三角，选择’settings’如果某台机器需要与github上的仓库交互，那么就要把这台机器的ssh公钥添加到这个github账户上。</p>
<p>(2)在git的命令行中，回到用户的主目录下，编辑文件.gitconfig,修改某台机器的git配置。<br>修改为注册github时的邮箱，填写用户名。</p>
<p>完美：</p>
<p>6.3 克隆项目</p>
<p>接着：</p>
<p>6.4 上传分支/推送代码<br>(1)项目克隆到本地之后，执行如下命令创建分支：</p>
<p>(2)创建一个views.py并提交一个版本：</p>
<p>(3)推送前github上文件列表如下图:</p>
<p>(4)推送前github上分支列表如下图:</p>
<p>(5)推送分支，就是把该分支上的所有本地提交推送到远程库，推送时要指定本地分支，这样，git就会把该分支推送到远程库对应的远程分支上：<br>git push origin 分支名称<br>例：<br>git push origin smart</p>
<p>（6）再次查看github分支：<br>接下来操作重新加载页面：</p>
<p>点击smart,再点击views.py,如图所示：</p>
<p>6.5 将本地分支跟踪服务器分支<br> git branch –set-upstream-to=origin/远程分支名称 本地分支名称<br>1<br>例：</p>
<p>  git branch –set-upstream-to=origin/smart smart<br>1</p>
<p>我的社交网址：<a target="_blank" rel="noopener" href="https://github.com/Keegan-y">https://github.com/Keegan-y</a></p>
<p>6.6 从远程分支上拉取代码<br>git pull orgin 分支名称<br>例：<br>git pull orgin smart<br>使用上述命令会把远程分支smart上的代码下载并合并到本地所在分支。</p>
<p>7.工作使用git<br>不墨迹直接上代码：<br>loading…<br>项目经理：<br>(1)项目经理搭建项目的框架。<br>(2)搭建完项目框架之后，项目经理把项目框架代码放到服务器。</p>
<p>普通员工：<br>(1)在自己的电脑上，生成ssh公钥，然后把公钥给项目经理，项目经理把它添加的服务器上面。<br>(2)项目经理会给每个组员的项目代码的地址，组员把代码下载到自己的电脑上。<br>(3)创建本地的分支dev,在dev分支中进行每天的开发。<br>(4)每一个员工开发完自己的代码之后，都需要将代码发布远程的dev分支上。</p>
<p>项目里一般会有两个分支，如：<br>Master:用于保存发布的项目代码。<br>Dev:用于保存开发过程中的代码。所有的组员开发完自己的代码提交到该分支上。<br>补充小技巧：<br>首先，整体认知一下工作中git常用的就这么几个命令：<br>步骤1.创建项目目录，如git_test【强烈建议返回到2.安装配置一节，学一学在windows中用mkdir git_test。工作中点来点去，文件夹一多就不爽了，学会在windows上用linux命令，工作效率谁用谁知道<del>】<br>步骤2.git init【如果你考皮github上别人的代码，必须将别人的.git文件删掉。步骤：进入项目目录，如git_test，cd git_test，ls -al，rm -rf .git】【工作中linux必会的，赶快回到2.安装配置一节，学一学在windows使用linux命令，这样就不用装linux环境了，简单胜于复杂</del>】<br>步骤3.git add .<br>步骤4.git commit -m “整体提交”<br>步骤5.git remote add origin 【你的github/gitlab仓库地址】<br>步骤6.git checkout -b dev<br>步骤7.git push origin dev<br>当然不止于这7步，这些步骤会在你的实践中不断升华，壮大<del>。<br>先把git玩起来再说，否则很容易从入门到放弃。先玩起来</del><br>步骤操作如图所示：</p>
<p>可以看到，代码推到仓库了。<br>掌握了上面基本命令，记住使用步骤，强烈建议建议建议你在PyCharm/Goland上操作git，能可视化+带提示帮你提交代码，解决冲突【你在git bash里搞不定冲突，在PyCharm/Goland上操作一看就知道怎么做了，人家可视化+提示，你只需要手指点一点即可，很简单，节约你的时间】，工具是个好东西，前面的步骤都是为了这样一句话铺垫：【PyCharm/Goland上玩git】<br>【不会的可以在评论区留言，我看到后会继续在后文补充。既然是git使用教程，那就是成体系的，知识技能是结构化安放的，方便查，方便增，是不？】</p>
<p>到此，git使用教程就写完了，既是自己的实践记录【记不住哈哈】，也能帮助更多的道友管理控制代码，如果内容对读者有用，请关注我，为思考点赞！</p>
<p>最后奉上导图笔记：</p>
<p>8.思维导图笔记</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/16/19.1.git/" data-id="cknllgmc1003esgwdhketbu2z" data-title="git" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-5.4.MySQL工具之Navicat" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/5.4.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:39:28.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/5.4.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/">MySQL工具之Navicat</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>安装Navicat</strong></p>
<p>因为工作原因，需要经常连接不同的数据库，这里我安装的是Navicat Premium版本，在公众号后台回复 <strong>Navicat</strong> 即可获取。</p>
<p>安装过程很简单，只要你能看懂中文，不停的下一步，等待安装完成即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2xKluMyr9zsylJ1bbEy5kAicNwLkqjO2V3j6G3XFBLhiaozUuKYzLCVkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>连接不同数据库</strong></p>
<p>这里分别介绍Oracle，MySQL，SQL Server这三种数据库的连接方法</p>
<p><strong>连接Oracle</strong></p>
<p>在连接Oracle之前我们需要先配置一下OCI文件，具体如下：</p>
<p>点开主菜单里的【工具】——【选项…】,在弹出的对话框中找的OCI选项</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ayiavVhGWNUtCxzSv7nRAL32mTpAlsHmG6XrhvA5NfV7JIUia6FnBDWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里就要把你安装的oracle的安装目录下的bin文件夹里面的oci.dll文件导入</p>
<p>E:\software\oracle\Oracle_win64\product\11.2.0\dbhome_1\BIN\oci.dll</p>
<p>以上是我的安装目录下的文件，大家根据自己的安装目录不同来导进来</p>
<p>导进来之后就重启Navicat，重启后会自动生效。</p>
<p>重启Navicat后，点击菜单栏的连接，选择Oracle，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2v4ibO1bTE1sICWwbjoGlYjlPrbKGNmCazdqNG3U4SJDY4lNvydb8vGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中做如下配置，其中连接名可以随意起，然后输入你要连接的主机名或IP地址，最后输入账号密码。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO26DXvmnuAFhema70Vibkj2nhLc13TEpb2SwxMibrVuY9ECoP4BudbRf0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你是使用DBA角色登录的，还需要点开高级选项卡，将角色选为DBA</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO225C85ic0Bd8oYibzpBoHLKtmog0ZBdlib7Pd8grxHDIia7aNwEVdfw46uA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置完了以后，我们可以点击连接测试</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2pBzAsdJSbnWUI9La2k8icmAKIbnMWpOMicy9FsgFO1CdKCiaC2p3OqUOA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">这样Oracle的连接就配置好了。</p>
<p><strong>连接MySQL和SQL Server</strong></p>
<p>MySQL和SQL Server的连接相对比较简单，只需要输入主机名或IP地址，账号密码即可，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2HxIZHHUhGKML0TC1mgA7djpa5KZ2cqyJyrW5HUAtr9xIwxAJBWxobg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2UzsMibLp6NUbiaAE5dNa09XeOjh61qyCmUib1uRzpy8p1PnwZd3FMuUxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置好后，点击连接测试，在弹出连接成功窗口就表示我们配置好了。</p>
<p>数据库连接成功后，下面是各个功能的介绍，我们以SQL Server数据库作为案例来介绍各个功能的使用。</p>
<p><strong>创建数据库</strong></p>
<p>右键我们刚新建的数据库连接——选择【新建数据库…】即可开始创建数据库了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO25lWoNb7icSiaocd6c07JMQRVdvqrXHpnPpmOWMkEXk5lSUPhTxCvE3Fg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以根据你的要求来进行配置，配置完以后，还可以在【SQL预览】看到完整的SQL代码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2f6LfOqSt2tKhHUhxV089tAicnqGw6gQr1ic6JpNzic21UDxVbicm2pul5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>数据传输</strong></p>
<p>数据传输，顾名思义就是将数据从其他地方传输到当前数据库，例如我们将SQL_Road数据库中的数据传输到刚才新建的Test数据库中。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO29JIouv6OTsvv1tVHEARMD95v6JjKVnvJ2Cw07xzqUAOPp9ktxpNueQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>右键刚才创建好的Test数据库，在弹出的选项中选择【数据传输…】，在弹出的窗口中我们配置源数据库为【SQL_Road】,目标数据库配置为【Test】，这样就可以将SQL_Road中的对象传输到Test了，支持传输的对象包括：表，视图，函数和存储过程，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2a5ovyOCg7icHWslZj0ZH0icOZG0GG2zF5McQWlWxXhb0h7IH8ScszhyQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始即可开始进行数据传输，传输效率还是很快的，即使你的数据量很大，也可以使用该方法进行数据传输，这里使用了不到2秒钟就将整个数据库对象迁移到新的数据库中了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2gYlkicBOLCHXSicuics171YBiaBM06vu5TsoxFD1v8tMiatk27AFnl8icDBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>此外如果你想导出整个数据库中的对象到文件，也可以使用该方法，只需要将方式改为文件即可，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2dKibsOAkMktKzv4RcEnGCzF21WvhA8u23aO8mxQoXNGpbLRXkjrrasw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你想自定义导出的内容，可以点击该窗口的【高级】选项进行自定义配置，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ibkdpgmia7AP9ciadmUt0kIpKZHJWBicQibibicdibEtaZFkHcicEGtjG1OSUCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置完成后，点击开始，就会将你选择的数据库对象以脚本的形式导出到文件中。</p>
<p>但是数据传输到文件有个不足的地方，就是会将数据记录也会一并导出，而很多时候，我们其实只需要表结构，那么我们可以使用下面的这个功能。</p>
<p><strong>转储SQL文件</strong></p>
<p>双击打开数据库后，我们右键架构名dbo，在弹出的选项中选择【转储SQL文件…】，这里还有两个子选项：【结构和数据…】和【仅结构…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2klrr7KbWlHjd8oVYVaFhibky2ywFHxDfGbU0SNr80OElzF5bTVOor1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>他们的区别就是一个有数据记录，一个没有数据记录，如果你只要数据结构可以只选择【仅结构…】，这样就可以大大节省导出时间了。</p>
<p><strong>打印模式/数据字典*<em>生成*</em></strong></p>
<p>做数据库仓库往往面对的不是几张表，往往是成百上千张数据表，该怎么维护对DBA是个非常头疼的事，如果有个数据表结构或数据字典之类的就非常完美了。</p>
<p>打印模式可以<strong>完美的生成所有表的数据表结构</strong>的。这里我们选择表数量较多的数据库ReportServer。右键dbo后，选择【打印模式…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2NIZlTicjuVONVpYrhO0W1IqAeicswxic28stRoicXeJokqNTBNSQ3L0zWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以看到右侧窗口里面出现了所有数据表的表结构，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2TvxbdBAlYHmoILKSDia33M0MIm0IAghtK3LXibzq5icU19hqlFYkESx0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>足足有10页之多，我们点击左上方的【打印】，将表结构打印成PDF文件，就可以得到一份非常完成的数据字典了，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2aud0pqYSgMzwR3nXRMTNGibYQP3zXkCDrbTEU8UhTKDUhwZ2UDZxrSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>内容中主键和索引也有仔细的标注出来，其中<strong>P代表主键</strong>，下面的<strong>index表示索引</strong>。</p>
<p>这个功能绝对是一个神器！</p>
<p><strong>在模式中查找</strong></p>
<p>这个功能主要用来查找数据或结果，当你需要从当前数据库中查找数据记录或对象中包含某些字符时，可以使用该功能，具体如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO26F4rBdtKPq3pM6kk4v0iboN54ExFSJ6P0A8JrFI9x7Aj1zEICJeYw3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中，我们查找pre的结构，就可以将当前数据库符合要求的的所有对象都查找出来，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2zfWey0meibpxuwyU8ljtT6r0JIvHybx1e5rCDeAHwty4T2PIEKdQ1uw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>逆向模式到模型</strong></p>
<p>这又是一个神仙技能，谁用谁知道，右键dbo在弹出的选项中选择【逆向模式到模型..】,如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2gqmyJ95SwfRD1sZgybhd30aOiaV4LFDDSSKG7icQyHRGbTicMvBSqYjMQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>它可以<strong>将当前数据库中创建的所有表，以E-R图的模型清楚的告诉你每个表之间的关联关系</strong>，包括主外键，表结构，关联关系等，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2uQjNXTMRT6dVMkyT4tsO8Bb1CnibJgJfWDEePaGpVe8sicmkHdib245iaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>你以为就这？</p>
<p>还支持<strong>模型转换，模型导出</strong>，说白了就是你可以<strong>将该模型转换成其他数据库的模型</strong>，从SQL Server转换成MySQL，Oracle，Postgresql都可以。点击左上角的三短横，选择【文件】——【模型转换】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2cyYKRyxc5KAibxWfnU2zWdvUn7wAicn2lxZCBSP8mibaOaiaUbW9TzWn9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中选择你要转换的类型，比如我们想转换成MySQL 5.6的，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2x6TSHrBrmkymXceib25CkBfqVibGJlYibS0PL6VpSrOBPiacP71D1iciaBHw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击确定后，即可将当前的SQL Server模型立马转换成MySQL 5.6。给大家看下对比效果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2BUAibtGeIM6N5WXroknLPhTjT4k0r9EaZA8QRgCKzsnnUHsfqict08Tw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>SQL Server模型</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ImacDMUrYmibib6ZwhWa5hSwhtVXIhEUia6z4XxSz6chIVaeTzxmQcicuw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>MySQL模型</p>
<p>转换成功后可以直接将转换后的模型导出成对应的SQL。</p>
<p>点击【工具】——【导出SQL…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2SmPTTmH3LNPNNlmst71wAL7cpjlJuicBexVXBLh230wCzz2j3PGfvBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择导出位置，点确定即可，导出的SQL文件里面就是MySQL的建库代码了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2pvSqyJrD6aqeYmPh2lrIt56UXRL4RKyxzukKiaJ8GvaE2JGyjrKZx6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>能导出肯定就可以打印，同样如果需要将模型文件保存，也可以导出为PDF，PNG，SVG等格式，但是建议打印成PNG图片格式，因为PDF会分页，导致模型不完整。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2v0WVtdIJS4Qnj98H6rZwSic0mpKNvY4ML8OQEb4S5Y1cFk7icCmctdnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>打印出来的图片如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2VXiacibexrSpbeY1Y7kANuyIKGGobrsFNTiaolsaEMXRaDt8kXdeoibNLA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>新建表</strong></p>
<p>这个是比较常见的功能，相比其他管理工具，Navicat将建表过程中所涉及的各种常用功能都包含进去了，包含新字段，索引，主键，外键，唯一键等等与表有关的内容，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgQEuibfiaJMxTYlVaxYzphdW6VfpKYm6uLw3X8dyOIWryib4Aw8OYCicCbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>针对表的几个常用功能，我们再详细给大家介绍一下</p>
<p><strong>字段</strong></p>
<p>字段的功能很多，也是其他功能的前提，意思是你必须先创建了字段才能使用后面的一些功能。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgNIZBSp4nV53ZvBRxLqcpa9YunxHyn1qtDLf9lmialP9BQsZN1zELt6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其中第一排的添加字段，插入字段，删除字段，可以通过字面意思来理解。</p>
<p>主键：选中某个字段，点击主键即可设置为主键</p>
<p>标识：勾选后一般用作自增长列来使用</p>
<p>注释：对字段的备注，通常为中文</p>
<p>名：字段存在表里的字段名</p>
<p>类型：字段数据类型</p>
<p>长度：字段的长度，通常int和datetime可以不设置长度。</p>
<p>比例：小数位数</p>
<p>不是Null：该字段是否为空，勾选不为空，不勾选为空。</p>
<p><strong>索引</strong></p>
<p>用来创建索引，只需要选定指定的列，就可以在对应的列上创建索引了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgZQSnF3fd6xNaee5ibV4VXEQ1u7cibJfo2D0NvfGbcic9C1l056rOP9fcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>名：索引的名称，通常按命名规范以index或idx开头，当然你也可以自定义。</p>
<p>字段：选择在哪个字段上创建索引。还可以选择排序规则，默认是升序ASC。</p>
<p>索引类型：不同的数据库索引类型不同，SQL Server类型一般为聚集索引（Clustered）和非聚集索引（Non-Clustered）</p>
<p>唯一键：用来限制字段的记录是否可以重复，勾选就是不可重复。</p>
<p><strong>外键</strong></p>
<p>用来创建外键约束的功能，目前的数据库设计中，通常不设置外键约束了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgYfEockSvWia9MOegfNXLnFeSzJLnO0GgDqBTouNbAAnx2xP7SFVKU9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>名：外键名称，通常以fk开头</p>
<p>字段：用来设置外键的字段</p>
<p>参考表：与之相关联的表</p>
<p>参考字段：与之相关联表中的字段</p>
<p>删除时：是否级联删除</p>
<p>更新时：是否级联更新</p>
<p><strong>唯一键</strong></p>
<p>区别于主键，唯一键具有唯一性</p>
<p>与主键的区别有：</p>
<p>1.主键不允许空值，唯一索引允许空值</p>
<p>2.主键只允许一个，唯一索引允许多个</p>
<p>3.主键产生唯一的聚集索引，唯一索引产生唯一的非聚集索引</p>
<p><strong>检查</strong></p>
<p>用来约束数据插入的合法性，对应SQL中的CHECK或DEFAULT</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgxCROXWLcic26pQfMYHDX8K5Let2XYlibrAYzYtiaMwElzkX17mt1mFrvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>触发器</strong></p>
<p>用来创建与表相关的触发器，其中触发器的使用可以查看历史文章：</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA3MTg4NjY4Mw==&mid=2457301529&idx=2&sn=b3881753e41e401ac374057bce52e768&chksm=88a5602dbfd2e93bcae925b00130230e7e8f1b957f29ce2f3e7471c4076ebba3bf36ad2b4ab1&scene=21#wechat_redirect">SQL高级知识V2——触发器</a></p>
<p><strong>选项</strong></p>
<p>这里主要用来设置自增长的种子值（起始值）和增量</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgTr5rCyPoOtCZKcLA7ibtWLy8M1o4opjVATrsNBelsORc2SoBQ3elGjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>SQL预览</strong></p>
<p>这里可以看到我们刚才对表做的配置所对应的SQL语句</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgVe1icibSk4HTrcOZKR3hnXwUqL22Ofo1XfLtpfbibYTI0jMdBhUcn5kQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>查看对象模式</strong></p>
<p>创建好的表有三种查看方式：列表，详细信息和ER图，如下图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIovQPPbZyXibIAxiaY94ey9NUBALdy7jiaghl9WczAyTSFrLYB8dbNpJzibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>列表模式</strong></p>
<p>只显示表名，是表的默认显示方式</p>
<p><strong>详细信息模式</strong></p>
<p>会显示除了表名以为的其他信息，记录数，修改日期和表的注释等</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2vc7yZjic33zyty6PylhMMA9icpMGjtGb8croq8uo47TuF9RjtSyd3zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>ER图模式</strong></p>
<p>会以ER图的形式显示每个表之间的关联关系，如下图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoApicGEtFC7zxyYETTOrtKYs06TTTic2SNpsnEAKp99kTS3UvXYzXqFzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>导入向导</strong></p>
<p>用来引导用户导入数据到数据库对应的表</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgZSuMc6TCjM8JAytt1BYL0RvBNn7k1Lxafshibm5libYAUCzycBfmMc6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们打算将Customers.xlsx里的数据导入到表Customers中，具体操作如下：</p>
<p>在导入向导中选择要导入的文件类型，Navicat支持多种导入类型，这里我们选择导入Excel文档，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo4kDbmWv2gicpicrUlQtmq33Zua6RkT4sZQXhXr9ibCkPnp6lw50Y29a4g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>找的需要导入的文件，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo1oic8nEeeSjQic5fIqLcGETvcWeJAra33SRQ2dNJouJ9ePIpNZJyIVdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置字段名等内容，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIofmn6WiaXl270ic5y07kUErIXsYd4jy7a7YmbxyxfxguW716fRKJcnoDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择要导入的目标表，你也可以直接新建一张表，这里我们导入到目标表Orders，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoTQ7UYQWjlr4dC3iaqrVkqWKVPNmptZrjAU6u9ZlrnP1vPLqLUVuJckA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置源表和目标表之间的字段对应关系，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoAo5sT3zWIOWYGCVKeC2DSPW0E0tM6z7GBM2XHwbTjo7HibAgXtzPYsw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择一个导入模式，如果是直接添加，可以选择添加模式，如果是要先清空目标表再导入可以选择复制模式，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJzoC5vQ9mb05YrSUsAoTR6FRGpgGmrSZIgq2Hke2Q1ZgA7a5xP0alA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始就可以导入数据了</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoqhr3jY27uwVkalMIMw3VNtY2ZsZsrMgXQCKoJFDPDH66By1IxYCHnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>导出向导</strong></p>
<p>需要将数据库里的数据导出可以使用导出向导，具体如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIosDqVIic9Fyw1GIzhhynAp1gj2YfBHUgEE53B03vdPOgDARQUsqBicvBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中选择导出文件类型，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo5SsBEomUrzic3fvd4TJr8Ig4sFTGGdHxtjCJMPjXU63pVEbmNUicexzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择需要导出的表，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIocqzcibg1sEPdpbx0f0FqziaiahGak5Iz24y2kWFtzm3BfOcEkalwDCKIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择需要导出的列，默认全部字段，也可以选择指定字段，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJuTZ3MzwxnY7PAbyvQypMRE4X4266DicRFzccGgKDibib8bwzHjBJ0VkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>定义一些附加选项，导出包含标题，遇到导出错误继续等，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoDqcgLqHnEASje1LdH85fxzASTibKuiaPuItStfxzjXKsydBho1xUpfQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始执行导出操作</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIotFkCMS4qmA9ZaU9lQV72kd9yf3xQuXH8tNQYy0Trjc89OaPJVfbODw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>新建查询</strong></p>
<p>新建查询有两种方式，可以直接右键选择新建查询，也可以点击菜单栏的查询-新建查询，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoZge8TTPMzoYaMaichOUmddo9OkwHGwIoVHSb7TpiauRtIgCHtnzZcoXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>查询功能</strong></p>
<p>查询是我们用的比较频繁的一个功能，在查询窗口里面有许多好用的功能</p>
<p><strong>智能提醒</strong></p>
<p>根据我们输入的字符来自动提醒一些关键字，字段名，表名，视图名，函数名等，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIodFO8VeLldjRGdxUUCu7JqaVDcZhpzu3ET8A2urodtyUE674d2P9R8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>美化SQL</strong></p>
<p>当你看到一段代码写的很复杂且都堆在一起，可以使用美化SQL功能，一键帮你把堆在一起的SQL美化得整整齐齐。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2ws81EQbUEv6OwTZVUCVv0SkYeQ4ibU7Mia0oUqubE856t8QFTYTZnkg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>美化前</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIop5eiciaJ9kT4iaL8sxibNmWaRI68twNTKSAUsiaF8lmc2N9OkJnhBb5lNGg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>美化后</p>
<p><strong>其他功能</strong></p>
<p>此外查询窗口还有很多其他功能，都集中在左上角的三短横上面，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoZfZE8m5xAlAiaWyiaoaB5ib4FJPHB48teicrvpL1iaZUc3mtIQ4ImHnBpKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里将查询窗口的所有功能都汇集在一起，比如注释，查看执行计划，简化SQL等都在这里可以找到，小伙伴们可以一一尝试一下。</p>
<p><strong>创建视图</strong></p>
<p>Navicat提供一套创建视图的模板，主要是针对新手朋友。如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIotlErKxibGVngibLqbKfAmZmJgao6RMMOEOf1buYlRthMN4EMV1emOnRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里我们只需要写查询语句即可，在SQL预览里可以看到完整的SQL语句。如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo58Z7WQHwWh2LicjJAsBAAbEUictk2oYmex5u79n1C4SlHzmSsK6JA4MQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击预览，可以看到我们刚定义的视图结果，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoobd6t9vLPcZRnteqc9v8N0jeYhS5gtyCkicTPnh8ymjLHr5sKPjolgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>创建函数和存储过程</strong></p>
<p>函数和存储过程是类似的，区别是函数必须要有返回值，而存储过程可有可无。</p>
<p>他们也有一套模板，选择函数后点击新建函数，弹出如下对话框：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJibuYXzHaia6wiaN41LwF9BQoqtteicJj4sDF5lFibicE6vXkYbT6F3ypGww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>输入函数名或过程名，然后选择你想是想创建函数还是存储过程。然后输入参数名称和类型，也可以不带参数，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoMVGCWGLLdRfME5vtAb7GP7jiaSZJ4bgwsmcZHVM1Cn1aCaEFVTDF6vg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>函数必须要有返回值，这里需要定义返回值类型，点击下一步或完成。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoc3Jq9L01h8luBsFpIPcibrqXOs4A6ibXqK5GEHQsibB8cRW5kia1FdO90A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里会配置函数的一些附加信息，通常不用配置，直接点击完成即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoTFmlaHv2ZIP9t0icQd6pMjFOAOHTibicYRdNXGTo18gyP0MPzDJueXRBQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后我们就可以看到函数的编辑窗口了</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIog39HtbibClCyegtdt1zjN8nIvxbIYcvpeLuaMI6oL7Dw5ic0copYAN2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>写好函数里的语句后点击运行即可开始测试了。</p>
<p><strong>备份和还原</strong></p>
<p>通过Navicat，我们可以很方便的完成备份和还原操作，我们先来备份一个文件。</p>
<p><strong>备份</strong></p>
<p>点击菜单栏的SQL Server备份——新建备份，在弹出的窗口中配置备份内容，然后点击生成SQL即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIowFVnb9HfcicQHiagCnb3HLzyvpicUpF7Cf9S5qBB7CmfUfFtpckMdcRQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在这里我们可以看到备份的代码，然后点备份就会开始备份</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2N7mdeSiaMqEKbib8784hD9cYszwMFVrU2k1eqOdWqfF3Qib2UGvkiabhw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>还原</strong></p>
<p>在备份完成后，我们可以选择还原该备份包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoFbj8G9rvic4Pod7YeTzZDFm4hFEh6eibImpO9KF62UYuunZGOlC6qV7g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中可以配置相关信息</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoYkYWtRVp2H7l25ib5NPT6nQmdyx0v2eU6Rzmng4jvLFoQYnvWRYDn6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击生成SQL就会看到执行备份的SQL命令，点击还原即可开始执行</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoOXxlnPcECCGib8L7RGNOMze8FPzDmHiaib7BgGGlXQr0Yd6s0kLiaVzicqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>历史日志记录</strong></p>
<p>该功能可以很方便的查看到你在数据库中执行了哪些操作。点击菜单栏中的工具——历史日志，就可以看到我们的操作记录了，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoNM11YDOPrBnV7ibs8eQwJorWiaTRo1icrlFZu2rIjjjssomNk5dAZlIuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/5.4.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/" data-id="cknllgmc4003lsgwd4kmwe8zl" data-title="MySQL工具之Navicat" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-21.1.微信开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:36:09.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/">微信开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="微信公众平台开发"><a href="#微信公众平台开发" class="headerlink" title="微信公众平台开发"></a>微信公众平台开发</h1><h2 id="订阅号和服务号和企业号"><a href="#订阅号和服务号和企业号" class="headerlink" title="订阅号和服务号和企业号"></a>订阅号和服务号和企业号</h2><p>订阅号每天一条，收拢至订阅号文件夹，不强制推送；服务号每月一条，消息仍展示在聊天列表，但下发消息将即时提醒用户。</p>
<p>1、订阅号：主要偏于为用户传达资讯（类似报纸杂志），认证前后都是每天只可以群发一条消息。</p>
<p>2、服务号：主要偏于服务交互（类似银行，114，提供服务查询），认证前后都是每个月可群发4条消息；</p>
<p>3、企业号：主要用于公司内部通讯使用，需要先验证身份才可以关注成功企业号。</p>
<h2 id="验证登录和授权：AccessToken"><a href="#验证登录和授权：AccessToken" class="headerlink" title="验证登录和授权：AccessToken"></a>验证登录和授权：AccessToken</h2><h3 id="1-查看appid及appsecret"><a href="#1-查看appid及appsecret" class="headerlink" title="1.查看appid及appsecret"></a>1.查看appid及appsecret</h3><p>公众号后台界面查看</p>
<h3 id="2-获取accessToken"><a href="#2-获取accessToken" class="headerlink" title="2.获取accessToken"></a>2.获取accessToken</h3><p>1.临时方法获取</p>
<p>临时通过<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/debug/">在线测试</a> 或者 浏览器/postman等方式发送get请求获取返回结果里的accessToken</p>
<p>2.接口获取</p>
<p>第三方需要一个access_token获取和刷新的中控服务器（这个服务器会提前进行刷新，确保无缝连接）。</p>
<p>并发获取access_token会导致AccessToken互相覆盖，影响具体的业务功能，所以需要加并发锁</p>
<h2 id="用户标识：openid和UnionID"><a href="#用户标识：openid和UnionID" class="headerlink" title="用户标识：openid和UnionID"></a>用户标识：openid和UnionID</h2><p>为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID。如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下。绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID，可以在用户管理-获取用户基本信息（UnionID机制）文档了解详情。</p>
<p>​    <strong>一个用户对于一个公众号只会存在一个openid，即使取消关注了再关注，openid也不会改变。如果一个大公司下有多个公众号，会产生不同的openid，为了实现该公司下公众号间的数据互通，会有一个唯一的UnionID作为用户的唯一标识</strong></p>
<h2 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h2><p>公众号主要通过公众号消息会话和公众号内网页来为用户提供服务的：</p>
<h3 id="1、公众号消息会话"><a href="#1、公众号消息会话" class="headerlink" title="1、公众号消息会话"></a><strong>1、公众号消息会话</strong></h3><p>公众号是以微信用户的一个联系人形式存在的，消息会话是公众号与用户交互的基础。</p>
<p>目前公众号内主要有这样几类消息服务的类型，分别用于不同的场景。</p>
<p>1）群发消息：公众号可以以一定频次（订阅号为每天1次，服务号为每月4次），向用户群发消息，包括文字消息、图文消息、图片、视频、语音等。</p>
<p><strong>在公众号后台管理界面的创作管理可以编辑后选择群发</strong></p>
<p>2）被动回复消息：在用户给公众号发消息后，微信服务器会将消息发到开发者预先在开发者中心设置的服务器地址（开发者需要进行消息真实性验证），公众号可以在5秒内做出回复，可以回复一个消息，也可以回复命令告诉微信服务器这条消息暂不回复。被动回复消息可以设置加密（在公众平台官网的开发者中心处设置，设置后，按照消息加解密文档来进行处理。其他3种消息的调用因为是API调用而不是对请求的返回，所以不需要加解密）。</p>
<p>3）客服消息：在用户给公众号发消息后的48小时内，公众号可以给用户发送不限数量的消息，主要用于客服场景。用户的行为会触发事件推送，某些事件推送是支持公众号据此发送客服消息的，详见微信推送消息与事件说明文档。</p>
<p>4）模板消息：在需要对用户发送服务通知（如刷卡提醒、服务预约成功通知等）时，公众号可以用特定内容模板，主动向用户发送消息。</p>
<h3 id="2、公众号内网页"><a href="#2、公众号内网页" class="headerlink" title="2、公众号内网页"></a><strong>2、公众号内网页</strong></h3><p>许多复杂的业务场景，需要通过网页形式来提供服务，这时需要用到：</p>
<p>1）网页授权获取用户基本信息：通过该接口，可以获取用户的基本信息（获取用户的OpenID是无需用户同意的，获取用户的基本信息则需用户同意）</p>
<p>2）微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。</p>
<h2 id="全局返回码"><a href="#全局返回码" class="headerlink" title="全局返回码"></a>全局返回码</h2><p>公众号每次调用接口时，可能获得正确或错误的返回码，开发者可以根据返回码信息调试接口，排查错误</p>
<p>-1：系统繁忙，此时请开发者稍候再试</p>
<p>0：请求成功</p>
<p>4xxxx，6xxxx，9xxxx：各种问题的返回码</p>
<h2 id="开始开发"><a href="#开始开发" class="headerlink" title="开始开发"></a>开始开发</h2><h3 id="1-申请服务器"><a href="#1-申请服务器" class="headerlink" title="1.申请服务器"></a>1.申请服务器</h3><h3 id="2-搭建服务"><a href="#2-搭建服务" class="headerlink" title="2.搭建服务"></a>2.搭建服务</h3><p>后端程序配置微信的设置</p>
<h3 id="3-申请公众号"><a href="#3-申请公众号" class="headerlink" title="3.申请公众号"></a>3.申请公众号</h3><h3 id="4-开发者基本配置"><a href="#4-开发者基本配置" class="headerlink" title="4.开发者基本配置"></a>4.开发者基本配置</h3><h4 id="1-填写服务器配置"><a href="#1-填写服务器配置" class="headerlink" title="1.填写服务器配置"></a>1.填写服务器配置</h4><p>服务器地址（URL）、Token和EncodingAESKey</p>
<p>URL是开发者用来接收微信消息和事件的接口URL。</p>
<p>Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。</p>
<p>EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥</p>
<p>填写并提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求：signature（微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数），timestamp（时间戳），nonce（随机数），echostr（随机字符串）</p>
<p>通过检验signature对请求进行校验：</p>
<p>1）将token、timestamp、nonce三个参数进行字典序排序 </p>
<p>2）将三个参数字符串拼接成一个字符串进行sha1加密</p>
<p> 3）将加密后的字符串与signature对比，true表示是微信发来的，false表示不是微信。</p>
<p>若确认此次GET请求来自微信服务器，原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败</p>
<h4 id="2-后续可以在公众号后台的开发-基本配置里修改配置："><a href="#2-后续可以在公众号后台的开发-基本配置里修改配置：" class="headerlink" title="2.后续可以在公众号后台的开发/基本配置里修改配置："></a>2.后续可以在公众号后台的开发/基本配置里修改配置：</h4><p>开发者ID（AppID）：自动生成</p>
<p>开发者密码(AppSecret)：可以重置自动生成复制</p>
<p>IP白名单：配置自己的白名单以便调用测试接口获得access_token</p>
<p>服务器地址(URL)：http://外网IP/wx ，端口固定为80（http://外网IP/wx）</p>
<p>令牌(Token)：自主设置，这个token与前面的access_token不是一回事。这个token只用于验证开发者服务器</p>
<p>消息加解密密钥(EncodingAESKey)</p>
<h3 id="5-后端进行框架构思"><a href="#5-后端进行框架构思" class="headerlink" title="5.后端进行框架构思"></a>5.后端进行框架构思</h3><p>主要有三个部分：负责业务逻辑部分的服务器，负责对接微信API的API-Proxy服务器，以及唯一的AccessToken中控服务器</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xnC7SUbrIRwI8NhEGFeax6HoPcTMDqKGYxaSoNqBwocrj70Pt1EcKnQ/0?wx_fmt=png" alt="img"></p>
<p>1）AccessToken中控服务器：</p>
<p>负责： 提供主动刷新和被动刷新机制来刷新accessToken并存储（为了防止并发刷新，注意加并发锁），提供给业务逻辑有效的accessToken。</p>
<p>优点： 避免业务逻辑方并发获取access_token，避免AccessToken互相覆盖，提高业务功能的稳定性。</p>
<p>2）API-Proxy服务器：</p>
<p>负责：专一与微信API对接，不同的服务器可以负责对接不同的业务逻辑，更可进行调用频率、权限限制。</p>
<p>优点：某台API-proxy异常，还有其余服务器支持继续提供服务，提高稳定性，避免直接暴漏内部接口，有效防止恶意攻击，提高安全性</p>
<p>3）后端服务的服务器</p>
<h3 id="6-码代码"><a href="#6-码代码" class="headerlink" title="6.码代码"></a>6.码代码</h3><h3 id="7-在线测试"><a href="#7-在线测试" class="headerlink" title="7.在线测试"></a>7.在线测试</h3><p>在线测试接口可以输入access_token，进行接口测试，返回”请求失败”，说明代码有问题，检查代码逻辑。</p>
<p>“请求成功”，然后根据返回结果查看是否符合预期</p>
<h3 id="8-真实体验"><a href="#8-真实体验" class="headerlink" title="8.真实体验"></a>8.真实体验</h3><p>手机端微信关注测试</p>
<h2 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h2><ol>
<li>自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。</li>
<li>一级菜单最多4个汉字，二级菜单最多7个汉字，多出来的部分将会以“…”代替。</li>
<li>创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile（简介）页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果</li>
</ol>
<h3 id="设置类型："><a href="#设置类型：" class="headerlink" title="设置类型："></a>设置类型：</h3><ol>
<li><p>click：点击推事件。用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互；</p>
</li>
<li><p>view：跳转URL。用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。</p>
</li>
<li><p>scancode_push：扫码推事件用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。</p>
</li>
<li><p>scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>pic_sysphoto：弹出系统拍照发图用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>pic_photo_or_album：弹出拍照或者相册发图用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。</p>
</li>
<li><p>pic_weixin：弹出微信相册发图器用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>location_select：弹出地理位置选择器用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>media_id：下发消息（除文本消息）用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频、图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</p>
</li>
<li><p>view_limited：跳转图文消息URL用户点击view_limited类型按钮后，微信客户端将打开开发者在按钮中填写的永久素材id对应的图文消息URL，永久素材类型只支持图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</p>
</li>
</ol>
<p>view类型：弹出网页（pc版本）</p>
<p>media_id类型：显示图文消息</p>
<p>click类型：发现公众号系统提示：“该公众号暂时无法提供服务“</p>
<p>点击click类型button，微信后台会推送一个event类型的xml 给开发者，需要开发者进一步完善后台代码逻辑，增加对自定义菜单事件推送的响应，必须设置key值</p>
<h3 id="创建-修改接口："><a href="#创建-修改接口：" class="headerlink" title="创建/修改接口："></a>创建/修改接口：</h3><p>这里的url应该是直接的url，不包含二级菜单</p>
<p>POST（使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN%EF%BC%8C%E8%AF%B7%E6%B1%82%E4%BD%93%E4%B8%BA%EF%BC%9A">https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN，请求体为：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;button&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;绑定安全帽&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;wxcc4bc1fc3f1774c4redirect_uri&#x3D;http%3A%2F%2felinktech.cn%2Fabout.htmlresponse_type&#x3D;codescope&#x3D;snsapi_basestate&#x3D;123#wechat_redirect&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;运营服务&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;wxcc4bc1fc3f1774c4redirect_uri&#x3D;http%3A%2F%2felinktech.cn%2Fdaohang.htmlresponse_type&#x3D;codescope&#x3D;snsapi_basestate&#x3D;123#wechat_redirect&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;E联商城&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;wxcc4bc1fc3f1774c4redirect_uri&#x3D;http%3a%2f%2felinktech.cn%2fshop.htmlresponse_type&#x3D;codescope&#x3D;snsapi_basestate&#x3D;123#wechat_redirect&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回0成功。</p>
<h3 id="查询接口："><a href="#查询接口：" class="headerlink" title="查询接口："></a>查询接口：</h3><p>GET <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/get_current_selfmenu_info?access_token=ACCESS_TOKEN%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84json%E5%8D%B3%E4%B8%BA%E6%8E%A5%E5%8F%A3">https://api.weixin.qq.com/cgi-bin/get_current_selfmenu_info?access_token=ACCESS_TOKEN，返回结果的json即为接口</a></p>
<h3 id="删除接口："><a href="#删除接口：" class="headerlink" title="删除接口："></a>删除接口：</h3><p>GET <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN%EF%BC%8C%E8%BF%94%E5%9B%9E0%E5%8D%B3%E4%B8%BA%E5%88%A0%E9%99%A4%E6%88%90%E5%8A%9F">https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN，返回0即为删除成功</a></p>
<h3 id="事件推送："><a href="#事件推送：" class="headerlink" title="事件推送："></a>事件推送：</h3><p>用户点击自定义菜单后，微信会把点击事件推送给开发者，请注意，点击菜单弹出子菜单，不会产生上报</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[FromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[event]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Event</span>&gt;</span>&lt;![CDATA[CLICK]]&gt;<span class="tag">&lt;/<span class="name">Event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">EventKey</span>&gt;</span>&lt;![CDATA[EVENTKEY]]&gt;<span class="tag">&lt;/<span class="name">EventKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="个性化菜单接口"><a href="#个性化菜单接口" class="headerlink" title="个性化菜单接口"></a>个性化菜单接口</h3><p>可以通过该接口，让公众号的不同用户群体看到不一样的自定义菜单</p>
<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包发到开发者填写的URL上。</p>
<h3 id="1-接收文本消息"><a href="#1-接收文本消息" class="headerlink" title="1.接收文本消息"></a>1.接收文本消息</h3><p> 1.粉丝给公众号发送的文本消息</p>
<p>粉丝给公众号发送文本消息：“欢迎开启公众号开发者模式”，在开发者后台，收到公众平台发送的xml 如下：（下文均隐藏了ToUserName 及 FromUserName 信息）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[公众号]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[粉丝号]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1460537339<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[欢迎开启公众号开发者模式]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>6272960105994287618<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>createTime 是微信公众平台记录粉丝发送该消息的具体时间</p>
<p>text: 用于标记该xml 是文本消息，一般用于区别判断</p>
<p>欢迎开启公众号开发者模式: 说明该粉丝发给公众号的具体内容是欢迎开启公众号开发者模式</p>
<p>MsgId: 是公众平台为记录识别该消息的一个标记数值, 微信后台系统自动产生</p>
<ol start="2">
<li>被动回复文本消息</li>
</ol>
<p>即公众号给粉丝发送的文本消息，官方wiki链接: <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message">被动回复用户消息</a></p>
<p>特别强调：</p>
<p>1） 被动回复消息，即发送被动响应消息，不同于客服消息接口</p>
<p>2） 它其实并不是一种接口，而是对微信服务器发过来消息的一次回复</p>
<p>3） 收到粉丝消息后不想或者不能5秒内回复时，需回复“success”字符串</p>
<p>4） 客服接口在满足一定条件下随时调用</p>
<p>公众号想回复给粉丝一条文本消息，内容为“test”, 那么开发者发送给公众平台后台的xml 内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[粉丝号]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[公众号]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1460541339<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[test]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>特别备注：</p>
<p>1）ToUserName（接受者）、FromUserName(发送者) 字段请实际填写。</p>
<p>2）createtime 只用于标记开发者回复消息的时间，微信后台发送此消息都是不受这个字段约束。</p>
<p>3）text : 用于标记 此次行为是发送文本消息 （当然可以是image/voice等类型）。</p>
<p>4）文本换行 ‘\n’。</p>
<p> 3.回复success问题</p>
<p>查询官方wiki 开头强调： 假如服务器无法保证在五秒内处理回复，则必须回复“success”或者“”（空串），否则微信后台会发起三次重试。</p>
<p>解释一下为何有这么奇怪的规定。发起重试是微信后台为了尽可以保证粉丝发送的内容开发者均可以收到。如果开发者不进行回复，微信后台没办法确认开发者已收到消息，只好重试。</p>
<p>真的是这样子吗？尝试一下收到消息后，不做任何回复。在日志中查看到微信后台发起了三次重试操作，日志截图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xauONdVFJvic1Wfzxa0HnSEZ5libLcYibWWkb7gNDjt56DFs8kiaY3OtFtw/0?wx_fmt=png" alt="img"></p>
<p>三次重试后，依旧没有及时回复任何内容，系统自动在粉丝会话界面出现错误提示“该公众号暂时无法提供服务，请稍后再试”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xBp7Iiam8ydK0W4MOZa9bfHKgTesMkj3HXOnsYxttsodweib7mH9y5eQg/0?wx_fmt=png" alt="img"></p>
<p>如果回复success，微信后台可以确定开发者收到了粉丝消息，没有任何异常提示。因此请大家注意回复success的问题。</p>
<ol start="4">
<li>流程图</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xEVXiblIZm80UCBlia6vYiaXD7Od9Ev3nujHoNkNCubr9WPo8L7opJGhIA/0?wx_fmt=png" alt="img"></p>
<h3 id="2-接收图片消息"><a href="#2-接收图片消息" class="headerlink" title="2.接收图片消息"></a>2.接收图片消息</h3><p>MediaID</p>
<p>目的：</p>
<p>1）引入素材管理</p>
<p>2）以文本消息，图片消息为基础，可自行理解剩余的语音消息、视频消息、地理消息等</p>
<p>预实现功能：</p>
<p>接受粉丝发送的图片消息，并立马回复相同的图片给粉丝。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0x6zWAJ79NkGrlg34cGBjvqxtSxSVw5gPMsmlygTyhdDblrsNiaCX8GhQ/0?wx_fmt=png" alt="img"></p>
<p> 1.接收图片消息</p>
<p>即粉丝给公众号发送的图片消息。官方wiki链接：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html">消息管理/接收消息-接受普通消息/ 图片消息</a>从实例讲解，粉丝给公众号发送一张图片消息，在公众号开发者后台接收到的xml如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml&gt;</span><br><span class="line"> &lt;ToUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/ToUserName&gt;</span><br><span class="line"> &lt;FromUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/FromUserName&gt;</span><br><span class="line"> &lt;CreateTime&gt;1460536575&lt;/CreateTime&gt;</span><br><span class="line"> &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;</span><br><span class="line"> &lt;PicUrl&gt;&lt;![CDATA[http://mmbiz.qpic.cn/xxxxxx /0]]&gt;&lt;/PicUrl&gt;</span><br><span class="line"> &lt;MsgId&gt;6272956824639273066&lt;/MsgId&gt;</span><br><span class="line"> &lt;MediaId&gt;&lt;![CDATA[gyci5a-xxxxx-OL]]&gt;&lt;/MediaId&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure>

<p>特别说明：</p>
<p>PicUrl: 这个参数是微信系统把“粉丝“发送的图片消息自动转化成url。 这个url可用浏览器打开查看到图片。</p>
<p>MediaId: 是微信系统产生的id 用于标记该图片，详情可参考wiki<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1444738727&token=&lang=zh_CN">素材管理/获取临时素材</a>，</p>
<p> 2.被动回复图片消息</p>
<p>即公众号给粉丝发送的图片消息。官方wiki链接：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140543&token=&lang=zh_CN">消息管理/发送消息-被动回复用户消息/ 图片消息</a>)</p>
<p>特别说明：</p>
<p>1） 被动回复消息，即发送被动响应消息，不同于客服消息接口</p>
<p>2） 它其实并不是一种接口，而是对微信服务器发过来消息的一次回复</p>
<p>3） 收到粉丝消息后不想或者不能5秒内回复时，需回复“success”字符串</p>
<p>4） 客服接口在满足一定条件下随时调用</p>
<p>开发者发送给微信后台的xml 如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml&gt;</span><br><span class="line"> &lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt;</span><br><span class="line"> &lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt;</span><br><span class="line"> &lt;CreateTime&gt;1460536576&lt;/CreateTime&gt;</span><br><span class="line"> &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;</span><br><span class="line"> &lt;Image&gt;</span><br><span class="line"> &lt;MediaId&gt;&lt;![CDATA[gyci5oxxxxxxv3cOL]]&gt;&lt;/MediaId&gt;</span><br><span class="line"> &lt;/Image&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure>

<p>这里填写的MediaId的内容，其实就是粉丝的发送图片的原MediaId，所以粉丝收到了一张一模一样的原图。 如果想回复粉丝其它图片怎么呢？</p>
<p>1） 新增素材，请参考 新增临时素材 或者 新增永久素材</p>
<p>2） 获取其MediaId，请参考 获取临时素材MediaID 或者 获取永久素材MediaID</p>
<p>3.3 流程图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xDdfzVUuLvr3iaR3BvJnkkL9kATK0TgmFXsF2tPHTlpulfJ6eU930a1Q/0?wx_fmt=png" alt="img"></p>
<h3 id="3-语音消息"><a href="#3-语音消息" class="headerlink" title="3.语音消息"></a>3.语音消息</h3><h3 id="4-视频消息"><a href="#4-视频消息" class="headerlink" title="4.视频消息"></a>4.视频消息</h3><h3 id="5-小视频消息"><a href="#5-小视频消息" class="headerlink" title="5.小视频消息"></a>5.小视频消息</h3><h3 id="6-地理位置信息"><a href="#6-地理位置信息" class="headerlink" title="6.地理位置信息"></a>6.地理位置信息</h3><h3 id="7-链接消息"><a href="#7-链接消息" class="headerlink" title="7.链接消息"></a>7.链接消息</h3><h2 id="接收事件推送"><a href="#接收事件推送" class="headerlink" title="接收事件推送"></a>接收事件推送</h2><h3 id="1-关注-取消关注事件"><a href="#1-关注-取消关注事件" class="headerlink" title="1 关注/取消关注事件"></a>1 关注/取消关注事件</h3><p>用户在关注与取消关注公众号时，微信会把这个事件推送到开发者填写的URL。方便开发者给用户下发欢迎消息或者做帐号的解绑。为保护用户数据隐私，开发者收到用户取消关注事件时需要删除该用户的所有信息</p>
<h3 id="2-扫描带参数二维码事件"><a href="#2-扫描带参数二维码事件" class="headerlink" title="2 扫描带参数二维码事件"></a>2 扫描带参数二维码事件</h3><p>用户扫描带场景值二维码时，可能推送以下两种事件：</p>
<ol>
<li>如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。</li>
<li>如果用户已经关注公众号，则微信会将带场景值扫描事件推送给开发者</li>
</ol>
<h3 id="3-上报地理位置事件"><a href="#3-上报地理位置事件" class="headerlink" title="3 上报地理位置事件"></a>3 上报地理位置事件</h3><p>用户同意上报地理位置后，每次进入公众号会话时，都会在进入时上报地理位置，或在进入会话后每5秒上报一次地理位置，公众号可以在公众平台网站中修改以上设置。上报地理位置时，微信会将上报地理位置事件推送到开发者填写的URL。</p>
<h3 id="4-自定义菜单事件"><a href="#4-自定义菜单事件" class="headerlink" title="4 自定义菜单事件"></a>4 自定义菜单事件</h3><p>用户点击自定义菜单后，微信会把点击事件推送给开发者，请注意，点击菜单弹出子菜单，不会产生上报</p>
<h3 id="5-点击菜单拉取消息时的事件推送"><a href="#5-点击菜单拉取消息时的事件推送" class="headerlink" title="5 点击菜单拉取消息时的事件推送"></a>5 点击菜单拉取消息时的事件推送</h3><h3 id="6-点击菜单跳转链接时的事件推送"><a href="#6-点击菜单跳转链接时的事件推送" class="headerlink" title="6 点击菜单跳转链接时的事件推送"></a>6 点击菜单跳转链接时的事件推送</h3><h2 id="被动回复用户消息"><a href="#被动回复用户消息" class="headerlink" title="被动回复用户消息"></a>被动回复用户消息</h2><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。</p>
<p>严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。</p>
<p>1、直接回复success（推荐方式） 2、直接回复空串（指字节长度为0的空字符串，而不是XML结构体中content字段的内容为空）</p>
<p>1、开发者在5秒内未回复任何内容 2、开发者回复了异常数据，比如JSON数据等</p>
<p>就会出现<strong>“该公众号暂时无法提供服务，请稍后再试”</strong></p>
<h2 id="自动回复规则"><a href="#自动回复规则" class="headerlink" title="自动回复规则"></a>自动回复规则</h2><p>开发者可以通过该接口，获取公众号当前使用的自动回复规则，包括关注后自动回复、消息自动回复（60分钟内触发一次）、关键词自动回复</p>
<h2 id="模板消息"><a href="#模板消息" class="headerlink" title="模板消息"></a>模板消息</h2><ol>
<li>模板消息调用时主要需要模板ID和模板中各参数的赋值内容</li>
<li>模板中参数内容必须以”.DATA”结尾，否则视为保留字</li>
<li>模板保留符号””</li>
</ol>
<p>在模版消息发送任务完成后，微信服务器会将是否送达成功作为通知，发送到开发者中心中填写的服务器配置地址中</p>
<h2 id="微信网页开发"><a href="#微信网页开发" class="headerlink" title="微信网页开发"></a>微信网页开发</h2><h3 id="适配问题"><a href="#适配问题" class="headerlink" title="适配问题"></a>适配问题</h3><p>安卓版微信直接调用系统浏览器内核，它是用chrome改造做的一套WKwebView,概念上类似是一套组建, iOS则是调用safari，但</p>
<p>微信<strong>iOS客户端</strong>于2017年3月1日前逐步升级为WKWebview内核。ios也可以自己切换为UIWebview。微信内任意入口进入任意网页，在网页加载成功后向下拉动页面（或点击网页右上角菜单按钮），使之显示出地址栏，当地址栏以 “此网页由” 开头即为当前使用WKWebview，若以“网页由”则是使用的UIWebview</p>
<h3 id="网页授权"><a href="#网页授权" class="headerlink" title="网页授权"></a>网页授权</h3><p>如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。</p>
<p>OAuth2.0鉴权</p>
<h4 id="1、引导用户进入授权页面同意授权，获取code"><a href="#1、引导用户进入授权页面同意授权，获取code" class="headerlink" title="1、引导用户进入授权页面同意授权，获取code"></a>1、引导用户进入授权页面同意授权，获取code</h4><p>在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），引导关注者打开如下页面：<a target="_blank" rel="noopener" href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a> 若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。</p>
<p>尤其注意：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问。</p>
<p>如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE</p>
<p>跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。</p>
<p>code说明 ： code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期</p>
<p><strong>关于网页授权回调域名的说明</strong></p>
<p>1、在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；</p>
<p>2、授权回调域名配置规范为全域名，比如需要网页授权的域名为：<a target="_blank" rel="noopener" href="http://www.qq.com,配置以后此域名下面的页面http//www.qq.com/music.html">www.qq.com，配置以后此域名下面的页面http://www.qq.com/music.html</a> 、 <a target="_blank" rel="noopener" href="http://www.qq.com/login.html">http://www.qq.com/login.html</a> 都可以进行OAuth2.0鉴权。但<a target="_blank" rel="noopener" href="http://pay.qq.com/">http://pay.qq.com</a> 、 <a target="_blank" rel="noopener" href="http://music.qq.com/">http://music.qq.com</a> 、 <a target="_blank" rel="noopener" href="http://qq.com/">http://qq.com</a> 无法进行OAuth2.0鉴权</p>
<p>3、如果公众号登录授权给了第三方开发者来进行管理，则不必做任何设置，由第三方代替公众号实现网页授权即可</p>
<p><strong>关于网页授权的两种scope的区别说明</strong></p>
<p>1、以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p>
<p>2、以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</p>
<p>3、用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p>
<h4 id="2、通过code换取网页授权access-token（与基础支持中的access-token不同）"><a href="#2、通过code换取网页授权access-token（与基础支持中的access-token不同）" class="headerlink" title="2、通过code换取网页授权access_token（与基础支持中的access_token不同）"></a>2、通过code换取网页授权access_token（与基础支持中的access_token不同）</h4><p>这里通过code换取的是一个特殊的网页授权access_token,与基础支持中的access_token（该access_token用于调用其他接口）不同。公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。</p>
<p>尤其注意：由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起</p>
<p>获取code后，请求以下链接获取access_token： <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</a></p>
<p><strong>关于网页授权access_token和普通access_token的区别</strong></p>
<p>1、微信网页授权是通过OAuth2.0机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权access_token），通过网页授权access_token可以进行授权后接口调用，如获取用户基本信息；</p>
<p>2、其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用。</p>
<h4 id="3、如果需要，开发者可以刷新网页授权access-token，避免过期"><a href="#3、如果需要，开发者可以刷新网页授权access-token，避免过期" class="headerlink" title="3、如果需要，开发者可以刷新网页授权access_token，避免过期"></a>3、如果需要，开发者可以刷新网页授权access_token，避免过期</h4><p>由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token有效期为30天，当refresh_token失效之后，需要用户重新授权</p>
<p>获取第二步的access_token后，请求以下链接获取refresh_token： <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN">https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN</a></p>
<h4 id="4、通过网页授权access-token和openid获取用户基本信息（支持UnionID机制）"><a href="#4、通过网页授权access-token和openid获取用户基本信息（支持UnionID机制）" class="headerlink" title="4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）"></a>4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</h4><p>如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了</p>
<p>http：GET（请使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</a></p>
<p><strong>关于UnionID机制</strong></p>
<p>1、请注意，网页授权获取用户基本信息也遵循UnionID机制。即如果开发者有在多个公众号，或在公众号、移动应用之间统一用户帐号的需求，需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用UnionID机制来满足上述需求。</p>
<p>2、UnionID机制的作用说明：如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性，因为同一用户，对同一个微信开放平台下的不同应用（移动应用、网站应用和公众帐号），unionid是相同的。</p>
<p><strong>关于特殊场景下的静默授权</strong></p>
<p>1、上面已经提到，对于以snsapi_base为scope的网页授权，就静默授权的，用户无感知；</p>
<p>2、对于已关注公众号的用户，如果用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是scope为snsapi_userinfo，也是静默授权，用户无感知。</p>
<p><strong>检验授权凭证（access_token）是否有效</strong></p>
<p>http：GET（请使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID">https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID</a></p>
<p>返回0代表有效</p>
<h3 id="网页开发样式库：WEBUI"><a href="#网页开发样式库：WEBUI" class="headerlink" title="网页开发样式库：WEBUI"></a>网页开发样式库：WEBUI</h3><h3 id="微信JS-SDK"><a href="#微信JS-SDK" class="headerlink" title="微信JS-SDK"></a>微信JS-SDK</h3><p>是<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/cgi-bin/loginpage?t=wxm2-login&lang=zh_CN">微信公众平台</a> 面向网页开发者提供的基于微信内的网页开发工具包</p>
<h3 id="WEB开发者工具"><a href="#WEB开发者工具" class="headerlink" title="WEB开发者工具"></a>WEB开发者工具</h3><p>调试工具</p>
<h3 id="云开发"><a href="#云开发" class="headerlink" title="云开发"></a>云开发</h3><p>开发者可以使用云开发开发微信小程序、小游戏、公众号，无需搭建服务器，即可使用云端能力。</p>
<p>云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。</p>
<h2 id="Cookie和LocalStorage设置相关"><a href="#Cookie和LocalStorage设置相关" class="headerlink" title="Cookie和LocalStorage设置相关"></a>Cookie和LocalStorage设置相关</h2><p>一：退出微信账号后，将会清空所有Cookie和LocalStorage。</p>
<p>二：页面功能依赖Cookie，或有涉及到Cookie的相关逻辑 WKWebview内部实现变更，会影响目前页面Cookie相关的逻辑。</p>
<p>变化1：跨域存取Cookie 问题说明：在访问一个页面A时，如果页面A引用了另一个页面B的资源（页面A和B为不同的域名），这时页面B就被认为是第三方页面。若在页面B中设置Cookie，就会命中WKWebview下阻止第三方跨域设置Cookie的安全策略，导致问题出现。 适配建议： 在WKWebview中是默认阻止跨域的第三方设置Cookie。所有通过Cookie传递的信息，可通过业务后台存储需要传递的信息，然后给页面一个存储信息相对应的access_token加密码，再通过Url中加入自己业务的access_token进行页面间的信息传递。</p>
<p>变化2：微信原生层面的网络请求读取不到WKWebview中设置的cookie，即使域名是相同的。 问题说明：如果页面的资源或图片存储的服务器依赖校验Cookie来返回数据的情况，在切换到WKWebview后，在微信内长按保存，或者点击预览大图时，原生层面发起的网络请求将不会完整地带上所设置的Cookie，会导致图片保存失败或预览失败。 适配建议： 建议静态资源cookie free。如果确实有信息需要传递，可通过业务后台存储需要传递的信息，然后给页面一个存储信息相对应的access_token加密码，再通过Url中加入自己业务的access_token进行页面间信息传递。</p>
<p>除上述两种情况，开发者不用担心其他情况下Cookie丢失的问题，所有请求都会带上完整的Cookie</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.每个接口都有每日接口<strong>调用频次</strong>限制，可以在公众平台官网-开发者中心处查看具体频次。</p>
<p>2.公众平台以<strong>access_token</strong>为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储，详见获取接口调用凭据（access_token）文档</p>
<p>3.公众平台接口调用仅支持<strong>80端口</strong></p>
<p>微信公众号接口必须以http://或https://开头，分别支持80端口和443端口</p>
<p>4.涉及<strong>用户数据</strong>：</p>
<ul>
<li>您的服务需要收集用户任何数据的，必须事先获得用户的明确同意，且仅应当收集为运营及功能实现目的而必要的用户数据， 同时应当告知用户相关数据收集的目的、范围及使用方式等，保障用户知情权。</li>
<li>您收集用户的数据后，必须采取必要的保护措施，防止用户数据被盗、泄漏等。</li>
<li>您在特定微信公众号中收集的用户数据仅可以在该特定微信公众号中使用，不得将其使用在该特定微信公众号之外或为其他任何目的进行使用，也不得以任何方式将其提供给他人。</li>
<li>如果腾讯认为您收集、使用用户数据的方式，可能损害用户体验，腾讯有权要求您删除相关数据并不得再以该方式收集、使用用户数据。</li>
<li>一旦您停止使用本服务，或腾讯基于任何原因终止您使用本服务，您必须立即删除全部因使用本服务而获得的数据（包括各种备份）， 且不得再以任何方式进行使用。</li>
</ul>
<p>其他规范：</p>
<ul>
<li>请勿为任何用户自动登录到微信公众平台提供代理身份验证凭据。</li>
<li>请勿提供跟踪功能，包括但不限于识别其他用户在个人主页上查看、点击等操作行为。</li>
<li>请勿自动将浏览器窗口定向到其他网页。</li>
<li>请勿设置或发布任何违反相关法规、公序良俗、社会公德等的玩法、内容等。</li>
<li>请勿公开表达或暗示，您与腾讯之间存在合作关系，包括但不限于相互持股、商业往来或合作关系等，或声称腾讯对您的认可。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/" data-id="cknllgmcg0045sgwd9aobf3kj" data-title="微信开发" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-22.1.计算机基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:30:15.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。"><a href="#计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。" class="headerlink" title="*计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。*"></a><em><strong>*计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。*</strong></em></h3><p>存储器分为内存和磁盘。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="一、CPU"><a href="#一、CPU" class="headerlink" title="*一、CPU*"></a><em><strong>*一、CPU*</strong></em></h3><p>1.计算机核心组件，在单个计算机芯片上放置数十亿个微型晶体管来构建成CPU。</p>
<p>2.CPU的核心是从程序或应用程序获取指令并执行计算。提取，解码，执行。从系统的RAM（随机存取存储器，也叫主存）中提取指令然后解码该指令的实际内容，然后再由CPU相关部分执行。</p>
<p>3.主要由两部分组成：控制单元和算术逻辑单元（ALU）。</p>
<p>控制单元：从内存中提取指令并解码执行。</p>
<p>算术逻辑单元：处理算术和逻辑运算。</p>
<p>从功能看，由四部分:****寄存器n个****和控制器、运算器、时钟。由电信号连通。</p>
<p>CPU是一系列寄存器的集合体。</p>
<p>****累加寄存器*<em><strong>、</strong></em>*标志寄存器*<em><strong>、</strong></em>*程序计数器*<em><strong>、基址寄存器、变址寄存器、通用寄存器、</strong></em>*指令寄存器*<em><strong>、</strong></em>*栈寄存器****。（基址变址通用有多个，其余都是只有一个）</p>
<p>（1）程序计数器：用来存储下一条指令所在单元的地址。程序计数器控制着程序的流程。</p>
<p>（2）标志寄存器：保存累加寄存器的运算结果，也负责溢出（指运算的指令超过了寄存器的长度范围）和奇偶校验。标志寄存器的第一个字节为1则为正，第二个字节为1则为0，第三个字节为1则为负数。</p>
<p>（CPU执行机制有个比较运算，实际上是减法运算，其结果记录在标志寄存器上）</p>
<p>函数调用机制：call指令调用和return指令返回，中间是栈</p>
<p>（3）基址寄存器和变址寄存器：用过这两个寄存器可以实现对主存上的特定区域进行划分，来实现类似****数组****的操作。</p>
<p>实际地址=基址寄存器的值+变址寄存器的值</p>
<table>
<thead>
<tr>
<th>寄存器名</th>
<th>名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td>eax</td>
<td>累加寄存器</td>
<td>运算</td>
</tr>
<tr>
<td>ebc</td>
<td>基址存储器</td>
<td>存储内存地址</td>
</tr>
<tr>
<td>ecx</td>
<td>计数存储器</td>
<td>计算循环次数</td>
</tr>
<tr>
<td>edx</td>
<td>数据寄存器</td>
<td>存储数据</td>
</tr>
<tr>
<td>esi</td>
<td>源基址寄存器</td>
<td>存储数据发送源的内存地址</td>
</tr>
<tr>
<td>edi</td>
<td>目的基址寄存器</td>
<td>存储数据发送目标的内存地址</td>
</tr>
<tr>
<td>ebp</td>
<td>扩展基址寄存器</td>
<td>存储数据存储领域基点的内存地址</td>
</tr>
<tr>
<td>esp</td>
<td>扩展栈指针寄存器</td>
<td>存储栈中最高位数据的内存地址</td>
</tr>
</tbody></table>
<p>数据的销毁：栈中存在两个参数，可通过两次pop指令可以将栈内的数据销毁；也可采用esp寄存器+8的方式更有效率（只需处理一次）：数值的单位是4字节，esp寄存器+8相当于pop2次，虽然内存中的数据实际上还残留着，但只要把esp寄存器的值更新为数据存储地址前面的数据位置，该数据就相当于销毁了。</p>
<p>函数的参数是通过栈来传递，返回值是通过寄存器返回的。</p>
<p>∷CPU指令执行过程:取指令，指令译码，执行指令，访存取数，结果写回。</p>
<h3 id="二、-内存（内部存储设备）"><a href="#二、-内存（内部存储设备）" class="headerlink" title="二、****内存（内部存储设备）****"></a><strong>二、***</strong>*内存（内部存储设备）****</h3><p>\1. 也叫主存。是与CPU进行沟通的桥梁。通过控制芯片相连，由可读写的元素构成，每个字节（1byte=8bits）都有一个地址编号。CPU通过地址从内存中读取数据和指令，也可以根据地址写入数据。计算机所有程序的运行都是在主存中运行的。当计算机关闭时，内存中的指令和数据就会被清除。</p>
<p>\2. 作用：存放CPU中的运算数据，与硬盘等外部存储设备交换的数据。其运行决定了计算机的稳定运行。</p>
<p>\3. 内存的内部由各种IC电路组成，可分为三种：</p>
<p>（1）随机存储器（RAM）：最重要的一种，可读可写，机器关闭时，信息会丢失。</p>
<p>（2）只读存储器（ROM）：只可读，机器关闭时，信息不会丢失。</p>
<p>程序的运行环境，存在着名为BIOS（Basic Input/Output System）的系统。BIOS存储在ROM中，是预先内置在计算机主机内部的程序，记录了用来控制外围设备的程序和数据。BIOS除了键盘、磁盘、显卡等基本控制外，还有引导程序的功能。****引导程序****是存储在启动驱动器启示区域的小程序。操作系统的启动驱动器一般是硬盘，也有CD-ROM和软盘。</p>
<p>（3）高速缓存（Cache）：分为一级缓存（L1 Cache）、二级缓存、三级缓存。位于内存和CPU之间，是一个读写速度比内存更快的存储器。</p>
<p>内存IC：一个完整的结构，内部有电源，地址信号，控制信号和用于寻址的IC****引脚（Pin）****来进行数据的读写。IC就是集成电器（integrated circuit）</p>
<p>存储方式有两种:低字节序列（将数据低位存储在内存低位地址）和高字节序列（将数据的高位存储在内存的低位）。</p>
<p>数组是内存的实现。</p>
<p>\4. 虚拟内存是内存和磁盘交互的第二个媒介，是把磁盘的一部分作为假想内存来使用。虚拟内存在硬盘上的存在形式就是PAGEFILE.SYS这个页面文件。</p>
<p>当内存不足时可借助虚拟内存运行程序，通过置换（swap）。分为分页式和分段式。</p>
<p>Windows操作系统：</p>
<p>1.Windows是以图形界面为基础的操作系统，前身是MS-DOC（16位操作系统）。</p>
<p>2.有两个版本32和64位。（指的是处理效率最高的数据大小）</p>
<p>3.通过API（Application Programming Interface，应用程序接口）函数集成来提供系统调用。API通过多个DLL文件来提供。</p>
<p>4.通过WYSIWYG（what you see is what you get）实现打印输出。</p>
<p>5.提供多任务功能：通过时钟分割技术来实现，底层是cpu时间切片，这也是多线程多任务的核心。</p>
<p>6.提供网络功能和数据库功能。它们和操作系统很接近，所以被称为中间件而不是应用。操作系统+中间件=系统软件。</p>
<p>7.即插即用实现设备驱动的自动设定。</p>
<p>节约内存有两种方式：增加内存的容量，加内存条；优化应用程序，使其尽可能变小。</p>
<p>怎样优化应用程序呢？</p>
<p>1.可以通过DLL文件实现函数共有。</p>
<p>DLL（Dynamic Link Library）文件是一种动态链接库文件，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。多个应用可以共有一个DLL文件从而达到节约内存的效果。</p>
<p>\2. 通过调用_stdcall来减少程序文件的大小。</p>
<p>_stdcall是standard call（标准调用）。Windows提供的DLL函数都是通过_stdcall调用。</p>
<p>三、磁盘（外部存储设备）</p>
<p>内存通过电流实现存储，磁盘通过磁记录技术来实现存储。</p>
<p>早期磁盘：软盘。如今用的是硬磁盘。磁盘中存储的程序必须加载到内存中才能运行。</p>
<p>磁盘的缓存叫做磁盘缓存，指的是把从磁盘中读出的数据存储到内存的方式，磁盘缓存大大改善了磁盘访问的速度。磁盘缓存是内存的一部分。</p>
<p>磁盘的物理结构指的是磁盘存储数据的形式。通过其物理表面划分成多个空间来使用，划分方式：可变长方式和扇区方式（一般是这种）。</p>
<p>扇区是对磁盘进行物理读写的最小单位。</p>
<p>四、操作系统环境</p>
<p>程序要运行需要运行环境。运行环境=操作系统+硬件。</p>
<p>操作系统又可以被称为软件，是由一系列的指令组成的。分为：Windows、Linux、Unix、FreeBSD(Unix系统的一种)。监控程序（加载程序、运行程序）可以说是操作系统的原型。后来又加上了基本的输入输出程序，再后来加上了硬件控制程序、编程语言处理器（汇编、编译、解析）、各种应用程序。操作系统其实就是多个程序的集合体。</p>
<p>Windows操作的是硬件而不是软件，软件通过操作windows系统可以达到控制硬件的目的。程序员没法直接控制硬件，且windows屏蔽了控制硬件的细节，但是windows却开放了系统调用功能来实现对硬件的控制，系统调用称为API，API就是应用调用的函数，这些函数的实体被存放在DLL文件中。</p>
<p>CPU的类型不同，所对应的机器的语言也不同。操作系统的类型不同，应用程序向操作系统传递指令的途径（称为API，Application Programming Interface）也不同。</p>
<p>五、显卡</p>
<p>承担图形的输出任务。又被称为图形处理器（Graphic Processing Unit,GPU）。</p>
<p>显示器中显示的信息一直存储在某内存中，该内存称为VRAM（Video RAM），在程序中，只要往VRAM中写入数据，该数据就会在显示器中显示出来。实现该功能的程序，是由操作系统或者BIOS提供，并借助中断来处理。</p>
<p>集成显卡：集成显卡是一种特殊的显卡，它一般不带有显存，而是使用系统的一部分主内存作为显存，具体的数量是系统根据需要自动动态调整的。</p>
<p>独立显卡：独立显卡简称独显，是指成独立的板卡，需要插在主板的相应接口上的显卡。独立显卡又分为内置独立显卡和外置显卡。独立显卡具备单独的显存，不占用系统内存，而且技术上领先于集成显卡，能够提供更好的显示效果和运行性能。</p>
<p>六、外围设备</p>
<p>1.IO端口</p>
<p>计算机主机中，附带了用来连接显示器以及键盘等外围设备的连接器，连接器内部都连接有用来交换计算机主机内外围设备之间电流特性的IC，这些IC统称为IO控制器。IO控制器中有用于临时保存输入输出数据的内存，被称为寄存器（与CPU的寄存器不同），这些内存就是端口。一个io控制器可以控制多个设备，各端口之间通过端口号来区分。端口号也被称为IO地址。</p>
<p>2.IRQ实现中断</p>
<p>外围设备的中断请求：IRQ（Interrupt Request）代表的就是中断请求。IRQ用来暂停当前正在运行的程序，并跳转到其他程序运行的必要机制，该机制被称为处理中断。实施中断请求的是连接外围设备的io控制器，负责实施中断处理的是CPU，外围设备的中断请求会使用不同于IO端口的其他编号，这个编号叫中断编号。操作系统以及BIOS则会提供响应中断编号的中断处理程序。</p>
<p>假如有多个外围设备请求中断的话，可以在IO控制器和CPU之间加入名为中断控制器的IC进行缓冲。</p>
<p>3.DMA实现短时间内大量数据传输</p>
<p>DMA（Direct Memory Access）：指在不通过CPU的情况下，外围设备直接和主存进行数据传输。磁盘等外围设备都用到了DMA机制</p>
<p>假如多个设备设定成相同的端口号、IRQ和DMA通道的话，计算机就无法正常工作，会提示设备冲突。</p>
<p>网址后缀名：</p>
<p>.org  非盈利性组织</p>
<p>.com  商业机构</p>
<p>.cn  政府</p>
<p>.edu  教育</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="cknllgmb70010sgwdf4ie908e" data-title="计算机基础知识" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库和SQL语句" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:29:35.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/">数据库和SQL语句</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数据库就是一个文件系统，通过标准的SQL语句获取数据</p>
<p>关系型数据库：存放的是实体之间的关系</p>
<p>ER模型图：E：Entity  R：Relational  （实体用矩形，属性用椭圆，关系用菱形）</p>
<p>表：对应一个实体类</p>
<p>对数据库的添加，修改，删除，查询操作</p>
<p>对数据库表的添加，修改，删除，查询操作</p>
<p>对数据库表记录的添加，修改，删除，查询操作</p>
<p>常见的关系型数据库：</p>
<p><strong>MySQL</strong></p>
<p><strong>Oracle</strong></p>
<p>SQLServer</p>
<p>DB2</p>
<p>SyBase</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps18.jpg" alt="img"> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/" data-id="cknllgmc0003asgwd6jx546fn" data-title="数据库和SQL语句" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-15.1.Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/15.1.Redis/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:28:54.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/15.1.Redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Redis是一个开源的使用ANSI <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1219.htm">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1088.htm">数据库</a>，并提供多种语言的APIRedis是一个开源的使用ANSI <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1219.htm">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1088.htm">数据库</a>，并提供多种语言的API</p>
<p>从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助</p>
<p>Redis是 NoSQL（not only SQL）技术阵营中的一员，它通过多种键值数据类型来适应不同场景下的存储需求，借助一些高层级的接口使用其可以胜任，如缓存、队列系统的不同角色</p>
<p>Redis可以保存在内存中（性能非常好），也可以持久化在文件中</p>
<p>Redis的官网: <a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<p>经常用的数据成缓存，所以用redis</p>
<p>特性：</p>
<p>1.Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</p>
<p>2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</p>
<p>3.Redis支持数据的备份，即master-slave模式的数据备份</p>
<p>优势：</p>
<p>1.性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s</p>
<p>2.丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作</p>
<p>3.原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行</p>
<p>4.丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性</p>
<h1 id="Redis-下载及安装"><a href="#Redis-下载及安装" class="headerlink" title="*Redis*****下载及安装****"></a><em><strong>*Redis*</strong>***</em>*下载及安装****</h1><p>Redis版本说明</p>
<p>Redis原生只支持linux系统。Redis官方是不支持windows平台，windows版本是微软自己建立的分支，基于官方的redis源码上进行编译、发布、维护的，所以window平台上的redis版本都略低于官方版本</p>
<p>当前redis最新版本是6.0</p>
<p>可以直接在windows上下载，通过上传工具上传到linux系统，也可以在linux下直接复制最新稳定版本下载链接的网址，然后wget+网址（这种方式必须要求可以上网）</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps1.jpg" alt="img"> </p>
<p>Redis安装：</p>
<p>1.将redis.tar.gz解压：tar -zxvf redis-3.2.8.tar.gz</p>
<p>mkdir redis  建一个目录</p>
<p>2.进入redis-3.2.8目录：cd redis-3.2.8</p>
<p>3.对redis进行编译:make  </p>
<p>4.安装到指定的目录：make PREFIX=/usr/local/redis install</p>
<p>如果安装redis是报下面的错误，是因为系统没有安装gcc环境，缺少依赖</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps2.jpg" alt="img"> </p>
<p>解决方案：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps3.jpg" alt="img"> </p>
<p>安装完成后，对redis进行重新编译安装</p>
<p>redis安装完成后，我们进入目录bin中查看</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps4.jpg" alt="img"> </p>
<p>redis-server          redis服务器</p>
<p>redis-cli           redis命令行客户端</p>
<p>redis-benchmark          redis性能测试工具</p>
<p>redis-check-aof         AOF文件修复工具</p>
<p>redis-check-rdb          RDB文件检索工具</p>
<p>redis客户端测试：</p>
<p>1.启动redis服务</p>
<p>./redis-server是可以启动的，但是有风险，只在测试环境下可以。正常启动需要加载配置文件</p>
<p>注意：我们需要将redis编译后的目录中的redis.conf文件copy到我们自己的redis目录中。 cp redis.conf /usr/local/redis </p>
<p>这个redis.conf文件是redis的配置文件</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps5.jpg" alt="img"> </p>
<p>在输入</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps6.jpg" alt="img">就可以启动</p>
<p>注意:前面是redis-server服务，后面redis.conf配置文件</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps7.jpg" alt="img"> </p>
<p>Redis占用的端口是6379</p>
<p>可以通过redis-cli命令行客户端来测试redis是否启动成功</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps8.jpg" alt="img"> </p>
<p>其他ip地址不能连接是因为配置文件中只允许回环地址127.0.0.1连接</p>
<h1 id="Redis-数据类型与常见操作"><a href="#Redis-数据类型与常见操作" class="headerlink" title="*Redis*****数据类型与常见操作****"></a><em><strong>*Redis*</strong>***</em>*数据类型与常见操作****</h1><p>redis是一个key-value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/51839.htm">存储系统</a>。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/549479.htm">链表</a>)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）</p>
<p>1.string类型常见操作</p>
<p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M</p>
<p>常见操作（小写也可）</p>
<p>l SET key value      </p>
<p>设定该Key持有指定的字符串Value，如果该Key已经存在，则覆盖其原有值。返回值：总是返回”OK”</p>
<p>l GET key      </p>
<p>获取指定Key的Value。如果与该Key关联的Value不是string类型，Redis将返回错误信息，因为GET命令只能用于获取string Value。</p>
<p>返回值：与该Key相关的Value，如果该Key不存在，则返回nil。</p>
<p>l MSET key value [key value …]      </p>
<p>该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SET命令。 </p>
<p>返回值：该命令不会失败，始终返回OK。 </p>
<p>l MGET key [key …]  </p>
<p>返回所有指定Keys的Values，如果其中某个Key不存在，或者其值不为string类型，该Key的Value将返回nil。    </p>
<p>返回值：返回一组指定Keys的Values的列表。</p>
<p>l SETNX key value  </p>
<p>如果指定的Key不存在，则设定该Key持有指定字符串Value，此时其效果等价于SET命令。相反，如果该Key已经存在，该命令将不做任何操作并返回。</p>
<p>返回值：1表示设置成功，否则0。（not exists）</p>
<p>l MSETNX key value [key value …]      </p>
<p>该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SETNX命令。然而这里需要明确说明的是，如果在这一批Keys中有任意一个Key已经存在了，那么该操作将全部回滚，即所有的修改都不会生效。</p>
<p>返回值：1表示所有Keys都设置成功，0则表示没有任何Key被修改。</p>
<p>ü APPEND key value  </p>
<p>如果该Key已经存在，APPEND命令将参数Value的数据追加到已存在Value的末尾。如果该Key不存在，APPEND命令将会创建一个新的Key/Value。</p>
<p>返回值：追加后Value的长度。</p>
<p>ü DECR key     </p>
<p>将指定Key的Value原子性的递减1。如果该Key不存在，其初始值为0，在decr之后其值为-1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。（error）</p>
<p>返回值：递减后的Value值。</p>
<p>l INCR key     </p>
<p>将指定Key的Value原子性的递增1。如果该Key不存在，其初始值为0，在incr之后其值为1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。</p>
<p>返回值：递增后的Value值。 </p>
<p>l DECRBY key decrement  </p>
<p>将指定Key的Value原子性的减少decrement。如果该Key不存在，其初始值为0，在decrby之后其值为-decrement。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</p>
<p>返回值：减少后的Value值。</p>
<p>l INCRBY key increment   </p>
<p>将指定Key的Value原子性的增加increment。如果该Key不存在，其初始值为0，在incrby之后其值为increment。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</p>
<p>返回值：增加后的Value值。</p>
<p>l GETSET key value     </p>
<p>原子性的设置该Key为指定的Value，同时返回该Key的原有值。和GET命令一样，该命令也只能处理string Value，否则Redis将给出相关的错误信息。</p>
<p>返回值：返回该Key的原有值，如果该Key之前并不存在，则返回nil。</p>
<p>l STRLEN key     </p>
<p>返回指定Key的字符值长度，如果Value不是string类型，Redis将执行失败并给出相关的错误信息。</p>
<p>返回值：指定Key的Value字符长度，如果该Key不存在，返回0。</p>
<p>l SETEX key seconds value     </p>
<p>原子性完成两个操作，一是设置该Key的值为指定字符串，同时设置该Key在Redis服务器中的存活时间(秒数)。该命令主要应用于Redis被当做Cache服务器使用时。     （expire，到期）</p>
<p>l SETRANGE key offset value  </p>
<p>替换指定Key的部分字符串值。从offset开始，替换的长度为该命令第三个参数value的字符串长度，其中如果offset的值大于该Key的原有值Value的字符串长度，Redis将会在Value的后面补齐(offset - strlen(value))数量的0x00，之后再追加新值。如果该键不存在，该命令会将其原值的长度假设为0，并在其后添补offset个0x00后再追加新值。鉴于字符串Value的最大长度为512M，因此offset的最大值为536870911。最后需要注意的是，如果该命令在执行时致使指定Key的原有值长度增加，这将会导致Redis重新分配足够的内存以容纳替换后的全部字符串，因此就会带来一定的性能折损。</p>
<p>返回值：修改后的字符串Value长度。</p>
<p>l GETRANGE key start end     </p>
<p>截取字符串。该命令在截取子字符串时，将以闭区间的方式同时包含start(0表示第一个字符)和end所在的字符，如果end值超过Value的字符长度，该命令将只是截取从start开始之后所有的字符数据。当end为-1时表示是最后一位，-4 -1表示从后数4位</p>
<p>返回值：子字符串；</p>
<p>l SETBIT key offset value      </p>
<p>设置在指定Offset上BIT的值，该值只能为1或0，在设定后该命令返回该Offset上原有的BIT值。如果指定Key不存在，该命令将创建一个新值，并在指定的Offset上设定参数中的BIT值。如果Offset大于Value的字符长度，Redis将拉长Value值并在指定Offset上设置参数中的BIT值，中间添加的BIT值为0。最后需要说明的是Offset值必须大于0。</p>
<p>返回值：在指定Offset上的BIT原有值。</p>
<p>l GETBIT key offset      </p>
<p>返回在指定Offset上BIT的值，0或1。如果Offset超过string value的长度，该命令将返回0，所以对于空字符串始终返回0。</p>
<p>返回值：在指定Offset上的BIT值。 </p>
<p>(布隆过滤器)</p>
<p>a  97  0110 0001    </p>
<p>A  65  0100 0001  其实只用 setbit key 2 0  就将a改为了A（从0开始计数）</p>
<p>2.list类型常见操作</p>
<p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的****普通链表****一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。</p>
<p>从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。</p>
<p>常见操作</p>
<p>l LPUSH key value [value …]      </p>
<p>在指定Key所关联的List Value的头部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的头部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。</p>
<p>返回值：插入后链表中元素的数量。</p>
<p>l LPUSHX key value       （x相当于判断）</p>
<p>仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的头部插入参数中给出的Value，否则将不会有任何操作发生。    </p>
<p>返回值：插入后链表中元素的数量。 </p>
<p>l LRANGE key start stop      </p>
<p>该命令的参数start和end都是0-based。即0表示链表头部(leftmost)的第一个元素。其中start的值也可以为负值，-1将表示链表中的最后一个元素，即尾部元素，-2表示倒数第二个并以此类推。该命令在获取元素时，start和end位置上的元素也会被取出。如果start的值大于链表中元素的数量，空链表将会被返回。如果end的值大于元素的数量，该命令则获取从start(包括start)开始，链表中剩余的所有元素。</p>
<p>返回值：返回指定范围内元素的列表。</p>
<p>这里的链表插入的头部插入相当于是栈：插入12345，输出时就会是54321</p>
<p>lrange key 0 -1 表示返回这个链表的所有元素</p>
<p>l LPOP key      （相当于把头部的那个元素移除）</p>
<p>返回并弹出指定Key关联的链表中的第一个元素，即头部元素。如果该Key不存，返回nil。</p>
<p>返回值：链表头部的元素。</p>
<p>l LLEN key     </p>
<p>返回指定Key关联的链表中元素的数量，如果该Key不存在，则返回0。如果与该Key关联的Value的类型不是链表，则返回相关的错误信息。</p>
<p>返回值：链表中元素的数量。</p>
<p>l LREM key count value  </p>
<p>在指定Key关联的链表中，删除前count个值等于value的元素。如果count大于0，从头向尾遍历并删除，如果count小于0，则从尾向头遍历并删除。</p>
<p>如果count等于0，则删除链表中所有等于value的元素。如果指定的Key不存在，则直接返回0。    </p>
<p>返回值：返回被删除的元素数量。</p>
<p>l LSET key index value </p>
<p>设定链表中指定位置的值为新值，其中0表示第一个元素，即头部元素，-1表示尾部元素。如果索引值Index超出了链表中元素的数量范围，该命令将返回相关的错误信息。     </p>
<p>(对指定脚标的值进行设置)</p>
<p>返回值：OK</p>
<p>l LINDEX key index      </p>
<p>该命令将返回链表中指定位置(index)的元素，index是0-based，表示头部元素，如果index为-1，表示尾部元素。如果与该Key关联的不是链表，该命令将返回相关的错误信息。    </p>
<p>返回值：返回请求的元素，如果index超出范围，则返回nil。</p>
<p>(读出指定脚标的值)</p>
<p>l LTRIM key start stop      </p>
<p>该命令将仅保留指定范围内的元素，从而保证链接中的元素数量相对恒定。start和stop参数都是0-based，0表示头部元素。和其他命令一样，start和stop也可以为负值，-1表示尾部元素。如果start大于链表的尾部，或start大于stop，该命令不会报错，而是返回一个空的链表，与此同时该Key也将被删除。如果stop大于元素的数量，则保留从start开始剩余的所有元素。     </p>
<p>l LINSERT key BEFORE|AFTER pivot value  </p>
<p>该命令的功能是在pivot元素的前面或后面插入参数中的元素value。如果Key不存在，该命令将不执行任何操作。如果与Key关联的Value类型不是链表，相关的错误信息将被返回。    </p>
<p>返回值：成功插入后链表中元素的数量，如果没有找到pivot，返回-1，如果key不存在，返回0。</p>
<p>(在指定的某个value前或后插入一个新的value)</p>
<p>l RPUSH key value [value …]      </p>
<p>在指定Key所关联的List Value的尾部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的尾部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。 </p>
<p>返回值：插入后链表中元素的数量。 </p>
<p>l RPUSHX key value </p>
<p>仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的尾部插入参数中给出的Value，否则将不会有任何操作发生。</p>
<p>返回值：插入后链表中元素的数量。 </p>
<p>l RPOP key      </p>
<p>返回并弹出指定Key关联的链表中的最后一个元素，即尾部元素，。如果该Key不存，返回nil。 </p>
<p>返回值：链表尾部的元素。 </p>
<p>l RPOPLPUSH source destination      </p>
<p>原子性的从与source键关联的链表尾部弹出一个元素，同时再将弹出的元素插入到与destination键关联的链表的头部。如果source键不存在，该命令将返回nil，同时不再做任何其它的操作了。如果source和destination是同一个键，则相当于原子性的将其关联链表中的尾部元素移到该链表的头部。    </p>
<p>返回值：返回弹出和插入的元素</p>
<p>3.hash类型常见操作</p>
<p>Redis中的Hashes类型可以看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如用户信息：Username、Password和Age等。每一个Hash可以存储4294967295个键值对。</p>
<p>常见操作</p>
<p>l HSET key field value     </p>
<p>为指定的Key设定Field/Value对，如果Key不存在，该命令将创建新Key以参数中的Field/Value对，如果参数中的Field在该Key中已经存在，则用新值覆盖其原有值。</p>
<p>返回值：1表示新的Field被设置了新值，0表示Field已经存在，用新值覆盖原有值。 </p>
<p>l HGET key field      </p>
<p>返回指定Key中指定Field的关联值。    </p>
<p>返回值：返回参数中Field的关联值，如果参数中的Key或Field不存，返回nil。</p>
<p>l HSETNX key field value     </p>
<p>只有当参数中的Key或Field不存在的情况下，为指定的Key设定Field/Value对，否则该命令不会进行任何操作。 </p>
<p>返回值：1表示新的Field被设置了新值，0表示Key或Field已经存在，该命令没有进行任何操作。</p>
<p>l HEXISTS key field      </p>
<p>判断指定Key中的指定Field是否存在。    </p>
<p>返回值：1表示存在，0表示参数中的Field或Key不存在。</p>
<p>l HLEN key      </p>
<p>获取该Key所包含的Field的数量。    返回Key包含的Field数量，如果Key不存在，返回0。</p>
<p>l HDEL key field [field …]      </p>
<p>从指定Key的Hashes Value中删除参数中指定的多个字段，如果不存在的字段将被忽略。</p>
<p>返回值：如果Key不存在，则将其视为空Hashes，并返回0，否则返回实际删除的Field数量。</p>
<p>l HINCRBY key field increment      </p>
<p>增加指定Key中指定Field关联的Value的值。如果Key或Field不存在，该命令将会创建一个新Key或新Field，并将其关联的Value初始化为0，之后再指定数字增加的操作。该命令支持的数字是64位有符号整型，即increment可以负数。返回值：运算后的值。</p>
<p>l HGETALL key     </p>
<p>获取该键包含的所有Field/Value。其返回格式为一个Field、一个Value，并以此类推。    </p>
<p>返回值：Field/Value的列表。</p>
<p>l HKEYS key      </p>
<p>返回指定Key的所有Fields名。    </p>
<p>返回值：Field的列表。</p>
<p>l HVALS key      </p>
<p>返回指定Key的所有Values名。 </p>
<p>返回值：Value的列表。 </p>
<p>l HMGET key field [field …]      </p>
<p>获取和参数中指定Fields关联的一组Values。如果请求的Field不存在，其值返回nil。如果Key不存在，该命令将其视为空Hash，因此返回一组nil。    </p>
<p>返回值：返回和请求Fields关联的一组Values，其返回顺序等同于Fields的请求顺序。</p>
<p>l HMSET key field value [field value …]     </p>
<p>逐对依次设置参数中给出的Field/Value对。如果其中某个Field已经存在，则用新值覆盖原有值。如果Key不存在，则创建新Key，同时设定参数中的Field/Value</p>
<p>4.set类型常见操作（不重复，可以完成交并差操作）</p>
<p>在Redis中，我们可以将Set类型看作为没有排序的字符串集合。Set可包含的最大元素数量是4294967295。</p>
<p>Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。</p>
<p>常见操作</p>
<p>l SADD key member [member …]     </p>
<p>如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。</p>
<p>返回值：本次操作实际插入的成员数量。</p>
<p>l SCARD key     </p>
<p>获取Set中成员的数量。    </p>
<p>返回值：返回Set中成员的数量，如果该Key并不存在，返回0。</p>
<p>l SISMEMBER key member     </p>
<p>判断参数中指定成员是否已经存在于与Key相关联的Set集合中。    </p>
<p>返回值：1表示已经存在，0表示不存在，或该Key本身并不存在。</p>
<p>l SMEMBERS key     </p>
<p>获取与该Key关联的Set中所有的成员。</p>
<p>返回值：返回Set中所有的成员。</p>
<p>l SPOP  key      </p>
<p>随机的移除并返回Set中的某一成员。 由于Set中元素的布局不受外部控制，因此无法像List那样确定哪个元素位于Set的头部或者尾部。    </p>
<p>返回值：返回移除的成员，如果该Key并不存在，则返回nil。</p>
<p>l SRANDMEMBER key      </p>
<p>和SPOP一样，随机的返回Set中的一个成员，不同的是该命令并不会删除返回的成员。    </p>
<p>返回值：返回随机位置的成员，如果Key不存在则返回nil。</p>
<p>l SREM key member [member …]     </p>
<p>从与Key关联的Set中删除参数中指定的成员，不存在的参数成员将被忽略，如果该Key并不存在，将视为空Set处理。    </p>
<p>返回值：从Set中实际移除的成员数量，如果没有则返回0。</p>
<p>l SMOVE source destination member     </p>
<p>原子性的将参数中的成员从source键移入到destination键所关联的Set中。如果该成员在source中并不存在，该命令将不会再执行任何操作并返回0，否则，该成员将从source移入到destination。如果此时该成员已经在destination中存在，那么该命令仅是将该成员从source中移出。</p>
<p>返回值：1表示正常移动，0表示source中并不包含参数成员。</p>
<p>l SDIFF key [key …]     </p>
<p>返回参数中第一个Key所关联的Set和其后所有Keys所关联的Sets中成员的差异。如果Key不存在，则视为空Set。    </p>
<p>返回值：差异结果成员的集合。</p>
<p>l SDIFFSTORE destination key [key …]      </p>
<p>该命令和SDIFF命令在功能上完全相同，两者之间唯一的差别是SDIFF返回差异的结果成员，而该命令将差异成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。    </p>
<p>返回值：返回差异成员的数量。</p>
<p>l SINTER key [key …]      </p>
<p>该命令将返回参数中所有Keys关联的Sets中成员的交集。因此如果参数中任何一个Key关联的Set为空，或某一Key不存在，那么该命令的结果将为空集。</p>
<p>返回值：交集结果成员的集合。</p>
<p>l SINTERSTORE destination key [key …]     </p>
<p>该命令和SINTER命令在功能上完全相同，两者之间唯一的差别是SINTER返回交集的结果成员，而该命令将交集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。    </p>
<p>返回值：返回交集成员的数量。 </p>
<p>l SUNION key [key …]      </p>
<p>该命令将返回参数中所有Keys关联的Sets中成员的并集。    </p>
<p>返回值：并集结果成员的集合。</p>
<p>l SUNIONSTORE destination key [key …]      </p>
<p>该命令和SUNION命令在功能上完全相同，两者之间唯一的差别是SUNION返回并集的结果成员，而该命令将并集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。 </p>
<p>返回值：返回并集成员的数量</p>
<p>5.sortedSet类型常见操作</p>
<p>Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的<em><strong>*成员必须是唯一*<em><strong>的，但是</strong></em>*分数*</strong>***</em>*(score)********却是可以重复****的。</p>
<p>在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。</p>
<p>常见操作</p>
<p>l ZADD key score member [score] [member]      </p>
<p>添加参数中指定的所有成员及其分数到指定key的Sorted-Set中，在该命令中我们可以指定多组score/member作为参数。如果在添加时参数中的某一成员已经存在，该命令将更新此成员的分数为新值，同时再将该成员基于新值重新排序。如果键不存在，该命令将为该键创建一个新的Sorted-Sets Value，并将score/member对插入其中。</p>
<p>返回值：本次操作实际插入的成员数量。</p>
<p>l ZINCRBY key increment member      </p>
<p>该命令将为指定Key中的指定成员增加指定的分数。如果成员不存在，该命令将添加该成员并假设其初始分数为0，此后再将其分数加上increment。如果Key不存，该命令将创建该Key及其关联的Sorted-Sets，并包含参数指定的成员，其分数为increment参数。</p>
<p>返回值：以字符串形式表示的新分数。</p>
<p>l ZCARD key      </p>
<p>获取与该Key相关联的Sorted-Sets中包含的成员总数量。</p>
<p>返回值：返回Sorted-Sets中的成员数量，如果该Key不存在，返回0。</p>
<p>l ZCOUNT key min max     </p>
<p>该命令用于获取<em><strong>*分数*</strong>***</em>*(score)****在min和max之间的成员数量。缺省情况下，min和max表示的范围是闭区间范围，即min &lt;= score &lt;= max内的成员将被返回。然而我们可以通过在min和max的前面添加”(“字符来表示开区间，如(min max表示min &lt; score &lt;= max，而(min (max表示min &lt; score &lt; max。</p>
<p>返回值：分数指定范围内成员的数量。</p>
<p>l ZRANGE key start stop [WITHSCORES]      </p>
<p>该命令返回****排名****在参数start和stop指定范围内的成员，这里start和stop参数都是0-based，即0表示第一个成员，-1表示最后一个成员。如果start大于该Sorted-Set中的最大索引值，或start &gt; stop，此时一个空集合将被返回。如果stop大于最大索引值，该命令将返回从start到集合的最后一个成员。如果命令中带有可选参数WITHSCORES选项，该命令在返回的结果中将包含每个成员的分数值，如value1,score1,value2,score2…。　　    </p>
<p>返回值：返回索引在start和stop之间的成员列表。</p>
<p>l ZREVRANGE key start stop [WITHSCORES]   </p>
<p>该命令的功能和ZRANGE基本相同，唯一的差别在于顺序相反。    </p>
<p>返回值：返回指定的成员列表。</p>
<p>l ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]      </p>
<p>该命令将返回****分数****在min和max范围内的成员，即满足表达式min &lt;= score &lt;= max的成员，其中返回的成员是按照其分数从低到高的顺序返回，如果成员具有相同的分数，则按成员的字典顺序返回。可选参数LIMIT用于限制返回成员的数量范围。可选参数offset表示从符合条件的第offset个成员开始返回，同时返回count个成员。</p>
<p>返回值：返回分数在指定范围内的成员列表。</p>
<p>l ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]      </p>
<p>该命令除了排序方式是基于从高到低的分数排序之外，其它功能和参数含义均与ZRANGEBYSCORE相同。    </p>
<p>返回值：返回分数在指定范围内的成员列表。 </p>
<p>l ZRANK key member      </p>
<p>该命令将返回参数中指定****成员的位置值****（按分数由低到高的顺序），其中0表示第一个成员，它是Sorted-Set中分数最低的成员。</p>
<p>返回值：如果该成员存在，则返回它的位置索引值。否则返回nil。</p>
<p>l ZREVRANK key member      </p>
<p>该命令的功能和ZRANK基本相同，唯一的差别在于顺序相反    </p>
<p>返回值：如果该成员存在，则返回它的位置索引值。否则返回nil。 </p>
<p>l ZSCORE key member     </p>
<p>获取指定成员的分数。    </p>
<p>返回值：如果该成员存在，以字符串的形式返回其分数，否则返回nil。</p>
<p>l ZREM key member [member …]     </p>
<p>该命令将移除参数中指定的成员，其中不存在的成员将被忽略。如果与该Key关联的Value不是Sorted-Set，相应的错误信息将被返回。</p>
<p>返回值：实际被删除的成员数量。</p>
<p>l ZREMRANGEBYRANK key start stop      </p>
<p>删除索引位置位于start和stop之间的成员，start和stop都是0-based，即0表示分数最低的成员，-1表示最后一个成员，即分数最高的成员。     </p>
<p>返回值：被删除的成员数量。</p>
<p>l ZREMRANGEBYSCORE key min max      </p>
<p>删除分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的所有成员。对于min和max参数，可以采用开区间的方式表示，具体规则参照ZCOUNT。 </p>
<p>返回值：被删除的成员数量</p>
<p>6.Key通用操作</p>
<p>l KEYS pattern     </p>
<p>获取所有匹配pattern参数（正则）的Keys。需要说明的是，在我们的正常操作中应该尽量避免对该命令的调用，因为对于大型数据库而言，该命令是非常耗时的，对Redis服务器的性能打击也是比较大的。pattern支持glob-style的通配符格式，如*表示任意一个或多个字符，?表示任意字符，[abc]表示方括号中任意一个字母。    匹配模式的键列表。</p>
<p>l DEL key [key …]     </p>
<p>从数据库删除中参数中指定的keys，如果指定键不存在，则直接忽略。还需要另行指出的是，如果指定的Key关联的数据类型不是String类型，而是List、Set、Hashes和Sorted Set等容器类型，该命令删除每个键的时间复杂度为O(M)，其中M表示容器中元素的数量。而对于String类型的Key，其时间复杂度为O(1)。</p>
<p>返回值：实际被删除的Key数量。</p>
<p>l EXISTS key      </p>
<p>判断指定键是否存在。    </p>
<p>返回值：1表示存在，0表示不存在。</p>
<p>l MOVE key db      </p>
<p>将当前数据库中指定的键Key移动到参数中指定的数据库中。如果该Key在目标数据库中已经存在，或者在当前数据库中并不存在，该命令将不做任何操作并返回0。     </p>
<p>返回值：移动成功返回1，否则0。</p>
<p>在redis.conf文件中定义了redis的默认库的数量</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps9.jpg" alt="img"> </p>
<p>我们可以使用select 数值 来进行库的切换: select  10.</p>
<p>l RENAME key newkey      </p>
<p>为指定的键重新命名，如果参数中的两个Keys的名字相同，或者是源Key不存在，该命令都会返回相关的错误信息。如果newKey已经存在，则直接覆盖。  </p>
<p>l RENAMENX key newkey     </p>
<p>如果新值不存在，则将参数中的原值修改为新值。其它条件和RENAME一致。</p>
<p>返回值：1表示修改成功，否则0。</p>
<p>l PERSIST key     </p>
<p>如果Key存在过期时间，该命令会将其过期时间消除，使该Key不再有超时，而是可以持久化存储。    </p>
<p>返回值：1表示Key的过期时间被移除，0表示该Key不存在或没有过期时间。</p>
<p>l EXPIRE key seconds      </p>
<p>该命令为参数中指定的Key设定超时的秒数，在超过该时间后，Key被自动的删除。如果该Key在超时之前被修改，与该键关联的超时将被移除。 </p>
<p>返回值：1表示超时被设置，0则表示Key不存在，或不能被设置。</p>
<p>l EXPIREAT key timestamp  </p>
<p>该命令的逻辑功能和EXPIRE完全相同，唯一的差别是该命令指定的超时时间是绝对时间，而不是相对时间。该时间参数是Unix timestamp格式的，即从1970年1月1日开始所流经的秒数。    </p>
<p>返回值：1表示超时被设置，0则表示Key不存在，或不能被设置。 </p>
<p>l TTL key      </p>
<p>获取该键所剩的超时描述。 </p>
<p>返回值：返回所剩描述，如果该键不存在或没有超时设置，则返回-1。</p>
<p>l RANDOMKEY     </p>
<p>从当前打开的数据库中随机的返回一个Key。    </p>
<p>返回值：返回的随机键，如果该数据库是空的则返回nil。</p>
<p>l TYPE key      </p>
<p>获取与参数中指定键关联值的类型，该命令将以字符串的格式返回。    </p>
<p>返回值：返回的字符串为string、list、set、hash和zset，如果key不存在返回none</p>
<p>7.事务</p>
<p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<p>l 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>l 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<p>开始事务。<em><strong>*MULTI*</strong></em> </p>
<p>命令入队。执行的redis的操作</p>
<p>执行事务。<em><strong>*EXEC*</strong></em> </p>
<p>事务常用命令</p>
<p>l MULTI</p>
<p>Redis Multi 命令用于标记一个事务块的开始。</p>
<p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p>
<p>返回值:总是返回OK</p>
<p>l EXEC</p>
<p>Redis Exec 命令用于执行所有事务块内的命令</p>
<p>返回值: 事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</p>
<p>l DISCARD</p>
<p>Redis Discard 命令用于取消事务，放弃执行事务块内的所有命令。</p>
<p>返回值: 总是返回 OK 。</p>
<p>l WATCH</p>
<p>Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</p>
<p>l UNWATCH</p>
<p>Redis Unwatch 命令用于取消 WATCH 命令对所有 key 的监视</p>
<h1 id="Redis-java-客户端-jedis"><a href="#Redis-java-客户端-jedis" class="headerlink" title="*Redis java*****客户端*****jedis*"></a><em><strong>*Redis java*</strong>***</em>*客户端****<em><strong>*jedis*</strong></em></h1><p>Jedis介绍与快速入门</p>
<p>通过java来操作redis：使用jedis</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps10.jpg" alt="img"> </p>
<p>搭建jedis环境：</p>
<p>新建一个javaproject，复制jar包到lib下，右键addpath构建路径</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps11.jpg" alt="img"> </p>
<p>编写代码</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps12.jpg" alt="img"> </p>
<p>程序执行报错：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps13.jpg" alt="img"> </p>
<p>原因:</p>
<p>1.redis服务器是否开启：linux上加载redis-server和redis.conf查看开启</p>
<p>2.linux的防火墙是否关闭：service iptables stop  关了之后在重启redis服务器</p>
<p>3.在redis.conf配置文件中 bind 127.0.0.1 代表的是外部不可以访问redis（可以把它注释掉，前面加#）</p>
<p>通过以上操作，错误信息不一样了：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps14.jpg" alt="img"> </p>
<p>原因：是我们没有设置密码</p>
<p>我们需要在redis.conf文件中设置密码admin：查找到requirepass，将前面的#删掉，然后将后面的改为admin，：wq保存退出</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps15.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps16.jpg" alt="img"> </p>
<p>有密码的情况下，在命令行下连接redis需加上-a：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps17.jpg" alt="img"> </p>
<p>string类型常见操作</p>
<p>//string操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo2 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示 set get</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.set(“username”, “tom”);        </p>
<p>​        String value = jedis.get(“username”);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示mset mget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        jedis.mset(“password”,”123”,”age”,”20”);</p>
<p>​        </p>
<p>​        List<String> values = jedis.mget(“username”,”password”,”age”);</p>
<p>​        </p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示 append  setrange getrange</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        //jedis.append(“username”,” is boy”);</p>
<p>​        </p>
<p>​        //jedis.setrange(“username”, 7,”girl”);</p>
<p>​        System.****<em>out*</em>***.println(jedis.get(“username”));</p>
<p>​        </p>
<p>​        </p>
<p>​        System.****<em>out*</em>***.println(jedis.getrange(“username”, 7, -1));</p>
<p>​    }</p>
<p>}</p>
<p>list类型常见操作：</p>
<p>//list操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo3 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示lpush lrange</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.lpush(“names”, “tom”, “james”, “张三”, “李四”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>​    // lset</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        // jedis.lset(“names”, 1, “王五”);</p>
<p>​        // List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        // System.out.println(names);</p>
<p>​        String value = jedis.lindex(“names”, 1);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    // linsert</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3() {</p>
<p>​        jedis.linsert(“names”, LIST_POSITION.****<em>BEFORE*</em>***, “james”, “fox”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>​    </p>
<p>​    // lrem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.lrem(“names”, 1, “tom”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>}</p>
<p>hash类型常见操作</p>
<p>//hash操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo4 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示hset hget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.hset(“user”, “username”, “tom”);</p>
<p>​        String value = jedis.hget(“user”, “username”);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    // 演示hmset hmget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        Map&lt;String, String&gt; hash = <em><strong>*new*</strong></em> HashMap&lt;String, String&gt;();</p>
<p>​        hash.put(“password”, “123”);</p>
<p>​        hash.put(“sex”, “male”);</p>
<p>​        jedis.hmset(“user”, hash);</p>
<p>​        List<String> values = jedis.hmget(“user”, “username”, “password”, “sex”);</p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示 hgetall hkeys kvals</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        Map&lt;String, String&gt; map = jedis.hgetAll(“user”);</p>
<p>​        <em><strong>*for*</strong></em>(String key:map.keySet()){</p>
<p>​            System.****<em>out*</em>***.println(key+”  “+map.get(key));</p>
<p>​        }</p>
<p>​        </p>
<p>​        Set<String> keys = jedis.hkeys(“user”);</p>
<p>​        System.****<em>out*</em>***.println(keys);</p>
<p>​        </p>
<p>​        List<String> values = jedis.hvals(“user”);</p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>//    演示hdel</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.hdel(“user”, “username”,”password”);</p>
<p>​        Map&lt;String, String&gt; map = jedis.hgetAll(“user”);</p>
<p>​        <em><strong>*for*</strong></em>(String key:map.keySet()){</p>
<p>​            System.****<em>out*</em>***.println(key+”  “+map.get(key));</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>set类型常见操作</p>
<p>//set操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo5 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);        </p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示sadd smembers</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        </p>
<p>​        Set<String> smembers = jedis.smembers(“language1”);</p>
<p>​        System.****<em>out*</em>***.println(smembers);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示srem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        jedis.srem(“language1”, “java”);</p>
<p>​        Set<String> smembers = jedis.smembers(“language1”);</p>
<p>​        System.****<em>out*</em>***.println(smembers);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //差集 sdiff</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        </p>
<p>​        Set<String> sdiff = jedis.sdiff(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sdiff);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //交集</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        Set<String> sinter = jedis.sinter(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sinter);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //并集</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test5(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        Set<String> sunion = jedis.sunion(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sunion);</p>
<p>​    }</p>
<p>​    </p>
<p>}</p>
<p>sortedSet类型常见操作</p>
<p>//sortedset操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo6 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示zadd zrange zrangeByScore</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Set<String> set = jedis.zrange(“zkey”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(set);</p>
<p>​        // 根据分数获取</p>
<p>​        Set<String> set1 = jedis.zrangeByScore(“zkey”, 70.0, 90.0);</p>
<p>​        System.****<em>out*</em>***.println(set1);</p>
<p>​    }</p>
<p>​    // 获取分数元素 zrangeWithScores</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Set<Tuple> zws = jedis.zrangeWithScores(“zkey”, 0, -1);</p>
<p>​        <em><strong>*for*</strong></em> (Tuple t : zws) {</p>
<p>​            System.****<em>out*</em>***.println(t.getScore() + “  “ + t.getElement());</p>
<p>​        }</p>
<p>​    }</p>
<p>​    // zrank</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Long num = jedis.zrank(“zkey”, “赵六”);</p>
<p>​        System.****<em>out*</em>***.println(num);</p>
<p>​    }</p>
<p>​    // zscore</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Double zscore = jedis.zscore(“zkey”, “张三”);</p>
<p>​        System.****<em>out*</em>***.println(zscore);</p>
<p>​    }</p>
<p>​    // zrem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test5() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        jedis.zrem(“zkey”, “李四”);</p>
<p>​        </p>
<p>​        Set<Tuple> zws = jedis.zrangeWithScores(“zkey”, 0, -1);</p>
<p>​        <em><strong>*for*</strong></em> (Tuple t : zws) {</p>
<p>​            System.****<em>out*</em>***.println(t.getScore() + “  “ + t.getElement());</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>key的常见操作</p>
<p>//key的通用操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo7 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // keys patten</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1(){</p>
<p>​        Set<String> keys = jedis.keys(“*”);</p>
<p>​        System.****<em>out*</em>***.println(keys);</p>
<p>​    }</p>
<p>​    </p>
<p>​    // del key</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        Long del = jedis.del(“user”);</p>
<p>​        System.****<em>out*</em>***.println(del);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //关于key时间设置</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        //jedis.expire(“username”, 200); //设置生命周期为200秒</p>
<p>​        jedis.persist(“username”);</p>
<p>​        Long ttl = jedis.ttl(“username”); //获取生命周期值</p>
<p>​        System.****<em>out*</em>***.println(ttl);</p>
<p>​        </p>
<p>​    }</p>
<p>}</p>
<h1 id="Redis-数据持久化"><a href="#Redis-数据持久化" class="headerlink" title="*Redis*****数据持久化****"></a><em><strong>*Redis*</strong>***</em>*数据持久化****</h1><p>Redis将内存存储和持久化存储相结合，既可提供数据访问的高效性，又可保证数据存储的安全性</p>
<p>1.Redis数据持久化机制介绍</p>
<p>1). RDB持久化：该机制是指在指定的时间间隔内将****内存中的数据集快照****写入磁盘。  </p>
<p>2). AOF(append only file)持久化:该机制将以****日志的形式记录服务器所处理的每一个写操作****，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</p>
<p>3). 同时应用AOF和RDB。 </p>
<p>4). 无持久化：可通过配置的方式禁用Redis服务器的持久化功能，这样我们就可以将Redis视为一个功能加强版的memcached了</p>
<p>2.Redis数据持久化配置与测试</p>
<p>l RDB快照方式:缺省情况下，Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开redis.conf文件之后，我们搜索save，可以看到下面的配置信息：</p>
<p>Ø save 900 1        </p>
<p>#在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。</p>
<p>Ø save 300 10       </p>
<p>#在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。</p>
<p>Ø save 60 10000     </p>
<p>#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</p>
<p>注意:关于dump.rdb文件存储的位置：它是设置是在redis.conf文件中dir ./</p>
<p>dir ./这段配置指的是服务器启动时的当前路径（在哪启动服务器时，这个rdb文件就在哪创建）。</p>
<p>l AOF日志文件方式：</p>
<p>Ø AOF日志持久化机制的开启：需要手动设置，在redis.conf文件中</p>
<p>将appendonly  no  改为 appendonly  yes</p>
<p>Ø AOF同步方式的配置：</p>
<p>在Redis的配置文件中存在三种同步方式，它们分别是：</p>
<p>appendfsync  always   #每次有数据修改发生时都会写入AOF文件。</p>
<p>appendfsync  everysec  #每秒钟同步一次，该策略为AOF的缺省策略。</p>
<p>appendfsync  no      #从不同步。高效但是数据不会被持久化。</p>
<p>3.RDB与AOF对比总结</p>
<p>l RDB存在哪些优势呢？</p>
<p>1). 数据的备份和恢复非常方便，因为一个数据库只有一个持久化文件</p>
<p>2). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p>
<p>3). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
<p>l RDB又存在哪些劣势呢？</p>
<p>1).系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
<p>2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p>l AOF的优势有哪些呢？</p>
<p>1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3种同步策略，即每秒同步、每修改同步和不同步。</p>
<p>2).对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。</p>
<p>3). 如果日志过大，Redis可以自动启用rewrite机制迅速“瘦身”(也可手动触发aof的rewrite操作，命令： bgrewriteaof)</p>
<p>4). AOF日志格式清晰、易于理解，很容易用AOF日志文件完成数据的重建。  </p>
<p>l AOF的劣势有哪些呢？</p>
<p>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。</p>
<p>2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/15.1.Redis/" data-id="cknllgmcf0044sgwd1bpzefip" data-title="Redis" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.7.内部类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:50:38.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/">内部类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>内部类：把类定义在其他类的内部，这个类就被称为内部类。</p>
<p>内部类访问特点：</p>
<p>内部类可以直接访问外部类的成员，包括私有。</p>
<p>外部类要访问内部类的成员，必须创建对象。</p>
<p>内部类的位置：</p>
<p>成员位置：成员内部类</p>
<p>成员内部类是非静态的访问方式：</p>
<p>外部类名.内部类名  对象名 = new  外部类名.new 内部类名()；</p>
<p>eg：Outer.Inner  oi = new Outer().new Inner();</p>
<p>常见修饰符：</p>
<p>1.一般内部类是不让外界直接访问的，所以用private，保证了数据的安全性。</p>
<p>2.static为了让数据访问更方便。内部类用静态修饰是因为内部类可以看作是外部类的成员。（所以static可以修饰内部类，不能修饰类）</p>
<p>被静态修饰的成员内部类只能访问外部类的静态成员（静态只能访问静态）</p>
<p>成员内部类被静态修饰后，是不能被对象访问的，只能被类访问。它下面的方法可以是静态可以是非静态。</p>
<p>成员内部类是静态的访问方式：</p>
<p> 外部类名.内部类名  对象名=new 外部类名.内部类名();</p>
<p>eg：Outer.Inner oi = new Outer.Inner();</p>
<p>oi.静态方法();   oi.非静态方法();</p>
<p>静态内部类的静态方法还可以用：Outer.Inner.静态方法名();</p>
<p>局部位置：局部内部类</p>
<p>可以直接访问外部类的成员</p>
<p>在局部位置可以创建内部类对象，通过对象调用内部类方法来使用局部内部类的功能</p>
<p>局部内部类访问局部变量的注意事项：</p>
<p>局部内部类访问的局部变量必须用final修饰。（因为局部变量是随着方法的调用而调用，随着调用完毕而消失，而堆内存的内容不会立即消失（如果不是final修饰的话，就会矛盾报错），所以加final修饰，使变为常量，即使消失了，也有数据在使用）</p>
<p>匿名内部类:就是内部类的简化写法。</p>
<p>前提：存在一个类或者接口。（这里的类可以是具体类也可以是抽象类）</p>
<p>格式： new  类名或者接口名(){</p>
<p>重写方法；</p>
<p>}</p>
<p>本质：就是具体类的子类或者抽象类的具体实现类或者接口的实现类的匿名****对象****。</p>
<p>因为本质是一个对象，所以后面可以跟调用方法。</p>
<p>new  类名或者接口名(){</p>
<p>重写方法；</p>
<p>}.方法名();</p>
<p>当有多个方法要重写时，只能调一次方法，因为这是个匿名对象。所以改进：在前面赋值给父接口或者父类、父抽象类，这就是多态。（实际上就是在{}中补了很多代码，其他格式不变），最后再通过多态的对象调用方法。</p>
<p>匿名内部类在开发中的使用：在android中常见，在ee中不常见。因为匿名内部类用完就会被回收不占内存。匿名内部类只能用一次。</p>
<p>类名调用方法，该方法就必须是静态类方法，否则应该是对象调用方法。</p>
<p>注意：内部类和外部类没有继承关系。</p>
<p>可以通过外部类名来限定this对象：new Outer().num  等价于  Outer.this.num（Outer.this其实是一个对象）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/" data-id="cknllgmbg001msgwd68rva8et" data-title="内部类" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.6.接口和抽象类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:50:31.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/">接口和抽象类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>为了体现事物功能的扩展性，java中提供了接口来定义这些额外功能，但不给出具体实现，将来有要实现的地方在添加实现。</p>
<p>特点：接口用interface关键字表示</p>
<p>格式：  interface  接口名{}</p>
<p>类实现接口用implements表示：</p>
<p>class  类名  implements  接口名{}</p>
<p>接口不能实例化。按照多态的方式，接口可以由具体的子类实例化。这也是多态的一种，接口多态。</p>
<p>所以多态有3种：</p>
<p>A. 具体类多态（几乎不用）</p>
<p>B. 抽象类多态（常用）</p>
<p>C. 接口多态（最常用）</p>
<p>接口的子类：要么是抽象类，要么重写接口中的所有抽象方法（推荐）。</p>
<p>接口成员特点：</p>
<p>成员变量：接口中的变量默认是常量，并且是静态的。默认修饰符public static final （所以建议自己手动给出）</p>
<p>构造方法：接口没有构造方法，因为接口主要是扩展功能的，没有具体存在</p>
<p>成员方法：只能是抽象方法。默认修饰符  public abstract（建议自己手动给出）</p>
<p>接口名+Impl这种格式是接口的实现类格式。</p>
<p>所有的类都默认继承自Object类。类 Object是类层次结构的根类，每个类都使用Object作为超类。因为Objec类只有无参构造，所以默认每个子类都会调用其父类的无参构造super();</p>
<p>类与类关系：继承关系，可以单继承，也可以多层继承</p>
<p>类与接口关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
<p>接口与接口的关系：继承关系，可以单继承，也可以多继承（java中有多继承，只有接口有）</p>
<p>抽象类和接口的区别：</p>
<p>A. 成员区别：抽象类有变量、常量，有构造方法，有抽象方法和非抽象方法</p>
<p>接口中只有常量，抽象方法</p>
<p>B. 关系区别：类与类关系、类与接口关系、接口与接口的关系</p>
<p>C. 设计理念区别：</p>
<p>抽象类被继承体现的是“is  a”的关系。共性功能</p>
<p>接口被实现体现的是“hava a”的关系。扩展功能（也有说like a的关系 谁像啥）</p>
<p>形式参数是引用类型：</p>
<p>类：类作为形参，其实需要的是该类的对象（匿名对象可以作为对象，只使用一次）</p>
<p>抽象类：需要的是该抽象类的子类对象。（因为它本身不能实例化，只有子类的对象）</p>
<p>接口：需要的是该接口的实现类对象。</p>
<p>返回值是引用类型：</p>
<p>类：返回的是该类的对象。</p>
<p>抽象类：返回的是该抽象类的子类对象。</p>
<p>接口：返回的是该接口的实现类对象。</p>
<p>链式编程：每次调用完毕方法后，返回的是一个对象。（适用于中间调用的返回值是类、接口、抽象类）</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在java中，一个没有方法体的方法应该定义为抽象方法。而类中如果有抽象方法，该类必须定义为抽象类。</p>
<p>抽象类和抽象方法必须使用abstract关键字修饰。</p>
<p>格式：抽象类：  abstract class 类名{…}</p>
<p> 抽象方法：    public abstract void eat（）；</p>
<p>空方法体用  ｛｝   没有方法体用  ;  </p>
<p>抽象类不一定有抽象方法（没有抽象方法的抽象类的意义就是不让外界创建对象，只能通过子类访问），但是有抽象方法的类一定是抽象类。</p>
<p>抽象类有构造方法（这个构造方法的作用是用于子类访问父类数据的初始化），但是不能实例化。按照多态的方式，抽象类可以由具体的子类实例化，和多态的声明一样: 父 f=new 子();  抽象类多态</p>
<p>抽象类的子类要么是抽象类，要么重写抽象类中的所有抽象方法成为一个具体的类。</p>
<p>抽象类的成员特点：</p>
<p>成员变量：既可以是变量，也可以是常量。</p>
<p>构造方法：有。用于子类访问父类数据的初始化。</p>
<p>成员方法：既可以是抽象的（强制要求子类做的事情），也可以是非抽象的（子类继承的事情，提高代码的复用性）。</p>
<p>如果测试的东西父类中都包含，可以使用多态。但如果要测试子类中特有的内容，我们无法用多态继续测试，所以要创建子类的对象来测试。</p>
<p>abstract不能共存的关键字：</p>
<p>private：冲突。加了就不让重写了。</p>
<p>final：冲突。不能被重写。</p>
<p>static：无意义。因为静态可以直接通过类名访问，而abstract没有方法体，访问一个没有方法体的方法是无意义的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/" data-id="cknllgmbg001jsgwd9h8gfumm" data-title="接口和抽象类" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.8.程序控制流程if" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:49:57.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/">程序控制流程if</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>想了想还是单独给程序控制流程部分开了一个文章。因为业务逻辑部分，最主要的用的还是if语句。通过对不同情形的判断，来进行情况分类，可以帮助我们实现功能，学会if是写逻辑层代码重要的一环。</p>
<p>流程控制语句：可以控制程序的执行流程。</p>
<h1 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h1><p>是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p>
<p>从上往下，依次执行。</p>
<h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><p>也被称为分支结构。有特定的语法规则，代码要执行具体的逻辑运算进行判断，逻辑运算的结果有两个，所以产生选择，按照不同的选择执行不同的代码。</p>
<p>两种：</p>
<p>if语句的使用场景：</p>
<p>a.针对表达式是一个boolean类型的判断</p>
<p>b.针对一个范围的判断</p>
<p>c.针对几个常量值的判断</p>
<p>switch语句使用场景：针对几个常量值的判断</p>
<p>1.if语句</p>
<p>if语句的使用格式：</p>
<p>a. 适合做单个判断</p>
<p> if(关系表达式){</p>
<p>语句体</p>
<p>}</p>
<p>if语句控制的语句体如果是一条语句，大括号可以省略，如果是多条语句，就不能省略。建议永远不要省略。</p>
<p>一般来说，有左大括号就没有分号，有分号就没有左大括号。if();或if(){}</p>
<p>b.适合做两个判断</p>
<p>if(关系表达式){</p>
<p>语句体1；</p>
<p>}else{</p>
<p>语句体2；</p>
<p>}</p>
<p>else后面是没有表达式的，只有if后面有。</p>
<p>三元运算符实现的都可以用if语句实现。反之不成立（因为当if语句控制的操作是一个输出语句时候就不能，三元运算符是一个运算符，操作完毕是会有一个结果而不是一个输出语句）</p>
<p>c.适合做多个判断</p>
<p>if(比较表达式1){</p>
<p>语句体1；</p>
<p>}else if(比较表达式2){</p>
<p>语句体2；</p>
<p>}else if(比较表达式3){</p>
<p>语句体3；</p>
<p>}</p>
<p>…</p>
<p>else{</p>
<p>语句体n+1；</p>
<p>}</p>
<p>注意事项：比较表达式无论简单还是复杂，结果必须是boolean类型。</p>
<p>if语句是可以任意嵌套使用的，把语句体n改为if语句即可实现（无论使用if三种格式那种都行）。</p>
<p>\2. switch语句</p>
<p>switch(表达式){</p>
<p>case  值1:</p>
<p>语句体1；</p>
<p>break；</p>
<p>case  值2:</p>
<p>语句体2；</p>
<p>break；</p>
<p>…</p>
<p>default：</p>
<p>语句体n+1；</p>
<p>break；</p>
<p>}</p>
<p>switch:表示这是switch选择结构。</p>
<p>表达式：表达式取值有限定，byte，short，char，int。JDK5以后可以是枚举，JDK7以后可以是字符串。</p>
<p>case后面跟的是要和表达式比较的值。</p>
<p>语句体部分可以是一条或者多条语句</p>
<p>break表示中断，结束的意思，可以结束switch语句。</p>
<p>注意事项：</p>
<p>\1. case后面只能是常量，不能是变量，而且多个case后面的值不能出现相同的。</p>
<p>\2. default可以省略。一般不建议，除非判断的case值是固定的（可以穷举完）。他的作用是对不正确的情况给出提示。</p>
<p>\3. break可以省略。一般不建议，会出现case穿透(可以利用case穿透来实现多个输出结果相同时整合到一起)。最后一个break可以省略。</p>
<p>\4. default位置可以出现在switch语句的任意位置。建议在最后。</p>
<p>\5. switch语句的结束条件：遇到break或者执行到程序的末尾。</p>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>循环语句的组成：</p>
<p>初始化语句：一条或者多条语句，这些语句完成一些初始化操作</p>
<p>判断条件语句：这是一个boolean表达式，这个表达式决定是否执行循环体</p>
<p>循环体语句：要多次循环的语句</p>
<p>控制条件语句：在一次循环结束后，下次循环判断条件执行前执行，通过用于控制循环条件中的变量，使得循环再合适的时候结束</p>
<h2 id="for循环："><a href="#for循环：" class="headerlink" title="for循环："></a>for循环：</h2><p>for(初始化语句；判断条件语句；控制条件语句)｛</p>
<p>循环体语句；</p>
<p>｝</p>
<p>注意事项：判断条件语句的结果是一个boolean类型</p>
<p>循环语句如果是一条语句，大括号可以省略，如果是多条语句，大括号不能省略，建议永远不要省略。</p>
<p>一般来说，有左大括号就没有分号，有分号就没有左大括号。</p>
<p>for循环：求和思想：初始化值为0。</p>
<p>求阶乘思想：初始化值为1。</p>
<p>水仙花数：就是指一个三位数，其各位数字的立方和等于该数本身。eg：153</p>
<h2 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h2><p>基本格式：</p>
<p>while(判断条件语句){</p>
<p>循环体语句；</p>
<p>}</p>
<p>扩展格式：</p>
<p>初始化语句；</p>
<p>while（判断条件语句）｛</p>
<p>循环体语句；</p>
<p>控制条件语句；</p>
<p>｝</p>
<p> for循环和while循环语句可以等价转换，但也存在区别：</p>
<p>使用区别：控制条件语句所控制的那个变量，在for循环结束后，就不能在被访问到了，而while循环结束还可以继续使用。若不使用推荐使用for循环，因为这个变量会从内存中消失，能够提高内存的使用效率。</p>
<p>场景区别：for循环适合针对一个范围判断进行操作，while循环适合判断次数不明确的操作。</p>
<h2 id="do-…-while-循环语句："><a href="#do-…-while-循环语句：" class="headerlink" title="do … while 循环语句："></a>do … while 循环语句：</h2><p>至少执行一次</p>
<p>基本格式：</p>
<p>do{</p>
<p>循环体语句；</p>
<p>}while（判断条件语句）;</p>
<p>扩展格式：</p>
<p>初始化语句；</p>
<p>do｛</p>
<p>循环体语句；</p>
<p>控制条件语句；</p>
<p>｝while（判断条件语句）;</p>
<p>优先考虑for循环，其次是while循环，最后考虑do… while循环。</p>
<p>注意死循环：ctrl+c中断循环</p>
<p>A：注意控制条件语句控制的那个变量的问题，不要丢了，否则会死循环。</p>
<p>B：两种最简单的死循环格式</p>
<p>while（true）｛</p>
<p>｝</p>
<p>for（；；）｛</p>
<p>｝</p>
<p>循环嵌套：循环语句的循环体本身是一个循环语句。</p>
<p>外循环控制行数，内循环控制列数。</p>
<h1 id="控制跳转语句"><a href="#控制跳转语句" class="headerlink" title="控制跳转语句"></a>控制跳转语句</h1><p>****break****：中断</p>
<p>使用场景：离开下面2个场景使用，无意义。</p>
<p>A：switch语句中</p>
<p>B：循环语句中（加入了if判断的情况）</p>
<p>使用：A：跳出单层循环</p>
<p>B：跳出多层循环，必须借助标签。</p>
<p>格式：</p>
<p>标签名： 语句</p>
<p>****continue****：继续</p>
<p>使用场景：循环语句中。（离开此场景无意义）</p>
<p>break和continue的区别：break是跳出单层循环。continue是跳出一次循环，进行下一次的判断执行。</p>
<p>****return****：返回</p>
<p>renturn关键字不是为了跳转出循环体，更常用的功能是结束一个方法，也就是推出一个方法，跳转到上层调用的方法。</p>
<p>一旦遇到return，程序就不会在继续往后执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/" data-id="cknllgmbh001osgwd2sqo92t1" data-title="程序控制流程if" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-1.5.编程规范" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T02:57:13.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/">编程规范</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>编写程序时注意：    </p>
<p>遇到左大括号缩进一个tab的位置。</p>
<p>关联不是很大的语句间空行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" data-id="cknllgmaq0005sgwd2h0w7lvm" data-title="编程规范" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E8%BF%B0/" rel="tag">概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%88%E6%9C%AC/" rel="tag">版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">概述</a> <a href="/tags/%E7%89%88%E6%9C%AC/" style="font-size: 10px;">版本</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/17/19.3.github/">github</a>
          </li>
        
          <li>
            <a href="/2021/04/17/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">代理和反向代理</a>
          </li>
        
          <li>
            <a href="/2021/04/17/24.%E7%AE%97%E6%B3%95/">算法</a>
          </li>
        
          <li>
            <a href="/2021/04/17/23.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
          </li>
        
          <li>
            <a href="/2021/04/17/22.3.%E5%B8%B8%E8%A7%81cmd%E5%91%BD%E4%BB%A4/">常见cmd命令</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>