<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/11/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-4.9.java中常用类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/4.9.java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T11:03:45.000Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/26/4.9.java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/">java中常用类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>API（Application Programming Interface）概述：就是java提供给我们使用的类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用，我们可以通过查找帮助文档来了解java提供的API如何使用。</p>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>JDK1.0</p>
<p>类层次结构的根类，每个类都直接或者间接继承自Object类。 所有对象（包括数组）都实现了这个类的方法。</p>
<p>构造方法： public Object()  </p>
<p>成员方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>



<p>public int hashCode()  返回该对象的哈希码值</p>
<p>哈希值是根据哈希算法计算出来的一个值，这个值和地址值有关，但不是实际地址值，可以理解为地址值。</p>
<p>public final Class getClass()  返回此Object的运行时类。</p>
<p>//Class也是一个类，是Class对象建模的类的类型。它其中有个方法：</p>
<p>//public String getName()  以String的形式返回此Class对象所表示的全类名称</p>
<p>public String toString()  返回该对象的字符串表示</p>
<p>toString()方法的值等价于：<a href="mailto:getClass().getName()+’@’+Integer.toHexString(hashCode())">getClass().getName()+’@’+Integer.toHexString(hashCode())</a></p>
<p>这个信息是没有任何意义的，所以建议所有子类都重写此方法。</p>
<p>重写：建议重写成把该类的所有成员变量值组成返回。（右键–resources–toString 自动生成，重写的最终版方案就是自动生成）</p>
<p>注意：直接输出一个对象的名称，其实就是调用该对象的toString()方法。</p>
<p>public boolean equals(Object obj)  指示其他某个对象是否与此对象“相等”</p>
<p>这个方法默认情况下比较的是地址值。</p>
<p>比较地址值一般意义不大，所以我们要重写该方法。重写完的方法一般是用来比较对象的成员变量值是否相同。</p>
<p>String的equals()方法是重写自Object类的，比较的是字符串的内容是否相同</p>
<p>重写的代码优化：提高效率，提高代码的健壮性。</p>
<p>最终版其实是自动生成。</p>
<p>==：基本类型：比较的就是值是否相同</p>
<p>引用类型：比较的就是地址值是否相同</p>
<p>equals：</p>
<p>只能比较引用类型：默认情况比较的是地址值，不过我们可以根据自己的情况重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同。</p>
<p>protected void finalize()  当垃圾回收器不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。永远垃圾回收，但是什么时候回收不确定。</p>
<p>protected Object clone()  创建并返回此对象的一个副本。</p>
<p>因为是prtected，所以需要重写该方法。</p>
<p>Cloneable：此类实现了Cloneable接口，以指示Object.clone()方法可以合法的对该类实力进行按字段复制。这个接口是****标记****接口，告诉我们实现该接口的类就可以实现对象的复制了。（就只是起个标记的作用，只有实现该接口的类才能被clone）</p>
<p>意义：clone之后改动对以前的数据无影响。而直接赋值引用改动会对以前的数据产生影响。（这只是浅克隆）</p>
<h1 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h1><p>需要导包：import java.util.Scanner</p>
<p>JDK5以后用于获取用户的键盘输入</p>
<p>构造方法：public Scanner(InputStreamsource)</p>
<p>System类下有一个静态的字段： public static final InputStream in; 标准的输入流，对应着键盘录入。</p>
<p>成员方法：</p>
<p>hasNextXxx() ****判断****是否还有下一个输入项，其中Xxx可以是Int，Double等。如果需要判断的是否包含下一个字符串，可以省略Xxx</p>
<p>nextXxx() 获取下一个输入项。</p>
<p>默认情况下，Scanner使用空格，回车等作为分隔符。</p>
<p>常用的方法：</p>
<p>public int nextInt()</p>
<p>public String nextLine()</p>
<p>先获取一个数值，在获取一个字符串，就会出现问题（因为换行符号被当成是字符串输入）</p>
<p>解决：A.先获取一个数值后，再创建一个新的键盘录入对象获取字符串。</p>
<p>B.把所有的数据都先按照字符串获取，然后要什么在对应转换成什么。</p>
<p>键盘录入数据</p>
<p>1.导包：import java.util.Scanner  （import必须出现在所有的class前面）</p>
<p>2.创建对象：Scanner sc=new Scanner(System.in)</p>
<p>3.接收数据：int x=sc.nextInt();</p>
<p>String s=sc.nextLine();</p>
<h1 id="String类-StringBuffer类-StringBuilder类"><a href="#String类-StringBuffer类-StringBuilder类" class="headerlink" title="String类/StringBuffer类/StringBuilder类"></a>String类/StringBuffer类/StringBuilder类</h1><p>字符串是由多个字符组成的一串数据（字符序列）</p>
<p>字符串可以看成是字符数组。</p>
<p>字符串字面值”abc”也可以看成是一个字符串对象。</p>
<p>字符串是常量，一旦被赋值，就不能被改变。字符串直接赋值的方式是先到方法区中的字符串常量池里面去找，如果有就直接返回，没有就创建返回。（赋的值不能变，引用可以变）</p>
<ol>
<li>String s=”hello”;  s+=”world”; 则s的输出结果是：helloworld</li>
</ol>
<p>因为s的赋值hello不能改变，但是+world后在方法区的常量池中会重新生成一个地址值指向栈的s。</p>
<ol start="2">
<li>String s=new String(“hello”);和String s=”hello”; 的区别？</li>
</ol>
<p>区别就是前者会生成2个或1个（可能常量池中已经存在hello常量）对象，而后者只会生成1个或0个对象。（因为前者会在堆内存中生成一个地址值，而后者是方法区中的常量池直接指向栈内存）</p>
<p>字符串如果是变量相加，先开空间，在拼接。</p>
<p>字符串如果是常量相加，直接加，然后在常量池中找，如果有就直接返回，否则就创建。</p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span>   <span class="comment">//空构造</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span>  <span class="comment">//把字节数组转成字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes,<span class="keyword">int</span> index,<span class="keyword">int</span> length)</span><span class="comment">//把字节数组的一部分转成字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value)</span>  <span class="comment">//把字符数组转成字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value,<span class="keyword">int</span> index,<span class="keyword">int</span> count)</span><span class="comment">//把字符数组的一部分转成字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span>  <span class="comment">//把字符串常量值转成字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String s</span>=”hello”; <span class="comment">//这个虽然不是构造方法，但结果也是一个字符串对象</span></span><br></pre></td></tr></table></figure>

<p>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>  ：返回此字符串的长度。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String类的判断功能：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>   比较字符串的内容是否相同，区分大小写</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span>比较字符串的内容是否相同，忽略大小写</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span>  判断大串中是否包含小串<span class="params">(连续的)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span> 判断字符串是否以某个指定的字符串开头</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span> 判断字符串是否以某个指定的字符串结尾</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> 判断字符串是否为空</span></span><br></pre></td></tr></table></figure>

<p>字符串内容为空（“”）和字符串对象为空（null）是两个概念。</p>
<p>空指针不能调用方法。</p>
<p>String类的获取功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>   获取字符串的长度</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>  获取指定索引位置的字符</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span>  返回指定字符在此字符串中第一次出现的索引</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">为什么是<span class="keyword">int</span>类型不是字符类型：因为’a’和97都可以代表’a’，但是如果写字符类型的话就不能写数字了，因为<span class="keyword">int</span>类型的范围比字符<span class="keyword">char</span>的类型范围大，要强转，可能会出错。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>  返回指定字符串在此字符串中第一次出现的索引</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch,<span class="keyword">int</span> fromIndex)</span>  返回指定字符在此字符串中从指定位置后第一次出现的索引</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span>  返回指定字符串在此字符串中从指定位置后第一次出现的索引</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span>  从指定位置开始截取字符串，默认到末尾（包括start索引）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>  从指定位置开始到指定位置结束截取字符串（包括start索引但是不包括end索引）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">遍历数组：<span class="title">length</span><span class="params">()</span>和<span class="title">charAt</span><span class="params">()</span>即可</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">统计一个字符串中大、小写字母、数字出现的次数：定义统计变量，遍历数组，每个字符判断。（判断就直接判断，因为字符判断时候都会转化成<span class="keyword">int</span>型在判断）</span></span><br></pre></td></tr></table></figure>

<p>String类的转换功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getBytes()   把字符串转换成字节数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] toCharArray() 把字符串转换成字符数组</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span>[] chs)</span> 把字符数组转换成字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> 把<span class="keyword">int</span>类型转换成字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String类的valueOf方法可以把任意类型的数据转成字符串（方法的重载）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span> 把字符串转成小写（原字符串不变）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span> 把字符串转成大写</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span> 把字符串拼接</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">String format（）</span></span><br></pre></td></tr></table></figure>

<p>String类的其他功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">替换功能：</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> old,<span class="keyword">char</span> new)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String old,String new)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">去除字符串的两端空格（不去除中间的）：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">按字典顺序比较两个字符串 ： （依次比较字符串的<span class="keyword">int</span>值，再做减法，返回值。如果两个字符串的长度不同，返回长度差。（都是看源码得知））</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>

<p>字符串反转：定义一个新的字符串，将给定的字符串倒着遍历，拼接到新的字符串。</p>
<p>统计大串中小串出现的次数：定义一个统计变量，获取小串在大串中第一次出现的索引（用indexOf()方法，不存在的话会返回-1），将索引+小串的长度作为起始位置截取原始大串并赋值给原始大串（用int indexOf(String str,int fromIndex)方法），继续获取小串在大串中第一次出现的索引（用indexOf()方法，不存在的话会返回-1）。</p>
<p>匹配功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">public int indexOf( String  str )</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">public boolean contains( CharSequence  s )</span><br><span class="line"></span><br><span class="line">3.通过正则表达式 + matches方法</span><br><span class="line">publicboolean matches( String  regex )</span><br><span class="line"></span><br><span class="line">4.字符串精确匹配，不考虑大小写</span><br><span class="line">public boolean equalsIgnoreCase( String  anotherString )</span><br></pre></td></tr></table></figure>



<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p>如果对字符串进行拼接操作，每次拼接都会构建一个新的String对象，既耗时又耗空间，所以产生了StringBuffer类。</p>
<p>线程安全的可变字符序列。</p>
<p>安全–同步–数据是安全的</p>
<p>不安全–不同步–效率高一些</p>
<p>StringBuffer和String的区别：前者长度和内容可变，后者不可变。</p>
<p>当字符串拼接时，前者不会浪费太多的资源。</p>
<p>StringBuffer的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span>  无参构造方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> 指定容量的字符串缓冲区对象 默认为16</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> 指定字符串内容的字符串缓冲区对象</span></span><br></pre></td></tr></table></figure>

<p>StringBuffer的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span>:返回当前容量。  理论值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>:返回长度（字符数）。实际值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">StringBuffer添加功能</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> 可以把任意类型的数据添加到字符串缓冲区里面，并返回字符串缓冲区本身。（所以可以使用链式编程）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset,String str)</span> 在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符串缓冲区本身</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">StringBuffer删除功能</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span> 删除指定位置的字符，并返回本身</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> 删除从指定位置开始指定位置结束的内容，并返回本身 [) 包左不包右</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="number">0</span>,x.length()</span>)用于初始化清空容器。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">StringBuffer替换功能</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,String str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">StringBuffer反转功能	</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> StringBuffer <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">StringBuffer截取功能</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span>这个索引后的所有字符串输出并返回到String</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>  把这段截取出来输出String</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">截取功能的返回值类型是String类型，本身String Buffer没有发生改变（前面的都是容器内容发生了变化，所以值都改变了，但是容器本身没有变化）</span></span><br></pre></td></tr></table></figure>

<p>类之间的转换：</p>
<p>A–B的转换：把A转换成B是为了使用B的功能</p>
<p>B–A的转换：要的结果是A类型，所以需要再转回来。</p>
<p>String和StringBuffer的相互转换：</p>
<p>String转成StringBuffer：</p>
<p>不能把字符串的值直接赋值给StringBuffer</p>
<p>方法1：通过构造方法：StringBuffer sb=new StringBuffer(s);</p>
<p>方法2：通过append方法：StringBuffer sb2=new StringBuffer();    sb2.append(s);</p>
<p>StringBuffer转成String：</p>
<p>方法1：通过构造方法：String s=new String(buffer);</p>
<p>方法2：通过toString方法：String str2 = buffer.toString();    </p>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>一个可变的字符序列，此类提供一个与StringBuffer兼容的API（在单线程中完全可以替代StringBuffer），但不保证同步。在单个线程使用时很普遍，因为不保证安全，但是比StringBuffer类快。</p>
<p>1.String，StringBuffer，String Builder的区别：</p>
<p>String内容是不可变的，而StringBuffer、StringBuilder都是内容可变的。</p>
<p>StringBuffer是同步的，数据安全，效率低；StringBuilder是不同步的，数据不安全，效率高。</p>
<p>2.StringBuffer和数组的区别：</p>
<p>二者都可以看成是容器装其他数据，但是StringBuffer的数据最终是一个字符串数据，而数组可以放置多种数据，但必须是同一种数据类型。</p>
<p>\3. 形式参数问题：</p>
<p>基本类型：形式参数的改变不影响实际参数</p>
<p>引用类型：形式参数的改变直接影响实际参数</p>
<p>String作为参数传递：效果和基本类型作为参数传递是一样的。（因为String是一种特殊的基本类型，常量池）</p>
<p>StringBuffer作为参数传递：只有调用方法时才改变了值，一般的赋值=不改变原来值。</p>
<h1 id="Arrays类和数组高级"><a href="#Arrays类和数组高级" class="headerlink" title="Arrays类和数组高级"></a>Arrays类和数组高级</h1><p>Arrays类：需要导包import java.util.Arrays</p>
<p>是针对数组进行操作的工具类，提供了排序，查找等功能。</p>
<p>无构造方法。成员方法全是静态方法。</p>
<p>成员方法：不懂就去看源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span> 把数组转成字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span>  对数组进行排序（底层是快速排序）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> key)</span> 二分查找（必须是有序的）</span></span><br></pre></td></tr></table></figure>



<p>数组高级：排序和查找</p>
<p>排序：</p>
<p>\1. 插入排序类：</p>
<p>（1）直接插入排序：（在小规模数据集或是基本有序时，该算法效率较高）每一步将一个待排序的元素，按其排序码的大小，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止</p>
<p>（2）希尔排序：先对数据进行预处理，使其基本有序，然后再用直接插入排序算法排序。</p>
<p>\2. 选择排序类：</p>
<p>（1）简单选择排序：（每次选择一个最大(小)的，直到所有元素都被输出）从0索引开始，依次和后面元素比较，小的回到0索引；第一次完毕后，最小值出现在了最小索引处；第二次比较，有1个元素不比；比较的次数是array.length-1。</p>
<p>（2）堆排序：根节点是整个堆的最大值，将它移走；将剩余n-1个节点重新构造成一个堆，再将根节点移走；重复执行1,2。直到没有节点可移动，就生成了有序序列。</p>
<p>\3. 交换排序类：</p>
<p>（1）冒泡排序：（该算法比较简单，几乎所有语言涉及到算法时，都会涉及到冒泡算法）相邻元素两两比较，大的往后放；第一次完毕，最大值出现在最大索引处；第二次比较，有1个元素不比；比较的次数是array.length-1。</p>
<p>（2）快速排序：（利用“分而治之”的思想对集合进行排序）</p>
<p>4.归并排序类：</p>
<p>归并排序：归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<p>5.计数排序：计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
<p>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。</p>
<p>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。</p>
<p>计数排序不是比较排序，排序的速度快于任何比较排序算法。</p>
<p>6.桶排序：将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</p>
<p>7.基数排序：取得数组中的最大数，并取得位数；arr为原始数组，从最低位开始取每个位组成radix数组；对radix进行计数排序（利用计数排序适用于小范围数的特点）</p>
<table>
<thead>
<tr>
<th><em><strong>*排序算法*</strong></em></th>
<th><em><strong>*平均时间复杂度*</strong></em></th>
<th><em><strong>*最差时间复杂度*</strong></em></th>
<th><em><strong>*空间复杂度*</strong></em></th>
<th><em><strong>*数据对象稳定性*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>数组不稳定、链表稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n*log2n)</td>
<td>O(n2)</td>
<td>O(log2n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n*log2n)</td>
<td>O(n*log2n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n*log2n)</td>
<td>O(n*log2n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n*log2n)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(m)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(k*n)</td>
<td>O(n2)</td>
<td></td>
<td>稳定</td>
</tr>
</tbody></table>
<p>查找：</p>
<p>\1. 基本查找：查找的数组无序（从头找到尾）</p>
<p>\2. 二分（折半）查找：查找的数组有序</p>
<p>只要是无序的就不能使用二分查找，因为二分查找一旦排序就改变了元素在数组中的位置，其索引也就不对了。</p>
<table>
<thead>
<tr>
<th><em><strong>*查找算法*</strong></em></th>
<th><em><strong>*平均时间复杂度*</strong></em></th>
<th><em><strong>*空间复杂度*</strong></em></th>
<th><em><strong>*查找条件*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>顺序查找</td>
<td>O(n)</td>
<td>O(1)</td>
<td>无序或有序</td>
</tr>
<tr>
<td>二分查找（折半查找）</td>
<td>O(log2n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td>插值查找</td>
<td>O(log2(log2n))</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td>斐波那契查找</td>
<td>O(log2n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td>哈希查找</td>
<td>O(1)</td>
<td>O(n)</td>
<td>无序或有序</td>
</tr>
<tr>
<td>二叉查找树（二叉搜索树查找）</td>
<td>O(log2n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>红黑树</td>
<td>O(log2n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2-3树</td>
<td>O(log2n - log3n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B树/B+树</td>
<td>O(log2n)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="基本类型包装类（Interger，Character）"><a href="#基本类型包装类（Interger，Character）" class="headerlink" title="基本类型包装类（Interger，Character）"></a>基本类型包装类（Interger，Character）</h1><p>为了对基本数据类型进行更多的操作，更方便的操作，java就对每一种基本类型提供了对应的类类型，包装类类型。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>常用于基本数据类型与字符串之间的转换。</p>
<p>Integer类：</p>
<p>Integer 类在对象中包装了一个基本类型 int 的值</p>
<p>该类提供了多个方法，能在 int 类型和 String 类型之间互相转换，还提供了处理 int 类型时非常有用的其他一些常量和方法</p>
<p>构造方法：</p>
<p>public Integer(int value)</p>
<p>public Integer(String s) 这个字符串s必须是由数字字符组成，不然就会报错。</p>
<p>int类型和String类型的相互转换</p>
<p>int – String：</p>
<p>\1. 字符串拼接：String s=””+number</p>
<p>\2. 调用String的方法：String  s= String.valueOf(number);</p>
<p>\3. int–Integer–String:： Integer i=new Integer(number);    String  s= i.toString();</p>
<p>\4. 调用Integer的方法：String  s= Integer.toString(number);</p>
<p>String – int:</p>
<p>\1. String–Integer–int: Integer  ii= new Integer(s);    int x = ii.intValue();</p>
<p>\2. 调用Integer的方法**:int x=Integer.parseInt(s); （这个方法很重要，是将字符串类型转换为基本数据类型，调用的是该基本数据类型的包装类的parseXxx方法）</p>
<p>成员方法：</p>
<p>常用的基本进制转换：</p>
<p>public static String toBinaryString(int i)   十进制到二进制</p>
<p>public static String toOctalString(int i)   十进制到八进制</p>
<p>public static String toHexString(int i)   十进制到十六进制</p>
<p>十进制到其他进制：</p>
<p>public static String toString(int i,int radix) radix代表int型数字（2-36），表示二到三十六进制（0-9，a-z）</p>
<p>其他进制到十进制</p>
<p>public static int parseInt(String s,int radix) 给出的s必须是radix可以转换的，不然会报错。</p>
<p>JDK5新特性：（通过反编译就可以发现）</p>
<p>自动装箱：把基本类型转换为包装类类型。</p>
<p>Integer x = new Integer(4);可以直接写成Integer x = 4;//自动装箱。</p>
<p>自动拆箱：把包装类类型转换为基本类型。</p>
<p>x  = x + 5;//自动拆箱。通过intValue方法。</p>
<p>在使用时，Integer  x = null;上面的代码就会出现NullPointerException。（所以要先判断对象是否为null）</p>
<p>1.5之后，加了个byte常量池：Integer的数据直接赋值，如果在-128到127之间，会直接从缓冲池里获取数据，而不会new一个新对象。</p>
<p>Character类：</p>
<p>Character 类在对象中包装一个基本类型 char 的值</p>
<p>此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，小写转成大写</p>
<p>构造方法</p>
<p>public Character(char value)</p>
<p>成员方法：</p>
<p>public static boolean isUpperCase(char ch)  判断给定的字符是否是大写字符</p>
<p>public static boolean isLowerCase(char ch)  判断给定的字符是否是小写字符</p>
<p>public static boolean isDigit(char ch)  判断给定的字符是否是数字字符</p>
<p>public static char toUpperCase(char ch)  把给定的字符转换成大写字符</p>
<p>public static char toLowerCase(char ch)  把给定的字符转换成小写字符</p>
<h1 id="正则表达式regex（Pattern，Matcher）"><a href="#正则表达式regex（Pattern，Matcher）" class="headerlink" title="正则表达式regex（Pattern，Matcher）"></a>正则表达式regex（Pattern，Matcher）</h1><p>是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。</p>
<p>组成规则：</p>
<p>规则字符在java.util.regex  Pattern类中</p>
<p>常见组成规则：</p>
<ol>
<li>字符：</li>
</ol>
<p>x  字符x。举例：’a’ 表示字符a</p>
<p>\  反斜线字符。因为一个\代表了转义。</p>
<p>\n  新行（换行）符  （‘\uoooA’）</p>
<p>\r   回车符  (‘\uoooD’)</p>
<ol start="2">
<li>字符类</li>
</ol>
<p>[abc]  a、b或c(简单类)  abc中的任意一个，但只能是一个</p>
<p>[^abc]  任何字符，除了a、b或c（否定）</p>
<p>[a-zA-Z]  a到z或A到Z，两头的字母包括在内（范围）</p>
<p>[0-9]  0到9的字符都包括</p>
<p>[]里不用转义字符，是什么就是什么</p>
<ol start="3">
<li>预定义字符类</li>
</ol>
<p>.  任何字符。如果就是.本身，应该写为 <code>\.</code> </p>
<p>\d  数字：[0-9]  在写的时候都是\d表示 因为要先转义。</p>
<p>\D  非数字:<code>[^ 0-9]</code></p>
<p>\w  单词字符(小w)：[a-zA-Z_0-9]  在正则表达式里面组成单词的东西必须由这些东西组成（可以是A-Z，a-z，0-9，下划线都行）</p>
<p><code>\W</code>  即(大W)表示除\w单词字符之外的其他所有字符</p>
<p>\S  匹配任何非Unicode空白的字符 <code>[^\s]</code></p>
<p>\s  空格字符:[\ t\n\x0B\f\r\n]</p>
<ol start="4">
<li>边界匹配器</li>
</ol>
<p>^  行的开头</p>
<p>$  行的结尾</p>
<p>\b  单词边界  就是不是单词字符的地方。（单词间隔就用这个字符占）</p>
<ol start="5">
<li>数量词</li>
</ol>
<p>X？  X，一次或一次也没有</p>
<p>X*  X,零次或多次</p>
<p>X+  X，一次或多次</p>
<p>X{n}  X，恰好n次</p>
<p>X{n,}  X，至少n次</p>
<p>X{n,m}  X，至少n次，但不超过m次</p>
<p>6.POSIX字符类</p>
<p>\p{Punct}  匹配任何标点字符 <code>“＃$％＆&#39;（）* +， - 。/:; &lt;=&gt;？@ [\ _] ^ _&gt; &#123;|&#125;</code></p>
<p>\p{Lower}  小写字母字符:[az]</p>
<p>\p{Upper}  大写字母字符:[AZ]</p>
<p>\p{ASCII}  所有ASCII:[\ x00-\x7F]</p>
<p>\p{Alpha}  字母字符:[\ p {Lower}\p {Upper}]</p>
<p>\p{Digit}  十进制数字:[0-9]</p>
<p>\p{Alnum}  字母数字字符:[\ p {Alpha}\p {Digit}]</p>
<p>\p{Graph}  一个可见的角色:[\ p {Alnum}\p {Punct}]</p>
<p>\p{Print}  可打印字符:[\ p {Graph}\x20]</p>
<p>\p{Blank}  空格或制表符:[\ t]</p>
<p>\p{XDigit}  十六进制数字:[0-9a-fA-F]</p>
<p>\p{Space}  一个空白字符:[\ t\n\x0B\f\r]</p>
<p>(?:pattern)<br>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。<br>(?=pattern)<br>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<br>(?!pattern)<br>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。<br>(?&lt;=pattern)<br>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。<br>(?&lt;!pattern)<br>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题 </p>
<p>应用：</p>
<p>判断功能</p>
<p>String类的public boolean matches(String regex)方法</p>
<p>分割功能</p>
<p>String类的public String[] split(String regex)方法  根据给定正则表达式的匹配拆分此字符串成字符串数组（相当于是把regex这个字符删除了，剩下的分成小片段）</p>
<p>（硬盘上的路径，我们应该用<code>\\</code>替代\，把它分割是<code>\\\\</code> 第一个\代表格式，第二个\代表转义，<code>\\</code>代表字符串）</p>
<p>替换功能</p>
<p>String类的public String replaceAll(String regex,String replacement)方法： 使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串  （应用：可以屏蔽一些子，密码的*等等）</p>
<p>获取功能</p>
<p>Pattern和Matcher类的使用</p>
<p>模式和匹配器的典型调用顺序：</p>
<p>\1. 把正则表达式编译成模式对象:Pattern p= Pattern.compile(“a*b”);</p>
<p>\2. 通过模式对象得到匹配器对象，这个时候需要的是被匹配的字符串:Matcher m=p.matcher(“aaaaab”);</p>
<p>\3. 调用匹配器对象的功能:</p>
<p>(1) boolean b=m.matches();  调用的matches方法尝试将整个输入序列与该模式匹配</p>
<p>(2) lookingAt  尝试将输入序列从头开始与该模式匹配</p>
<p>(3) find方法扫描输入序列以查找玉该模式匹配的下一个子序列</p>
<p>以上三种方法都是返回boolean类型。find方法后还有一个group方法用来获取匹配的子字符串。</p>
<p>JAVA时间字符串去空格、冒号和横杠</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String date &#x3D; &quot;2017-09-19 14:40:01&quot;;</span><br><span class="line">String response &#x3D; date.replaceAll(&quot;[[\\s-:punct:]]&quot;,&quot;&quot;);</span><br><span class="line">匹配所有空白字符，-，：，标点符号</span><br></pre></td></tr></table></figure>

<p>[[:punct:]]是指所有的符号<code>！#$%&amp;&#39;（）*+，-./：；&lt;=&gt;？@[]^ </code>{}~`</p>
<p>\s匹配任何空白字符[\t\n\x0B\f\r]，第一个\是转义</p>
<h1 id="Math类-Random类-System类"><a href="#Math类-Random类-System类" class="headerlink" title="Math类/Random类/System类"></a>Math类/Random类/System类</h1><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p>
<p>成员变量：</p>
<p>publi static final double PI</p>
<p>publi static final double E</p>
<p>成员方法（都是静态，不用创建对象）</p>
<p>public static int abs(int a)  绝对值</p>
<p>public static double ceil(double a)  向上取整</p>
<p>public static double floor(double a)  向下取整</p>
<p>public static int max(int a,int b)  最大值</p>
<p>public static double pow(double a,double b)  a的b次幂</p>
<p>public static double random()  随机数[0.0,1.0)</p>
<p>public static int round(float a)  四舍五入（+0.5后向下取整）</p>
<p>public static double sqrt(double a)  正平方根</p>
<p>如果想得到任意范围的随机数：</p>
<p>int number=(int) (Math.random()*(end-start+1))+start;</p>
<p>Random类：util包中，此类的实例用于生成伪随机数流。</p>
<p>如果用<em>相同的种子</em>创建两个 Random 实例，则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列。</p>
<p>构造方法</p>
<p>public Random() 没有给种子，用的是默认种子，是当前时间的毫秒值</p>
<p>public Random(long seed) 给出指定的种子。  给定种子后，每次得到的随机数是相同的。</p>
<p>Random类成员方法</p>
<p>public int nextInt() 返回的是int范围内的随机数</p>
<p>public int nextInt(int n) 返回的是[0,n)范围内的随机数</p>
<p>System类：lang包</p>
<p>System 类包含一些有用的类字段和方法。它不能被实例化，全是静态。</p>
<p>成员方法</p>
<p>public static void gc() 运行垃圾回收器 不要一直调用们因为每一次执行垃圾回收，jvm都会强制启动垃圾回收器运行，这回耗费更多的系统资源，会与正常的java程序争夺资源，只有执行大量的对象的释放时，才会调用垃圾回收。</p>
<p>public static void exit(int status) 终止当前正在运行的java虚拟机，参数用作状态码，根据惯例，非0的状态码表示异常终止。（所以一般用System.exit（0）；相当于按了x退出，后面的都不运行）</p>
<p>public static long currentTimeMillis() 返回以毫秒为单位的当前时间（可以用来计时）</p>
<p>为什么是1970年1月1日0点：一种说法是java起源于UNIX系统，而UNIX系统认为1970.1.1是时间纪元。因为当时的操作系统是32位，换算下来相当于68.1年就会达到最大值，从而回到起始值，所以将1970.1.1当作起点，让这个时间推迟到2038年，而现在已经出现了64位操作系统，所以时间无线大，解决了这个问题。</p>
<p>public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length) 从指定原数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。arraycopy中c小写，因为刚开始命名不规范改不回去了。src代表原数组，srcPos代表原数组中的起始位置。dest目标数组，destPos代表目标数组中的起始位置。length代表要复制的数组元素的数量。相当于原数组不变，新数组的长度也不变，只是把原数组中的length长度元素替换到了新数组中。</p>
<h1 id="BigInterger类-BigDecimal类"><a href="#BigInterger类-BigDecimal类" class="headerlink" title="BigInterger类/BigDecimal类"></a>BigInterger类/BigDecimal类</h1><p>BigInteger类：</p>
<p>可以让超过Integer范围内的数据进行运算</p>
<p>构造方法</p>
<p>public BigInteger(String val)</p>
<p>BigInteger类的成员方法</p>
<p>public BigInteger add(BigInteger val)  +</p>
<p>public BigInteger subtract(BigInteger val)  -</p>
<p>public BigInteger multiply(BigInteger val)  * </p>
<p>public BigInteger divide(BigInteger val)  /</p>
<p>public BigInteger[] divideAndRemainder(BigInteger val)  返回的是商和余数的数组</p>
<p>BigDecimal类：</p>
<p>由于在运算的时候，float类型和double很容易丢失精度，演示案例。所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal（金融方面就要用）</p>
<p>是不可变的、任意精度的有符号十进制数。</p>
<p>构造方法</p>
<p>public BigDecimal(String val)</p>
<p>BigDecimal类的成员方法</p>
<p>public BigDecimal add(BigDecimal augend)</p>
<p>public BigDecimal subtract(BigDecimal subtrahend)</p>
<p>public BigDecimal multiply(BigDecimal multiplicand)</p>
<p>public BigDecimal divide(BigDecimal divisor)</p>
<p>public BigDecimal divide(BigDecimal divisor,int scale, int roundingMode) 商，几位小数，如何取舍</p>
<p>判断 BigDecimal 是否为0：</p>
<p>new BigDecimal(“0.00”).compareTo(你的数据)  == 0</p>
<h1 id="Date类-DateFormat类-Calendar类"><a href="#Date类-DateFormat类-Calendar类" class="headerlink" title="Date类/DateFormat类/Calendar类"></a>Date类/DateFormat类/Calendar类</h1><p>Date类：</p>
<p>类 Date 表示特定的瞬间，精确到毫秒。  大部分方法已经过时。</p>
<p>构造方法</p>
<p>public Date()</p>
<p>public Date(long date)</p>
<p>成员方法</p>
<p>public long getTime()  获取时间，以毫秒为单位</p>
<p>public void setTime(long time)  设置时间</p>
<p>Syste.ou.println(new Date(0));  为什么打印的是8.而不是0.呢：因为存在系统时间和本地时间的间隔，系统时间依然是0点，而电脑的时区设置在东8区，所以打印的结果是8点。</p>
<p>DateFormat类：txt包</p>
<p>Date–String  格式化  public final String format(Date  date)</p>
<p>String–Date  解析   public Date parse(String source)</p>
<p>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。</p>
<p>DateFormat可以进行日期和字符串的格式化和解析，但由于是抽象类，所以使用其子类SimpleDateFormat</p>
<p>SimpleDateFormat类的构造方法：</p>
<p>public SimpleDateFormat() 默认模式</p>
<p>public SimpleDateFormat(String pattern) 给定的模式</p>
<p>API中有对应的模式举例：</p>
<p>年  y</p>
<p>月  M</p>
<p>日  d</p>
<p>时  H</p>
<p>分  m</p>
<p>秒  s</p>
<p>2020年11月14日 17：58：20</p>
<p>yyyy年MM月dd日 HH:mm：ss</p>
<p>在把一个字符串解析为日期的时候，请注意格式必须和给定的字符串格式匹配。</p>
<p>成员方法</p>
<p>public final String format(Date date)</p>
<p>public Date parse(String source)</p>
<p>Calendar类</p>
<p>Date类的很多都被Calendar类替代了。</p>
<p>Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p>
<p>成员方法</p>
<p>public static Calendar getInstance() 其实相当于多态，表面上返回的是Calendar，其实返回的是Calendar的一个实现子类。</p>
<p>public int get(int field) 返回给定日历字段的值。日历类中的每个日历字段都是静态的成员变量，并且是int类型。</p>
<p>public void add(int field,int amount) 根据给定的日历字段和对应的时间，来对当前的日历进行操作。  amount可以是 -3  3</p>
<p>public final void set(int year,int month,int date) 设置当前日历的年月日。</p>
<p>month都是0-11  所以适当+1</p>
<h1 id="RunTime类"><a href="#RunTime类" class="headerlink" title="RunTime类"></a>RunTime类</h1><p>该类主要代表了应用程序的运行环境。一个RunTime就代表一个运行环境</p>
<p>方法</p>
<p>(1) getRuntime()：该方法用于返回当前应用程序的运行环境对象。</p>
<p>(2) exec(String command)：该方法用于根据指定的路径执行对应的可执行文件。</p>
<p>(3) freeMemory()：该方法用于返回Java虚拟机中的空闲内存量，以字节为单位。<br>(4) maxMemory()：该方法用于返回Java虚拟机试图使用的最大内存量。</p>
<p>(5) totalMemory()：该方法用于返回Java虚拟机中的内存总量。</p>
<p>例子：</p>
<p><img src="/4.9.java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/image-20210809165151605.png" alt="image-20210809165151605"></p>
<h3 id="getRuntime-exec"><a href="#getRuntime-exec" class="headerlink" title="getRuntime().exec()"></a>getRuntime().exec()</h3><p>在java中，RunTime.getRuntime().exec()实现了调用服务器命令脚本来执行功能需要</p>
<p>用法：     </p>
<p>public Process exec(String command)—–在单独的进程中执行指定的字符串命令。</p>
<p>public Process exec(String [] cmdArray)—在单独的进程中执行指定命令和变量</p>
<p>public Process exec(String command, String [] envp)—-在指定环境的独立进程中执行指定命令和变量</p>
<p>public Process exec(String [] cmdArray, String [] envp)—-在指定环境的独立进程中执行指定的命令和变量</p>
<p>public Process exec(String command,String[] envp,File dir)—-在有指定环境和工作目录的独立进程中执行指定的字符串命令</p>
<p>public Process exec(String[] cmdarray,String[] envp,File dir)—-在指定环境和工作目录的独立进程中执行指定的命令和变量</p>
<p>举例：</p>
<ol>
<li><p>RunTime.getRuntime().exec（String  command）;</p>
<pre><code>     在windows下相当于直接调用   /开始/搜索程序和文件  的指令，比如
 
     Process process = Runtime.getRuntime().exec(&quot;notepad.exe&quot;);  -------打开windows下记事本。
</code></pre>
</li>
<li><p>public Process exec(String [] cmdArray)；</p>
<pre><code>      Linux下：
 
      Process process = Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/sh&quot;,&quot;-c&quot;, &quot;;
 
      Windows下：
 
      Process process = Runtime.getRuntime().exec(new String[]&#123; &quot;cmd&quot;, &quot;/c&quot;, cmds&#125;);
</code></pre>
</li>
</ol>
<p><strong>补充</strong>：#!/bin/bash和#!/bin/sh的区别</p>
<p>#! 是个指示路径的表示符，/bin/bash和/bin/sh指定了脚本解析器的程序路径</p>
<p>bash是sh的完整版，bash完全兼容sh命令，反之不行</p>
<p>OPTIONS:</p>
<p>　    -c string　　　   该选项表明string中包含了一条命令.如 bash -c ls ~</p>
<p>　　-i　　　　　　　使Bash以交互式方式运行</p>
<p>　　-r　　　　　　　使Bash以受限方式运行</p>
<p>　　–login　　　　   使Bash以登录Shell方式运行</p>
<p>　　–posix　　　　  使Bash遵循POSIX标准</p>
<p>　　–verbose　　　 使Bash显示所有其读入的输入行</p>
<p>　　–help　　　　　打印Bash的使用信息</p>
<p>　　–version　　　  打印版本信息</p>
<p><strong>Process</strong>的几种方法：<br>1.destroy()：杀掉子进程</p>
<p>2.exitValue()：返回子进程的出口值，值 0 表示正常终止</p>
<p>3.getErrorStream()：获取子进程的错误流</p>
<p>4.getInputStream()：获取子进程的输入流</p>
<p>5.getOutputStream()：获取子进程的输出流</p>
<p>6.waitFor()：导致当前线程等待，如有必要，一直要等到由该 Process 对象表示的进程已经终止。如果已终止该子进程，此方法立即返回。如果没有终止该子进程，调用的线程将被阻塞，直到退出子进程，根据惯例，0 表示正常终止</p>
<p>注意：在java中，调用runtime线程执行脚本是非常消耗资源的，所以切忌不要频繁使用！</p>
<p>在调用runtime去执行脚本的时候，其实就是JVM开了一个子线程去调用JVM所在系统的命令，其中开了三个通道： 输入流、输出流、错误流，其中输出流就是子线程走调用的通道。</p>
<p>waitFor是等待子线程执行命令结束后才执行， 但是在runtime中，打开程序的命令如果不关闭，就不算子线程结束。比如以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static Process p &#x3D; null;</span><br><span class="line"></span><br><span class="line">p &#x3D; Runtime.getRuntime().exec(&quot;notepad.exe&quot;);</span><br><span class="line"></span><br><span class="line">p.waitFor();     </span><br><span class="line"></span><br><span class="line">System.out.println(&quot;--------------------------------------------我被执行了&quot;);</span><br></pre></td></tr></table></figure>

<p>以上代码中，打开windows中记事本。如果我们不手动关闭记事本，那么输出语句就不会被执行，这点是需要理解的。  </p>
<p> process的阻塞：</p>
<p>在runtime执行大点的命令中，输入流和错误流会不断有流进入存储在JVM的缓冲区中，如果缓冲区的流不被读取被填满时，就会造成runtime的阻塞。所以在进行比如：大文件复制等的操作时，我们还需要不断的去读取JVM中的缓冲区的流，来防止Runtime的死锁阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">在linux 上封装的方法：</span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> daemon true,后台执行，false,直接执行</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args 指令行</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">sendCommand</span><span class="params">(<span class="keyword">boolean</span> daemon,String args)</span> </span>&#123;</span><br><span class="line">		logger.info(<span class="string">&quot;args=&#123;&#125;&quot;</span>, args);</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="comment">//	InputStreamReader ir = null;</span></span><br><span class="line">	<span class="comment">//	LineNumberReader input = null;</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String[] envp = &#123; <span class="string">&quot;LANG=UTF-8&quot;</span> &#125;;</span><br><span class="line">			Process process=<span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span>(daemon) &#123;</span><br><span class="line">				String[] comands = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, args&#125;;</span><br><span class="line">				process = Runtime.getRuntime().exec(comands, envp);</span><br><span class="line">				process.waitFor();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				process = Runtime.getRuntime().exec(args, envp);</span><br><span class="line">				process.waitFor(<span class="number">60</span>,TimeUnit.SECONDS);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> (InputStreamReader ir =  <span class="keyword">new</span> InputStreamReader(process.getInputStream(), Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));LineNumberReader input = <span class="keyword">new</span> LineNumberReader(ir)) &#123;</span><br><span class="line">				String tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				<span class="keyword">while</span> ((tmp = input.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">					builder.append(tmp).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				logger.error(e.getMessage(), e);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Result(ErrorCode.EC_FAILED, e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> (InputStreamReader ir =  <span class="keyword">new</span> InputStreamReader(process.getErrorStream(), Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));LineNumberReader input = <span class="keyword">new</span> LineNumberReader(ir)) &#123;</span><br><span class="line">				String tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				<span class="keyword">while</span> ((tmp = input.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">					builder.append(tmp).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				logger.error(e.getMessage(), e);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Result(ErrorCode.EC_FAILED, e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			logger.error(e.getMessage(), e);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(ErrorCode.EC_FAILED, e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		String result = builder.toString();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isNotEmpty(result)&amp;&amp;StringUtils.containsIgnoreCase(result, <span class="string">&quot;ERROR&quot;</span>)) &#123;</span><br><span class="line">			logger.info(<span class="string">&quot;result=&#123;&#125;&quot;</span>, result);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(ErrorCode.EC_FAILED, result);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(ErrorCode.EC_OK);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/26/4.9.java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/" data-id="ckw61sdwr0069oswd6a6t1ljw" data-title="java中常用类" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-10.4.项目踩坑" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/10.4.%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T10:50:02.000Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/26/10.4.%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/">项目踩坑</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1.R是com.baomidou.mybatisplus.extension.api中写好的一个统一结果返回集。主要包含code，data，msg</p>
<p>**R(IErrorCode errorCode)**：    {data:null,code:errorCode.getCode(),msg:errorCode.getMsg()}</p>
<p><strong>R.ok(T data)</strong>:         默认情况下：{data:data,code:0,msg:执行成功}  如果data为Boolean类型且就是false:{data:false,code:-1,msg:操作失败}</p>
<p><strong>R.failed(String msg)</strong>:        {data:null,code:-1,msg:msg}</p>
<p><strong>R.failed(IErrorCode errorCode)</strong> :            {data:null,code:errorCode.getCode(),msg:errorCode.getMsg()}</p>
<p><strong>R.restResult(T data, IErrorCode errorCode)</strong>  :            {data:data,code:errorCode.getCode(),msg:errorCode.getMsg()}</p>
<p><strong>R.restResult(T data, long code, String msg)</strong>:            {data:data,code:code,msg:msg}</p>
<p>可以自己定义枚举类实现IErrorCode接口</p>
<p>遇到的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R.restResult(vo, ApiSuccessCode.YELLOW)</span><br><span class="line">当YELLOW定义为（-1，&quot;yellow&quot;)时，前端会toast出yellow。(因为前端代码如果不符合要求Toast(res.data.msg);)</span><br><span class="line">&#x2F;&#x2F;解决方法：将YELLOW的code定义为其他不常用的特殊数字，前端对这个数字进行判断来满足这个单独的场景</span><br></pre></td></tr></table></figure>

<p>2.多看文档的API，可能有封装好的方法</p>
<p>3.lombok里的@data可以自动装填get/set</p>
<p>4.docker里的时间比写入到mysql的时间少8小时。java程序在本地运行时间（正常，相当于就是mysql的时间）比在docker容器上运行时间迟（多）8小时。（用date命令查看时间是CST还是UTC）</p>
<p>原因 ：</p>
<p>一般宿主机用的都是CST时区（China Standard Time UT+8:00 中国标准时间），而docker容器中初始用的都是UTC时区（Coordinated Universal Time 世界协调时间）比CST慢8个小时</p>
<p>解决方案：</p>
<p>查阅相关资料后得知： jre是通过<code>/etc/timezone</code> 配置文件读取本地时间的</p>
<p>需要将挂载宿主机的/etc/localtime 到容器的/etc/localtime，这时输入<code>date</code>命令容器时区显示正常，但是跑在容器中的java项目取到的时间却早了8小时。</p>
<p>接着我修改了/etc/timezone配置命令如下：<br><code>echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</code></p>
<p>重启了下容器，然后java项目中读取的时区恢复正常了。</p>
<p>但是仅仅是java容器内的正常了，nginx容器内时间还是少8个小时，所以还需要将nginx的容器的时区进行更改。</p>
<p>也可以执行命令更改时区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@06057b1eeb48:&#x2F;usr&#x2F;share# cd &#x2F;etc&#x2F;</span><br><span class="line">root@06057b1eeb48:&#x2F;etc# mv localtime localtime.bak</span><br><span class="line">root@06057b1eeb48:&#x2F;etc# cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br></pre></td></tr></table></figure>

<p>输入date查看时间是否是CST</p>
<p>5.程序内微信的acces_token过期，返回值为400001，但是postman正常发送返回值为0。清下服务器上redis的数据库即可。</p>
<p><img src="C:\Users\swx\AppData\Roaming\Typora\typora-user-images\image-20210410201322948.png" alt="image-20210410201322948"></p>
<p>6.关于vue项目打包的问题：</p>
<p>花了一个下午，差不多搞明白了。</p>
<p>node.js有一个版本号，安装好node.js之后，会自动安装了npm。npm也有一个版本号。</p>
<p>npm可以再安装vue，再安装vue的脚手架：vue -cli，这两个的版本号是同一个。</p>
<p>​    1.注意这里的版本号。写vue项目用到什么的版本号都会写在vue项目里的package.json。版本过高或者过低都会报错。还要注意这几个软件的安装位置，最好都在一起。</p>
<p>​    2.特别坑。为什么每次打包都会出错？是因为你运行的VUE的文件外面还包了一个文件。运行的时候一般就是总文件，然后直接打包会成功，如果外面再有一个文件夹（比如你是从git上pull的项目，它外面会自带一个文件夹，你再直接打开这个文件就会出现这种情况），就会报错。</p>
<p>7.String类的int类型hex进制转10进制的时候：00000000会自动转为0，需要转换为00000000再转为string类型，可以用String.format(“%08d”,i)方法</p>
<p>8.vue页面的图片插入问题：require（’相对路径’）</p>
<p>服务器上的/xx/xx/xxx.jpg</p>
<p>9.HttpServletRequest </p>
<p>public void weixin(@RequestParam(name = “openid”, defaultValue = “”) String openid, @RequestBody String xml)</p>
<p>10.将一个xml格式的string类型数据进行解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">String str= sb.toString();</span><br><span class="line">        Document doc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doc = DocumentHelper.parseText(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Element root = doc.getRootElement();<span class="comment">// 指向根节点  &lt;root&gt;</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里的是Element，需要转换为String类型</span></span><br><span class="line">            Element mark=root.element(<span class="string">&quot;header&quot;</span>).element(<span class="string">&quot;mark&quot;</span>);</span><br><span class="line">            Element second=root.element(<span class="string">&quot;body&quot;</span>).element(<span class="string">&quot;data&quot;</span>).element(<span class="string">&quot;first&quot;</span>).element(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">            <span class="comment">//获取xml的节点内容</span></span><br><span class="line">            System.out.println(mark.getTextTrim());</span><br><span class="line">            System.out.println(second.getTextTrim());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将xml存入map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">parseXml</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将解析结果存储在HashMap中</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 从request中取得输入流</span></span><br><span class="line">        InputStream inputStream = request.getInputStream();</span><br><span class="line">        <span class="comment">// 读取输入流</span></span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = reader.read(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到xml根元素</span></span><br><span class="line">        Element root = document.getRootElement();</span><br><span class="line"><span class="comment">//获得子元素下的元素</span></span><br><span class="line">        Iterator&lt;Element&gt; iterator = root.elementIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Element e = iterator.next();</span><br><span class="line">            map.put(e.getName(), e.getText());</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            List&lt;Element&gt; sonList = e.elements();</span><br><span class="line">            <span class="keyword">for</span> (Element son : sonList) &#123;</span><br><span class="line">                map.put(son.getName(), son.getText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>11.idea里的文件名字变蓝是因为文件里的内容被修改过，没有提交到版本库。变红是新增的文件。</p>
<p>12.微信回复消息的时候，<code>&lt;Content&gt;&lt;![CDATA[&quot;+text+&quot;]]&gt;&lt;/Content&gt;</code>中的text文本乱码成？？？？？</p>
<p>是由于spring mvc的@ResponseBody注解返回字符串时默认返回的是“ISO-8859-1”而不是utf-8。</p>
<p>  虽然大家的项目里面可能都有字符编码过滤器，但是有一个问题在这里，我们设置response.setContentType(“text/html; charset=utf-8”);时都是在chain.doFilter(request, response);之前设置的，也就是过滤器前处理是设置的响应编码格式，之所以不在后处理时设置是因为后处理时响应内容已经生成此时设置是无效的，必须在响应内容生成之前设置响应编码格式。</p>
<p>问题就出在这个地方，我们虽然设置了响应编码格式，可是spring mvc在有@ResponseBody注解的响应是，篡改了我们的响应编码！<br>  相信大家对spring的Message Converters不会陌生，HttpMessageConverters<T>这个接口是用来把请求信息转化为对象T，把T输出为响应信息的一个接口，在该接口众多的实现类中有一个实现类StringHttpMessageConverter，这个类的作用就是把请求信息转换未字符串，而@ResponseBody注解就是默认调用的这个类，而这个类中默认的编码格式就是ISO-8859-1，所以罪魁祸首找到了</p>
<p>原因：</p>
<p>由于spring默认对String类型的返回的编码采用的是 StringHttpMessageConverter<br>&gt;&gt;&gt; spring mvc的一个bug，spring MVC有一系列HttpMessageConverter去处理用@ResponseBody注解的返回值，如返回list则使用MappingJacksonHttpMessageConverter。返回string，则使用StringHttpMessageConverter。这个convert使用的是字符集是iso-8859-1,而且是final的：<br>public static final Charset DEFAULT_CHARSET = Charset.forName(“ISO-8859-1”);</p>
<p>解决：</p>
<p>在RequestMapping里加上<code> produces = &quot;text/html;charset=UTF-8&quot;</code>//只针对单个方法生效，不全局生效</p>
<p>例：@RequestMapping(value = “/weixin/validation” , method = RequestMethod.POST , produces = “text/html;charset=UTF-8”)</p>
<p>13.程序内是生成6位数字的验证码结果，通过阿里云短信发送出来有时只有5位：因为返回到阿里云里面的验证码，会被识别为数字。然后第一位数字是0就默认去掉了。</p>
<p>提供的解决方法：</p>
<p>​    1.随机生成数开头为0的话，继续随机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span></span>&#123; 	<span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>); 	</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == number)&#123; 		</span><br><span class="line">        <span class="keyword">return</span> getRandom(); 	</span><br><span class="line">    &#125; 	</span><br><span class="line">    <span class="keyword">return</span> number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    2.是在验证码外层拼接一个单引号 ：<code>&quot;&#123;code:&quot;+&quot;&#39;&quot;+code+&quot;&#39;&quot;+&quot;&#125;&quot;</code>     为什么加了一个单引号就可以实现？阿里云的接口定义这里应该是一个json格式。</p>
<p>14.记录表和状态表：状态表的主键唯一，unquire。记录表主键为normal，可以重复多条。</p>
<p>15.关于移动端的v-console按钮：</p>
<p><img src="/10.4.%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/image-20210514122852087.png" alt="image-20210514122852087"></p>
<p>当不需要显示时：在main.js文件中将new Vconsole()注释掉即可。</p>
<p>16.spring MVC接收请求体总是多一个等号</p>
<p>例：我发送的请求体是字符串aaa，spring MVC 接收到的是aaa=</p>
<p>//因为请求的content type不对，应该是:<strong>application/json;charset=UTF-8</strong>。而我设置的content type是:application/x-www-form-urlencoded;charset=UTF-8</p>
<p>原因是后端接收的是context-type:application/json<br>而axios的post请求默认是context-type: application/x-www-form-urlencoded<br>这里在前端发起请求前，在请求拦截器中设置一下context-type为json就好了</p>
<p>因为默认是以键值对形式传递<br>前端传过来的内容是放在k中，v为空，这时候取值时，内容就变成了k=,也就是为什么后端接收的数据，末尾多了一个＝</p>
<p>17.qw条件构造器连续使用的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper qw = <span class="keyword">new</span> QueryWrapper();</span><br><span class="line">        qw.eq(<span class="string">&quot;node_num&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        Nodes nodes = nodesService.getOne(qw);</span><br><span class="line">       </span><br><span class="line">        qw = <span class="keyword">new</span> QueryWrapper();<span class="comment">//需要新加这一行代码才能保证上下两个查询语句互不相连。如果没有这条语句，下面的查询语句会有两个限定条件</span></span><br><span class="line">        qw.eq(<span class="string">&quot;user_id&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        List&lt;Bind&gt; bind = bindService.list(qw);</span><br></pre></td></tr></table></figure>

<ol start="18">
<li> qs.stringify（this.form）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid&#x3D;cs11&amp;pwd&#x3D;000000als&amp;username&#x3D;cs11&amp;password&#x3D;000000als</span><br></pre></td></tr></table></figure>

<p>qs是一个npm仓库所管理的包,可通过<code>npm install qs</code>命令进行安装</p>
<ol>
<li>qs.parse()将URL解析成对象的形式</li>
<li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li>
</ol>
<p>JSON中同样存在stringify方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;uid&quot;:&quot;cs11&quot;,&quot;pwd&quot;:&quot;000000als&quot;,&quot;username&quot;:&quot;cs11&quot;,&quot;password&quot;:&quot;000000als&quot;&#125;   </span><br></pre></td></tr></table></figure>



<p>当前端页面需要借助url来往后台传递<strong>参数</strong>的时候我们通常会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var  url&#x3D;&quot;base&#x2F;exchangeController&#x2F;1&#x2F;searchExchanges?code&#x3D;&quot;+code+&quot;&amp;name&#x3D;&quot;+name;</span><br></pre></td></tr></table></figure>

<p>   如果你的name传递的是中文的话，在谷歌浏览器中传递到后台的数据是正常的（其他浏览器未测试），但是在IE浏览器中，后台接受到的将会是乱码，这是因为IE浏览器没有将你传递的<strong>参数</strong>序列化<strong>为URL 编码文本字符串，后台在解码你的</strong>参数的时候就会形成乱码，解决方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var  param&#x3D;&#123;&quot;code&quot;:code,&quot;name&quot;:name&#125;;</span><br><span class="line">var  url&#x3D;&quot;base&#x2F;exchangeController&#x2F;1&#x2F;searchExchanges&quot;+&quot;?&quot;+$.param(param);</span><br></pre></td></tr></table></figure>

<p>　　借助jquery的param方法将你要携带的<strong>参数</strong>对象化之后，再<strong>序列化</strong>一下，这样IE浏览器下即使你传递中文，后台接收到的数据也是正常的中文了</p>
<p>19.前端调试的时候：console.log(A) 输出的数组A显示是Object，而不是包含的值，但只是打印出来的log是Object，在引用时候还是数组的值。需要查看打印的值（将数组A转换为json字符串）：console.log(JSON.stringify(A))  </p>
<p>20.前端页面动态赋值时不起作用，在属性前面加<code>:</code>绑定后生效。</p>
<p>21.前端页面的css样式复用问题：原页面a.vue用的v-router去跳转到b.vue，然后退回来时a.vue的样式全乱了，我在b.vue中导入了一个css文件，然后页面调试是看到退回后styles是不变的，也就是说a.vue用的不是原来的样式而是b.vue中导入的样式，刷新一下的话就又可以了。</p>
<p>怎么让vue不去使用上个页面的样式，或者说让当前vue只用自己写的当前样式：两个名字不要起一样的，就是两个css样式了。</p>
<p>22.导航下拉菜单被遮住或显示不全：</p>
<p>原因：层叠关系错误</p>
<p>解决：设置z-index，最上面的层级值越大。但是必须有两个前提条件：1.必须是同级。2.二者分别设定了position:relative 或 absolute 或 fixed；</p>
<p>23.后端springboot项目，入口的Application类必须放在最上层，才能读取到所有的其他配置。</p>
<p>24.@Slf4j</p>
<p>如果不想每次都写**private final Logger logger = LoggerFactory.getLogger(当前类名.class); **</p>
<p><strong>可以在类上用注解@Slf4j</strong>，然后就可以直接使用<strong>log.info(“字符串内容”);</strong></p>
<p>25.在工具类中调用静态方法时，mapper无法注入的问题：一个<strong>工具类中的静态方法调用<code>mybatis</code>的<code>mapper</code>接口</strong>时，会出现<code>@Autowired</code>无法注入的问题，即使添加了这个注解，spring容器加载完成声明的参数也是空值</p>
<p>在<code>SpringFramework</code>里，不能<code>@Autowired</code>一个静态变量，使之成为一个<code>Spring bean</code>的</p>
<p>解决方案：</p>
<p>首先，在实体类上加上注解@Component，方便spring容器进行加载，然后定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">在静态工具类中注入mapper的方式示例</span><br><span class="line">*&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class CodeMapUtils &#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">private static Logger LOGGER &#x3D; LoggerFactory.getLogger(DoAllController.class);</span><br><span class="line"></span><br><span class="line">private static CodeMapUtils codeMapUtils;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private CodeMapMapper codeMapMapper;</span><br><span class="line"></span><br><span class="line">@PostConstruct</span><br><span class="line">public void init() &#123;</span><br><span class="line">codeMapUtils &#x3D; this;</span><br><span class="line">    codeMapUtils.codeMapMapper &#x3D; this.codeMapMapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String queryFromCodeMap(String key, String colName) &#123;</span><br><span class="line">String value &#x3D; codeMapUtils.codeMapMapper.getValueByKeyAndColName(key, colName);</span><br><span class="line"> &#x2F;&#x2F; do something...</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p> 另外，spring中Constructor、@Autowired、@PostConstruct的顺序：</p>
<p> 其实从依赖注入的字面意思就可以知道，要将对象p注入到对象a，那么首先就必须得生成对象a和对象p，才能执行注入。所以，如果一个类A中有个成员变量p被@Autowried注解，那么@Autowired注入是发生在A的构造方法执行完之后的。</p>
<p> 如果想在生成对象时完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么就无法在构造函数中实现。为此，可以使用@PostConstruct注解一个方法来完成初始化，@PostConstruct注解的方法将会在依赖注入完成后被自动调用。</p>
<p> 加载顺序：Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct</p>
<p>另：</p>
<p>spring无法自动注入静态变量、spring注入null 的解决方法：</p>
<p>方式一：使用@Resource注解set方法，将注入的bean对象赋值给静态变量。</p>
<p>/**</p>
<ul>
<li><p>@description: 自定義公共方法</p>
</li>
<li><p>@author: H2103424</p>
</li>
<li><p>@createTime: 2021/1/22 下午 02:15<br>**/<br>@Component<br>public class CustomUtil {</p>
<p>private static UserService userService;<br>private static MailSendService mailSendService;</p>
<p>@Resource<br>public void setMailSendService(MailSendService mailSendService) {</p>
<pre><code>CustomUtil.mailSendService = mailSendService;
</code></pre>
<p>}</p>
<p>@Resource<br>public void setUserService(UserService userService) {</p>
<pre><code>CustomUtil.userService = userService;
</code></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>@description: 根據 用戶編號list 獲取用戶郵箱list</li>
<li>@author:  H2103424</li>
<li>@dateTime: 2021/1/22 下午 03:06<br>*</li>
<li>@param users 用戶編號集合</li>
<li>@return 用戶郵箱集合<br>*/<br>public static List<String> getEmailsByUsers(List<Object> users){<br>List&lt;Map&lt;String,Object&gt;&gt; userInfos = userService.getUserByUserNo(users);<br>List<String> userEmails = new ArrayList&lt;&gt;();<br>userInfos.forEach(u -&gt; {<pre><code>userEmails.add((String) u.get(&quot;user_email&quot;));
</code></pre>
});<br>return userEmails;<br>}</li>
</ul>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法二：使用@Resource自动注入普通变量，然后使用@PostConstruct注解将普通变量赋值给静态变量。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>/**</p>
<ul>
<li><p>@description: 自定義公共方法</p>
</li>
<li><p>@author: H2103424</p>
</li>
<li><p>@createTime: 2021/1/22 下午 02:15</p>
</li>
<li><p>*/<br>@Component<br>public class CustomUtil {</p>
<p>  @Resource<br>  private UserService userServiceBean;<br>  @Resource<br>  private MailSendService mailSendServiceBean;</p>
<p>  private static UserService userService;<br>  private static MailSendService mailSendService;</p>
<p>  @PostConstruct<br>  public void init(){</p>
<pre><code>  userService = userServiceBean;
  mailSendService = mailSendServiceBean;
</code></pre>
<p>  }</p>
<p>  /**</p>
<ul>
<li>@description: 根據 用戶編號list 獲取用戶郵箱list</li>
<li>@author:  H2103424</li>
<li>@dateTime: 2021/1/22 下午 03:06</li>
<li></li>
<li>@param users 用戶編號集合</li>
<li>@return 用戶郵箱集合</li>
<li>/<br>public static List<String> getEmailsByUsers(List<Object> users){<br>  List&lt;Map&lt;String,Object&gt;&gt; userInfos = userService.getUserByUserNo(users);<br>  List<String> userEmails = new ArrayList&lt;&gt;();<br>  userInfos.forEach(u -&gt; {<pre><code>  userEmails.add((String) u.get(&quot;user_email&quot;));
</code></pre>
  });<br>  return userEmails;<br>}<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。</span><br><span class="line"></span><br><span class="line">Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>package com.example.studySpringBoot.util;</p>
<p>import com.example.studySpringBoot.service.MyMethorClassService;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.stereotype.Component;</p>
<p>import javax.annotation.PostConstruct;</p>
<p>@Component<br>public class MyUtils {</p>
<p>private static MyUtils  staticInstance = new MyUtils();</p>
<p>@Autowired<br>private MyMethorClassService    myService;</p>
<p>@PostConstruct<br>public void init(){<br>    staticInstance.myService = myService;<br>}</p>
<p>public static Integer invokeBean(){<br>    return staticInstance.myService.add(10,20);<br>}</p>
<p>}</p>
<p>项目里实际用的这种也可以：（这两个上面加不加@Autowired效果一样的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">private UserUtil(UserMapper userMapper) &#123;</span><br><span class="line">    UserUtil.userMapper &#x3D; userMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>26.vue项目地址里的/#/，#是因为 Vue 的路由使用了 Hash 模式，是单页面应用的经典用法。如果需要去掉的话：可以在路由配置中选择使用 History 模式，但会引发一些问题，需要在后端作出处理。</p>
<p>27.如果自动安装maven依赖的过程没有执行，可以在 <code>pom.xml</code> 上右键，选择 Maven -&gt;reload project。</p>
<p>如果右边没有maven菜单栏时，<code>shift+shift 选择actions 点击add maven project</code></p>
<p>28.springboot项目报错：（未实操）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o.apache.coyote.http11.Http11Processor   : Error parsing HTTP request header</span><br><span class="line">Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.</span><br><span class="line">java.lang.IllegalArgumentException: Invalid character found in method name. HTTP method names must be tokens </span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<p>用的是tomcat9.0版本</p>
<p>解决方法：不推荐降低tomcat版本，这等于掩耳盗铃，绝对得不偿失。Tomcat在 7.0.73, 8.0.39, 8.5.7 版本后，在http解析时做了严格限制。RFC3986文档规定，请求的Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符</p>
<p>1）在server.xml中的Connector中添加maxHttpHeaderSize=”8192”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;   maxHttpHeaderSize&#x3D;&quot;8192&quot;    connectionTimeout&#x3D;&quot;20000&quot;   maxThreads&#x3D;&quot;150&quot;  maxSpareThreads&#x3D;&quot;75&quot;   redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;  </span><br></pre></td></tr></table></figure>

<p>2）在在conf/catalina.properties中最后添加2行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tomcat.util.http.parser.HttpParser.requestTargetAllow&#x3D;|&#123;&#125;</span><br><span class="line">org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH&#x3D;true</span><br></pre></td></tr></table></figure>

<p> <code>requestTargetAllow</code> 只能配置|、{、} 允许这三个字符，对于其他的(例如” &lt; &gt; [ \ ] ^ ` { | } .)，在请求时，仍然拦截，如果使用了|{}之外的其他字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relaxedPathChars&#x3D;&quot;[\]^&#96;&#123;|&#125;&quot; relaxedQueryChars&#x3D;&quot;[\]^&#96;&#123;|&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>3）如果是https访问的页面，改为http</p>
<p>4）将HTTP1.1改成org.apache.coyote.http11.Http11NioProtocol，结果启动tomcat的时候出现了一大堆“地址已使用”的错误</p>
<p>29.学习项目时，如果跑起来报错jedis，可能是因为本地redis密码没有设置，需要在命令行进行redis登录，再设置密码，退出，再启动项目。</p>
<p>30.idea里如果get，set方法飘红，是因为lombok插件没有下载，需要在settings里的plugins下载。如果插件半天加载不出来，可以在设置里的HTTP Proxy setting勾选Auto-detect proxy settings，再勾选Automatic proxy configuration URL:填入代理地址url:<a target="_blank" rel="noopener" href="http://127.0.0.1:1080/">http://127.0.0.1:1080</a></p>
<p>31.代码规范可以下载<code>alibaba java coding guidelines</code>，在项目处右击选择 <code>编码规约扫描</code></p>
<p>32.localStorage 是存储在浏览器前端的，后台想获取，就需要前端传过去获取，可以在axios中将head的参数全局设置为localStorage 中的某个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(</span><br><span class="line">  (config) &#x3D;&gt; &#123;</span><br><span class="line">    Toast.loading(&#123;</span><br><span class="line">      message: &quot;加载中...&quot;,</span><br><span class="line">      loadingType: &quot;spinner&quot;,</span><br><span class="line">      forbidClick: true,</span><br><span class="line">      duration: 0,</span><br><span class="line">    &#125;);</span><br><span class="line">    const openid &#x3D; localStorage.getItem(&quot;openid&quot;);</span><br><span class="line">    config.headers[&quot;openid&quot;] &#x3D; openid;</span><br><span class="line">    if( localStorage.getItem(&#39;flag&#39;)&#x3D;&#x3D;1)&#123;</span><br><span class="line">        config.headers[&quot;openid&quot;] &#x3D; &quot;tangseng&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return config;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>33.vue页面的轮询：一般轮询都会使用setInterval，但是单独使用它会使页面卡死</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">   data() &#123;</span><br><span class="line">         return &#123;</span><br><span class="line">            timer: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.getList();</span><br><span class="line">    this.timer &#x3D; window.setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            this.getList()</span><br><span class="line">        &#125;,0)</span><br><span class="line">    &#125;,3000)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    getList() &#123;</span><br><span class="line">        &#x2F;&#x2F; 发送接口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">destroyed() &#123;</span><br><span class="line">    window.clearInterval(this.timer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用说明：setInterval不会清除定时器队列，每重复执行1次都会导致定时器叠加，会出现网页卡死现象。但是setTimeout是自带清除定时器的，两者结合使用将避免页面卡死。</p>
<p>页面初始化，待开始轮询后，离开页面，通过生命周期destroyed钩子函数，销毁定时任务。</p>
<p>如果不进行销毁，在vue页面中，即使离开了有定时器的页面，仍会执行定时任务，但是当关闭页面后，定时任务就没了。</p>
<p>34.spring方法里写了mapper以后，记得上面加注解@comment将这个类注入到spring中。</p>
<p>35.vue中：当选择了拒绝或者同意之后，this.radio可以正确取到，但是this.myform.reviewStatus显示为undefined</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">van-radio-group</span> <span class="attr">v-model</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;horizontal&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 20px;display: flex;align-items: center;justify-content: center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">van-radio</span> <span class="attr">name</span>=<span class="string">&quot;1&quot;</span>&gt;</span>拒绝<span class="tag">&lt;/<span class="name">van-radio</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">van-radio</span> <span class="attr">name</span>=<span class="string">&quot;2&quot;</span>&gt;</span>同意<span class="tag">&lt;/<span class="name">van-radio</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">van-radio-group</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">              radio: &#x27;1&#x27;,</span><br><span class="line">              myform: &#123;</span><br><span class="line">                  type: &quot;绑定安全帽审核&quot;,                 </span><br><span class="line">                  position:this.$route.query.position,                </span><br><span class="line">                  reviewStatus:this.radio,//2同意，1拒绝</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为data里的this是指父级作用域的上下文，所以this.radio并拿不到其本身作用域的radio<br>需要的话可以通过mounted，将radio赋值给reviewStatus：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            radio: <span class="number">1</span>,</span><br><span class="line">            reviewStatus: <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    moounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.reviewStatus = <span class="built_in">this</span>.radio</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.reviewStatus) <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>36.BigDecimal 进行浮点数精确运算时</p>
<p>利用 BigDecimal.valueOf 方法构造对象的方法，获得的浮点数发生了精度异常。(当 BigDecimal.valueOf(…) 的入参是 float 类型时，BigDecimal 会把入参强制转换成 double 类型。假如直接使用 new BigDecimal(double val) 构造函数来进行运算，则会发现计算结果发生来精度异常)</p>
<p>利用 new BigDecimal(String val) 方法，运算正确</p>
<p>37.LocalDateTime如果秒数是00的话，会自动去掉 比如00:00:00 转为LocalDateTime后变为00:00</p>
<p>38.java的类不能多继承，但是接口可以多继承，却不能implements任何接口</p>
<p>39.设计思路：对于订单的延时取消，可以在mysql的数据字段给个过期时间（也可以根据创建时间来判断是否过期），过期了就在查之前更新，将更新后的结果返回。没有过期就是正常查询。</p>
<p>40.url（前后端接口）的命名规范：</p>
<p>​    URL请求采用小写字母，数字，部分特殊符号（非制表符）组成（尽量使用一个单词，如果非要用2个，加_即可 /module/tickets/recently_closed）</p>
<p>​    URL请求中不采用大小写混合的驼峰命名方式，尽量采用全小写单词，如果需要连接多个单词，则采用连接符“_”连接单词</p>
<p>需要分级的话：</p>
<p>​    第一级Pattern为模块,比如组织管理/orgz, 网格化：/grid</p>
<p>​    第二级Pattern为资源分类或者功能请求，优先采用资源分类。</p>
<p>​    如果为资源分类，则按照RESTful的方式定义第三级Pattern，RESTful规范中，资源必须采用资源的名词复数定义。</p>
<p>例子：/orgz/members/120</p>
<p>41.redis里的缓存还没到时间就自动消失：是因为redis作为docker容器运行在docker里，而当初创建容器的时候没有设置时间参数，导致使用了docker的默认时间UTC，导致用的是国际时间，而你往redis里存的时候使用的是本地时间即上海地区时间，存入的时候正常，在容器里检测过期了8小时就会自动删除。</p>
<p>需要设置redis容器的时间为上海地区的时间。</p>
<p>42.redis莫名其妙会有保存的数据丢失，查看日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.</span><br></pre></td></tr></table></figure>

<p>可能是被人攻击了，删除了，需要设置redis的密码</p>
<p>43.把一个任意类型的值转换为布尔类型：用<code>！！</code> 一个！是取非 再一个！又取非 相当于把这个数据转换为boolen类型了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">前端转换：</span><br><span class="line"><span class="comment">// 强制转换为Boolean 用 !!</span></span><br><span class="line"><span class="keyword">var</span> bool = !!<span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bool); <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制转换为Number 用 +</span></span><br><span class="line"><span class="keyword">var</span> num = +<span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num); <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制转换为String 用 &quot;&quot;+</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;&quot;</span>+ <span class="number">1234</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str); <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//强制转换为Number，用 - 0</span></span><br></pre></td></tr></table></figure>

<p>44.vant框架的list组件：</p>
<p>页面加载完成后默认会自动加载一次，可以:immediate-check=”false”这样设置一下，页面加载完成后就不会自动加载一次了（此时可以在created方法或mounted方法中手动加载第一页的东西）</p>
<p>45.手写的一个aop切面的日志注解，加在方法A上可以正常切面打印日志，如果方法A里调用了方法B，但是方法B上的切面日志注解就不会起作用。</p>
<p>  aop切面的执行正常顺序为：@Before ，@Around，@After，@AfterReturning，@AfterThrowing</p>
<p>  从Spring5.2.7开始，在相同@Aspect类中，通知方法将根据其类型按照从高到低的优先级进行执行：@Around，@Before ，@After，@AfterReturning，@AfterThrowing</p>
<p>46.insert之后返回的返回值实际是增加的数据列数，并不是主键id。要想获取主键id，只需要在insert之后直接get该对象的主键id即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增银行卡</span></span><br><span class="line">BankCard bankCard = <span class="keyword">new</span> BankCard();</span><br><span class="line">bankCard.setBankCardRealName(bankCardRequest.getRealName());</span><br><span class="line">bankCard.setBankCardNum(bankCardRequest.getBankCardNum());</span><br><span class="line">bankCard.setBankName(bankCardRequest.getBankName());</span><br><span class="line">bankCardMapper.insert(bankCard);</span><br><span class="line">Long id = bankCard.getId();</span><br></pre></td></tr></table></figure>

<p>47.vue页面初始化时声明一个数组的属性，然后axios后端返回的值可以直接赋值。提交数据后将该数组置为{}会导致下一次赋值无法正确赋值，需要采用vue.set或者this.$set。也可以在清空数据的同时把原字段重新初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">adminForm: &#123;</span><br><span class="line">        nodeNum: &#39;&#39;,</span><br><span class="line">        helmetColor: &#39;&#39;</span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line">1.用完之后清空 this.adminForm &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">再次使用时动态绑定上 this.$set(this.adminForm, &#39;helmetColor&#39;,res.data.data.helmetColor);</span><br><span class="line"></span><br><span class="line">2.清空的时候同时初始化，就可以直接赋值</span><br><span class="line">this.adminForm: &#123;</span><br><span class="line">        nodeNum: &#39;&#39;,</span><br><span class="line">        helmetColor: &#39;&#39;</span><br><span class="line">&#125;</span><br><span class="line">this.bindForm.nodeNum &#x3D; res.data.data.nodeNum</span><br></pre></td></tr></table></figure>

<p>48.设置数据库对应的entity的属性为null。1.设置字段填充策略，会产生影响。2.写一个sql语句，调用设置字段为null。</p>
<p>49.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String S&#x3D; &quot;1&quot;;</span><br><span class="line">Integer i &#x3D; (Integer) s;&#x2F;&#x2F;会报错：String不能强转Integer，因为string强转Integer时不能加括号强转</span><br><span class="line">需要：</span><br><span class="line">Integer i &#x3D; Integer.parseInt(s);</span><br></pre></td></tr></table></figure>

<p>50.包装类为空的话，不能直接赋值给基础类，不然会报null。因为自动拆箱的时候报空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String S&#x3D; null;</span><br><span class="line">int i &#x3D; s;&#x2F;&#x2F;会报错：string转int涉及到自动装箱和拆箱</span><br></pre></td></tr></table></figure>

<p>51.不能以名字作为参数判断条件，因为可能出现重名，要以id作为判断条件</p>
<p>52.微信复制的内容可能会将空格替换。用postman复制别人微信发的post的body格式时踩到的坑。</p>
<p>53.idea里代码大部分飘红，但是项目可以正常启动。重新载入maven依赖也没起作用。</p>
<p>是因为IDEA有缓存，只需要刷新一下缓存就好了。解决方案：File -&gt; Invalidate Caches / Restart 然后选择Invalidate and Restart。</p>
<p>54.spring的事务和redis的“事务”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">加@Transactional</span><br><span class="line">1.mysql没有插入，事务生效</span><br><span class="line">		Company company&#x3D;new Company();</span><br><span class="line">        company.setName(&quot;1号公司1&quot;);</span><br><span class="line">        companyMapper.insert(company);</span><br><span class="line">        System.out.println(10&#x2F;0);</span><br><span class="line">2.mysql没有插入，事务生效      </span><br><span class="line">		Company company &#x3D; new Company();</span><br><span class="line">        company.setName(&quot;1号公司2&quot;);</span><br><span class="line">        companyMapper.insert(company);</span><br><span class="line">        redisService.test(&quot;test&quot;);</span><br><span class="line">3.mysql没有插入，redis数据更改了</span><br><span class="line">        Company company &#x3D; new Company();</span><br><span class="line">        company.setName(&quot;1号公司2&quot;);</span><br><span class="line">        companyMapper.insert(company);</span><br><span class="line">        redisService.set(&quot;test&quot;,&quot;aaa&quot;);</span><br><span class="line">        System.out.println(10&#x2F;0);</span><br><span class="line">4.redis数据更改，mysql没有插入(name设置为不能插入重复字段)</span><br><span class="line">        redisService.set(&quot;test&quot;,&quot;ccc&quot;);</span><br><span class="line">        Company company &#x3D; new Company();</span><br><span class="line">        company.setName(&quot;1号公司1&quot;);</span><br><span class="line">        companyMapper.insert(company);</span><br><span class="line">结论：事务只对mysql生效，redis数据自己成功就是成功，失败就是失败</span><br></pre></td></tr></table></figure>

<p>redis的事务其实不是事务，因为redis操作都是原子性的。如果命令可以执行成功则一定被执行且无法回滚。而spring的事务只要抛出异常，就会将方法内所有内容（除mysql之外的东西是否回滚待测试）回滚，reids不会回滚。</p>
<p>55.实体类的BigDecimal类型字段，在序列化后或者转换为json后，小数点后的0会被自动去掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DecimalFormat df &#x3D; new DecimalFormat(&quot;#0.00&quot;);--指定保留两位小数</span><br><span class="line">p.setPrice(p.getPrice&#x3D;&#x3D;null?null:df.format(new BigDecimal(p.getPrice)));</span><br><span class="line"></span><br><span class="line">或者在该对象的字段上</span><br><span class="line">@JsonFormat(shape &#x3D; JsonFormat.Shape.STRING)</span><br><span class="line">private BigDecimal amt;</span><br></pre></td></tr></table></figure>

<p>上述方法会将BigDecimal类型转为String类型，其实没有达到解决的目的。</p>
<p>56.前端金额显示为xx.00元：</p>
<p>如果字段为String类型：<code>return (parseInt(price*100)/100).toFixed(2);</code></p>
<p>如果字段为Number类型：<code>(price * 100 / 100).toFixed(2)</code></p>
<p>57.redis的<code>redisTemplate.boundValueOps(key).set(value);</code>方法中，key为<code>test:::</code>则是在redis分了test一层，<code> </code>二，三，四层，一共四层</p>
<p>58.方法A调用异步方法B，如果方法A回滚了，方法B仍会执行，所以最好的办法就是在方法A执行结束确保没问题了，再去通知异步执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/26/10.4.%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/" data-id="ckw61sdw10042oswd0oovg42a" data-title="项目踩坑" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.1.初识java：特性、版本、安装" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/4.1.%E5%88%9D%E8%AF%86java%EF%BC%9A%E7%89%B9%E6%80%A7%E3%80%81%E7%89%88%E6%9C%AC%E3%80%81%E5%AE%89%E8%A3%85/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T03:42:16.000Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/26/4.1.%E5%88%9D%E8%AF%86java%EF%BC%9A%E7%89%B9%E6%80%A7%E3%80%81%E7%89%88%E6%9C%AC%E3%80%81%E5%AE%89%E8%A3%85/">初识java</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="java概述"><a href="#java概述" class="headerlink" title="java概述"></a>java概述</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="1-简单"><a href="#1-简单" class="headerlink" title="1.简单"></a>1.简单</h3><p>语法规则和c++类似，是对C++的简化和提高，使用接口取代了多重继承，并取消了指针，java还有垃圾自动收集。</p>
<p>提供了丰富的类库，API文档和第三方开发包，还有大量基于java 的开源项目。</p>
<h3 id="2-面向对象（Object-Oriented）"><a href="#2-面向对象（Object-Oriented）" class="headerlink" title="2.面向对象（Object Oriented）"></a>2.面向对象（Object Oriented）</h3><p>是对现实世界的一种抽象，面向对象会把相关的数据和方法组织为一个整体来看待。所有的元素都要通过类和对象来访问。</p>
<h3 id="3-分布性"><a href="#3-分布性" class="headerlink" title="3.分布性"></a>3.分布性</h3><p>Java语言支持Internet应用的开发，java中有net.api，他提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p>
<p>包括操作分布和数据分布。操作分布是指在多个不同的主机上布置相关操作，而数据分布是将数据分别存放在多个不同的主机上。</p>
<h3 id="4-平台独立性和可移植性（write-once-run-anywhere）"><a href="#4-平台独立性和可移植性（write-once-run-anywhere）" class="headerlink" title="4.平台独立性和可移植性（write once ,run anywhere）"></a>4.平台独立性和<em><strong>可移植性</strong></em>（write once ,run anywhere）</h3><p>核心是jvm。</p>
<p>在应用中编写java代码，用Eclipse或javac把java代码编译为.class文件，然后把.class文件打成.jar文件，.jar文件可以在windows、MacOS、Linux系统下运行。</p>
<h3 id="5-解释性"><a href="#5-解释性" class="headerlink" title="5.解释性"></a>5.解释性</h3><p>运行java程序需要解释器，任何移植了java解释器的计算机或其他设备都可以用java字节码进行解释运行。</p>
<h3 id="6-安全性"><a href="#6-安全性" class="headerlink" title="6. 安全性"></a>6. 安全性</h3><p>删除了类C语言中的指针和内存释放等语法，有效避免了用户对内存的非法操作。Java程序代码要经过代码校验，指针校验等很多测试步骤才能运行。</p>
<h3 id="7-健壮性"><a href="#7-健壮性" class="headerlink" title="7. 健壮性"></a>7. 健壮性</h3><p>Java的强类型机制，异常处理，垃圾的自动收集等。开发工具如：Eclipse、NetBeans。</p>
<h3 id="8-多线程"><a href="#8-多线程" class="headerlink" title="8.多线程"></a>8.多线程</h3><p>Java在用户空间实现的多线程（实现多线程的方式有：在用户空间、在内核空间、在用户和内核空间中混合实现）应用程序在同一时间并行执行多项任务，而且相应的同步机制可以保证不同的线程可以正确的共享数据。</p>
<h3 id="9-高性能"><a href="#9-高性能" class="headerlink" title="9.高性能"></a>9.高性能</h3><p>Hotspot JVM提供了JIT（just in time）编译器即动态编译器，能够在运行时将代码编译为机器码，运行效率比较高。</p>
<h3 id="10-动态"><a href="#10-动态" class="headerlink" title="10.动态"></a>10.动态</h3><p>可以动态调整库内方法和增加变量，而客户端不需要作任何更改。</p>
<h3 id="11-开源"><a href="#11-开源" class="headerlink" title="11.开源"></a>11.<em>开源</em></h3><p> java的这个特性决定了它的广泛应用。</p>
<h2 id="运行和工作原理"><a href="#运行和工作原理" class="headerlink" title="运行和工作原理"></a>运行和工作原理</h2><p>Java源代码（HelloWorld.java）  <a href="%E7%BB%8Fjavac%E7%BC%96%E8%AF%91">–&gt;</a>   java字节码文件（HelloWorld.class）<a href="%E7%BB%8Fjava%E6%89%A7%E8%A1%8C">–&gt;</a>  机器码  –&gt;  运行结果</p>
<p>1.首先编写java源代码程序，扩展名为.java</p>
<p>2.在命令行模式中，输入javac命令:<code>javac 源文件名.java</code>对源代码进行编译，生成字节码文件,扩展名为.class</p>
<p>3.编译完成后，如果没有报错信息，输入java命令:<code>java 类名</code>对class字节码文件进行解释运行，执行时不需要添加.class扩展名</p>
<p>这里是我最早接触java时，还没有用到开发工具，在cmd命令行进行的HelloWorld输出。当时踩得坑如下：</p>
<ul>
<li><p>文件隐藏了扩展名</p>
</li>
<li><p>javac+文件名，java+类名 （所以当时需要文件名和类名一致）</p>
</li>
<li><p>严格区分大小写</p>
</li>
<li><p>非法字符：/65307确是中文问题，要保证全部英文状态</p>
</li>
<li><p>括号成对</p>
</li>
<li><p>最后贴一个梦开始的main方法：</p>
<p>public static void main(String[] args){</p>
<p>​    System.out.println(“HelloWorld”);</p>
<p>}</p>
</li>
</ul>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><table><thead><tr><th>版本</th><th>名称</th><th>发行日期</th></tr></thead><tbody><tr><td>JDK 1.0</td><td>Oak(橡树)</td><td>1996-01-23</td></tr><tr><td>JDK 1.1</td><td>none（无）</td><td>1997-02-19</td></tr><tr><td>JDK 1.1.4</td><td>Sparkler（宝石）</td><td>1997-09-12</td></tr><tr><td>JDK 1.1.5</td><td>Pumpkin（南瓜）</td><td>1997-12-13</td></tr><tr><td>JDK 1.1.6</td><td>Abigail（阿比盖尔–女子名）</td><td>1998-04-24</td></tr><tr><td>JDK 1.1.7</td><td>Brutus（布鲁图–古罗马政治家和将军）</td><td>1998-09-28</td></tr><tr><td>JDK 1.1.8</td><td>Chelsea（切尔西–城市名）</td><td>1999-04-08</td></tr><tr><td>J2SE 1.2</td><td>Playground（运动场）</td><td>1998-12-04</td></tr><tr><td>J2SE 1.2.1</td><td>none（无）</td><td>1999-03-30</td></tr><tr><td>J2SE 1.2.2</td><td>Cricket（蟋蟀）</td><td>1999-07-08</td></tr><tr><td>J2SE 1.3</td><td>Kestrel（美洲红隼）</td><td>2000-05-08</td></tr><tr><td>J2SE 1.3.1</td><td>Ladybird（瓢虫）</td><td>2001-05-17</td></tr><tr><td>J2SE 1.4.0</td><td>Merlin（灰背隼）</td><td>2002-02-13</td></tr><tr><td>J2SE 1.4.1</td><td>grasshopper（蚱蜢）</td><td>2002-09-16</td></tr><tr><td>J2SE 1.4.2</td><td>Mantis（螳螂）</td><td>2003-06-26</td></tr><tr><td>Java SE 5.0 (1.5.0)</td><td>Tiger（老虎）</td><td>2004-09-30</td></tr><tr><td>Java SE 6.0 (1.6.0)</td><td>Mustang（野马）</td><td>2006-04</td></tr><tr><td>Java SE 7.0 (1.7.0)</td><td>Dolphin（海豚）</td><td>2011-07-28</td></tr><tr><td>Java SE 8.0 (1.8.0)</td><td>Spider（蜘蛛）</td><td>2014-03-18</td></tr><tr><td>Java SE 9.0</td><td>none（无）</td><td>2017-09-21</td></tr><tr><td>Java SE 10.0</td><td>none（无）</td><td>2018-03-21</td></tr><tr><td>Java SE 11.0</td><td>none（无）</td><td>2018-09-25</td></tr></tbody></table>

<p>这里的JAVA就是指JDK开发工具</p>
<h3 id="Java2"><a href="#Java2" class="headerlink" title="Java2"></a>Java2</h3><p>1998年12月8日，Sun公司发布了第二代Java平台（简称为Java2）的3个版本</p>
<p>J2ME（Java2 Micro Edition，Java2平台的微型版）：主要用于嵌入式系统的开发，应用于移动、无线及有限资源的环境</p>
<p>J2SE（Java 2 Standard Edition，Java 2平台的标准版）：应用于桌面应用软件的编程</p>
<p>J2EE（Java 2 Enterprise Edition，Java 2平台的企业版）：应用于基于Java的应用服务器</p>
<h3 id="Java5"><a href="#Java5" class="headerlink" title="Java5"></a>Java5</h3><p>2004年9月30日</p>
<h4 id="1-自动拆装箱"><a href="#1-自动拆装箱" class="headerlink" title="1.自动拆装箱"></a>1.自动拆装箱</h4><h4 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2.泛型"></a>2.泛型</h4><h4 id="3-增强for"><a href="#3-增强for" class="headerlink" title="3.增强for"></a>3.增强for</h4><p>说明：是for循环的一种，简化数组和Collection集合的遍历（增强for就是来替代迭代器的）</p>
<p>格式：</p>
<p>for(元素数据类型 变量 : 数组或者Collection集合) {</p>
<p>​        使用变量即可，该变量就是元素</p>
<p>​    }</p>
<p>注意事项：增强for的目标要先进行不为null的判断，然后再使用</p>
<h4 id="4-静态导入"><a href="#4-静态导入" class="headerlink" title="4.静态导入"></a>4.静态导入</h4><p>说明：可以直接导入到方法级别</p>
<p>格式：import static 包名….类名.方法名;</p>
<p>注意事项：</p>
<p>​    方法必须是静态的</p>
<p>​    如果有多个同名的静态方法，容易不知道使用谁?这个时候要使用的话，就必须在调用前面加静态的包，类名前缀。由此可见，意义不大，所以一般不用。</p>
<h4 id="5-可变参数"><a href="#5-可变参数" class="headerlink" title="5.可变参数"></a>5.可变参数</h4><p>说明：定义方法的时候不知道该定义多少个参数，当调用的时候才知道需要几个参数。</p>
<p>格式：</p>
<p>public static int sunm(int… a){}</p>
<p>​    修饰符 返回值类型 方法名(数据类型…  变量名){</p>
<p>}</p>
<p>注意事项：</p>
<p>1.这里的变量(a)其实是一个数组</p>
<p>2.如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个（如果不是最后一个，相当于前面的都包含了，最后单独的多出来了，所以就会报错。只有当可变参数是最后一个才是正常的）</p>
<p>3.如果要调用的方法可以和两个可变参数匹配，则出现错误</p>
<p>4.在调用方法的时候，如果能够和固定参数的方法匹配，也能够与可变长参数的方法匹配，<strong>则选择固定参数的方法</strong></p>
<p>Arrays工具类中的一个方法：把数组转成集合</p>
<p><code>public  static  &lt;T&gt;  List&lt;T&gt;  asList(T... a)</code></p>
<p>注意事项：集合的长度不能改变，因为其本质还是一个数组。（所以对集合进行操作时，只要改变了其长度就会报错）</p>
<h4 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6.枚举"></a>6.枚举</h4><h3 id="Java7"><a href="#Java7" class="headerlink" title="Java7"></a>Java7</h3><h4 id="1-二进制字面量"><a href="#1-二进制字面量" class="headerlink" title="1.二进制字面量"></a>1.二进制字面量</h4><p>JDK7开始，可以用二进制来表示整数（byte,short,int和long）。</p>
<p>好处：可以使代码更容易被理解。语法非常简单，只要在二进制数值前面加 0b或者0B</p>
<h4 id="2-数字字面量可以出现下划线"><a href="#2-数字字面量可以出现下划线" class="headerlink" title="2.数字字面量可以出现下划线"></a>2.数字字面量可以出现下划线</h4><p>为了增强对数值的阅读性，如我们经常把数据用逗号分隔一样。JDK7提供了_对数据进行分隔。</p>
<p>注意事项：</p>
<p>​    不能出现在进制标识和数值之间</p>
<p>​    不能出现在数值开头和结尾</p>
<p>​    不能出现在小数点旁边</p>
<h4 id="3-switch-语句可以用字符串"><a href="#3-switch-语句可以用字符串" class="headerlink" title="3.switch 语句可以用字符串"></a>3.switch 语句可以用字符串</h4><h4 id="4-泛型简化（泛型推断）"><a href="#4-泛型简化（泛型推断）" class="headerlink" title="4.泛型简化（泛型推断）"></a>4.泛型简化（泛型推断）</h4><h4 id="5-异常的多个catch合并"><a href="#5-异常的多个catch合并" class="headerlink" title="5.异常的多个catch合并"></a>5.异常的多个catch合并</h4><p>出现了一个新的异常处理方案：</p>
<p>try {</p>
<p>} catch (异常名1  |  异常名2  |  异常名3   …   变量 ) {</p>
<p>​    }</p>
<p>这个方式虽然简洁，但是也不够好：</p>
<p>A：处理方式是一致的。（实际开发中，好多时候可能就是针对同类型的问题，给出同一个处理）</p>
<p>B：多个异常间必须是平级关系</p>
<h4 id="6-try-with-resources-语句"><a href="#6-try-with-resources-语句" class="headerlink" title="6.try-with-resources 语句"></a>6.try-with-resources 语句</h4><p>try ( 必须是java.lang.AutoCloseable的子类对象 ) { … }</p>
<p>好处：</p>
<p>​    资源自动释放，不需要close()了</p>
<p>​    把需要关闭资源的部分都定义在（）中就ok了</p>
<p>这个接口的子类主要是流体系的对象(JDK7的API中AutoCloseable的子类)</p>
<h3 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h3><p>2014年3月18日，普遍使用的版本，是java5以来最具革命性的版本。支持32位</p>
<h4 id="1-允许接口中有默认方法，静态方法实现"><a href="#1-允许接口中有默认方法，静态方法实现" class="headerlink" title="1.允许接口中有默认方法，静态方法实现"></a>1.允许接口中有默认方法，静态方法实现</h4><h4 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2.Lambda表达式"></a>2.Lambda表达式</h4><p><strong>一、引言</strong></p>
<p>java8最大的特性就是引入Lambda表达式，即函数式编程，可以将行为进行传递。总结就是：使用不可变值与函数，函数对不可变值进行处理，映射成另一个值。</p>
<p><strong>二、Java重要的函数式接口</strong></p>
<p><strong>1、什么是函数式接口</strong></p>
<p>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</p>
<p><strong>1.1 java8自带的常用函数式接口。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuflAIHxeAlDrM7xK8JrNAicwEo07y8LxWXMdBEbwsXQIyX0DLuHmbP1RKpKyzU9iavbiaHrwrJdMu5tg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Predicate&lt;Integer&gt; predicate &#x3D; x -&gt; x &gt; 185;</span><br><span class="line">        Student student &#x3D; new Student(&quot;9龙&quot;, 23, 175);</span><br><span class="line">        System.out.println(</span><br><span class="line">            &quot;9龙的身高高于185吗？：&quot; + predicate.test(student.getStature()));</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer &#x3D; System.out::println;</span><br><span class="line">        consumer.accept(&quot;命运由我不由天&quot;);</span><br><span class="line"></span><br><span class="line">        Function&lt;Student, String&gt; function &#x3D; Student::getName;</span><br><span class="line">        String name &#x3D; function.apply(student);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; supplier &#x3D; </span><br><span class="line">            () -&gt; Integer.valueOf(BigDecimal.TEN.toString());</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line"></span><br><span class="line">        UnaryOperator&lt;Boolean&gt; unaryOperator &#x3D; uglily -&gt; !uglily;</span><br><span class="line">        Boolean apply2 &#x3D; unaryOperator.apply(true);</span><br><span class="line">        System.out.println(apply2);</span><br><span class="line"></span><br><span class="line">        BinaryOperator&lt;Integer&gt; operator &#x3D; (x, y) -&gt; x * y;</span><br><span class="line">        Integer integer &#x3D; operator.apply(2, 3);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line"></span><br><span class="line">        test(() -&gt; &quot;我是一个演示的函数式接口&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 演示自定义函数式接口使用</span><br><span class="line">     *</span><br><span class="line">     * @param worker</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void test(Worker worker) &#123;</span><br><span class="line">        String work &#x3D; worker.work();</span><br><span class="line">        System.out.println(work);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface Worker &#123;</span><br><span class="line">        String work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;9龙的身高高于185吗？：false</span><br><span class="line">&#x2F;&#x2F;命运由我不由天</span><br><span class="line">&#x2F;&#x2F;9龙</span><br><span class="line">&#x2F;&#x2F;10</span><br><span class="line">&#x2F;&#x2F;false</span><br><span class="line">&#x2F;&#x2F;6</span><br><span class="line">&#x2F;&#x2F;我是一个演示的函数式接口</span><br></pre></td></tr></table></figure>

<p>以上演示了lambda接口的使用及自定义一个函数式接口并使用。<strong>下面，我们看看java8将函数式接口封装到流中如何高效的帮助我们处理集合。</strong></p>
<p>注意：Student::getName例子中这种编写lambda表达式的方式称为方法引用。格式为ClassNmae::methodName。是不是很神奇，java8就是这么迷人。</p>
<blockquote>
<p>示例：本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。</p>
</blockquote>
<p><img src="/4.1.%E5%88%9D%E8%AF%86java%EF%BC%9A%E7%89%B9%E6%80%A7%E3%80%81%E7%89%88%E6%9C%AC%E3%80%81%E5%AE%89%E8%A3%85/640" alt="图片"></p>
<p><strong>1.2 惰性求值与及早求值</strong></p>
<p>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。</p>
<p>及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。</p>
<p><strong>2、常用的流</strong></p>
<p><strong>2.1 collect(Collectors.toList())</strong></p>
<p>将流转换为list。还有toSet()，toMap()等。及早求值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TestCase &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Student&gt; studentList &#x3D; Stream.of(new Student(&quot;路飞&quot;, 22, 175),</span><br><span class="line">                new Student(&quot;红发&quot;, 40, 180),</span><br><span class="line">                new Student(&quot;白胡子&quot;, 50, 185)).collect(Collectors.toList());</span><br><span class="line">        System.out.println(studentList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;[Student&#123;name&#x3D;&#39;路飞&#39;, age&#x3D;22, stature&#x3D;175, specialities&#x3D;null&#125;, </span><br><span class="line">&#x2F;&#x2F;Student&#123;name&#x3D;&#39;红发&#39;, age&#x3D;40, stature&#x3D;180, specialities&#x3D;null&#125;, </span><br><span class="line">&#x2F;&#x2F;Student&#123;name&#x3D;&#39;白胡子&#39;, age&#x3D;50, stature&#x3D;185, specialities&#x3D;null&#125;]</span><br></pre></td></tr></table></figure>

<p><strong>2.2 filter</strong></p>
<p>顾名思义，起过滤筛选的作用。内部就是Predicate接口。惰性求值。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbuflAIHxeAlDrM7xK8JrNAicwsOWrISBwKtdpkszkznM1Z3OMMupFgvZ8vIw4tWumhm779kibicuiccb1A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>比如我们筛选出出身高小于180的同学。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class TestCase &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Student&gt; students &#x3D; new ArrayList&lt;&gt;(3);</span><br><span class="line">        students.add(new Student(&quot;路飞&quot;, 22, 175));</span><br><span class="line">        students.add(new Student(&quot;红发&quot;, 40, 180));</span><br><span class="line">        students.add(new Student(&quot;白胡子&quot;, 50, 185));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list &#x3D; students.stream()</span><br><span class="line">            .filter(stu -&gt; stu.getStature() &lt; 180)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;[Student&#123;name&#x3D;&#39;路飞&#39;, age&#x3D;22, stature&#x3D;175, specialities&#x3D;null&#125;]</span><br></pre></td></tr></table></figure>

<p><strong>2.3 map</strong> </p>
<p>转换功能，内部就是Function接口。惰性求值</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbuflAIHxeAlDrM7xK8JrNAicwUcEAL9TC7agTHutUPjfvuBgptdprp6f9hWJibdzSMeKkicBDo4S8qTxw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestCase &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Student&gt; students &#x3D; new ArrayList&lt;&gt;(3);</span><br><span class="line">        students.add(new Student(&quot;路飞&quot;, 22, 175));</span><br><span class="line">        students.add(new Student(&quot;红发&quot;, 40, 180));</span><br><span class="line">        students.add(new Student(&quot;白胡子&quot;, 50, 185));</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; names &#x3D; students.stream().map(student -&gt; student.getName())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(names);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;[路飞, 红发, 白胡子]</span><br></pre></td></tr></table></figure>

<p>例子中将student对象转换为String对象，获取student的名字。</p>
<p><strong>2.4 flatMap</strong></p>
<p>将多个Stream合并为一个Stream。惰性求值</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbuflAIHxeAlDrM7xK8JrNAicwgrbFtttUaiadNQce8ficHgoxxIicia9p0xXL7Ce8ibFsk0u0hRYLfvgWPxw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestCase &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Student&gt; students &#x3D; new ArrayList&lt;&gt;(3);</span><br><span class="line">        students.add(new Student(&quot;路飞&quot;, 22, 175));</span><br><span class="line">        students.add(new Student(&quot;红发&quot;, 40, 180));</span><br><span class="line">        students.add(new Student(&quot;白胡子&quot;, 50, 185));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; studentList &#x3D; Stream.of(students,</span><br><span class="line">                asList(new Student(&quot;艾斯&quot;, 25, 183),</span><br><span class="line">                        new Student(&quot;雷利&quot;, 48, 176)))</span><br><span class="line">                .flatMap(students1 -&gt; students1.stream()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(studentList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;[Student&#123;name&#x3D;&#39;路飞&#39;, age&#x3D;22, stature&#x3D;175, specialities&#x3D;null&#125;, </span><br><span class="line">&#x2F;&#x2F;Student&#123;name&#x3D;&#39;红发&#39;, age&#x3D;40, stature&#x3D;180, specialities&#x3D;null&#125;, </span><br><span class="line">&#x2F;&#x2F;Student&#123;name&#x3D;&#39;白胡子&#39;, age&#x3D;50, stature&#x3D;185, specialities&#x3D;null&#125;, </span><br><span class="line">&#x2F;&#x2F;Student&#123;name&#x3D;&#39;艾斯&#39;, age&#x3D;25, stature&#x3D;183, specialities&#x3D;null&#125;,</span><br><span class="line">&#x2F;&#x2F;Student&#123;name&#x3D;&#39;雷利&#39;, age&#x3D;48, stature&#x3D;176, specialities&#x3D;null&#125;]</span><br></pre></td></tr></table></figure>

<p>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。</p>
<p><strong>2.5 max和min</strong></p>
<p>我们经常会在集合中求最大或最小值，使用流就很方便。及早求值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TestCase &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Student&gt; students &#x3D; new ArrayList&lt;&gt;(3);</span><br><span class="line">        students.add(new Student(&quot;路飞&quot;, 22, 175));</span><br><span class="line">        students.add(new Student(&quot;红发&quot;, 40, 180));</span><br><span class="line">        students.add(new Student(&quot;白胡子&quot;, 50, 185));</span><br><span class="line"></span><br><span class="line">        Optional&lt;Student&gt; max &#x3D; students.stream()</span><br><span class="line">            .max(Comparator.comparing(stu -&gt; stu.getAge()));</span><br><span class="line">        Optional&lt;Student&gt; min &#x3D; students.stream()</span><br><span class="line">            .min(Comparator.comparing(stu -&gt; stu.getAge()));</span><br><span class="line">        &#x2F;&#x2F;判断是否有值</span><br><span class="line">        if (max.isPresent()) &#123;</span><br><span class="line">            System.out.println(max.get());</span><br><span class="line">        &#125;</span><br><span class="line">        if (min.isPresent()) &#123;</span><br><span class="line">            System.out.println(min.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;Student&#123;name&#x3D;&#39;白胡子&#39;, age&#x3D;50, stature&#x3D;185, specialities&#x3D;null&#125;</span><br><span class="line">&#x2F;&#x2F;Student&#123;name&#x3D;&#39;路飞&#39;, age&#x3D;22, stature&#x3D;175, specialities&#x3D;null&#125;</span><br></pre></td></tr></table></figure>

<p>max、min接收一个Comparator（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象，该对象是java8新增的类，专门为了防止null引发的空指针异常。</p>
<p>可以使用max.isPresent()判断是否有值；可以使用max.orElse(new Student())，当值为null时就使用给定值；也可以使用max.orElseGet(() -&gt; new Student());这需要传入一个Supplier的lambda表达式。</p>
<p><strong>2.6 count</strong></p>
<p>统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestCase &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Student&gt; students &#x3D; new ArrayList&lt;&gt;(3);</span><br><span class="line">        students.add(new Student(&quot;路飞&quot;, 22, 175));</span><br><span class="line">        students.add(new Student(&quot;红发&quot;, 40, 180));</span><br><span class="line">        students.add(new Student(&quot;白胡子&quot;, 50, 185));</span><br><span class="line"></span><br><span class="line">        long count &#x3D; students.stream().filter(s1 -&gt; s1.getAge() &lt; 45).count();</span><br><span class="line">        System.out.println(&quot;年龄小于45岁的人数是：&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;年龄小于45岁的人数是：2</span><br></pre></td></tr></table></figure>

<p><strong>2.7 reduce</strong> </p>
<p>reduce 操作可以实现从一组值中生成一个值。在上述例子中用到的 count 、 min 和 max 方法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。及早求值。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbuflAIHxeAlDrM7xK8JrNAicwvtsrmndy1PguAw1xq8I3tAtf0hwRlt7QSA7icV0icdRmNge6Y0A5UmWA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestCase &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer reduce &#x3D; Stream.of(1, 2, 3, 4).reduce(0, (acc, x) -&gt; acc+ x);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;10</span><br></pre></td></tr></table></figure>

<p>我们看得reduce接收了一个初始值为0的累加器，依次取出值与累加器相加，最后累加器的值就是最终的结果。</p>
<p><strong>三、高级集合类及收集器</strong></p>
<p><strong>3.1 转换成值</strong></p>
<p>收集器，一种通用的、从流生成复杂值的结构。只要将它传给 collect 方法，所有的流就都可以使用它了。标准类库已经提供了一些有用的收集器，以下示例代码中的收集器都是从 java.util.stream.Collectors 类中静态导入的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class CollectorsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Student&gt; students1 &#x3D; new ArrayList&lt;&gt;(3);</span><br><span class="line">        students1.add(new Student(&quot;路飞&quot;, 23, 175));</span><br><span class="line">        students1.add(new Student(&quot;红发&quot;, 40, 180));</span><br><span class="line">        students1.add(new Student(&quot;白胡子&quot;, 50, 185));</span><br><span class="line"></span><br><span class="line">        OutstandingClass ostClass1 &#x3D; new OutstandingClass(&quot;一班&quot;, students1);</span><br><span class="line">        &#x2F;&#x2F;复制students1，并移除一个学生</span><br><span class="line">        List&lt;Student&gt; students2 &#x3D; new ArrayList&lt;&gt;(students1);</span><br><span class="line">        students2.remove(1);</span><br><span class="line">        OutstandingClass ostClass2 &#x3D; new OutstandingClass(&quot;二班&quot;, students2);</span><br><span class="line">        &#x2F;&#x2F;将ostClass1、ostClass2转换为Stream</span><br><span class="line">        Stream&lt;OutstandingClass&gt; classStream &#x3D; Stream.of(ostClass1, ostClass2);</span><br><span class="line">        OutstandingClass outstandingClass &#x3D; biggestGroup(classStream);</span><br><span class="line">        System.out.println(&quot;人数最多的班级是：&quot; + outstandingClass.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;一班平均年龄是：&quot; + averageNumberOfStudent(students1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取人数最多的班级</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static OutstandingClass biggestGroup(Stream&lt;OutstandingClass&gt; outstandingClasses) &#123;</span><br><span class="line">        return outstandingClasses.collect(</span><br><span class="line">                maxBy(comparing(ostClass -&gt; ostClass.getStudents().size())))</span><br><span class="line">                .orElseGet(OutstandingClass::new);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计算平均年龄</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static double averageNumberOfStudent(List&lt;Student&gt; students) &#123;</span><br><span class="line">        return students.stream().collect(averagingInt(Student::getAge));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;人数最多的班级是：一班</span><br><span class="line">&#x2F;&#x2F;一班平均年龄是：37.666666666666664</span><br></pre></td></tr></table></figure>

<p>maxBy或者minBy就是求最大值与最小值。</p>
<p><strong>3.2 转换成块</strong></p>
<p>常用的流操作是将其分解成两个集合，Collectors.partitioningBy帮我们实现了，接收一个Predicate函数式接口。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbuflAIHxeAlDrM7xK8JrNAicwibrTgiamib8rjT5icBDRkibCTVfgA4koz8AiaC9SXcyVKvQFWHJfia7dj3HDQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>将示例学生分为会唱歌与不会唱歌的两个集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class PartitioningByTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;省略List&lt;student&gt; students的初始化</span><br><span class="line">        Map&lt;Boolean, List&lt;Student&gt;&gt; listMap &#x3D; students.stream().collect(</span><br><span class="line">            Collectors.partitioningBy(student -&gt; student.getSpecialities().</span><br><span class="line">                                      contains(SpecialityEnum.SING)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.3 数据分组</strong></p>
<p>数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，可以使用任意值对数据分组。Collectors.groupingBy接收一个Function做转换。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbuflAIHxeAlDrM7xK8JrNAicwRcIpico9nUmTm0G7DVmdXXbF96icwFWbQRZhopibe905VnfyzCR7IWX2w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如图，我们使用groupingBy将根据进行分组为圆形一组，三角形一组，正方形一组。</p>
<p>例子：根据学生第一个特长进行分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class GroupingByTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;省略List&lt;student&gt; students的初始化</span><br><span class="line">         Map&lt;SpecialityEnum, List&lt;Student&gt;&gt; listMap &#x3D; </span><br><span class="line">             students.stream().collect(</span><br><span class="line">             Collectors.groupingBy(student -&gt; student.getSpecialities().get(0)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collectors.groupingBy与SQL 中的 group by 操作是一样的。</p>
<p><strong>3.4 字符串拼接</strong></p>
<p>如果将所有学生的名字拼接起来，怎么做呢？通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class JoiningTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Student&gt; students &#x3D; new ArrayList&lt;&gt;(3);</span><br><span class="line">        students.add(new Student(&quot;路飞&quot;, 22, 175));</span><br><span class="line">        students.add(new Student(&quot;红发&quot;, 40, 180));</span><br><span class="line">        students.add(new Student(&quot;白胡子&quot;, 50, 185));</span><br><span class="line"></span><br><span class="line">         String names &#x3D; students.stream()</span><br><span class="line">             .map(Student::getName).collect(Collectors.joining(&quot;,&quot;,&quot;[&quot;,&quot;]&quot;));</span><br><span class="line">        System.out.println(names);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">&#x2F;&#x2F;[路飞,红发,白胡子]</span><br></pre></td></tr></table></figure>

<p>joining接收三个参数，第一个是分界符，第二个是前缀符，第三个是结束符。也可以不传入参数Collectors.joining()，这样就是直接拼接。</p>
<h4 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3.函数式接口"></a>3.函数式接口</h4><h4 id="4-内置函数式接口"><a href="#4-内置函数式接口" class="headerlink" title="4.内置函数式接口"></a>4.内置函数式接口</h4><h4 id="5-Streams"><a href="#5-Streams" class="headerlink" title="5.Streams"></a>5.Streams</h4><p>得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端</p>
<p>传统集合在于使用循环遍历。for循环的语法就是“怎么做”，for循环的循环体才是“做什么”。</p>
<p>Java 8的Lambda让我们可以更加专注于做什么(What)，而不是怎么做(How)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author tanglei</span><br><span class="line"> * @date 2020&#x2F;6&#x2F;10 10:28 下午</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StreamFilter &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  list.add(&quot;张无忌&quot;);</span><br><span class="line">  list.add(&quot;周芷若&quot;);</span><br><span class="line">  list.add(&quot;赵敏&quot;);</span><br><span class="line">  list.add(&quot;张强&quot;);</span><br><span class="line">  list.add(&quot;张三丰&quot;);</span><br><span class="line"> </span><br><span class="line">  list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(&quot;张&quot;))</span><br><span class="line">    .filter(s -&gt; s.length() &#x3D;&#x3D; 3)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何 元素(或其地址值</p>
<p>获取流：</p>
<p>所有的 Collection 集合都可以通过 stream 默认方法获取流;</p>
<p>Stream 接口的静态方法 of 可以获取数组对应的流</p>
<p>根据Collection获取流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; stream1 &#x3D; list.stream();</span><br><span class="line">    Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; stream2 &#x3D; set.stream();</span><br><span class="line">    Vector&lt;String&gt; vector &#x3D; new Vector&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据Map获取流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; keyStream &#x3D; map.keySet().stream();</span><br><span class="line">    Stream&lt;String&gt; valueStream &#x3D; map.values().stream();   </span><br><span class="line">    Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream &#x3D; map.entrySet().stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据数组获取流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String[] array &#x3D; &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;;</span><br><span class="line">    Stream&lt;String&gt; stream &#x3D; Stream.of(array); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<p>逐一处理:forEach     会将每一个流元素交给该函数进行处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">    stream.forEach(name‐&gt; System.out.println(name)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤:filter     可以通过 filter 方法将一个流转换成另一个子集流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">    Stream&lt;String&gt; result &#x3D; original.filter(s ‐&gt;   s.startsWith(&quot;张&quot;)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射:map    如果需要将流中的元素映射到另一个流中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stream&lt;String&gt; original &#x3D; Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;);</span><br><span class="line">    Stream&lt;Integer&gt; result &#x3D; original.map(str‐&gt;Integer.parseInt(str)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>统计个数:count    数一数其中的元素个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line"> Stream&lt;String&gt; result &#x3D; original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));</span><br><span class="line"> System.out.println(result.count()); &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取用前几个:limit    可以对流进行截取，只取用前n个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line"> Stream&lt;String&gt; result &#x3D; original.limit(2);   </span><br><span class="line"> System.out.println(result.count()); &#x2F;&#x2F; 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳过前几个:skip   如果希望跳过前几个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stream&lt;String&gt; original &#x3D; Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); </span><br><span class="line"> Stream&lt;String&gt; result &#x3D; original.skip(2); </span><br><span class="line"> System.out.println(result.count()); &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合:concat    如果有两个流，希望合并成为一个流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stream&lt;String&gt; streamA &#x3D; Stream.of(&quot;张无忌&quot;);    </span><br><span class="line"> Stream&lt;String&gt; streamB &#x3D; Stream.of(&quot;张翠山&quot;); </span><br><span class="line"> Stream&lt;String&gt; result &#x3D; Stream.concat(streamA, streamB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个List泛型根据另一个List泛型的属性进行过滤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list1 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">User u1 &#x3D; new User();</span><br><span class="line">u1.setName(&quot;u1&quot;);</span><br><span class="line">u1.setAge(12)</span><br><span class="line"> </span><br><span class="line">User u2 &#x3D; new User();</span><br><span class="line">u2.setName(&quot;u2&quot;);</span><br><span class="line">u2.setAge(13)</span><br><span class="line"> </span><br><span class="line">User u3 &#x3D; new User();</span><br><span class="line">u3.setName(&quot;u3&quot;);</span><br><span class="line">u3.setAge(13)</span><br><span class="line"> </span><br><span class="line">list1.add(u1);</span><br><span class="line">list1.add(u2);</span><br><span class="line">list1.add(u3);</span><br><span class="line"> </span><br><span class="line">List&lt;User&gt; list2 &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">User u4 &#x3D; new User();</span><br><span class="line">u4.setName(&quot;u4&quot;);</span><br><span class="line">u4.setAge(13)</span><br><span class="line"> </span><br><span class="line">list2.add(u3);</span><br><span class="line">list2.add(u4);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;resList 过滤后的结果</span><br><span class="line"> List&lt;User&gt; resList &#x3D; list1 .stream().filter(new Predicate&lt;User&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(User u) &#123;</span><br><span class="line">                &#x2F;&#x2F;如根据name过滤</span><br><span class="line">                for (User user : list2) &#123;</span><br><span class="line">                    if(u.getName().equals(user.getName()))&#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;resList 输出为 u1 u2  （去掉了重复的u3）</span><br></pre></td></tr></table></figure>





<h4 id="6-Map"><a href="#6-Map" class="headerlink" title="6.Map"></a>6.Map</h4><h4 id="7-时间日期API"><a href="#7-时间日期API" class="headerlink" title="7. 时间日期API"></a>7. 时间日期API</h4><p>Java8以前，我们一直长期使用Date和Calendar来处理时间，而在使用Date处理日期时间问题上会存在一定的隐患，产生线程不安全的问题，最典型的就是在一定负载并发量的情况下使用SimpleDateFormat引发的线程安全性问题。如今Java8提供了LocalDate、LocalTime、LocalDateTime三个日期时间类，在安全性和操作性上对比Date和Calendar非常可观</p>
<ol>
<li>使用Date输出的日期可读性差（在不进行日期格式化的情况下）</li>
</ol>
<p>Tue Sep 10 09:34:04 CST 2019</p>
<ol start="2">
<li>在对Date使用SimpleDateFormat进行日期时间格式化时我们需要明确的知道，SimpleDateFormat是线程不安全的，在高并发高负载的情况下使用，极容易引发线程安全性问题</li>
</ol>
<p>calendar是共享变量，并且这个共享变量没有做线程安全控制。当多个线程同时使用相同的SimpleDateFormat对象【如用static修饰的SimpleDateFormat】调用format方法时，多个线程会同时调用calendar.setTime方法，可能一个线程刚设置好time值另外的一个线程马上把设置的time值给修改了导致返回的格式化时间可能是错误的。SimpleDateFormat除了format是线程不安全以外，parse方法也是线程不安全的。parse方法实际调用alb.establish(calendar).getTime()方法来解析，alb.establish(calendar)方法里主要完成了以下操作（这三步不是原子性操作）：</p>
<p>重置日期对象cal的属性值<br>使用calb中中属性设置cal<br>返回设置好的cal对象</p>
<p>多线程并发如何保证线程安全</p>
<p>避免线程之间共享一个SimpleDateFormat对象，每个线程使用时都创建一次SimpleDateFormat对象（问题：创建和销毁对象时大量内存资源开销）<br>对使用format和parse方法的地方进行加锁（问题：线程阻塞性能差）<br>使用ThreadLocal保证每个线程最多只创建一次SimpleDateFormat对象，属于较好的方法。<br>3. Date对时间处理比较麻烦</p>
<p>比如想获取某年、某月、某星期，以及n天以后的时间，使用Date来处理的话会特别麻烦，你可能会说Date类不是有getYear、getMonth这些方法吗，获取年月日很Easy，但都被JDK弃用了。</p>
<p>LocalDate：年月日</p>
<p>LocalTime：时分秒</p>
<p>LocalDateTime：年月日时分秒</p>
<ol>
<li>LocalDate</li>
</ol>
<p>//获取当前年月日<br>LocalDate localDate = LocalDate.now();<br>//构造指定的年月日<br>LocalDate localDate1 = LocalDate.of(2019, 9, 10);<br>//获取年、月、日、星期几<br>int year = localDate.getYear();<br>int year1 = localDate.get(ChronoField.YEAR);<br>Month month = localDate.getMonth();<br>int month1 = localDate.get(ChronoField.MONTH_OF_YEAR);<br>int day = localDate.getDayOfMonth();<br>int day1 = localDate.get(ChronoField.DAY_OF_MONTH);<br>DayOfWeek dayOfWeek = localDate.getDayOfWeek();<br>int dayOfWeek1 = localDate.get(ChronoField.DAY_OF_WEEK);<br>2. LocalTime</p>
<p>// 获取当前时间<br>LocalTime localTime1 = LocalTime.now();<br>// 获取指定时间<br>LocalTime localTime = LocalTime.of(13, 51, 10);<br>//获取小时<br>int hour = localTime.getHour();<br>int hour1 = localTime.get(ChronoField.HOUR_OF_DAY);<br>//获取分<br>int minute = localTime.getMinute();<br>int minute1 = localTime.get(ChronoField.MINUTE_OF_HOUR);<br>//获取秒<br>int second = localTime.getMinute();<br>int second1 = localTime.get(ChronoField.SECOND_OF_MINUTE);</p>
<ol start="3">
<li>LocalDateTime</li>
</ol>
<p>等同于LocalDate+LocalTime</p>
<p>// 获取当前日期 年月日时分秒<br>LocalDateTime localDateTime = LocalDateTime.now();<br>// 设置指定日期时间 年月日时分秒<br>LocalDateTime localDateTime1 = LocalDateTime.of(2019, Month.SEPTEMBER, 10, 14, 46, 56);<br>LocalDateTime localDateTime2 = LocalDateTime.of(localDate, localTime);<br>LocalDateTime localDateTime3 = localDate.atTime(localTime);<br>LocalDateTime localDateTime4 = localTime.atDate(localDate);<br>LocalDate localDate2 = localDateTime.toLocalDate();<br>LocalTime localTime2 = localDateTime.toLocalTime();<br>4. Instant（获取秒数）</p>
<p>Instant instant = Instant.now();<br>long currentSecond = instant.getEpochSecond();<br>long currentMilli = instant.toEpochMilli();<br>注：个人觉得如果只是为了获取秒数或者毫秒数，使用System.currentTimeMillis()来得更为方便</p>
<p>LocalDate、LocalTime、LocalDateTime、Instant为不可变对象，修改这些对象对象会返回一个副本。比如增加、减少年数、月数、天数等，以LocalDateTime为例：</p>
<p>LocalDateTime localDateTime = LocalDateTime.of(2019, Month.SEPTEMBER, 10,<br>              14, 46, 56);<br>//增加一年<br>localDateTime = localDateTime.plusYears(1);<br>localDateTime = localDateTime.plus(1, ChronoUnit.YEARS);<br>//减少一个月<br>localDateTime = localDateTime.minusMonths(1);<br>localDateTime = localDateTime.minus(1, ChronoUnit.MONTHS);<br>通过with修改某些值</p>
<p>//修改年为2019<br>localDateTime = localDateTime.withYear(2020);<br>//修改为2022<br>localDateTime = localDateTime.with(ChronoField.YEAR, 2022);<br>还可以修改月、日，比如有些时候想知道这个月的最后一天是几号、下个周末是几号</p>
<p>LocalDate localDate = LocalDate.now();<br>//比如通过firstDayOfYear()返回了当前日期的第一天日期，还有很多方法这里不在举例说明<br>LocalDate localDate1 = localDate.with(firstDayOfYear());</p>
<p>格式化时间</p>
<p>LocalDate localDate = LocalDate.of(2019, 9, 10);<br>String s1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);<br>String s2 = localDate.format(DateTimeFormatter.ISO_LOCAL_DATE);<br>//自定义格式化<br>// DateTimeFormatter默认提供了多种格式化方式，如果默认提供的不能满足要求，可以通过DateTimeFormatter的ofPattern方法创建自定义格式化方式<br>DateTimeFormatter dateTimeFormatter =   DateTimeFormatter.ofPattern(“dd/MM/yyyy”);<br>String s3 = localDate.format(dateTimeFormatter);</p>
<p>解析时间</p>
<p>LocalDate localDate1 = LocalDate.parse(“20190910”, DateTimeFormatter.BASIC_ISO_DATE);<br>LocalDate localDate2 = LocalDate.parse(“2019-09-10”, DateTimeFormatter.ISO_LOCAL_DATE);</p>
<p>不能单纯认为localdatetime是calender类的替代品，它和date一样是一种类型，是数据库支持的类型，并且提出更加简易的方法</p>
<h4 id="8-Annotations"><a href="#8-Annotations" class="headerlink" title="8.Annotations"></a>8.Annotations</h4><h4 id="9-Optional类型"><a href="#9-Optional类型" class="headerlink" title="9.Optional类型"></a>9.Optional类型</h4><p>它是作为某个指定类型的对象的包装器或者用于那些不存在对象(null)的场景</p>
<p>简单来说，它是处理空值的一个更好的替代品</p>
<p>使用下它的三个静态方法就可以了：</p>
<p>public static Optional stringOptional(String input) {</p>
<p>return Optional.of(input);</p>
<p>}</p>
<p>简单明了——创建一个包含这个值的Optional包装器。记住——如果这个值是null的话，它会抛出NPE!public static Optional stringNullableOptional(String input) {</p>
<p>if (!new Random().nextBoolean()) {</p>
<p>input = null;</p>
<p>}</p>
<p>return Optional.ofNullable(input);</p>
<p>}</p>
<p>我个人认为是要更好一点。这样就不会有NPE的风险了——如果输入为null的话，会返回一个空的Optionalpublic static Optional emptyOptional() {</p>
<p>return Optional.empty();</p>
<p>}</p>
<p>如果你真的就是希望返回一个”空”值的话。“空”值并不意味着null。</p>
<p>好吧，那如何去消费/使用Optional呢？public static void consumingOptional() {</p>
<p>Optional wrapped = Optional.of(“aString”);</p>
<p>if (wrapped.isPresent()) {</p>
<p>System.out.println(“Got string - “ + wrapped.get());</p>
<p>}</p>
<p>else {</p>
<p>System.out.println(“Gotcha !”);</p>
<p>}</p>
<p>}</p>
<p>简单的方法就是检查Optional包装器是否真的有值(使用isPresent方法)——你会怀疑这和使用if(myObj != null)相比有什么好处。别担心，这个我会解释清楚的。public static void consumingNullableOptional() {</p>
<p>String input = null;</p>
<p>if (new Random().nextBoolean()) {</p>
<p>input = “iCanBeNull”;</p>
<p>}</p>
<p>Optional wrapped = Optional.ofNullable(input);</p>
<p>System.out.println(wrapped.orElse(“default”));</p>
<p>}</p>
<p>你可以使用orElse方法，这样万一封装的确实是一个null值的话可以用它来返回一个默认值——它的好处显而易见。在提取出真实值的时候可以避免调用ifPresent方法这样明显多余的方式了。public static void consumingEmptyOptional() {</p>
<p>String input = null;</p>
<p>if (new Random().nextBoolean()) {</p>
<p>input = “iCanBeNull”;</p>
<p>}</p>
<p>Optional wrapped = Optional.ofNullable(input);</p>
<p>System.out.println(wrapped.orElseGet(</p>
<p>() -&gt; {</p>
<p>return “defaultBySupplier”;</p>
<p>}</p>
<p>));</p>
<p>}</p>
<p>这个我就有点搞不清楚了。为什么有两个同样目的的不同方法？orElse和orElseGet明明可以重载的(同名但不同参数)。</p>
<p>不论如何，这两个方法明显的区别就在于它们的参数——你可以选择使用lambda表达式而不是Supplier的实例来完成这个(一个函数式接口)</p>
<p>为什么使用Optional要比常见的null检查强？</p>
<p>1.使用Optional最大的好处就是可以更明白地表述你的意图——返回null值的话会让消费者感到疑惑(当真的出现NPE的时候)这是不是故意返回的，因此还得查看javadoc来进一步定位。而使用Optional就相当明了了。</p>
<p>2.有了Optional你就可以彻底避免NPE了——如上所提，使用Optional.ofNullable，orElse以及orElseGet可以让我们远离NPE。</p>
<h3 id="Java11"><a href="#Java11" class="headerlink" title="Java11"></a>Java11</h3><p>2018年9月26日</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="明确概念"><a href="#明确概念" class="headerlink" title="明确概念"></a>明确概念</h3><p>1.JDK（java development kit）：java开发工具包JRE+tools</p>
<p>​    是提供给java开发人员使用的，其中包含了java的开发工具，也包括了JRE</p>
<p>​    Java的开发工具：编译工具（javac.exe）和打包工具（jar.exe）</p>
<p>2.JRE（java runtime environment）：java运行环境 JVM+class library</p>
<p>​    包括java虚拟机和java程序所需的核心类库等</p>
<p>3.JVM（java virture machine）：java虚拟机</p>
<p>jvm是用C和汇编语言写的，jdk的开发工具包都是用java写的。</p>
<p>可以去网上查找jdk并下载安装，这里推荐使用JDK1.8</p>
<h3 id="配置JDK环境变量"><a href="#配置JDK环境变量" class="headerlink" title="配置JDK环境变量"></a>配置JDK环境变量</h3><p>要使java文件写在其他文件下面，仍可以运行，就需要配置环境变量。</p>
<p>我的电脑→属性→高级系统设置→环境变量→系统变量：以下三个环境变量 已存在则点击“编辑”，不存在则点击“新建”</p>
<p>1.新建JAVA_HOME（变量名）指向的是JDK的安装路径（变量值），在此路径下能找到bin、lib等目录。</p>
<p>2.编辑PATH环境变量,目的是为了指向JDK的bin目录，这里面放的是各种编译执行命令。目的是<strong>使javac指令可以在任意目录下运行</strong>。</p>
<p>配置方法一：</p>
<p>​    将javac指令所在目录也就是JDK安装目录下的bin目录配置到path变量下，即可使javac指令在任意目录下运行。系统中本来有path环境变量，直接放后面就行，中间用分号间隔。path环境变量具有先后顺序</p>
<p>具体方法：</p>
<p>​    将JDK安装目录下的bin目录添加到最左边并添加分号</p>
<p><strong>配置方法二</strong>（因为jdk可能有多个，主要用这个）：</p>
<p>​    新建变量名为：JAVA_HOME            变量值为：JDK安装目录            将path环境变量中的JDK目录修改为：%JAVA_HOME%\bin；（%%相当于引用）</p>
<p>​    切换JDK时只需修改变量值</p>
<p>Tips：操作系统因不明原因导致%JAVA_HOME%环境变量失效，即使正确配置“Path”中的内容，也无法验证通过。此时可以采用“弃用JAVA_HOME”的办法，在“Path”环境变量中，直接添加JDK下bin文件夹的完整地址（即配置方法一）。</p>
<p>如果“弃用JAVA_HOME”之后依然无法通过验证，则要打开JDK的bin文件夹，检查此文件夹下是否有“java.exe”和“javac.exe”这两个文件，这两个可执行文件实际上就是java命令和javac命令的“本体”，如果缺失了这两个文件，JDK就无法正常使用，环境也就永远无法验证通过。</p>
<p>3.CLASSPATH（class文件的环境变量）一般<strong>不用配置</strong>，仅了解，不推荐配置在系统的环境变量中</p>
<p>​    创建新的变量名称：classpath          变量值设定为指定的含有class文件的目录，多个目录之间使用分号（；）分割。</p>
<p>​    作用：使classpath目录中的.class文件可以在任意目录运行</p>
<p>classpath目录中的配置存在先后顺序，先在第一个目录下查找，没有的话；.再继续查找第二个，依次类推</p>
<p>​    区别：path环境变量里面记录的是可执行性文件，如：.exe文件。</p>
<p>​    classpath环境变量里面记录的是java类的运行文件所在的目录如：.class文件</p>
<h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><p>cmd中输入<code>java -version</code> 或者输入<code>javac</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    这里的下载安装很简单，最主要的是JDK的环境变量配置。原理就是在path的环境变量中加入java的bin文件夹（这个bin文件夹 中会有javac.exe和java.exe），这样在运行java时，就会找到javac命令和java命令并运行。设置JAVA_HOME的目的是为了防止有多个java时，在切换版本时需要不断更改操作path，为了方便操作，当path中运行到%JAVA_HOME%.bin时，会去再访问JAVA_HOME这个变量下的java文件夹，最终目的是一样的。classpath就是一组目录的集合，它设置了一个搜索路径，当运行某个类时，会依次查找这个目录下的这个类，找到了就会运行，如果找不到就会报错。所以一般情况下，不用配置classpath，用默认的配置在当前文件下查找这个类即可。</p>
<p>​    这里的配置环境变量是接触的第一个环境变量。环境变量这个东西一通百通，以后的环境变量配置也可以参照这个原理，其根本目的都是要使系统的path路径中可以找到你的软件的bin目录。教程只是一方面，背后的原理才是以后会独立配置的关键。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/26/4.1.%E5%88%9D%E8%AF%86java%EF%BC%9A%E7%89%B9%E6%80%A7%E3%80%81%E7%89%88%E6%9C%AC%E3%80%81%E5%AE%89%E8%A3%85/" data-id="ckw61sdwp0067oswd25cf61mw" data-title="初识java" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-3.2.java开发工具之IDEA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/25/3.2.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA/" class="article-date">
  <time class="dt-published" datetime="2021-03-25T03:46:22.000Z" itemprop="datePublished">2021-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/25/3.2.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA/">java开发工具之IDEA</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="IDEA介绍"><a href="#IDEA介绍" class="headerlink" title="IDEA介绍"></a>IDEA介绍</h1><p>IDEA 全称 IntelliJ IDEA，是java编程语言开发的集成环境（集成开发环境IDE（Integrated Development Environment）:把开发，运行，编译集成在一起）。IntelliJ在业界被公认为最好的java开发工具，尤其在智能代码助手、代码自动提示、重构、JavaEE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA属于JetBrains这个公司，旗下的知名软件还有：PyCharm-智能 Python 集成开发工具，WebStorm - 最智能的 JavaScript IDE。</p>
<p>​    在刚接触java的时候，跟着视频下载了eclipse，白色的界面，很有教科书的感觉。当时看到一些博主，微信公众号的推送的代码示例截图，编写代码的工具都是黑色的，感觉很像命令行的风格，以为很高大上，就很羡慕（其实只是界面皮肤的问题）。后来才接触到了idea，默认的一种黑色的界面给了我逼格很高的感觉，想着终于拥有了大佬一样的开发工具，我也算是大佬了，hhhh。就像是长江后浪推前浪，有的人认为eclipse也是在不断完善，认为新兴的idea始终无法替代eclipse；也有的人自从接触了idea就爱不释手，毫不犹豫的抛弃了eclipse。说到底这也只是个工具而已，能够帮助我们更高效、简洁、方便的开发代码，达到我们的目的，使用什么工具又有什么所谓呢。</p>
<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><p>目前常用</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ctrl + D</strong></td>
<td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</td>
</tr>
<tr>
<td><strong>Ctrl + /</strong></td>
<td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</td>
</tr>
<tr>
<td>ctrl+shif+/</td>
<td>注释一段代码</td>
</tr>
<tr>
<td><strong>Ctrl + F</strong></td>
<td>在当前文件进行文本查找</td>
</tr>
<tr>
<td>ctrl+shift+f</td>
<td>在全局搜索</td>
</tr>
<tr>
<td><strong>Ctrl  + Z</strong></td>
<td>撤销</td>
</tr>
<tr>
<td><strong>Ctrl + Shift + Z</strong></td>
<td>取消撤销</td>
</tr>
<tr>
<td><strong>Alt + F7</strong></td>
<td>查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td><strong>Ctrl + Alt + 鼠标左键</strong></td>
<td><strong>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</strong></td>
</tr>
<tr>
<td><strong>Ctrl + Alt + ←</strong></td>
<td>跳到上次浏览的位置</td>
</tr>
<tr>
<td>alt+shift+上下键</td>
<td>将某一行或选中的区域整体上下移动</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>ctrl + alt + u</td>
<td>显示类之间的关系</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>sout</td>
<td>System.out.println();</td>
</tr>
<tr>
<td>fori</td>
<td>for(int i=0;i&lt; ;i++)</td>
</tr>
<tr>
<td>itar</td>
<td>Iterate elements of array</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Shift + F6</td>
<td>对文件 / 文件夹 重命名（变量，类名，方法名都可以）</td>
</tr>
<tr>
<td>ctrl+r</td>
<td>替换本页内容</td>
</tr>
<tr>
<td>ctrl+shift+r</td>
<td>在多个文件中替换内容</td>
</tr>
</tbody></table>
<h2 id="ctrl"><a href="#ctrl" class="headerlink" title="ctrl"></a>ctrl</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ctrl + R</strong></td>
<td>在当前文件进行文本替换 （必备）</td>
</tr>
<tr>
<td><strong>Ctrl + O</strong></td>
<td><strong>选择可重写的方法</strong></td>
</tr>
<tr>
<td><strong>Ctrl + W</strong></td>
<td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</td>
</tr>
<tr>
<td><strong>Ctrl + Y</strong></td>
<td>删除光标所在行 或 删除选中的行 （必备）</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>显示最近打开的文件记录列表</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>根据输入的 类名 查找类文件</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>显示当前类的层次结构</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>选择可继承的方法</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>在当前文件跳转到指定行处</td>
</tr>
<tr>
<td>Ctrl + J</td>
<td>插入自定义动态代码模板</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>方法参数提示显示</td>
</tr>
<tr>
<td>Ctrl + Q</td>
<td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击</td>
</tr>
<tr>
<td>Ctrl + K</td>
<td>版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td>Ctrl + +</td>
<td>展开代码</td>
</tr>
<tr>
<td>Ctrl + -</td>
<td>折叠代码</td>
</tr>
<tr>
<td>Ctrl + [</td>
<td>移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td>Ctrl + ]</td>
<td>移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td>Ctrl + Space</td>
<td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</td>
</tr>
<tr>
<td>Ctrl + Delete</td>
<td>删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td>Ctrl + BackSpace</td>
<td>删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td>Ctrl + F1</td>
<td>在光标所在的错误代码出显示错误信息</td>
</tr>
<tr>
<td>Ctrl + F3</td>
<td>调转到所选中的词的下一个引用位置</td>
</tr>
<tr>
<td>Ctrl + F4</td>
<td>关闭当前编辑文件</td>
</tr>
<tr>
<td>Ctrl + F8</td>
<td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td>Ctrl + F9</td>
<td>执行 Make Project 操作</td>
</tr>
<tr>
<td>Ctrl + F11</td>
<td>选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td>Ctrl + F12</td>
<td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td>Ctrl + Enter</td>
<td>智能分隔行</td>
</tr>
<tr>
<td>Ctrl + End</td>
<td>跳到文件尾</td>
</tr>
<tr>
<td>Ctrl + Home</td>
<td>跳到文件头</td>
</tr>
<tr>
<td>Ctrl + 1,2,3…9</td>
<td>定位到对应数值的书签位置</td>
</tr>
<tr>
<td>Ctrl + 左键单击</td>
<td>在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td>Ctrl + 光标定位</td>
<td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td>Ctrl + 左方向键</td>
<td>光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td>Ctrl + 右方向键</td>
<td>光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td>Ctrl + 前方向键</td>
<td>等效于鼠标滚轮向前效果</td>
</tr>
<tr>
<td>Ctrl + 后方向键</td>
<td>等效于鼠标滚轮向后效果</td>
</tr>
</tbody></table>
<h2 id="alt"><a href="#alt" class="headerlink" title="alt"></a>alt</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Alt + Enter</strong></td>
<td><strong>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</strong></td>
</tr>
<tr>
<td><strong>Alt + Insert</strong></td>
<td><strong>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</strong></td>
</tr>
<tr>
<td>Alt + Q</td>
<td>弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td>Alt + `</td>
<td>显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td>Alt + F1</td>
<td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td>Alt + F2</td>
<td>对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td>Alt + F3</td>
<td>选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td>Alt + F8</td>
<td>在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td>Alt + Home</td>
<td>定位 / 显示到当前文件的 Navigation Bar</td>
</tr>
<tr>
<td>Alt + 左方向键</td>
<td>按左方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td>Alt + 右方向键</td>
<td>按右方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td>Alt + 前方向键</td>
<td>当前光标跳转到当前文件的前一个方法名位置</td>
</tr>
<tr>
<td>Alt + 后方向键</td>
<td>当前光标跳转到当前文件的后一个方法名位置</td>
</tr>
<tr>
<td>Alt + 1,2,3…9</td>
<td>显示对应数值的选项卡，其中 1 是 Project 用得最多</td>
</tr>
</tbody></table>
<h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Shift + 滚轮前后滚动</strong></td>
<td>当前文件的横向滚动轴滚动</td>
</tr>
<tr>
<td>Shift + F1</td>
<td>如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td>Shift + F2</td>
<td>跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td>Shift + F3</td>
<td>在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td>Shift + F4</td>
<td>对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Shift + F7</td>
<td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td>
</tr>
<tr>
<td>Shift + F9</td>
<td>等效于点击工具栏的 Debug 按钮</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>等效于点击工具栏的 Run 按钮</td>
</tr>
<tr>
<td>Shift + F11</td>
<td>弹出书签显示层</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>取消缩进</td>
</tr>
<tr>
<td>Shift + ESC</td>
<td>隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td>Shift + End</td>
<td>选中光标到当前行尾位置</td>
</tr>
<tr>
<td>Shift + Home</td>
<td>选中光标到当前行头位置</td>
</tr>
<tr>
<td>Shift + Enter</td>
<td>开始新一行。光标所在行下空出一行，光标定位到新行位置</td>
</tr>
<tr>
<td>Shift + 左键单击</td>
<td>在打开的文件名上按此快捷键，可以关闭当前打开文件</td>
</tr>
</tbody></table>
<h2 id="ctrl-alt"><a href="#ctrl-alt" class="headerlink" title="ctrl+alt"></a>ctrl+alt</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ctrl + Alt + L</strong></td>
<td>格式化代码，可以对当前文件和整个包目录使用 （必备）</td>
</tr>
<tr>
<td><strong>Ctrl + Alt + T</strong></td>
<td><strong>对选中的代码弹出环绕选项弹出层</strong></td>
</tr>
<tr>
<td>Ctrl + Alt + V</td>
<td>快速引进变量</td>
</tr>
<tr>
<td>Ctrl + Alt + O</td>
<td>优化导入的类，可以对当前文件和整个包目录使用 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + I</td>
<td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td>Ctrl + Alt + J</td>
<td>弹出模板选择窗口，讲选定的代码加入动态模板中</td>
</tr>
<tr>
<td>Ctrl + Alt + H</td>
<td>调用层次</td>
</tr>
<tr>
<td>Ctrl + Alt + Y</td>
<td>同步、刷新</td>
</tr>
<tr>
<td>Ctrl + Alt + S</td>
<td>打开 IntelliJ IDEA 系统设置</td>
</tr>
<tr>
<td>Ctrl + Alt + F7</td>
<td>显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td>Ctrl + Alt + F11</td>
<td>切换全屏模式</td>
</tr>
<tr>
<td>Ctrl + Alt + Enter</td>
<td>光标所在行上空出一行，光标定位到新行</td>
</tr>
<tr>
<td>Ctrl + Alt + Home</td>
<td>弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td>Ctrl + Alt + Space</td>
<td>类名自动完成</td>
</tr>
</tbody></table>
<h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ctrl + Shift + U</strong></td>
<td><strong>对选中的代码进行大 / 小写轮流转换 （必备）</strong></td>
</tr>
<tr>
<td><strong>Ctrl + Shift + F</strong></td>
<td>根据输入内容查找整个项目 或 指定目录内文件 （必备）</td>
</tr>
<tr>
<td><strong>Ctrl + Shift + /</strong></td>
<td>代码块注释 （必备）</td>
</tr>
<tr>
<td><strong>Ctrl + Shift + Space</strong></td>
<td>智能代码提示</td>
</tr>
<tr>
<td><strong>Ctrl + Shift + Enter</strong></td>
<td>自动结束代码，行末自动添加分号 （必备）</td>
</tr>
<tr>
<td><strong>Ctrl + Shift + Backspace</strong></td>
<td>退回到上次修改的地方</td>
</tr>
<tr>
<td>Ctrl + Shift + J</td>
<td>自动将下一行合并到当前行末尾 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + R</td>
<td>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + I</td>
<td>快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td>Ctrl + Shift + E</td>
<td>显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td>Ctrl + Shift + T</td>
<td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td>
</tr>
<tr>
<td>Ctrl + Shift + C</td>
<td>复制当前文件磁盘路径到剪贴板</td>
</tr>
<tr>
<td>Ctrl + Shift + V</td>
<td>弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td>Ctrl + Shift + H</td>
<td>显示方法层次结构</td>
</tr>
<tr>
<td>Ctrl + Shift + B</td>
<td>跳转到类型声明处</td>
</tr>
<tr>
<td>Ctrl + Shift + A</td>
<td>查找动作 / 设置</td>
</tr>
<tr>
<td>Ctrl + Shift + [</td>
<td>选中从光标所在位置到它的顶部中括号位置</td>
</tr>
<tr>
<td>Ctrl + Shift + ]</td>
<td>选中从光标所在位置到它的底部中括号位置</td>
</tr>
<tr>
<td>Ctrl + Shift + +</td>
<td>展开所有代码</td>
</tr>
<tr>
<td>Ctrl + Shift + -</td>
<td>折叠所有代码</td>
</tr>
<tr>
<td>Ctrl + Shift + F7</td>
<td>高亮显示所有该选中文本，按Esc高亮消失</td>
</tr>
<tr>
<td>Ctrl + Shift + F8</td>
<td>在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td>Ctrl + Shift + F9</td>
<td>编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td>Ctrl + Shift + F12</td>
<td>编辑器最大化</td>
</tr>
<tr>
<td>Ctrl + Shift + 1,2,3…9</td>
<td>快速添加指定数值的书签</td>
</tr>
<tr>
<td>Ctrl + Shift + 左方向键</td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td>Ctrl + Shift + 右方向键</td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td>Ctrl + Shift + 左方向键</td>
<td>在光标焦点是在工具选项卡上，缩小选项卡区域</td>
</tr>
<tr>
<td>Ctrl + Shift + 右方向键</td>
<td>在光标焦点是在工具选项卡上，扩大选项卡区域</td>
</tr>
<tr>
<td>Ctrl + Shift + 前方向键</td>
<td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td>
</tr>
<tr>
<td>Ctrl + Shift + 后方向键</td>
<td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td>
</tr>
</tbody></table>
<h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + Shift + F7</td>
<td>在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td>Alt + Shift + N</td>
<td>选择 / 添加 task</td>
</tr>
<tr>
<td>Alt + Shift + F</td>
<td>显示添加到收藏夹弹出层</td>
</tr>
<tr>
<td>Alt + Shift + C</td>
<td>查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td>Alt + Shift + F</td>
<td>添加到收藏夹</td>
</tr>
<tr>
<td>Alt + Shift + I</td>
<td>查看项目当前文件</td>
</tr>
<tr>
<td>Alt + Shift + F9</td>
<td>弹出 Debug 的可选择菜单</td>
</tr>
<tr>
<td>Alt + Shift + F10</td>
<td>弹出 Run 的可选择菜单</td>
</tr>
<tr>
<td>Alt + Shift + 左键双击</td>
<td>选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td>
</tr>
<tr>
<td>Alt + Shift + 前方向键</td>
<td>移动光标所在行向上移动</td>
</tr>
<tr>
<td>Alt + Shift + 后方向键</td>
<td>移动光标所在行向下移动</td>
</tr>
</tbody></table>
<h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Shift + Alt + V</td>
<td>无格式黏贴</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + N</td>
<td>前往指定的变量 / 方法</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + S</td>
<td>打开当前项目设置</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + C</td>
<td>复制参考信息</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>F2</td>
<td>跳转到下一个高亮错误 或 警告位置 （必备）</td>
</tr>
<tr>
<td>F3</td>
<td>在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td>F4</td>
<td>编辑源</td>
</tr>
<tr>
<td>F7</td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td>F8</td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td>F9</td>
<td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td>F11</td>
<td>添加书签</td>
</tr>
<tr>
<td>F12</td>
<td>回到前一个工具窗口</td>
</tr>
<tr>
<td>Tab</td>
<td>缩进</td>
</tr>
<tr>
<td>ESC</td>
<td>从工具窗口进入代码文件窗口</td>
</tr>
<tr>
<td>连按两次Shift</td>
<td>弹出 Search Everywhere 弹出层</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>使用IDEA读取底层源码的快捷键集合<br>自己常用的两种方式:<br>如果是看接口的底层,就用<strong>ctrl+alt</strong><br>如果是看其他的底层,就双击锁定,然后<strong>两下shift</strong>即可.<br>如果看继承树,<strong>ctrl+h</strong></p>
<p>感觉通常都是<code>ctrl+键</code>是主要功能，shift是全选，alt</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Alt+回车</code></td>
<td>导入包,自动修正</td>
</tr>
<tr>
<td><code>Ctrl+Alt+L</code></td>
<td>格式化代码</td>
</tr>
<tr>
<td><code>Alt+Insert</code></td>
<td>生成代码(如get,set方法,构造函数等)</td>
</tr>
<tr>
<td><code>Ctrl+F</code></td>
<td>查找文本</td>
</tr>
<tr>
<td><code>Ctrl+N</code></td>
<td>查找类</td>
</tr>
<tr>
<td><code>Ctrl+Shift+N</code></td>
<td>查找文件</td>
</tr>
<tr>
<td><code>Ctrl+Shift+Alt+N</code></td>
<td>查找类中的方法或变量</td>
</tr>
<tr>
<td><code>Ctrl+R</code></td>
<td>在当前文件进行文本替换</td>
</tr>
<tr>
<td><code>Ctrl+Y</code></td>
<td>删除光标所在行 或 删除选中的行</td>
</tr>
<tr>
<td><code>Ctrl+Space</code></td>
<td>代码提示</td>
</tr>
<tr>
<td><code>Ctrl+Shift+Space</code></td>
<td>自动补全代码(常用)</td>
</tr>
<tr>
<td><code>Ctrl+P</code></td>
<td>方法参数提示</td>
</tr>
<tr>
<td><code>Ctrl+/</code>或<code>Ctrl+Shift+/</code></td>
<td>注释（//或者/…./）</td>
</tr>
<tr>
<td><code>Ctrl+D</code></td>
<td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</td>
</tr>
<tr>
<td><strong><code>Ctrl+Shift+Up/Down</code></strong></td>
<td>代码向上/下移动</td>
</tr>
<tr>
<td><strong><code>Alt+ Up/Down</code></strong></td>
<td>在方法间快速移动定位</td>
</tr>
<tr>
<td><strong><code>Ctrl + U</code></strong></td>
<td>前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td><strong><code>Ctrl+Alt+left/right </code></strong></td>
<td>返回至上次浏览的位置</td>
</tr>
<tr>
<td><code>F2 或Shift+F2 </code></td>
<td>高亮错误或警告快速定位</td>
</tr>
<tr>
<td><strong><code>选中文本，按Alt+F3</code></strong></td>
<td>逐个往下查找相同文本，并高亮显示</td>
</tr>
</tbody></table>
<h1 id="IDEA出现的问题"><a href="#IDEA出现的问题" class="headerlink" title="IDEA出现的问题"></a>IDEA出现的问题</h1><p>1.idea查看源码时会显示<code>/*compiled code*/</code>，一般新版的idea会自带反编译功能，如果出现了表示反编译没有成功。</p>
<p>解决方案：</p>
<p>File-&gt;setting-&gt;Plugins，然后下拉，找到Java Bytecode Decompiler  打钩  应用保存 重启</p>
<p>如果发现已经打过勾仍出现这种情况，可能是因为用了 java decompiler Intellij Plugin这个插件，取消打勾之后重启也可。</p>
<h1 id="IDEA个人配置"><a href="#IDEA个人配置" class="headerlink" title="IDEA个人配置"></a>IDEA个人配置</h1><p>1.Java文件统一添加固定Header，通过IDE统一配置（code templates）　 File and Code Templates</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @author swx</span><br><span class="line">* @site</span><br><span class="line">* @company</span><br><span class="line">* @create $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125;-$&#123;TIME&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>2.Auto Import</p>
<p>可以帮助我们自动删除无用的包Import(未被引用)，以及自动Import填充尚未导入的包。完全智能化地帮助我们在开发程序时，省略了导包的操作，大大优化了开发的效率。并且，当你移动某个类改变其路径的时候，这个功能会相应的改变关联的文件中包的路径</p>
<p>Settings→Editor→General→Auto Import<br>然后勾选Add unambiguous imports on the fly以及Optimize imports on the fly</p>
<p>Add unambiguous imports on the fly：快速添加明确的导入。</p>
<p>Optimize imports on the fly：快速优化导入，优化的意思即自动帮助删除无用的导入。</p>
<h1 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h1><h2 id="JRebel"><a href="#JRebel" class="headerlink" title="JRebel"></a>JRebel</h2><p>是一款JVM插件，它使得Java代码修改后不用重启系统，立即生效</p>
<p>1.搜索并安装插件jrebel</p>
<p>2.在线GUID地址：在线生成GUID</p>
<p><a target="_blank" rel="noopener" href="https://www.guidgen.com/">https://www.guidgen.com/</a></p>
<p>3.ctrl+shift+s 打开settings设置，找到jrebel 面板，选择Connect to online licensing service</p>
<p><img src="/3.2.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA/image-20211107125210013.png" alt="image-20211107125210013"></p>
<p><a target="_blank" rel="noopener" href="https://jrebel.qekang.com/+%E7%94%9F%E6%88%90%E7%9A%84GUID">https://jrebel.qekang.com/+生成的GUID</a></p>
<p>自己的邮箱地址</p>
<p>4.打开jrebel面板，把JRebel设置为offline模式 点一下<strong>work offline</strong></p>
<p>5.设置项目自动编译</p>
<p>settings下找到build，Execution，deployment下的compiler，勾选build project automaticlly</p>
<p>6.设置 compiler.automake.allow.when.app.running</p>
<p>ctrl+shift+A 或者 help-&gt;find action…打开并搜索registry或者按<strong>快捷键 Ctrl+Shift+Alt+/</strong> ，选择 Registry<br>找到 compiler.automake.allow.when.app.running 并✔</p>
<p>开始使用：</p>
<p>左下角有一个Jrebel，点击打开的窗口，选择你所需要进行热部署的项目。勾选后会在resource下生成一个rebel.xml文件，此文件可以忽略</p>
<p>这样设置之后就可以通过JRebel的图标启动项目。这样修改完Java代码后，就可以通过快捷键 <strong>Ctrl+shift+F9</strong>（更多的用ctrl+F9编译） 而不再需要重启站点这样繁琐浪费时间的操作了</p>
<p>修改快捷键，可以利用宏设置：</p>
<p>edit—&gt;macros—&gt;start macro recording</p>
<p>右下角会出现一个提示</p>
<p><img src="/3.2.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA/20210603104826766.png" alt="在这里插入图片描述"></p>
<p>然后点击ctrl+F9，此时右下角会有提示，点击红色停止</p>
<p><img src="/3.2.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA/20210603105037206.png" alt="在这里插入图片描述"></p>
<p>会弹出一个窗口，在窗口中输入宏的名字build</p>
<p>打开设置，找到kaymap，找到宏下面会出现刚刚设置的名字，可以设置快捷键，以后就可以用新的快捷键</p>
<p>Jrebel<strong>不适用于resources包</strong>下面的文件，修改此包下面的必须重启，否则不生效</p>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><ol>
<li>启动 IntelliJ IDEA。</li>
</ol>
<p>如果打开欢迎屏幕，请单击“新建项目”。否则，从主菜单中选择 File | New | Project。</p>
<ol start="2">
<li><p>在 New Project 向导中，从左侧的列表中选择 Java。</p>
</li>
<li><p>要在 intellijidea 中开发 Java 应用程序，您需要 javasdk (JDK)。</p>
</li>
</ol>
<p>如果所需的 JDK 已经在 IntelliJ IDEA 中定义，那么从 Project SDK 列表中选择它。</p>
<p>如果 JDK 安装在您的计算机上，但是没有在 IDE 中定义，那么选择 Add JDK 并指定 JDK home 目录的路径(例如,/library/java/javavialmachines/JDK-13.0.1)。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWfbzkZ1UiapTicga31j6w7oSrPR83iahT0WyyjGViax2MHm7BN4vSV25Mkg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果您的计算机上没有必要的 JDK，选择 Download JDK。在下一个对话框中，指定 JDK 供应商(例如 OpenJDK)、版本，如果需要则更改安装路径，然后单击 Download。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWPEfHh4J5MwWia0dJ6OwdoRs7BTZVPsibxgICz0aWYpDEzZE9JBsldIQA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在本教程中，我们不打算使用任何其他库或框架，因此请单击“下一步”。不要从模板创建项目。</p>
<p>为项目命名，例如：HelloWorld。 如有必要，请更改默认项目位置并单击“完成”。</p>
<h2 id="创建-package-和-class"><a href="#创建-package-和-class" class="headerlink" title="创建 package 和 class"></a><strong>创建 package 和 class</strong></h2><p>包用于将属于同一类别或提供类似功能的类组合在一起，用于构造和组织具有数百个类的大型应用程序。</p>
<ol>
<li><p>在 Project 工具窗口中，选择 src 文件夹，按 Alt + Insert，然后选择 Java Class</p>
</li>
<li><p>在 Name 字段中，键入 com.example.HelloWorld. HelloWorld 并单击 OK. IntelliJ IDEA 创建 com.example.HelloWorld 包和 HelloWorld 类。</p>
</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWQmzbSjUuddQ1M5HolHMoGyOtscdEdibHRaQt0M3xeONvObF3RsrnJfg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p>与该文件一起，IntelliJ IDEA 自动为您的类生成了一些内容。在这种情况下，IDE 插入了包语句和类声明。这是通过文件模板来完成的。根据您创建的文件的类型，IDE 插入初始代码和预期在该类型的所有文件中存在的格式。有关如何使用和配置模板的详细信息，请参阅文件模板。</p>
<h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a><strong>开始编码</strong></h2><p>通过动态模板增加 main 方法</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWeXJlIYYZ5yU9w0TXqqFApqRfoSbRMSZMu6bOhllCKEiaehIqmvCDdGw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<h2 id="输出-print-方法"><a href="#输出-print-方法" class="headerlink" title="输出 print 方法"></a>输出 print 方法</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWozxeT70eCw3QDjjZEcicXxr7YkPiaAE43lyRXU88EMR03MRtFicRqAQ1g/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<h2 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWrwGLeicySTnyUD1ZRH1Ge37bdK3Lr6t4nmd1l5kPBQrPxXzz2EvvQjA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<h2 id="将工程打包为-Jar-包"><a href="#将工程打包为-Jar-包" class="headerlink" title="将工程打包为 Jar 包"></a>将工程打包为 Jar 包</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWjJwY4wwXngccbGVJbL9w92g4vB9xQiaVSTL7xibEoWGLXEH1Ufc7QjOA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWnjsC32TbeR66PK4wr3g92nmdMYYiaNrrQGRxWxEAPCh1Adu5AEfnDnA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p>如果你能看到 <code>out/artifacts</code> 文件夹，那么你将能看到 Jar 包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWPETajnwylHwQvO6QvWfcFvCXNL50lxMyicmW3k7LPg7Yib159OMEiaVdw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="运行打包的应用程序，执行-Jar"><a href="#运行打包的应用程序，执行-Jar" class="headerlink" title="运行打包的应用程序，执行 Jar"></a>运行打包的应用程序，执行 Jar</h2><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><p><strong>在相同内容后生成光标，一个一个选择</strong> ：</p>
<p>具体什么意思可以看下面这个动图就行了，需要配合快捷键使用，可以在相同的关键字后面生成光标，这样删除、修改添加新的代码不就方便了吗？</p>
<ul>
<li>Windows：<code>Alt + J</code></li>
<li>Mac: <code>Ctrl + G</code></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCqoz4dPTicpfofx0aUICa9dU0ZdGxvvuHv0Gxu85WvLFSRWiah2p6tcDw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p><strong>在所有的相同的内容后添加光标，一步到位：</strong></p>
<p>使用快捷键就能在所有的 word 后生成光标</p>
<ul>
<li>Windows：<code>Ctrl + Shift + Alt + J</code></li>
<li>Mac: <code>Ctrl + Command + G</code></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCp1H6w3F6DPcMM7A93OBmgiaJCJtF9t7XrxvJFtn57ic1icib6AzC6tiaUcw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p><strong>数列光标：</strong></p>
<p>方法：alt + 按住鼠标左键拖动就能达到下面动图的效果了，效率 max！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCiaOTkEVAOYNUKmyYGxTx6qdN8QWDeViaqkcicKsfqMbTLkSkMCndnicjIg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p><strong>行尾添加光标</strong> </p>
<p>alt + 按住鼠标左键拖动，从左侧拖动到右侧。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCsBp8625jJrS1SP4LrrDibz2qwcjZibT7XqHlQhoJ55XYxgWe9r9RibJuA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p><strong>在指定位置添加光标操作</strong> </p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCAZuEutmsuEmic1lmSClfveKemWXibZqz2ep2A44AsqGSSXSXgveD4liag/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<h2 id="格式批量调整"><a href="#格式批量调整" class="headerlink" title="格式批量调整"></a><strong>格式批量调整</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCtYIKLt8ZkLQ8rmIO5fCTib51gZvyGGOzwhvWmNxEiblZKNBibsTLwGxLw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>将上方左侧的代码批量变为右侧代码</p>
<blockquote>
<p>alt+shift+鼠标选中多个光标，ctrl+w扩大选中范围，ctrl+c复制，ctrl + alt + enter 将光标移动到当前行的上一行</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCSlicmLibmIsRslic8JdFfz2Q1uK3QgEBD5kn2qY7ZbG0kJuVLnf9NeBicw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<h2 id="批量添加-Swagger-属性注释"><a href="#批量添加-Swagger-属性注释" class="headerlink" title="批量添加 Swagger 属性注释"></a><strong>批量添加 Swagger 属性注释</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCc70TxcjXYXQlicCbrk5SjzSqf9KBJKMicw6MDcanbe8V7WuM6xIC73CA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>将上图左侧只有注释的类，添加上 swagger 信息</p>
<p>ctrl+shift+鼠标点击多个选中，复制，回车，输入，粘贴</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCRPPpgthYoBj24AlKm6TsCCyRUB5aVruGGxQAicSAj8AuwibDgtEFhHkg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p><strong>在多个相同结构 Json 中提取某字段信息</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUC9QFMKzLTrtiaDnU9wUb2a9YvNY0dpJkXN2nEmVhJiaqLTfic1Z6nRdt5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>提取左侧 Json 中所有的 role 字段</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCE8dU7IxEEoiaknVuNQjQCqHB6rftAEia1BPB4a6Gr4KXqniarOp6JP34w/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<h1 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h1><p>上面介绍了一些配合鼠标使用的快捷键，还有一些常用快捷键。</p>
<p><strong>方法参数提示</strong><br><code>ctrl + p</code></p>
<blockquote>
<p>非常实用的快捷键, 有的时候我们自己写的方法, 或者在看一些源码时, 都非常有用</p>
</blockquote>
<p><strong>文本大小写转换</strong></p>
<p>ctrl + shift + U</p>
<p><strong>折叠代码/展开代码</strong></p>
<p>ctrl + - / ctrl + +</p>
<p><strong>快速查找和打开最近使用过的文件码</strong></p>
<p>ctrl + E</p>
<p><strong>自动代码片</strong></p>
<p>ctrl + j</p>
<p><strong>实现接口方法</strong></p>
<p>ctrl + i</p>
<p><strong>查看当前类的子类</strong></p>
<p>ctrl + h</p>
<p><strong>将当前行和下一行进行合并</strong></p>
<p>ctrl + shfit + j</p>
<p><strong>将光标跳到当前行的上一行</strong></p>
<blockquote>
<p>有时候在写完一行代码的时候需要添加注释, 或者为类属性添加注释的时候需要跳到当前行的上一行, 这个快捷键就非常方便</p>
</blockquote>
<p>ctrl + alt + enter</p>
<p><strong>idea git 提交</strong></p>
<p>ctrl + k</p>
<p><strong>删除当前行</strong></p>
<p>ctrl + y</p>
<p><strong>重写 或者 实现接口或父类方法</strong></p>
<p>ctrl + o</p>
<p><strong>删除类中没有用到的 package</strong></p>
<p>ctrl + alt + o</p>
<p><strong>进入设置界面</strong></p>
<p>ctrl + alt + s</p>
<p><strong>在当前光标在的这样一行的下一行添加一行</strong></p>
<p>ctrl + shfit + enter</p>
<p><strong>弹出， 当前类中的方法集合</strong></p>
<p>ctrl + F12</p>
<blockquote>
<p>最常用的快捷键之一, 快速的查找方法</p>
</blockquote>
<p><strong>添加书签</strong></p>
<p>ctrl + F11</p>
<p><strong>快速生成</strong> <strong><code>try, if</code> 等语句</strong> </p>
<p>alt + shift + t</p>
<blockquote>
<p>当你试用了之后, 你会爱上这个快捷键的</p>
</blockquote>
<p><strong>抽取局部变量</strong></p>
<p>ctrl + alt + v</p>
<blockquote>
<p>将当前选中的代码抽取为一个局部变量</p>
</blockquote>
<p><strong>进入到实现子类中</strong></p>
<p>ctrl + alt + b</p>
<blockquote>
<p>在使用<code>mvc</code>框架的时候, 往往我们只有一个接口的实例 这个快捷键可以直接到实现类中</p>
</blockquote>
<p><strong>格式化代码</strong></p>
<blockquote>
<p>让代码变得优美, 是每个程序员都应该注意的事, 方便自己和他人阅读, 利人利己</p>
</blockquote>
<p><strong>idea 多光标选择</strong></p>
<p><strong>按下滚轮上下拖动鼠标即可</strong></p>
<p>ctrl + alt + L</p>
<p><strong>idea 批量修改相同内容</strong></p>
<p>ctrl + alt + shift + j</p>
<blockquote>
<p>有的时候数据需要批量处理, 比如, 正常来说我们的实体类, 在使用<code>mybatis</code> 等逆向工程进行生成的时候, 一般属性是有注释的, 但是在针对如果我们使用了<code>swagger</code> 等插件需要来显示传递实体所代表的含义的时候, 就需要我们自己一个个的去写, 就会显得异常麻烦</p>
</blockquote>
<p><strong>运行当前类</strong></p>
<p>ctrl + shift + F10</p>
<blockquote>
<p>在写一些测试代码的时候 这个快捷键就显得特别方便</p>
</blockquote>
<p><strong>从多项目中启动一个 debug 模式</strong></p>
<p>alt + shfit + F9</p>
<blockquote>
<p>在微服务中 多个工程在一个项目中的时候, 这个方法就比较的好用, 这样就不用自己一个一个的去点省去很多没必要的操作</p>
</blockquote>
<p><strong>从多项目中启动一个 正常模式</strong></p>
<p>alt + shfit + F10</p>
<p><strong>重新编译当前项目</strong></p>
<p>ctrl + shift + F9</p>
<blockquote>
<p>当你发现有的问题 特别的奇怪, 命名表面上没问题, 但就是项目运行不了的时候, 重新编译一下获取就好了</p>
</blockquote>
<p>查看当前类在哪些地方被使用过</p>
<p><strong>快速的查看选中类, 选中方法的定义</strong></p>
<blockquote>
<p>有的时候我们不想进入方法内部, 或者进入类的内部查看细节, 想要在外面就探查清楚, 就可以使用此种方法</p>
</blockquote>
<p>ctrl + shift + i</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCQoDia6qpsnAbYDfYYk7kdRxYqqRqXan7IrRkq7vOLIliaEibYb6yczr0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>比较强大的几个快捷键之一 <code>Ctrl + ~ </code>(感叹号旁边的按键)</p>
<p><strong>共有五种可供选择的操作</strong></p>
<p><strong>Switch Code Formatter (切换代码格式化程序)</strong></p>
<p><strong>1. Color Scheme (配色方案)</strong></p>
<p>可以设置一些常用的配色, 字体样式, 可以一键切换</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCVdTF7EZkNIkfKdyONHp7AA1amyfVmUD1xPCdhibvxtvU58cUia5vgBEw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"><strong>2.</strong> <strong><code>Code Style Scheme</code></strong></p>
<p><strong>3.</strong> <strong><code>Keymap</code> (快捷键列表)</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCiaNQMn3gO7PelrVHnraSibbX6AqdpwJokibBx4IaX2krm3wOibokmiaglhQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p><strong>4. View Mode (显示模式)</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCoBEhL91j8SL1Oiajx2crej1tIvtkyn5XrRlE0KeMzibml1xOibgRIykuw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p><strong>5. Look and Feel (设置软件主题)</strong></p>
<p><strong>idea 调出版本控制操作</strong></p>
<p>alt + ~</p>
<p>\4. IDEA常用设置</p>
<h3 id="IDEA-以新窗口的形式打开多个项目"><a href="#IDEA-以新窗口的形式打开多个项目" class="headerlink" title="IDEA 以新窗口的形式打开多个项目"></a><strong>IDEA 以新窗口的形式打开多个项目</strong></h3><blockquote>
<p>File - Settings - Appearance &amp; Behavior - System Settings</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCAq0TibZIlhbxSI3rhibXnKB9ibubwZVk53waw4DIveOia3IeJEbDhaaRzA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="修改-IDEA-默认编码-gt-UTF-8"><a href="#修改-IDEA-默认编码-gt-UTF-8" class="headerlink" title="修改 IDEA 默认编码 -&gt; UTF-8"></a><strong>修改 IDEA 默认编码 -&gt; UTF-8</strong></h3><blockquote>
<p>File - Settings - Editor - File Encodings</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCXJN0kicBLLO4oce3opDHAdnqicNiaicyMggH83Gu5O93fCQhStTlusKYLg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="设置统一编译器和编译版本"><a href="#设置统一编译器和编译版本" class="headerlink" title="设置统一编译器和编译版本"></a><strong>设置统一编译器和编译版本</strong></h3><blockquote>
<p>File - Setting - Build - Compiler - Java Compiler</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUC9k2ep1cGnGROQbs5qLaA1go7dYGicWzgMI267lIJ155Q1wUBpAKrp6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="设置类注释"><a href="#设置类注释" class="headerlink" title="设置类注释"></a><strong>设置类注释</strong></h3><blockquote>
<p>File - Editor- File and Code Templates</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCfPSMWDuXZrJcVwDV46f2936yss72wEoaxm1VZ1BSvlevaXOVdNVjXA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><code>$$end$$</code> 可以设置光标结束的位置</p>
<h3 id="自动导包"><a href="#自动导包" class="headerlink" title="自动导包"></a><strong>自动导包</strong></h3><blockquote>
<p>File - Editor- General - Auto Import</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCLGR8H8YgXnIg5Ou1BjXxCJO9brkqa44WViawzrabug9ypkwRCA438Ow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="内存使用量展示"><a href="#内存使用量展示" class="headerlink" title="内存使用量展示"></a><strong>内存使用量展示</strong></h3><blockquote>
<p>由于日常开发时都是在公司的办公电脑上进行的，所以内存总是不够用，但是又不清楚 IDEA 具体实时的占用了多少内存。这个时候对于一些内存并不是太够的开发人员来说能看到实时的内存使用量还是比较好的</p>
<p>File - Settings - Appearance &amp; Behavior</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCHHCQZaOF9rVYy7xjMW3oGSiaK3iahzic3Ss2xiaZZBDPibIVkbxeEZxsYAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="开启悬浮提示"><a href="#开启悬浮提示" class="headerlink" title="开启悬浮提示"></a><strong>开启悬浮提示</strong></h3><blockquote>
<p>有时候在看代码的时候，不清楚一个类具体是干什么的，就会点进去看这个类的注释，但是强大的 IDEA 是支持不用点进去就可以看到注释的以及类的相关信息的。</p>
<p>File - Settings - Editor - General</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCnm6GE8SbIbXs5fsQicc9HDpKuG3N5XngeB9zQe1icq6ZicT28TIHDeaBA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="Ctrl-鼠标滚轴修改字体大小"><a href="#Ctrl-鼠标滚轴修改字体大小" class="headerlink" title="Ctrl+鼠标滚轴修改字体大小"></a><strong>Ctrl+鼠标滚轴修改字体大小</strong></h3><blockquote>
<p>IDEA 也支持向浏览器那样按住 Ctrl+鼠标滚轴来改变编辑区的字体的大小</p>
<p>File–&gt;Settings–&gt;Editor–&gt;General。</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCJtwciau1o4EAicf0NemhU46vSsNkIX5Y9wMrTrpz8qKcb0wOK3xIfchw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="显示多行-Tab"><a href="#显示多行-Tab" class="headerlink" title="显示多行 Tab"></a><strong>显示多行 Tab</strong></h3><blockquote>
<p>当我们打开的标签页多了的时候，默认的会隐藏在右侧，当我们需要的时候在右侧找到后再打开。IDEA 是支持多行显示的，这样在大屏幕的显示器上也不用总去点击右侧的去找刚才打开过的文件了</p>
<p>File - Settings - Editor - General - Editor Tabs</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCCeld6NVtO5MaHcNtMh1bCFGHy0yRxqaNiaJQywnnDicMGwjosJicXicXeA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="设置字体-行距-让代码看着更舒服"><a href="#设置字体-行距-让代码看着更舒服" class="headerlink" title="设置字体, 行距 让代码看着更舒服"></a><strong>设置字体, 行距 让代码看着更舒服</strong></h3><blockquote>
<p>File - Settings - Editor - Font</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCW9T5QbNZSmuKv1aV3VmLZHjEOg749d85cvUfGaQp9PfmwT5Hw18TPw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="IDEA-GIT-配置"><a href="#IDEA-GIT-配置" class="headerlink" title="IDEA GIT 配置"></a><strong>IDEA GIT 配置</strong></h3><blockquote>
<p>File - Settings - Version Control - Git</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUC21QpUpdeOZzWHEhSyKiau5DdZ8OFEeeZ77fIAGERJsVdbyZicYh9XYUg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="IDEA-MAVEN-配置"><a href="#IDEA-MAVEN-配置" class="headerlink" title="IDEA MAVEN 配置"></a><strong>IDEA MAVEN 配置</strong></h3><blockquote>
<p>File - Settings - Build - Build Tools - Maven</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCXwFmKicTU9rOUd3mDtGCC1KTibxYicwK8Sc25mia8AycibGgJ37lu1ib1vIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>maven 阿里镜像配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;nexus&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">    &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">&lt;&#x2F;mirror&gt;</span><br></pre></td></tr></table></figure>

<h2 id="自动编译"><a href="#自动编译" class="headerlink" title="自动编译"></a><strong>自动编译</strong></h2><p>具体步骤：顶部工具栏 File -&gt;Other Settings -&gt; Default Settings -&gt; Auto Import</p>
<p>说明：开启自动编译之后，结合Ctrl+Shift+F9 会有热更新效果。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMwibTxtyZ5ggYDuJKVwq4B9qtGEpF2zibnntvBOD4fRJ8Atdjy2t3TI0qkH6z6m7ciah6ER4GhSA9Ag/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>具体步骤：敲击 Ctrl + Shift + Alt + / 然后双击Shift搜索进入Registry ，找到compiler.automake.allow.when.app.running ，然后勾选上。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMwibTxtyZ5ggYDuJKVwq4B9NQ6URxjciav5STm3AMr6Al1cPFBHlkibNm8AFo22iaSajuQyUMibV90H0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMwibTxtyZ5ggYDuJKVwq4B9jmk7G9H6NGnyXdCZ9tfopCtiaB0W0d89a5MTu7jZvCLEb3h1Q2Ea4aA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>最后 如果想知道SpringBoot如何具体实现热部署的请点击SpringBoot+IDEA实现热部署教程：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f658fed35786">https://www.jianshu.com/p/f658fed35786</a></p>
<h2 id="取消大小写敏感"><a href="#取消大小写敏感" class="headerlink" title="取消大小写敏感"></a><strong>取消大小写敏感</strong></h2><p>具体步骤：</p>
<p>File | Settings | Editor | General | Code Completion Case | Sensitive Completion = None</p>
<p>取消大小敏感，在编写代码的时候，代码的自动提示将更加全面和丰富。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMwibTxtyZ5ggYDuJKVwq4B91Kia9RjAEXo4sdr9QhE0icsybC0Vpt4L55eqqFdJb3VpQwxBO5doQXcw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="调整字体类型和字体大小"><a href="#调整字体类型和字体大小" class="headerlink" title="调整字体类型和字体大小"></a><strong>调整字体类型和字体大小</strong></h2><p>默认的白色背景和细小的字体会影响大家的编码体验，这里特意提供了调整代码窗的快捷配置。打开配置，搜索Font，然后再Font可以调整字体类型，Size可以调整字体大小，如图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMwibTxtyZ5ggYDuJKVwq4B96r46MRAvpZHP4KoiaLzxB9gHQoWVZTfKzPnzphiaVFicDSnlohPXTRuQA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="将快捷键设置为跟Eclipse一样"><a href="#将快捷键设置为跟Eclipse一样" class="headerlink" title="将快捷键设置为跟Eclipse一样"></a><strong>将快捷键设置为跟Eclipse一样</strong></h2><p>很多人可能并不习惯IDEA的快捷键，为了方便，这里我们将快捷键设置为跟 Eclipse一样。</p>
<p>具体步骤: File -&gt; Settings -&gt; Keymap - &gt; 选择Eclipse .</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMwibTxtyZ5ggYDuJKVwq4B927IIibSTv7XQEd5DfeBRlmII9px6oYFCxfnodiaEuKnIQr2BEXManmGQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>从Eclipse转过来的小伙伴 可以放心使用</p>
<h2 id="打开常用工具栏"><a href="#打开常用工具栏" class="headerlink" title="打开常用工具栏"></a><strong>打开常用工具栏</strong></h2><p>具体步骤：顶部导航栏 - View -&gt; 勾选 Toolbar &amp; Tool Buttons</p>
<p>\5. IDEA 常用插件</p>
<h2 id="AlibabaCloudToolkit自动部署"><a href="#AlibabaCloudToolkit自动部署" class="headerlink" title="AlibabaCloudToolkit自动部署"></a><strong>AlibabaCloudToolkit</strong>自动部署</h2><p>这个插件更加适用于小型项目，或者在测试环境开发。生产环境 个人感觉不太适用。</p>
<p>个人经常会有这样的需求，每次自己更新完测试环境之后, 就需要 <code>Maven</code> 打包<code>clean install</code>, 然后<code>copy</code> <code>jar</code> 包, 利用<code>ftp</code>工具上传<code>jar</code>包到测试服务器, 然后<code>kill</code> 服务, 在启动服务 <code>java -jar</code> , 有时更新频繁 这就是一件非常麻烦的事</p>
<p><code>Cloud Toolkit</code> 是本地 <code>IDE</code> 插件，帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，您可以将本地应用一键部署到云端<code>（ECS、EDAS 和 Kubernetes 等</code>）和任意服务器；并且它还内置了 <code>Arthas</code> 程序诊断、<code>Dubbo工具</code>、<code>Terminal Shell</code> 终端和 <code>MySQL</code> 执行器等工具。</p>
<p>官方链接：<a target="_blank" rel="noopener" href="https://www.aliyun.com/product/cloudtoolkit">https://www.aliyun.com/product/cloudtoolkit</a></p>
<p>简单的说, 安装了这个插件之后，Idea 就具备了一些 Jenkins 的自动部署的功能</p>
<p><strong>1</strong> 安装</p>
<p>在 Idea 工具中 Plugins 直接搜索安装</p>
<p><strong>2</strong> 使用</p>
<p>在安装完成之后, 在工具栏中就会出现阿里云的按钮, <strong>点击按钮</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCnomY6Mu7RricncKiaGFyBLfm49JM9IB909xZ3asaGJ9rPLqYiapmMLC8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后点击 <code>Deploy to Host</code>, 然后下方就会出现添加主机页面</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCxicp9of0h1ysbxGCbB8YiaPVhicpW8xMdHQaEnrcyWaVEMdIEric1Wqp1w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击 <code>Add Host</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCLNKc3jFnIKYUYUJicHeQGdj3QQplrZzNJo63NhicAibRSB8fTXvTIwy8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>以我自己的博客为例, 输入完配置之后, 点击 <code>Test Connection</code>, 出现 <code>Succeeded</code>, 点击 <code>add</code>, 代表添加成功</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCjxkOECykPSpPCxw72fpRQSibrCibeR7ibHibxnUe5Na9qfKkltgSdKo2icg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后再点击 <code>Deploy to Host</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCqRj0Qibo89LJbnKZRYCeEmvZibYDjFOHPruxZntK3cibWUDxR9ibPmicGsA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击<code>Run</code>, <code>idea</code> 便会, 先使用<code>maven</code>打包, 后发送到服务器的指定位置</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCDu6azuO6iavaibIaKjJVkOdffJFkeYQBUVPf3TJQGelkicSK3RUvzmscA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCaW1hKVvt9Wlgop9Wiaw1ukIeuvza4BkuFb96hX0DpWNsPQibntVAOIIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>后续还可以 监听启动日志, 很简单, 就是 <code>Advanced</code> 里面, 大家看看就知道了,</p>
<p><strong>IDEA 插件 Git Flow</strong></p>
<h2 id="插件作用：集成-Git-Flow-让我们更加专注在-开发-这件事上。"><a href="#插件作用：集成-Git-Flow-让我们更加专注在-开发-这件事上。" class="headerlink" title="插件作用：集成 Git Flow 让我们更加专注在 开发 这件事上。"></a>插件作用：集成 Git Flow 让我们更加专注在 开发 这件事上。</h2><p>Git Flow：</p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@rafavinnce/gitflow-branch-guide-8a523360c053">https://medium.com/@rafavinnce/gitflow-branch-guide-8a523360c053</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCqknTxMR0rjDZt2kHsgqFlOyjzQ7XcKKIB7YtoCprS6mdRLCFZzoXwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h2><p>最开始还没有初始化的时候，点击右下脚 GitFlow init</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCCRwYLnISXVxFkD5noUicbeS3NgcTwKUWtXUG3WgZbIdt62BLZkGkuNg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>直接 默认 设置就好，点击 Ok 之后，就可以开始使用了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCBYVzFx98Eyenu25afLXpk4GAnibZcKuOB7XPPxlvPdsuPBVCTMXBoJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>按照最规范的流程走，可以避免在未来某个阶段掉坑里。</p>
<p>Git 版本管理规范：</p>
<p>master：永远处于production-ready状态</p>
<ul>
<li>主分支，产品的功能全部实现后，最终在master分支对外发布；</li>
<li>只读分支，只能从release或hotfix分支合并，不能修改；</li>
<li>所有在master分支的推送应该做标签记录，方便追溯。</li>
</ul>
<p>develop：最新的下次发布的开发状态</p>
<ul>
<li>主开发分支，基于master分支克隆，发布到下一个release；</li>
<li>只读分支，feature功能分支完成，合并到develop（不推送）；</li>
<li>develop拉取release分支，提测；</li>
<li>release/hotfix分支上线完毕，合并到develop并推送。</li>
</ul>
<p>feature：开发新功能都从develop分支出来，完成后merge回develop</p>
<ul>
<li>功能开发分支，基于develop分支克隆，用于新需求的开发；</li>
<li>功能开发完毕后合并到develop分支（未正式上线之前不能推送到远程中央仓库）</li>
<li>feature可以同时存在多个，用于团队多功能同步开发，属于临时分支，开发完毕后可以删除。</li>
</ul>
<p>release：准备要release的版本，只修bug。从develop出来，完成后merge回master和develop</p>
<ul>
<li>测试分支，feature分支合并到develop分支之后，从develop分支克隆；</li>
<li>只要用于提交给测试人员进行功能测试，测试过程中如果发现BUG在release分支修复，修复完成上线后合并到</li>
<li>develop/master分支并推送完成，做标签记录；</li>
<li>临时分支，上线后可删除。</li>
</ul>
<p>hotfix：等不及release版本就必须马上修复master上线。从master出来，完成后merge回master和develop</p>
<ul>
<li>补丁分支，基于master分支克隆，主要用于对线上的版本进行BUG修复；</li>
<li>修复完毕后合并到develop/master分支并推送，做标签记录；</li>
<li>所有hotfix分支的修改会进入到下一个release；</li>
<li>临时分支，补丁修复上线后可以删除；</li>
</ul>
<p><strong>IDEA 插件 PlantUML</strong></p>
<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a><strong>1.</strong> 背景</h3><p>之前介绍过 使用 Vscode 画 UML，实际上 idea 中也有类似的插件 可以画 UML 图。</p>
<p>PlantUML 语法：<a target="_blank" rel="noopener" href="https://plantuml.com/zh/component-diagram">https://plantuml.com/zh/component-diagram</a></p>
<h3 id="安装插件安装地址："><a href="#安装插件安装地址：" class="headerlink" title="安装插件安装地址："></a>安装插件安装地址：</h3><h3 id="https-plugins-jetbrains-com-plugin-7017-plantuml-integration"><a href="#https-plugins-jetbrains-com-plugin-7017-plantuml-integration" class="headerlink" title="https://plugins.jetbrains.com/plugin/7017-plantuml-integration"></a><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7017-plantuml-integration">https://plugins.jetbrains.com/plugin/7017-plantuml-integration</a></h3><p>在安装完官方的插件之后，还需要额外安装一个 graphviz ，不然有的复杂的用例图就没办法展示了。</p>
<p>graphviz：<a target="_blank" rel="noopener" href="https://graphviz.org/download/">https://graphviz.org/download/</a></p>
<p><strong>2.</strong> windows 安装</p>
<p><em>choco install graphviz</em></p>
<p>使用</p>
<blockquote>
<p>新建文件 - PlantUML File - 选择想要创建的类型</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUC6LDoUDUrKhvQ0pJl9FO0Uw4UVm3QE1FYMD60j0rW85DzgymmKsSXNg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a><strong>流程图</strong></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCfoDwLaAadpVLKI29n57ibhL6MvRBVgqjVgSBgz81BdmlIJTwH49qia9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>流程图 CODE</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCtDmHNVCNhRkEXQ764ib7a8Z68dU6SCNVJAYBF2T3I5pT1CEGU2YuEKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p> <strong>用例图</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCQVYUkJiavibPaOfZWdY7B2OHtFM64hyL4OYVQ0srW3E1vibArAmCXkFzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>用例图 Code</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">left to right direction</span><br><span class="line"></span><br><span class="line">actor 普通 as User</span><br><span class="line">actor 审核 as Aduitor</span><br><span class="line">actor 编辑 as Editor</span><br><span class="line">actor 营销 as Marketing</span><br><span class="line">actor 运营 as Operator</span><br><span class="line">actor 管理员 as Admin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Admin --|&gt; User</span><br><span class="line"></span><br><span class="line">rectangle 社区 &#123;</span><br><span class="line">  User -- (查看文章)</span><br><span class="line">  User -- (发布文章&#x2F;帖子)</span><br><span class="line"></span><br><span class="line">  (帖子管理) &lt;|-- (置顶)</span><br><span class="line">  (帖子管理) &lt;|-- (审核)</span><br><span class="line">  (帖子管理) &lt;|-- (推荐)</span><br><span class="line">  (帖子管理) &lt;|-- (删除)</span><br><span class="line"></span><br><span class="line">  (社区运营) &lt;|-- (帖子管理)</span><br><span class="line">   Operator -- (社区运营)</span><br><span class="line">   Aduitor -- (社区运营)</span><br><span class="line">   Editor -- (社区运营)</span><br><span class="line">   Marketing -- (社区运营)</span><br><span class="line"></span><br><span class="line">  (App 配置) &lt;|-- (商品图片配置)</span><br><span class="line">  (App 配置) &lt;|-- (启动页配置)</span><br><span class="line">  (App 配置) &lt;|-- (活动 Banner)</span><br><span class="line">  (App 配置) &lt;|-- (互动 Banner)</span><br><span class="line">  (App 配置) &lt;|-- (商城配置)</span><br><span class="line">  (App 配置) &lt;|-- (功能配置)</span><br><span class="line">  (App 配置) &lt;|-- (产品配置)</span><br><span class="line">  (App 配置) &lt;|-- (系统配置)</span><br><span class="line">  (App 配置) &lt;|-- (新人礼包)</span><br><span class="line">  (App 配置) &lt;|-- (个人中心)</span><br><span class="line">  (App 配置) &lt;|-- (渠道配置)</span><br><span class="line">  Admin -- (App 配置)</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><strong>类图</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUC2TZkNFGLW3EOibcLVl8Xf6Q6Jv7h0oeGgh9eW08S4zPzoudSA1w3lXQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>彩虹括号 🌈 Rainbow Brackets</p>
<p>由于很多人没有养成好的编码风格，没有随手 format 代码的习惯，甚至有些同事会写代码超过几百行，阅读起来将非常痛苦。</p>
<p>痛苦的原因之一就是找到上下文，由于括号太多，不确定当前代码行是否属于某个代码块，此时这个插件就会帮上大忙.</p>
<h3 id="界面效果"><a href="#界面效果" class="headerlink" title="界面效果"></a>界面效果</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUC1CTXMvUwUAHMicb4Rqd0QPjk1RsOJ9K61KaMOK4pskFXRrJChB97gew/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">动图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUClCOXeXS3CNwiczQWXN0Zej2XD4bySqpUOcNo8EvicLekUHhqgsqVwKHw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<p><strong>阿里巴巴编码规范：Alibaba Java Coding Guidelines</strong></p>
<p>实时监测代码的规范性, 从代码层面减少空指针等异常的出现，阿里巴巴出品的<code>Java代码</code>规范插件, 可以扫描整个项目找到不规范的地方 并且大部分可以自动修复。</p>
<p>虽说检测功能没有 <code>findbugs</code> 强大，但是可以自动修复, 阿里巴巴 Java 编码指南插件支持。</p>
<p>让代码变得更规范， 是我们每一位程序员都应该记在心中的事。</p>
<h3 id="变量驼峰命名规范"><a href="#变量驼峰命名规范" class="headerlink" title="变量驼峰命名规范"></a>变量驼峰命名规范</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCAI2pa28zw5AP3pniczSNLqanx5kZ1o25ND6ysFLjIckxicNLfUPgACyA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当鼠标移到变量上时, 就会自动提示 不符合 <code>lowerCamelCase</code>命名风格</p>
<h3 id="字符串比较提示-equals"><a href="#字符串比较提示-equals" class="headerlink" title="字符串比较提示 equals"></a>字符串比较提示 <code>equals</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str &#x3D; null;</span><br><span class="line"></span><br><span class="line">    if (str.equals(&quot;test&quot;)) &#123;</span><br><span class="line">      System.out.println(&quot;success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>WARNING</p>
<p>当我们初学 <code>Java</code>时, 很有可能会犯这样的错误, 这里很明显会报空指针异常, 而在编辑器中</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCgZ5xgF4IeTeXqbg0BT1hOCibX9dAaBmgbiaJA24vcib0FxJnQtdyDY2hA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>安装插件之后, 编辑器已经给出详细提示,<code>&quot;test“</code> 应该做为 <code>equals</code>方法的调用方, 并给出了原因, 应为这样很容易导致空指针异常, 并给出了例子</p>
<h3 id="当你的类命名不规范时"><a href="#当你的类命名不规范时" class="headerlink" title="当你的类命名不规范时"></a>当你的类命名不规范时</h3><p>比如我创建了一个测试类 <code>test.java</code>，就会出现如下提示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCQiahMxAkt3ILdRM8H111axd1BhKaSEkic6u4QwibNfSe8stbzuUb9BD0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>类名，首字母需要大写。缺少作者注释。</p>
<p><strong>mybatis 插件：Free Mybatis plugin</strong></p>
<blockquote>
<p>安装此插件后可以节约很多的开发时间, 在 <code>mapper</code> 层接口可以直接进入 <code>xml</code>文件中</p>
</blockquote>
<h3 id="IntelliJ-Lombok-plugin"><a href="#IntelliJ-Lombok-plugin" class="headerlink" title="IntelliJ Lombok plugin"></a><strong>IntelliJ Lombok plugin</strong></h3><p>Lombok pom.xml 文件配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.16.18&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生命很宝贵, 没有必要浪费在这个重复的工作上, 尤其是如果我们使用传统的 get set 方法, 在实体类进行变更的时候, 或多添加了列, 或减少了列, 又要重新生成对应的 get set 这难道不就是浪费时间浪费生命吗?</p>
</blockquote>
<p>还不熟悉使用的可以看这篇文章，Java 开发之 Lombok 必知必会：</p>
<p>juejin.im/post/5cf3edf7e51d454f71439c79</p>
<h3 id="GenAllSetter"><a href="#GenAllSetter" class="headerlink" title="GenAllSetter"></a><strong>GenAllSetter</strong></h3><p>在 Java 方法中, 根据 new 关键词, 为 Java Bean 生成所有Setter方法。按 GenAllSetter 键两次, 会为 Setter 方法生成默认值。</p>
<h3 id="GenDaoCode"><a href="#GenDaoCode" class="headerlink" title="GenDaoCode"></a><strong>GenDaoCode</strong></h3><p>一键生成 dao xml service</p>
<h3 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a><strong>CodeGlance</strong></h3><p>在右侧生成代码地图</p>
<h3 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a><strong>RestfulToolkit</strong></h3><p>一套 Restful 服务开发辅助工具</p>
<ul>
<li>1.根据 URL 直接跳转到对应的方法定义 ( Ctrl \ or Ctrl Alt N );</li>
<li>2.提供了一个 Services tree 的显示窗口;</li>
<li>3.一个简单的 http 请求工具;</li>
<li>4.在请求方法上添加了有用功能: 复制生成 URL;,复制方法参数…</li>
<li>5.其他功能: java 类上添加 Convert to JSON 功能，格式化 json 数据 ( Windows: Ctrl + Enter; Mac: Command + Enter )。</li>
</ul>
<h3 id="Grep-Console"><a href="#Grep-Console" class="headerlink" title="Grep Console"></a><strong>Grep Console</strong></h3><p>高亮log不同级别日志，看日志的时候一目了然。</p>
<h3 id="MyBatis-Log-Plugin"><a href="#MyBatis-Log-Plugin" class="headerlink" title="MyBatis Log Plugin"></a><strong>MyBatis Log Plugin</strong></h3><p>把 Mybatis 输出的sql日志还原成完整的sql语句，看起来更直观。</p>
<h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a><strong>GsonFormat</strong></h3><blockquote>
<p>快速的讲一个 json转换为一个实体 安装完插件后 alt + s 放入正确的 json格式</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUC03FOSY1FR1ttlCzuB3DED8VQaBFVsaqHrMbEuEXvMolpLDAT6cHb1w/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p>
<h3 id="VisualVm-Launcher"><a href="#VisualVm-Launcher" class="headerlink" title="VisualVm Launcher"></a><strong>VisualVm Launcher</strong></h3><p>运行java程序的时候启动visualvm，方便查看jvm的情况 比如堆内存大小的分配</p>
<p>某个对象占用了多大的内存，jvm调优必备工具</p>
<h3 id="jclasslib-bytecode-viewer"><a href="#jclasslib-bytecode-viewer" class="headerlink" title="jclasslib bytecode viewer"></a><strong>jclasslib bytecode viewer</strong></h3><p>一款可视化的字节码查看插件</p>
<h3 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a><strong>Codota</strong></h3><p>支持智能代码自动提示，该功能可以增强 IDEA 的代码提示功能。</p>
<p>支持 JDK 和知名第三方库的函数的使用方法搜索，可以看到其他知名开源项目对该函数的用法。当我们第一次使用某个类，对某个函数不够熟悉时，可以通过该插件搜索相关用法，快速模仿学习。</p>
<h3 id="Auto-filling-Java-call-arguments"><a href="#Auto-filling-Java-call-arguments" class="headerlink" title="Auto filling Java call arguments"></a><strong>Auto filling Java call arguments</strong></h3><p>开发中，我们通常会调用其它已经编写好的函数，调用后需要填充参数，但是绝大多数情况下，传入的变量名称和该函数的参数名一致，当参数较多时，手动单个填充参数非常浪费时间。</p>
<p>该插件就可以帮你解决这个问题。安装完该插件以后，调用一个函数，使用 Alt+Enter 组合键，调出 “Auto fill call parameters” 自动使用该函数定义的参数名填充。</p>
<h3 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a><strong>Rainbow Brackets</strong></h3><p>由于很多人没有养成好的编码风格，没有随手 format 代码的习惯，甚至有些同事会写代码超过几百行，阅读起来将非常痛苦。</p>
<p>痛苦的原因之一就是找到上下文，由于括号太多，不确定当前代码行是否属于某个代码块，此时这个插件就会帮上大忙。</p>
<h3 id="SequenceDiagram"><a href="#SequenceDiagram" class="headerlink" title="SequenceDiagram"></a><strong>SequenceDiagram</strong></h3><p>SequenceDiagram 可以根据代码调用链路自动生成时序图，超级赞，超级推荐！</p>
<p>这对研究源码，梳理工作中的业务代码有极大的帮助，堪称神器。</p>
<p>安装完成后，在某个类的某个函数中，右键 –&gt; Sequence Diagaram 即可调出。</p>
<h3 id="Java-Stream-Debugger"><a href="#Java-Stream-Debugger" class="headerlink" title="Java Stream Debugger"></a><strong>Java Stream Debugger</strong></h3><p>Stream 非常好用，可以灵活对数据进行操作，但是对很多刚接触的人来说，不好理解。</p>
<p>那么 Java Stream Debugger 这款神器的 IDEA 就可以帮到你。它可以将 Stream 的操作步骤可视化，非常有助于我们的学习。</p>
<p>下面是刚刚介绍的这些插件的名字。</p>
<ul>
<li>AlibabaCloudToolkit</li>
<li>Git Flow</li>
<li>PlantUML</li>
<li>Rainbow Brackets</li>
<li>Alibaba Java Coding Guidelines</li>
<li>翻译插件</li>
<li>mybatis 插件</li>
<li>IntelliJ Lombok plugin</li>
<li>GenAllSetter</li>
<li>GenDaoCode</li>
<li>CodeGlance</li>
<li>RestfulToolkit</li>
<li>Grep Console</li>
<li>MyBatis Log Plugin</li>
<li>GsonFormat</li>
<li>VisualVm Launcher</li>
<li>jclasslib bytecode viewer</li>
<li>Codota</li>
<li>Auto filling Java call arguments</li>
<li>Rainbow Brackets</li>
<li>SequenceDiagram</li>
<li>Java Stream Debugger</li>
<li>Ace Jump</li>
</ul>
<p>\6. 好看字体</p>
<p>最近JetBrains公司推出了一款优雅美观的字体：JetBrainsMono。</p>
<h3 id="对比-Consolas"><a href="#对比-Consolas" class="headerlink" title="对比 Consolas"></a>对比 Consolas</h3><p>对比之前一直在使用 <code>Consolas</code> 字体</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCJY4YB7dWyom6MZmdNFDsy4m3h2UpiaUdzSyS2vfarrOuwicrypPnibjQA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCLfVFrc59HhSzTXsAicRl3ibPgbPQBYTh7moKmVzZIrZ6IWMb2vqWzH4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="下载字体"><a href="#下载字体" class="headerlink" title="下载字体"></a>下载字体</h3><p>官网下载：<a target="_blank" rel="noopener" href="https://www.jetbrains.com/lp/mono/">https://www.jetbrains.com/lp/mono/</a></p>
<p>坚果云下载：jianguoyun.com/p/DRPh-GkQ_7eJCBiv2uMC</p>
<p>Windows 安装</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCXnz3YErWQH7Y5yXyU0shiaESNuoHLs3mgF1B2n6HnjbKGPeQ5sgk35Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li>下载后，解压文件</li>
<li>直接双击扩展名为 <code>tff</code> 后缀的文件</li>
<li>重启 <code>IDEA</code></li>
<li><code>Perferences/Setting -&gt; Editor -&gt; Font</code>，选择 JetBrains Mono 确认即可</li>
</ul>
<p>\7. 版本控制 </p>
<p>这里主要盘点一下在 IDEA 中进行版本控制时，大部分人没注意到的一些细节吧，主要包括下面这写。</p>
<ul>
<li>查看每一行代码的条件人, 提交时间（大部分人不知道）</li>
<li>克隆远程代码</li>
<li>拉取远程代码</li>
<li>将暂存区代码提交到本地库</li>
<li>将本地库 提交到远程库</li>
<li>切换分支, 或拉取远程分支</li>
<li>查看当前打开类 历史记录</li>
<li>Stash</li>
<li>Check Out</li>
</ul>
<p>查看每一行代码的条件人, 提交时间（大部分人不知道）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCw1DXaYL0OXmjuib5UUrRJjsfoMMmXV63rCuBda4CloECXGSlWaE78kQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择后入下图所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCphlxOnqBPc4nyMyUS2tYgbdIA9Hp9yicakyXAKrq6oOSvVlpSQq3vibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>鼠标移动上去还能看到提交详细信息</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCUibHgHy8sc9Cl4W8sqF3y93gqTvd8ibewV2yEYlIzgEEkyG1PqFrczwg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>克隆远程代码</p>
<blockquote>
<p>git clone origin url</p>
</blockquote>
<p><strong>常规操作</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUC9ZvpmQeXn3snS2ZbRnxOQZBvZMgyc7errfPhicoN324tyDzG7V0kgAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>装逼操作</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCprERNlI8XrFKe9tJvU5m06MwkGbO93YF696U0404Wg6uBwZ9nzHUnw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>拉取远程代码</p>
<blockquote>
<p>git pull</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCxeKpRrqibNCEJVcXT97icRya8bEOibQA7m8obfd6dL2CgPpw8OfvFIuiaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>快捷方式</p>
<p>ctrl + t</p>
<p>将暂存区代码提交到本地库</p>
<blockquote>
<p>git commit -m ‘message’</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUC0BmFVuAwI6jymoCm8PMrh27umCSxjd6WSIxhXyWRAGlIsLO6icCxf6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> <img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCIj99tVrBhQZHZdp79leg0OqgwuBRib2Yvd3SEqHnlZAPgLEiaNvsxHQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>将本地库 提交到远程库</p>
<blockquote>
<p>git push</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCAibq15uPsaibBn7WuCiaGJwHDrGVxUbvGxFwDWWQTIKElqD4ukjN2JicnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>快捷键</p>
<p>ctrl + shif 或 alt + 1 + 8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">切换分支, 或拉取远程分支</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUC699vEsKurssqH5eGJtyia1aHQeLsKb4ny78bvrKvqK2hLoxicUOQ256A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>以下提供几种快捷方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + shift + &#96; 或 alt + ~ + 7 或</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCrbXbiaciblZIkn0rthiaXcd8cpN0jEcoVar7FIjmTKBu3klyb8G9Oj8xw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>查看当前打开类 历史记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + ~ + 4查看项目工程历史记录</span><br></pre></td></tr></table></figure>

<p>选中工程后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + ~ + 4</span><br></pre></td></tr></table></figure>

<p>或 <code>alt + 9</code> 切换到 <code>Version Control</code> 面板 选择log</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCVkibroqcHeVrGsnzyEmIUPNrY4nRxwyvLZme5UlQW6wnicFPQiaazK8gg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Stash</p>
<p>应用场景</p>
<p>我在本地修改好后，发现远程分支已经被改动了，此时我本地也被改动了就造成了冲突，无法push或者pull。此时可以使用git stash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash &#x2F;&#x2F;把本地的改动暂存起来</span><br><span class="line">git pull &#x2F;&#x2F;拉取远端分支（此时本地分支会回滚到上次commit的情况，新的改动都存在了stash中）</span><br><span class="line">git stash pop &#x2F;&#x2F; 将栈顶改动重新加回本地分支，就可以继续修改了，当然，如果改好了就是add,commit,push啥的。。</span><br></pre></td></tr></table></figure>

<p>不小心改动了其他分支，例如忘记切换，直接在master分支上做改动，这里假设我的分支是test分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash &#x2F;&#x2F;把本地当前改动暂存起来，此时master分支就恢复到了上次拉取时的状态</span><br><span class="line">git checkout test &#x2F;&#x2F;切换到需要改动的分支</span><br><span class="line">git stash pop &#x2F;&#x2F;将改动pop到自己当前的分支</span><br></pre></td></tr></table></figure>



<p>Idea 将现在本地的修改存储在 Stash 中<code>alt + ~</code>加 <code>9</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCpB9sjs9lUQP25nmh2KibxbTS8xZHZhiagynpibFUPI45DLHs0gfY0YtbQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>将 Stash 中的代码还原</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruwBkQUFiaMLcXTcEKOFSszUCkq8hSBQLS9UJS5JKyibyQvrDrMuytxubKlILk7AsIiceoSztgmibUN50g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="Check-Out"><a href="#Check-Out" class="headerlink" title="Check Out"></a>Check Out</h3><p>将本地修改的代码还原对应命令 <code>git checkout &lt;file&gt;</code></p>
<p>\8. Terminal 配置</p>
<p>将 Idea 的 Terminal 改为 Git Bash。使用体验翻倍</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWg7sfKREk1jXhGr6tMrlHbeDa6ryODeLkGyicrw0XRuNGbxCEy2fp3vw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>以前用着这么恶心的 CMD Terminal 我居然没有想法去修改。设置看图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9I5jwWKz2iaLTicUXmdtMTWUVWiaEyOT6LQ8em6iaWpiaB2Ftspouqzkegxuu4DV3jScvUz6DpahDpJw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h1 id="调试功能"><a href="#调试功能" class="headerlink" title="调试功能"></a>调试功能</h1><p><strong>1.设置断点</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAgrfXuQGnxW2XeOweZm2iaRic1TqWVeXUUhMUGGRnojWfa00fhpERYAVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选定要设置断点的代码行，在行号的区域后面单击鼠标左键即可。</p>
<h3 id="2-开启调试会话"><a href="#2-开启调试会话" class="headerlink" title="2.开启调试会话"></a><strong>2.开启调试会话</strong></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAPh4zkUvZewflv9fFdEM0RK9XFl8ibreIxEejroYpTx2oNR7mJMT5JaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击红色箭头指向的小虫子，开始进入调试。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAfy9CwIdCfN1Z86PM1D5QGspbjCX9ibBlBMD8fAN2ROZaVdvnWh87RPQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>IDE下方出现 Debug 视图，红色的箭头指向的是现在调试程序停留的代码行，方法 f2() 中，程序的第11行。红色箭头悬停的区域是程序的方法调用栈区。在这个区域中显示了程序执行到断点处所调用过的所用方法，越下面的方法被调用的越早。</p>
<h3 id="3-单步调试"><a href="#3-单步调试" class="headerlink" title="3.单步调试"></a><strong>3.单步调试</strong></h3><h4 id="3-1-step-over"><a href="#3-1-step-over" class="headerlink" title="3.1 step over"></a><strong>3.1 step over</strong></h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAtes030yYSf7JmkWy8tia4I0EJY8YnTnx5cicBbuYVaWibujRTH3oVtt6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击红色箭头指向的按钮，程序向下执行一行（如果当前行有方法调用，这个方法将被执行完毕返回，然后到下一行）</p>
<h4 id="3-2-step-into"><a href="#3-2-step-into" class="headerlink" title="3.2 step into"></a><strong>3.2 step into</strong></h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAIQOdSkBBImQnsva3gDWE12owbO9pibl1rJ1qNukvXmn4cibAAqjibjZPA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击红色箭头指向的按钮，程序向下执行一行。如果该行有自定义方法，则运行进入自定义方法（不会进入官方类库的方法）。具体步骤如下：</p>
<p>在自定义方法发f1()处设置断点，执行调试</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAWiaXuIla4x4RFKp1Go7A88Twdj1xxnJ1icF6qbeWPA0picJ7peicwhHcWw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeA4t4ibbDhjvUpDSb71E6QwGzZYxeKbIKnkBuCIudI21gzkNibSSTcHxxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAo8efN5IzFfmqXpKrdj76obiawa6oSeibn2cnLUibXoiaibD7YCTANRgEJug/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="3-3-Force-step-into"><a href="#3-3-Force-step-into" class="headerlink" title="3.3 Force step into"></a><strong>3.3 Force step into</strong></h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAoXCfDC0OSoIt0xoub57lxHolZ8s2HHkZc9bS7ibTEmBQvrfr6INPCfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>该按钮在调试的时候能进入任何方法。</p>
<h4 id="3-4-step-out"><a href="#3-4-step-out" class="headerlink" title="3.4 step out"></a><strong>3.4 step out</strong></h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAMhqygzvWYGw1Lxa7VvmwpUmD2NULEG1icZgj4Ilb73s5vvKRJ0gWnTg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果在调试的时候你进入了一个方法(如f2())，并觉得该方法没有问题，你就可以使用stepout跳出该方法，返回到该方法被调用处的下一行语句。值得注意的是，该方法已执行完毕。</p>
<h4 id="3-5-Drop-frame"><a href="#3-5-Drop-frame" class="headerlink" title="3.5 Drop frame"></a><strong>3.5 Drop frame</strong></h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAFeCZCJB0iaCtXIHHkJC2icSYp1EmrZQpLNcRhTGYXDgcPas78eexPLiag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击该按钮后，你将返回到当前方法的调用处（如上图，程序会回到main()中）重新执行，并且所有上下文变量的值也回到那个时候。只要调用链中还有上级方法，可以跳到其中的任何一个方法。</p>
<h4 id="3-6-run-to-cursor"><a href="#3-6-run-to-cursor" class="headerlink" title="3.6 run to cursor"></a>3.6 run to cursor</h4><p>运行到光标处</p>
<h3 id="4-高级调试"><a href="#4-高级调试" class="headerlink" title="4. 高级调试"></a><strong>4. 高级调试</strong></h3><h4 id="4-1-跨断点调试"><a href="#4-1-跨断点调试" class="headerlink" title="4.1 跨断点调试"></a><strong>4.1 跨断点调试</strong></h4><p>设置多个断点，开启调试。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAiaYEGgspwTuiaKGYTKQmLTVt05k4HV9SOWPuxF8GzeItvdRQHpg7qYmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>想移动到下一个断点，点击如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeA63tGWv6KriakE42BvsXExiaj4qsgYSnIDh2rHW0yCKiaxicdKBtqIxTasA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>程序将运行一个断点到下一个断点之间需要执行的代码。如果后面代码没有断点，再次点击该按钮将会执行完程序。</p>
<h4 id="4-2-查看断点"><a href="#4-2-查看断点" class="headerlink" title="4.2 查看断点"></a><strong>4.2 查看断点</strong></h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAbUmTuWF92qEF8c4Wfzjfq89LcuVsO7gDp4iaWf2m5rYyYibImicUcliaicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击箭头指向的按钮，可以查看你曾经设置过的断点并可设置断点的一些属性。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAAzEZVf34fN0OBAvWGfRia9mVdLRTjGf8v8Eb5Undypfgyia1kSJdWrkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>箭头1指向的是你曾经设置过的断点，箭头2可以设置条件断点（满足某个条件的时候，暂停程序的执行，如 c==97）。结束调试后，应该在箭头1处把所设的断点删除(选择要删除的断点后，点击上方的红色减号）。</p>
<h4 id="4-3-设置变量值"><a href="#4-3-设置变量值" class="headerlink" title="4.3 设置变量值"></a><strong>4.3 设置变量值</strong></h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbueVclsDbEIr99jYCox8jUeAA0zyJcSx4KjibxPDEXcMdpnMy0wp8iabWicOicH8cVEe0oyk2OZib2TyWWg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>调试开始后，在红箭头指向的区域可以给指定的变量赋值（鼠标左键选择变量，右键弹出菜单选择setValue…）。这个功能可以更加快速的检测你的条件语句和循环语句。</p>
<h1 id="idea插件将jar包反编译的命令"><a href="#idea插件将jar包反编译的命令" class="headerlink" title="idea插件将jar包反编译的命令"></a>idea插件将jar包反编译的命令</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp <span class="string">&quot;D:\swx\IntelliJ IDEA 2020.1.2\plugins\java-decompiler\lib&quot;</span> org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=<span class="keyword">true</span> yxtl1.jar data D:\yxtl</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/25/3.2.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BIDEA/" data-id="ckw61sdyr0076oswd6v61g9dr" data-title="java开发工具之IDEA" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-3.开发常用软件汇总" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/3.%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T10:07:14.000Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/24/3.%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/">开发常用软件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>开发中常接触的软件</p>
<h2 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>txt文本文档</code></strong></td>
<td>备忘录放桌面，随时记灵感思路</td>
</tr>
<tr>
<td><strong><code>notepad++</code></strong></td>
<td>看配置文件</td>
</tr>
<tr>
<td><strong><code>typora</code></strong></td>
<td>编辑文档</td>
</tr>
<tr>
<td><code>xmind</code></td>
<td>画思维导图，屡关系，发散思维（快捷键高效）</td>
</tr>
<tr>
<td><code>ProcessOn</code></td>
<td>免费在线作图工具,画原型图、思维导图、UML图(有网页版方便)</td>
</tr>
<tr>
<td><code>Sublime Text</code></td>
<td>代码草稿本。对python友好</td>
</tr>
<tr>
<td><code>Microsoft To Do</code></td>
<td>待办事项</td>
</tr>
<tr>
<td><code>腾讯文档</code></td>
<td>在线文档，功能不如金山文档多</td>
</tr>
<tr>
<td><code>金山文档</code></td>
<td>在线文档，wps旗下，会有崩溃现象</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>谷歌浏览器</code></strong></td>
<td>chrome，各种插件脚本丰富，大多网页都可以拿谷歌访问</td>
</tr>
<tr>
<td><code>火狐浏览器</code></td>
<td>F12开发者模式是中文，易懂一些。可以在本地存储里手动设定key value值</td>
</tr>
<tr>
<td><code>Microsoft Edge</code></td>
<td>微软自带的win 10浏览器</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="解压工具"><a href="#解压工具" class="headerlink" title="解压工具"></a>解压工具</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>7-zip</code></strong></td>
<td>推荐使用，免费，无广告</td>
</tr>
<tr>
<td><strong><code>winrar</code></strong></td>
<td>广告多，但也凑合用</td>
</tr>
<tr>
<td><code>2345</code></td>
<td>极不推荐，会安装流氓软件</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Java后端"><a href="#Java后端" class="headerlink" title="Java后端"></a>Java后端</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>jdk</code></strong></td>
<td>java版本，常用为1.8</td>
</tr>
<tr>
<td><code>NetBeans</code></td>
<td>java开发工具，可以用于Java、C/C++，PHP等语言的开发</td>
</tr>
<tr>
<td><strong><code>eclipse</code></strong></td>
<td>java开发工具，最早接触，前期常用</td>
</tr>
<tr>
<td><code>MyEclipse</code></td>
<td>在Eclipse基础上追加的功能性插件，对插件收费。在WEB开发中提供强大的系统架构平台</td>
</tr>
<tr>
<td><strong><code>idea</code></strong></td>
<td>java开发工具，目前常用，插件丰富</td>
</tr>
<tr>
<td><code>XJad</code></td>
<td>反编译java的class文件为java文件</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Java技术栈"><a href="#Java技术栈" class="headerlink" title="Java技术栈"></a>Java技术栈</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>spring</code></strong></td>
<td>java框架，核心是IOC和AOP</td>
</tr>
<tr>
<td><code>spring MVC</code></td>
<td></td>
</tr>
<tr>
<td><strong><code>spring boot</code></strong></td>
<td></td>
</tr>
<tr>
<td><code>spring cloud</code></td>
<td></td>
</tr>
<tr>
<td><strong><code>mybatis</code></strong></td>
<td></td>
</tr>
<tr>
<td><strong><code>mybatis plus</code></strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Java常用的第三方工具包"><a href="#Java常用的第三方工具包" class="headerlink" title="Java常用的第三方工具包"></a>Java常用的第三方工具包</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>lombok</code></td>
<td>自动生成get/set等方法</td>
</tr>
<tr>
<td><code>swagger</code></td>
<td>自动生成api文档</td>
</tr>
<tr>
<td><code>Hutool</code></td>
<td>常用的工具类聚合</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="分布式框架"><a href="#分布式框架" class="headerlink" title="分布式框架"></a>分布式框架</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>RocketMQ</code></td>
<td></td>
</tr>
<tr>
<td><code>RabbitMQ</code></td>
<td></td>
</tr>
<tr>
<td><code>ActiveMQ</code></td>
<td></td>
</tr>
<tr>
<td><code>Kafka</code></td>
<td></td>
</tr>
<tr>
<td><code>ZeroMQ</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Zookeeper</code></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
</tr>
</tbody></table>
<h2 id="IDEA的一些插件"><a href="#IDEA的一些插件" class="headerlink" title="IDEA的一些插件"></a>IDEA的一些插件</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IDE Eval Reset</code></td>
<td>idea重置插件。（需添加第三方插件仓库<a target="_blank" rel="noopener" href="https://plugins.zhile.io)/">https://plugins.zhile.io）</a></td>
</tr>
<tr>
<td><code>Gitee</code></td>
<td>idea集合的码云</td>
</tr>
<tr>
<td><code>Free Mybatis plugin</code></td>
<td>mapper接口跳转到xml文件</td>
</tr>
<tr>
<td><code>Translation</code></td>
<td>在线翻译的插件</td>
</tr>
<tr>
<td><strong><code>lombok</code></strong></td>
<td>可以将lombok的相关代码消除飘红，可以进行代码提示</td>
</tr>
<tr>
<td><code>Alibaba Java Coding Guidelines</code></td>
<td>阿里巴巴代码规范</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><table>
<thead>
<tr>
<th>种类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>mysql</code></strong></td>
<td>5.7</td>
</tr>
<tr>
<td><code>SQLite</code></td>
<td></td>
</tr>
<tr>
<td><strong><code>redis</code></strong></td>
<td></td>
</tr>
<tr>
<td><code>Minio</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="数据库工具"><a href="#数据库工具" class="headerlink" title="数据库工具"></a>数据库工具</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SQLyog</code></td>
<td>前期使用，已转战</td>
</tr>
<tr>
<td><strong><code>navicat</code></strong></td>
<td>设计表好用，会出下长时间不点击的下一次点击特别慢</td>
</tr>
<tr>
<td><code>DataGrip</code></td>
<td>jetbrains旗下的数据库软件，反应快</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Redis Desktop Manager</code></td>
<td>redis的管理工具（普遍用这个，但是需要收费）</td>
</tr>
<tr>
<td><strong><code>AnotherRedisDesktopManager</code></strong></td>
<td>免费，所以<a target="_blank" rel="noopener" href="https://github.com/qishibo/AnotherRedisDesktopManager/releases">比上面那个好用</a></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ElasticSearch</code></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
</tr>
</tbody></table>
<h2 id="项目管理工具"><a href="#项目管理工具" class="headerlink" title="项目管理工具"></a>项目管理工具</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>maven</code></strong></td>
<td>3.6.1，pom.xml文件中放依赖</td>
</tr>
<tr>
<td><code>gradle</code></td>
<td>安卓的依赖</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="代码管理工具"><a href="#代码管理工具" class="headerlink" title="代码管理工具"></a>代码管理工具</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>svn</code></td>
<td></td>
</tr>
<tr>
<td><strong><code>git</code></strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>gitee</code></strong></td>
<td>码云，国内常用</td>
</tr>
<tr>
<td><strong><code>git hub</code></strong></td>
<td>国外全英文，最火最棒；速度慢，经常打不开</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="原型图"><a href="#原型图" class="headerlink" title="原型图"></a>原型图</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Axure RP</code></td>
<td>快速创建应用软件或Web网站的线框图、流程图、原型和规格说明文档</td>
</tr>
<tr>
<td><code>墨刀</code></td>
<td>移动端原型工具，推荐这个</td>
</tr>
<tr>
<td>Figma</td>
<td>项目团队合作的页面设计，素材库</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>HBuilder</code></td>
<td>HTML开发的工具。快、绿柔护眼、国产</td>
</tr>
<tr>
<td><strong><code>webstorm</code></strong></td>
<td>jetbrains旗下的前端开发工具</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>node.js</code></td>
<td></td>
</tr>
<tr>
<td><strong><code>Vue</code></strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="前端样式框架"><a href="#前端样式框架" class="headerlink" title="前端样式框架"></a>前端样式框架</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>bootstrap</code></td>
<td></td>
</tr>
<tr>
<td><code>layui</code></td>
<td>简约实用，2021.10.13官网下线，但是git上还有</td>
</tr>
<tr>
<td><code>element ui</code></td>
<td></td>
</tr>
<tr>
<td><code>iview</code></td>
<td></td>
</tr>
<tr>
<td><code>vant</code></td>
<td>移动端商城组件</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>VMware</code></td>
<td></td>
</tr>
<tr>
<td><code>Ubuntn</code></td>
<td></td>
</tr>
<tr>
<td><code>Centos</code></td>
<td>7版本常见，服务器用的多</td>
</tr>
<tr>
<td><code>XenServer</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Tomcat</code></strong></td>
<td></td>
</tr>
<tr>
<td><strong><code>Ngnix</code></strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="windows和linux的交互"><a href="#windows和linux的交互" class="headerlink" title="windows和linux的交互"></a>windows和linux的交互</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Xftp</code></td>
<td>windows上将linux服务器内文件可视化界面</td>
</tr>
<tr>
<td><code>WinSCP</code></td>
<td>windows上访问linux，配合putty可以打开命令行</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>MobaXterm_Personal</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Docker</code></strong></td>
<td>原生的docker容器</td>
</tr>
<tr>
<td><code>portainer.io</code></td>
<td>可视化的docker可视化工具，支持中文</td>
</tr>
<tr>
<td>``</td>
<td></td>
</tr>
</tbody></table>
<h2 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>wireshark</td>
<td>可以将某段时间内的所有数据抓包，过滤自己需要的信息</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>postman</code></td>
<td>接口测试工具，英文</td>
</tr>
<tr>
<td><code>apipost</code></td>
<td>接口测试工具，中文</td>
</tr>
<tr>
<td><code>jmeter</code></td>
<td></td>
</tr>
<tr>
<td><code>微信开发者工具</code></td>
<td>开发微信，可以模拟微信浏览器</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="远程连接服务器"><a href="#远程连接服务器" class="headerlink" title="远程连接服务器"></a>远程连接服务器</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>XShell</code></td>
<td>命令行访问</td>
</tr>
<tr>
<td><code>PuTTY</code></td>
<td>配合winscp使用，打开服务器端的命令行</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>FileZilla</code></td>
<td>FTP客户端工具，可以共享文件，本地局域网内</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="远程办公"><a href="#远程办公" class="headerlink" title="远程办公"></a>远程办公</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>VNC</code></td>
<td></td>
</tr>
<tr>
<td><code>向日葵</code></td>
<td>分两个版本，完成远程控制</td>
</tr>
<tr>
<td>``</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Python</code></td>
<td></td>
</tr>
<tr>
<td><code>VS code</code></td>
<td></td>
</tr>
<tr>
<td><strong><code>pycharm</code></strong></td>
<td>jetbrains旗下的python开发工具</td>
</tr>
<tr>
<td>``</td>
<td></td>
</tr>
</tbody></table>
<h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Selenium</td>
<td>自动化测试工具</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    <code>工欲善其事必先利其器</code>，开发中，工具是必不可少的东西，它能帮助我们减轻很多的工作量，让开发变得更容易。工具没有好坏之分，只有适合自己与不适合。以上就是总结的目前所接触过的工具，随着时代的不断发展，工具层出不穷，有新的就会有淘汰旧的，正如逆水行舟，不进则退,只有不断完善自己，开发新功能，才不至于被淘汰。人也是如此，只有不断学习，不断充实自己，才不至于被社会淘汰。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/24/3.%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/" data-id="ckw61sdv10019oswdg28hdpg8" data-title="开发常用软件" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.3.java基础知识附录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/23/4.3.java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%99%84%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-03-23T07:48:20.000Z" itemprop="datePublished">2021-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/23/4.3.java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%99%84%E5%BD%95/">java基础知识附录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h1><p>在计算机内，有符号数有三种表示法：原码，反码，补码。计算机中，所有数据的运算都是采用补码进行的。</p>
<p>原码：二进制定点表示法，即最高位为符号位。0表示正，1表示负，其余位表示数值的大小。</p>
<p>反码：正数的反码与其原码相同。负数的反码是对其原码逐位取反，但符号位除外。</p>
<p>补码：正数的补码与其原码相同。负数的补码是在其反码的末位+1。</p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>浮点数：浮点数是属于有理数中某特定子集的数的数字表示，在计算机中用以近似表示任意某个实数。具体的说，这个实数由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到，这种表示方法类似于基数为10的科学计数法。</p>
<p>一个浮点数a由两个数m和e来表示：a = m × b^e^。（计算机中b一般为2） 尾数就是小数 二进制的小数点和十进制的小数点是不同的。二进制小数点后是2的负幂，十进制是10的负幂。</p>
<p>float类型数字在计算机中用4个字节存储。遵循IEEE-754格式标准：一个浮点数有2部分组成：底数m和指数e</p>
<p>底数部分m: 使用二进制数来表示此浮点数的实际值</p>
<p>指数部分e: 占用8bit的二进制数，可表示数值范围为0-255</p>
<p>​    但是指数可正可负，所以，IEEE规定，此处算出的次方必须减去127才是真正的指数。所以，float类型的指数可从-126到128</p>
<p>​    底数部分实际是占用24bit的一个值，但是最高位始终为1，所以，最高位省去不存储，在存储中占23bit</p>
<p>格式：</p>
<p>SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM</p>
<p>S表示浮点数正负   </p>
<p>E指数加上127后的值得二进制数据，指数位决定了大小范围</p>
<p>M底数，尾数位决定了计算精度</p>
<p>举例：</p>
<p>17.625在内存中的存储</p>
<p>首先要把17.625换算成二进制：10001.101</p>
<p>​    整数部分，除以2，直到商为0，余数反转。</p>
<p>​    小数部分，乘以2，直到乘位0，进位顺序取。</p>
<p>在将10001.101右移，直到小数点前只剩1位：    1.0001101 * 2^4 因为右移动了四位</p>
<p>这个时候，我们的底数和指数就出来了</p>
<p>底数：因为小数点前必为1，所以IEEE规定只记录小数点后的就好。所以，此处的底数为：0001101</p>
<p>指数：实际为4，必须加上127(转出的时候，减去127)，所以为131。也就是10000011</p>
<p>符号部分是正数，所以是0</p>
<p>综上所述，17.625在内存中的存储格式是：</p>
<p>01000001 10001101 00000000 00000000    </p>
<p>float  符号位1bit  指数位e 8bit  尾数位m 23bit  </p>
<p>double 符号位1bit  指数位e 11bit  尾数位m 52bit </p>
<h1 id="boolean占几个字节"><a href="#boolean占几个字节" class="headerlink" title="boolean占几个字节"></a>boolean占几个字节</h1><p>虽然boolean表现出非0即1的“位”特性，但是存储空间的基本计量单位是字节，不是位。所以boolean至少占一个字节。<br>JVM规范中，boolean变量作为int处理，也就是4字节（声明一个基本变量类型时，占4个字节）；boolean数组当做byte数组处理（声明一个数组类型时，数组中的每个元素占1个字节）</p>
<h1 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><table>
<thead>
<tr>
<th>优先级</th>
<th>描述</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>括号</td>
<td>()、[]</td>
</tr>
<tr>
<td>2</td>
<td>正负号</td>
<td>+、-</td>
</tr>
<tr>
<td>3</td>
<td>自增自减，非</td>
<td>++、–、!</td>
</tr>
<tr>
<td>4</td>
<td>乘除，取余</td>
<td>*、/、%</td>
</tr>
<tr>
<td>5</td>
<td>加减</td>
<td>+、-</td>
</tr>
<tr>
<td>6</td>
<td>移位运算</td>
<td>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td>
</tr>
<tr>
<td>7</td>
<td>大小关系</td>
<td>&gt;、&gt;=、&lt;、&lt;=</td>
</tr>
<tr>
<td>8</td>
<td>相等关系</td>
<td>==、!=</td>
</tr>
<tr>
<td>9</td>
<td>按位与</td>
<td>&amp;</td>
</tr>
<tr>
<td>10</td>
<td>按位异或</td>
<td>^</td>
</tr>
<tr>
<td>11</td>
<td>按位或</td>
<td>|</td>
</tr>
<tr>
<td>12</td>
<td>逻辑与</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>13</td>
<td>逻辑或</td>
<td>||</td>
</tr>
<tr>
<td>14</td>
<td>条件运算</td>
<td>?:</td>
</tr>
<tr>
<td>15</td>
<td>赋值运算</td>
<td>=、+=、-=、*=、/=、%=</td>
</tr>
<tr>
<td>16</td>
<td>位赋值运算</td>
<td>&amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</td>
</tr>
</tbody></table>
<p>如果在程序中，要改变运算顺序，可以使用()括起来</p>
<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><p>java语言使用的是Unicode编码。</p>
<p>一般软件中的ANSI指的是对应当前系统 locale 的遗留（legacy）编码。</p>
<p>建议用 Notepad++ 等正常的专业文本编辑器保存为不带 BOM 的 UTF-8。另外，如果文本中所有字符都在 ASCII 范围内，那么其实，记事本保存的所谓的「ANSI」文件，和 ASCII 或无 BOM 的 UTF-8 是一样的。</p>
<p>ASCII码表</p>
<p><img src="file://C:\Users\swx\AppData\Roaming\Typora\typora-user-images\image-20210323162019525.png?lastModify=1618245408" alt="image-20210323162019525"></p>
<p>ASCII码规定最高位必须为0，因此只能有128个，即0~127。</p>
<p>于是需要Unicode（统一码，万国码，单一码）这个东西，就是要把地球上所有的语言的符号，都用<strong>统一的字符集</strong>来表示，一个编码真正做到了唯一，在表示Unicode字符时，通常会用“U+”然后紧跟着一组十六进制的数字来表示。</p>
<p>UTF-8是针对Unicode的一种可变长度字符编码，可以用来表示Unicode标准中的任何字符，而且编码中的第一个字节与ASCII相容。UTF-8使用一至四个字节为每个字符进行编码，汉字一般采用3个字节。</p>
<p>中文网站不需要其他国家的文字出现，用UTF-8进行编码，大多数占用3个字节甚至更多，会造成存储浪费，所以采用一套GB系列的编码，最常用的是GBK。GBK编码英文采用单字节编码，完全兼容ASCII码表，汉字采用2个字节进行编码，范围为0x8140到0xFEFE（剔除xx7F，因为对应的ASCII码表是DEL，意味着要向后删除一个字符）</p>
<p>Unicode定义一个特殊字符�，对应编码为0xFFFD。假如A支持一个特殊字符，但B不支持，在B中就会用�代替。这个字符用UTF-8编码后，十六进制表示为0xEF  0XBF  0XBD，如果连续出现两个符号，即为0xEF  0XBF  0XBD  0xEF  0XBF  0XBD，再转换成GBK码（2个字节一个字符）就成了锟（0xEFBF），斤（0xBDEF），拷（0xBFBD）。出现锟斤拷的原因就是UTF-8转码GBK时出现了问题，至少需要两个字符出现乱码才会出现锟斤拷。</p>
<p>Unicode编码：指的是带有 BOM 的小端序 UTF-16（BOM（byte order mark）也是Unicode标准的一部分，有它特定的适用范围。通常BOM是用来标示Unicode纯文本字节流的，用来提供一种方便的方法让文本处理程序识别读入的.txt文件是哪个Unicode编码（UTF-8，UTF-16BE，UTF-16LE），Linux系统不会识别BOM，直接读取；而windows会先识别，从而会使一些代码加载出问题）</p>
<p>UTF-8编码：指的是带 BOM 的 UTF-8。（对于微软而言）linux系统的UTF-8是不带BOM的，因为他要运行老版本。而windows系统之前是不带BOM的，但是为了考虑兼容性问题，所以以后的UTF-8编码都是带BOM的。（这里推荐使用不带的）</p>
<h1 id="java中的参数传递问题"><a href="#java中的参数传递问题" class="headerlink" title="java中的参数传递问题"></a>java中的参数传递问题</h1><p>基本类型：形式参数的改变对实际参数没有影响。（值传递）</p>
<p>引用类型：形式参数的改变直接影响实际参数。（地址值传递）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/23/4.3.java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%99%84%E5%BD%95/" data-id="ckw61sdvd0024oswdajiy5sr1" data-title="java基础知识附录" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2.2.hexo搭建博客" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/23/2.2.hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time class="dt-published" datetime="2021-03-23T06:44:44.000Z" itemprop="datePublished">2021-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/23/2.2.hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">hexo搭建博客</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="用hexo来搭建一个自己的博客"><a href="#用hexo来搭建一个自己的博客" class="headerlink" title="用hexo来搭建一个自己的博客"></a>用hexo来搭建一个自己的博客</h1><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。</p>
<p>​    个人理解：GitHub上自己申请一个公共的仓库，这个仓库的地址对应的是你的博客地址。通过hexo这个工具将你本地的一些md文档上传到你的github仓库里，这样别人访问你的网站时，相当于是访问了你的仓库，在你的仓库里get到了你写的这些md文档并可以阅读。</p>
<h2 id="hexo的搭建"><a href="#hexo的搭建" class="headerlink" title="hexo的搭建"></a>hexo的搭建</h2><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h3><p>​    git属于版本管理工具的一种，是一种分布式的系统，功能确实很强大，在协作开发中会经常性用到，所以很有必要了解。</p>
<p>windows：到git官网上下载,<a target="_blank" rel="noopener" href="https://gitforwindows.org/">Download git</a>，按照安装步骤安装到本地。下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p>
<p>linux：最早的git就是在linux上编写的，只需要一行代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>安装好后，用<code>git --version</code> 来查看一下版本<br><img src="/image-20210319151950597.png" alt="image-20210319151950597"></p>
<h3 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h3><p>​    Hexo是基于node.JS编写的，所以需要安装一下node.Js和里面的npm工具。这个属于前端一个常用工具，也有必要了解。</p>
<p>windows：<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">nodejs</a>选择LTS版本就行了</p>
<p>linux：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure>

<p>安装完后，打开命令行查看版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>



<p>windows在安装完git后，可以使用git bash命令来代替cmd。</p>
<p><img src="/image-20210319152742280.png" alt="image-20210319152742280"></p>
<h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h3><p>​    安装完git和node后就可以继续安装hexo。hexo就是我们用来管理博客的工具，之后博客的相关命令都是与hexo相关的。</p>
<p>先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开），输入命令（cli是命令行界面）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>用<code>hexo -v</code>查看一下版本</p>
<p><img src="/image-20210319153759391.png" alt="image-20210319153759391"></p>
<p>至此安装完成：git，node，hexo。</p>
<p>接下来初始化一下hexo</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog#这个myblog可以自己取什么名字都行，然后</span><br><span class="line">cd myblog #进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>


<p>新建完成后，指定文件夹目录下有：</p>
<p>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br> _config.yml: 博客的配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>


<p>打开hexo的服务，在浏览器输入localhost:4000就可以看到我们博客的预览图</p>
<p>按CTRL+C就可以把这个server关闭</p>
<h3 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4.GitHub创建个人仓库"></a>4.GitHub创建个人仓库</h3><p>​    github是一个将来很常用的网站，虽然全是英文，但是不影响会有很多优秀的项目，软件需要从GitHub上下载和借鉴，所以掌握并熟用是必须的。注册一个属于自己的GitHub账号是很必需的。</p>
<p>登录GitHub账户后点击你的头像下有一个Your repositories，点击后可以看到你的所有仓库，点击new创建一个和你用户名相同的仓库，后面加.github.io（这里必须要和你用户名相同，只有这样，将来要部署到GitHub page的时候，才会被识别，这是一个大坑）也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。</p>
<h3 id="5-生成SSH添加到GitHub"><a href="#5-生成SSH添加到GitHub" class="headerlink" title="5.生成SSH添加到GitHub"></a>5.生成SSH添加到GitHub</h3><p>​    SSH是一种安全协议，我记得好像在https，服务器连接好多地方看到过。有用户名/密码，也有密钥。</p>
<p>在git bash中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;    #yourname输入你的GitHub用户名</span><br><span class="line">git config --global user.email &quot;youremail&quot;  #youremail输入你GitHub的邮箱</span><br></pre></td></tr></table></figure>

<p>这样GitHub才能知道你是不是对应它的账户。可以在检查一下有没有输对：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br><span class="line"><span class="meta">#</span><span class="bash">创建ssh</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">一路回车，最后提示生成了.ssh的文件夹</span></span><br></pre></td></tr></table></figure>

<p>在电脑中找到.ssh的文件夹：</p>
<p><code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的</p>
<p><code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p>
<p><code>known_hosts</code>是记录你连接过的ip文件</p>
<p>将公钥部署到你的仓库里：在GitHub的头像下点击setting，找到SSH keys的设置选项，点击<code>New SSH key</code><br>把你的<code>id_rsa.pub</code>里面的信息复制进去</p>
<p>在git bash中输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>



<h3 id="6-将hexo部署到GitHub"><a href="#6-将hexo部署到GitHub" class="headerlink" title="6.将hexo部署到GitHub"></a>6.将hexo部署到GitHub</h3><p>​    将hexo和github关联起来主要是修改 _config.yml这个文件的相关内容。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">swx</span>                <span class="comment">#网站的标题名</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;blog&#x27;</span>          <span class="comment">#网站的副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;我的博客&#x27;</span>     <span class="comment">#网站描述。主要用于SEO，告诉搜索引擎一个关于站点的简单描述，通常建议在其中包含网站的关键词。</span></span><br><span class="line"><span class="attr">keywords:</span>                 </span><br><span class="line"><span class="attr">author:</span> <span class="string">swx</span>               <span class="comment">#你的名字。用于主题显示文章的作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>           <span class="comment">#网站使用的语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span>              <span class="comment">#网站的时区。Hexo 默认使用自己电脑的时区、时区列表。比如说：America/New_York, Japan, 和 UTC 。</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">url:</span> <span class="string">https://s-qwer.github.io/</span>         <span class="comment">#你的网站域名</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>   <span class="comment">#文章的永久链接格式。生成某个文章时的那个链接格式：比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是https://s-qwer.github.io/2021/03/18/hexo/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span>                    <span class="comment">#永久链接中各部分的默认值</span></span><br><span class="line"></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span>          <span class="comment">#设置主题在这里，默认的是landscape。当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数为theme文件夹下的文件名就可以</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span> <span class="comment">#这个在后面进行双平台部署的时候会再次用到deploy</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/YourgithubName/YourgithubName.github.io.git</span>   <span class="comment">#YourgithubName就是你的GitHub账户</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span>                   <span class="comment">#分支</span></span><br></pre></td></tr></table></figure>

<p>接下来需要先安装<code>deploy-git</code> ，也就是部署的命令,这样你才能用命令部署到GitHub</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">hexo clean      #清除了之前生成的东西，也可以不加,相当于把public这个文件夹删除了</span><br><span class="line">hexo generate   #生成静态文章，可以用 hexo g缩写</span><br><span class="line">hexo deploy     #部署文章，可以用hexo d缩写 </span><br><span class="line"><span class="meta">#</span><span class="bash">注意deploy时可能要你输入username和password，这是一个很痛苦的过程，每次都需要输入用户名/密码，可以在网上找解决方式。最后我找了一种用git而不是https的方式。repo：git@github.com:s-qwer/s-qwer.github.io.git</span></span><br></pre></td></tr></table></figure>

<p>现在就可以在<code>http://yourname.github.io</code> 这个网站看到自己的博客</p>
<h3 id="7-设置个人域名"><a href="#7-设置个人域名" class="headerlink" title="7.设置个人域名"></a>7.设置个人域名</h3><p>​    域名这个东西相当于是一个网址的后缀名。域名是从后往前算的，依次是一级二级。。。常见的一级域名有.com,.cn,.org你可以在域名查询系统里查询这个域名是否可用，像一些比较火的域名，可能被人先注册的，你如果需要使用就需要花钱。也可以在网上找一些免费的域名。这个东西也只是作为一个标识，本质上还是指向了你的GitHub的仓库里的那个项目的文件。</p>
<p>现在你的个人网站的地址是 yourname.github.io，如果觉得这个网址不太彳亍，就需要你设置个人域名了。</p>
<p>在你的域名控制台中点解析，添加解析。192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。注意，解析线路选择默认。</p>
<p>登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名</p>
<p>然后在你的博客文件source中创建一个名为CNAME文件，不要后缀。写上你的域名。</p>
<p>最后，在git bash中，输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d    #后两个命令也可以合并为 hexo d -g    hexo g -d  效果是一样的</span><br></pre></td></tr></table></figure>

<h3 id="8-发布文章"><a href="#8-发布文章" class="headerlink" title="8.发布文章"></a>8.发布文章</h3><p>接下来就可以正式开始写文章并发布。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo new newpapername      #这里的newpapername就是你要写的文章的标题名，可以是中文，英文</span><br><span class="line"><span class="meta">#</span><span class="bash">然后在<span class="built_in">source</span>/_post中就会生成一个md文件 打开这个markdown文件，就可以开始编辑写自己的文章了。当你写完的时候，再</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line"><span class="meta">#</span><span class="bash">接下来就可以在你设置好的域名访问到你的博客了</span></span><br></pre></td></tr></table></figure>

<h3 id="9-Front-matter"><a href="#9-Front-matter" class="headerlink" title="9.Front-matter"></a>9.Front-matter</h3><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>layout</code></td>
<td>布局</td>
</tr>
<tr>
<td><code>title</code></td>
<td>标题</td>
</tr>
<tr>
<td><code>date</code></td>
<td>建立日期</td>
</tr>
<tr>
<td><code>updated</code></td>
<td>更新日期</td>
</tr>
<tr>
<td><code>comments</code></td>
<td>开启文章的评论功能</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>标签（不适用于分页）</td>
</tr>
<tr>
<td><code>categories</code></td>
<td>分类（不适用于分页）</td>
</tr>
<tr>
<td><code>permalink</code></td>
<td>覆盖文章网址</td>
</tr>
</tbody></table>
<p>分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>



<h5 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h5><p>当你每一次使用代码  <code>hexo new paper</code>  它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。</p>
<p>Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径。而自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td><code>post</code></td>
<td><code>source/_posts</code></td>
</tr>
<tr>
<td><code>page</code></td>
<td><code>source</code></td>
</tr>
<tr>
<td><code>draft</code></td>
<td><code>source/_drafts</code></td>
</tr>
</tbody></table>
<p>而new这个命令其实是：<code>hexo new [layout] &lt;title&gt;</code>  只不过这个layout默认是post罢了。</p>
<p>page<br>如果你想另起一页，那么可以使用<code>hexo new page board</code>  系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是<a target="_blank" rel="noopener" href="http://xxx.xxx/board">http://xxx.xxx/board</a></p>
<p>draft<br>draft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以<code>hexo new draft newpage</code>  这样会在source/_draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用<code>hexo server --draft</code>  在本地端口中开启服务预览。</p>
<p>如果你的草稿文件写完了，想要发表到post中，<code>hexo publish draft newpage</code>  就会自动把newpage.md发送到post中。</p>
<h3 id="10-更换主题"><a href="#10-更换主题" class="headerlink" title="10.更换主题"></a>10.更换主题</h3><p>可以在<a target="_blank" rel="noopener" href="https://hexo.io/themes/">主题网站</a>上探索你喜欢的主题，然后点击主题的名字，会直接跳转到GitHub上，直接下载下来，然后放到theme文件夹下就行了，（也可以使用git bash命令： <code>git clone 跳转的网址地址</code>，这样会在theme文件夹下自动生成相应的文件夹）然后再在刚才说的配置文件中把theme换成那个主题文件夹的名字，它就会自动在theme文件夹中搜索你配置的主题。</p>
<p>而后进入你下载好的主题文件夹，可以看到里面也有一个配置文件config.xml，貌似它默认是config.xml.example，把它复制一份，重命名为_config.xml就可以了。这个配置文件是修改你整个主题的配置文件。</p>
<h3 id="11-遇到的坑"><a href="#11-遇到的坑" class="headerlink" title="11.遇到的坑"></a>11.遇到的坑</h3><p>​    严格按照步骤进行的操作，可以直接访问到了自己的博客网址。记录下自己遇到的坑：</p>
<p>​    1.因为没有按照说明输入自己的用户名作为博客的网址，从而一直报错，所以按照教程步骤一步一步来复现还是很有必要的。    </p>
<p>​    2.上传的第一篇文章的标题格式没有搞对，于是删除了本地的文件，重新加了title：+文章名字 之后上传就开始一直报错，这期间我不断进行：hexo clean 、hexo d -g的循环操作，而且需要一直输入用户名密码，被折磨了很多次之后，查了相关教程，发现hexo s可以本地预生成，访问localhost：4000可以访问，然后继续进行clean和g -d的循环操作，还是一直出错。最后看了一篇关于简化不用输入那么多次密码的方法教学，把rep里的https改为了git@之后，提交，部署一气呵成。nice！所以有的教程里面推荐rep写https也有的是直接写git格式，原理都是一样的，用的协议不一样，个人感觉git格式更方便一些，同样也是可以连接到仓库的地址。<code>repo：git@github.com:s-qwer/s-qwer.github.io.git</code>   <code>repo: git@github.com:s-qwer/s-qwer.github.io.git</code></p>
<p>​    3.因为修改时，有些配置没有起作用，这里还有个坑，就是相关的配置<code>：</code>后面必须有一个空格！</p>
<p>​    4. <code>数据类型[][]  数组名=new  数据类型[][]&#123;&#123; 元素1，元素2，.... &#125;, &#123; 元素1，元素2，.... &#125;, &#123; 元素1，元素2，.... &#125;&#125;;</code> 这个字段hexo d -g 的时候一直报错：expected name as lookup value, got .   </p>
<p>改为：<code>数据类型[][]  数组名=new  数据类型[][]&#123;&#123; 元素1,元素2... &#125;, &#123; 元素1,元素2... &#125;, &#123; 元素1,元素2... &#125;&#125;;</code> 仍然报错： expected variable end  （应为变量结尾）</p>
<p>改为：<code>数据类型[] []  数组名=new  数据类型[] []&#123;&#123; 元素1,元素2...元素n &#125;, &#123; 元素1,元素2... 元素n&#125;, &#123; 元素1,元素2...元素n &#125; &#125; ;</code></p>
<p>放弃了，加了个引用就不报错了。</p>
<p>​    5.卸载了node，重新安装npm之后，hexo命令找不到。重新安装了一下hexo，可以正常提交了。</p>
<p>​    6.提交报错：</p>
<p><img src="/2.hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20210601181054370.png" alt="image-20210601181054370"></p>
<p>错误说明：YAMLException: unidentified alias “<em>title</em>*:”</p>
<p>解决方法：将*去掉不再报错</p>
<p>​    7.提交报错：</p>
<p><img src="/2.hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20210601181222745.png" alt="image-20210601181222745"></p>
<p>错误说明：Error [Nunjucks Error]: _posts/8.6.VUE.md [Line 520, Column 159] expected name as lookup value, got .</p>
<p>原因猜测：是正文里面出现了多次<code>&#123;% %&#125;</code>这样的语句，网上解释说是Nunjucks引擎会把它解释为其它意思</p>
<p>解决方法：在大括号前加上\转义字符即可。我的解决方法是将内容变为代码块。</p>
<h2 id="hexo的完善"><a href="#hexo的完善" class="headerlink" title="hexo的完善"></a>hexo的完善</h2><h3 id="图片显示问题"><a href="#图片显示问题" class="headerlink" title="图片显示问题"></a>图片显示问题</h3><p>​    将文章<code>hexo d -g</code>之后去网站上查看，发现图片都无法显示。</p>
<p>在md文件中插入图片的语法为<code>![]()</code>。</p>
<p>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。</p>
<p>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。</p>
<p>网络路径就是直接引用网上的图片，直接复制图片地址，放在圆括号中就完事了。</p>
<p>这种方式十分的方便，但是也存在一定的问题：</p>
<ul>
<li>图片失效导致无法加载；</li>
<li>打开网页后要再请求加载图片；</li>
<li>原网站限制，如微信公众号的图片会变得不可见等。</li>
</ul>
<p>这种方式算是有利有弊。</p>
<p>绝对路径是图片在计算机中的绝对位置，相对路径是相对于当前文件的路径。</p>
<p>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。</p>
<p>在hexo中使用<strong>文章资源文件夹</strong>需要在<code>config.yaml</code>文件中更改一下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>当该配置被应用后，使用<code>hexo new</code>命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。</p>
<p>由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。<br>如在一个文件目录下，博客名为<code>1.md</code>，相应的存在一个<code>1</code>文件夹存放图片<code>image.jpg</code>。<br>在Typora编辑器中，普通的md文件使用<code>![](1/image.jpg)</code>能在编辑器中正常显示图片。<br>在hexo中，按理说应该是使用<code>![](image.jpg)</code>，但网页中却无法正常显示。<br>此时应该使用这样的方式来引入图片：<code>&#123;% asset_img image.jpg 这是一张图片 %&#125;</code></p>
<p>虽然可以正常引用图片了，但是这种引用图片的方式只有一句话能形容，wtf。</p>
<h4 id="图片插件"><a href="#图片插件" class="headerlink" title="图片插件"></a><strong>图片插件</strong></h4><p>插件<a href="https://link.zhihu.com/?target=https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>解决了这个问题。可以只用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在<code>config.yaml</code>中更改配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>之后就可以在使用<code>![](image.jpg)</code>的方式愉快的插入图片了。</p>
<p>我们做了这么多都是为了方便，那么为什么不再方便一点呢。</p>
<h4 id="hexo与Typora的完美结合"><a href="#hexo与Typora的完美结合" class="headerlink" title="hexo与Typora的完美结合"></a><strong>hexo与Typora的完美结合</strong></h4><p>上述是从文章资源文件夹中引用图片，前提是<strong>先将图片放入到文章资源文件夹</strong>，如果图片数量众多的话，一张一张的放很影响效率。但是不用怕，我们有很方便的解决方法。</p>
<p><strong>Typora</strong>是我非常喜欢的Markdown文本编辑器，在之前的文章中也介绍过一点。</p>
<p>Typora对于插入图片的支持做得非常好，在<code>文件-&gt;偏好设置</code>或者直接<code>&lt;C-,&gt;</code>进入设置。</p>
<p><img src="/v2-52220b2dba6901ee2181b72951d25a7b_720w.jpg" alt="img"></p>
<p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p>
<p>如复制网络路径的图片<code>https://...../image.jpg</code>粘贴到Typora中叫<code>文章名</code>的文章后，图片会自动变为<code>![](文章名/image.jpg)</code>。</p>
<p>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的<code>文件名/</code>。不慌，也很简单。</p>
<p>在Typora编辑器中，使用<code>&lt;C-f&gt;</code>快捷键，将所有的<code>文章名/</code>替换为空即可删除。</p>
<p><img src="/v2-9202796d27f4659d96ff13b11e6808c1_720w.png" alt="img"></p>
<p>然后再将博客上传，图片就会随着文章一起打包。在网页中就可以看到正常显示的图片，大功告成</p>
<h3 id="多台电脑使用"><a href="#多台电脑使用" class="headerlink" title="多台电脑使用"></a>多台电脑使用</h3><p>使用场景：希望公司、家里电脑都能正常使用，电脑升级更新环境</p>
<ul>
<li>使用网盘或其他方式同步hexo源文件； — git很容易搞定</li>
<li>创建两个repo分别管理站点和源文件；— 没有必要，可以利用git分支</li>
</ul>
<p>这里使用git分支来管理站点、源文件的方式</p>
<p>Hexo生产的静态博客的特点，首先它是一个静态博客生成工具，可以根据你的配置和md文件生成一系列的html、css、js等文件，组成一个站点，部署到github pages，这样网站就可以访问了。</p>
<p>完成hexo的部署命令，其实hexo帮助我们做的事情就是：</p>
<ol>
<li>生成站点有关文件到 <code>.deploy_git</code></li>
<li>把它初始化为git目录，并根据你的配置指定remote和branch(一般是master)</li>
<li>进行<code>git commit</code>，并把修改push到指定的remote branch</li>
<li>命令执行完成后，到github仓库，发现master分支上的内容其实就和’.deploy_git’中一样</li>
</ol>
<p>按照教程建站完成部署后，你的本地源文件其实都没有同步到github，所以只需要想办法把源文件同步即可。最简单的方式就是在你的xx.github.io repo中创建一个source分支，管理源文件，对源文件的修改注意commit/push即可</p>
<p>步骤如下：</p>
<ol>
<li><p>给源文件目录初始化git，并增加remote</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br><span class="line">git remote <span class="keyword">add</span> origin https:<span class="comment">//github.com/xx/xx.github.io // 填入你的repo地址</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建分支<code>source</code>，commit/push</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">source</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;add source&#x27;</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure></li>
<li><p>ok，可以在github上把<code>source</code>设置为主分支。其他电脑上只需clone你的.io repo，切换到<code>source</code>分支操作即可。</p>
</li>
<li><p>初次clone需要切换到<code>source</code>分支，并执行<code>npm install</code>，初始化hexo有关的依赖。</p>
</li>
</ol>
<p>因为服务器上的项目无法创建分支，所以出现了错误，暂时不能跑通。</p>
<h3 id="换电脑-重装系统"><a href="#换电脑-重装系统" class="headerlink" title="换电脑/重装系统"></a>换电脑/重装系统</h3><p>​    如果准备换电脑或者重装系统，那么我们的md文件和相关配置怎么保存或者重新设置呢。</p>
<p>​    以上，就是搭建的全过程了，借鉴了很多文章，很多内容都是复制粘贴下来的，为了给自己以后再次搭建时一个步骤说明。这些只是一些基础的功能，保证了自己写的文章可以被保存在服务器上。hexo还有很多功能我目前没有用到，包括一些互动功能，git分支，国内外分流，SEO等。以后用到了再去查查相关资料完善吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/23/2.2.hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" data-id="ckw61sdw4004boswdewdpdwqa" data-title="hexo搭建博客" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-10.2.项目架构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/23/10.2.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-03-23T04:02:26.000Z" itemprop="datePublished">2021-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/23/10.2.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/">PO,BO,VO，DTO,DAO与POJO</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>UML</strong></p>
<p>不想多讨论 UML 相关的知识，但是我觉得你如果真的会写 Java，请先学会表达自己，UML 就是你说话的语言，做一名优秀的 Java 程序员，请至少学会这两种 UML 图：</p>
<ol>
<li>类图</li>
<li>时序图</li>
</ol>
<p><strong>clean code</strong></p>
<p>我认为保持代码的简洁和可读性是代码的最基本保证，如果有一天为了程序的效率而降低了这两点，我认为是可以谅解的，除此之外，没有任何理由可以让你任意挥霍你的代码。</p>
<ol>
<li>读者可以看一下 Robert C. Martin 出版的《Clean Code》（代码整洁之道） 这本书</li>
<li>可以参考美团文章聊聊 clean code（<a target="_blank" rel="noopener" href="http://tech.meituan.com/clean-code.html%EF%BC%89%EF%BC%9B">http://tech.meituan.com/clean-code.html）；</a></li>
<li>也可以看一下阿里的 Java 编码规范</li>
</ol>
<p>无论如何，请保持你的代码的整洁。</p>
<p><strong>Linux 基础命令</strong></p>
<p>这点其实和会写 Java 没有关系，但是 Linux 很多时候确实承载运行 Java 的容器，请学好 Linux 的基础命令。</p>
<ol>
<li>参考鸟哥的《Linux私房菜》</li>
</ol>
<p>PO：persistent object 持久对象</p>
<p>1 ．有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。</p>
<p>2 ．在hibernate持久化框架中与insert/delet操作密切相关。</p>
<p>3 ．PO中不应该包含任何对数据库的操作。</p>
<hr>
<p>POJO ：plain ordinary java object 无规则简单java对象</p>
<p>一个中间对象，可以转化为PO、DTO、VO。</p>
<p>1 ．POJO持久化之后==〉PO</p>
<p>（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。）</p>
<p>2 ．POJO传输过程中==〉DTO</p>
<p>3 ．POJO用作表示层==〉VO</p>
<p>PO 和VO都应该属于它。</p>
<hr>
<p>BO：business object 业务对象</p>
<p>业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。</p>
<p>比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。</p>
<p>建立一个对应简历的BO对象处理简历，每个BO包含这些PO。</p>
<p>这样处理业务逻辑时，我们就可以针对BO去处理。</p>
<p>封装业务逻辑为一个对象（可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用）。</p>
<p>关于BO主要有三种概念</p>
<p>1 、只包含业务对象的属性；</p>
<p>2 、只包含业务方法；</p>
<p>3 、两者都包含。</p>
<p>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。</p>
<hr>
<p>VO：value object 值对象 / view object 表现层对象</p>
<p>1 ．主要对应页面显示（web页面/swt、swing界面）的数据对象。</p>
<p>2 ．可以和表对应，也可以不，这根据业务的需要。</p>
<hr>
<p>DTO（TO）：Data Transfer Object 数据传输对象</p>
<p>1 ．用在需要跨进程或远程传输时，它不应该包含业务逻辑。</p>
<p>2 ．比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</p>
<hr>
<p>DAO：data access object数据访问对象</p>
<p>1 ．主要用来封装对DB的访问（CRUD操作）。</p>
<p>2 ．通过接收Business层的数据，把POJO持久化为PO。</p>
<p>简易的关系图：</p>
<p><img src="https://img-blog.csdn.net/20180717104224284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4NzA1NDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="偷的图"></p>
<p>为什么偷来这么一篇文章：不同的对象需要用在不同的地方，之前全是POJO，现在传输用DTO，条件查询用BO，查询对象用POJO接收，显示对象用VO，虽然增加了一点代码量，但是代码结构更加清晰，也防止了表结构的暴露。</p>
<p>个人理解：</p>
<p>po，数据库表字段，一个字段对应一个po</p>
<p>dto，数据传输对象，是从数据库表中查询出来的自定义数据封装。</p>
<p>vo，表现层对象，前端页面显示时所需要的所有数据。由dto组装成vo</p>
<p>如果传输的dto刚好是前端表示所需要的值，此时dto也就是vo。</p>
<p>entity里的每一个字段，与数据库相对应，vo里的每一个字段，是和你前台页面相对应， 而dto，是用类做entity和dto之间转换的实体类。</p>
<p>说到代码结构问题，业务分层</p>
<p>所以一个好的应用分层需要具备以下几点：</p>
<ul>
<li><p>方便后续代码进行维护扩展</p>
</li>
<li><p>分层的效果需要让整个团队都接受</p>
</li>
<li><p>各个层职责边界清晰</p>
</li>
</ul>
<p>阿里规范</p>
<p>在阿里的编码规范中约束的分层如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQqEAgWRiaA1sb6iaWDTyVBe5YWiaWLRS0C3lEialHhbeOLTMr9BgzLjU6t0ghaTurqHcfWdvGYicklpWjw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>①开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</p>
<p>②终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</p>
<p>③Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</p>
<p>④Service 层：相对具体的业务逻辑服务层。</p>
<p>⑤Manager 层：通用业务处理层。</p>
<p>它有如下特征:</p>
<p>对第三方平台封装的层，预处理返回结果及转化异常信息。</p>
<p>对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。</p>
<p>与 DAO 层交互，对多个 DAO 的组合复用。</p>
<p>⑥DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。</p>
<p>下面介绍一下具体业务中应该如何实现分层。</p>
<p>优化分层</p>
<p>从我们的业务开发中总结了一个较为的理想模型,这里要先说明一下由于我们的 RPC 框架选用的是 Thrift 可能会比其他的一些 RPC 框架例如 Dubbo 会多出一层，作用和 controller 层类似。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQqEAgWRiaA1sb6iaWDTyVBe5YLVITibODXlsqmh5EMetyNYuicbmiaCQzOc5Lb0RGbzjSwxiczcpaLXmIgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>最上层 Controller 和 TService 是阿里分层规范里面的第一层：轻业务逻辑，参数校验，异常兜底。</p>
<p>通常这种接口可以轻易更换接口类型，所以业务逻辑必须要轻，甚至不做具体逻辑。</p>
<p>①Service：业务层，复用性较低，这里推荐每一个 Controller 方法都得对应一个 Service，不要把业务编排放在 Controller 中去做，为什么呢？</p>
<p>如果我们把业务编排放在 Controller 层去做的话，如果以后我们要接入 Thrift，我们这里又需要把业务编排在做一次，这样会导致我们每接入一个入口层这个代码都得重新复制一份。</p>
<p>如下图所示： </p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQqEAgWRiaA1sb6iaWDTyVBe5YnWJTmEDkawjyZZNLy1aSbz1A3E4ib5rbLkkuIOwQZRAichZWh0aCTP6Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这样大量的重复工作必定会导致我们开发效率下降，所以我们需要把业务编排逻辑都得放进 Service 中去做：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQqEAgWRiaA1sb6iaWDTyVBe5YsUB1r8UL3x5iauKkpk7rLdECodQBZ52hVJsWbPWctKSIx4TAsJksmDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Mannager：可复用逻辑层。这里的 Mannager 可以是单个服务的，比如我们的 Cache，MQ 等等，当然也可以是复合的。</p>
<p>当你需要调用多个 Mannager 的时候，这个可以合为一个 Mannager，比如逻辑上的连表查询等。如果是 httpMannager 或 rpcMannager 需要在这一层做一些数据转换。</p>
<p>③DAO：数据库访问层。主要负责“操作数据库的某张表，映射到某个 Java 对象”，DAO 应该只允许自己的 Service 访问，其他 Service 要访问我的数据必须通过对应的 Service。</p>
<p>分层领域模型的转换</p>
<p>在阿里巴巴编码规约中列举了下面几个领域模型规约：</p>
<p>DO（Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 </p>
<p>DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。 </p>
<p>BO（Business Object）：业务对象。由 Service 层输出的封装业务逻辑的对象。 </p>
<p>AO（Application Object）：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。 </p>
<p>VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。 </p>
<p>Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用 Map 类来传输。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQqEAgWRiaA1sb6iaWDTyVBe5YtqYj5Lx0AiatXmOuibRLUjL7aCTMWHrZBRUpqx6jAG8UCdPjegDFDE0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>每一个层基本都自己对应的领域模型，这样就导致了有些人过于追求每一层都是用自己的领域模型。</p>
<p>这样就导致了一个对象可能会出现 3 次甚至 4 次转换在一次请求中，当返回的时候同样也会出现 3-4 次转换，这样有可能一次完整的请求-返回会出现很多次对象转换。</p>
<p>如果在开发中真的按照这么来，恐怕就别写其他的了，一天就光写这个重复无用的逻辑算了吧</p>
<p>所以我们得采取一个折中的方案：</p>
<p>允许 Service/Manager 可以操作数据领域模型，对于这个层级来说，本来自己做的工作也是做的是业务逻辑处理和数据组装。 </p>
<p>Controller/TService 层的领域模型不允许传入 DAO 层，这样就不符合职责划分了。 </p>
<p>同理，不允许 DAO 层的数据传入到 Controller/TService。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQqEAgWRiaA1sb6iaWDTyVBe5Yba2L0Glia9PTaWIiadLeRJIzEJAicTjf5Ky9wwb3YZibIdGdzTqgClUNgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>bean 使我们使用最多的模型之一</p>
<p><strong>domain 包名</strong></p>
<p>根据很多 Java 程序员的”经验”来看，一个数据库表则对应着一个 domain 对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是 domain。但是你错了，domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的，所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为:com.xxx.entity。</p>
<p><strong>DTO</strong></p>
<p>数据传输我们应该使用 DTO 对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端 API 设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候(input or output)，这些对象成为 DTO 对象。</p>
<p>请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是 DTO 对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到 OMS 或者 ERP 系统，这些对接的返回值以及入参也叫 DTO 对象。</p>
<p>我们约定某对象如果是 DTO 对象，就将名称改为 XXDTO，比如订单下发OMS：OMSOrderInputDTO。</p>
<p><strong>DTO 转化</strong></p>
<p>正如我们所知，DTO 为系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转化为 BO 对象或者是普通的 entity 对象，让 service 层去处理。</p>
<p><strong>场景</strong></p>
<p>比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;v1&#x2F;api&#x2F;user&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class UserApi &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public User addUser(UserInputDTO userInputDTO)&#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setUsername(userInputDTO.getUsername());</span><br><span class="line">        user.setAge(userInputDTO.getAge());</span><br><span class="line"></span><br><span class="line">        return userService.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只关注一下上述代码中的转化代码，其他内容请忽略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user &#x3D; new User();</span><br><span class="line">user.setUsername(userInputDTO.getUsername());</span><br><span class="line">user.setAge(userInputDTO.getAge());</span><br></pre></td></tr></table></figure>

<p><strong>请使用工具</strong></p>
<p>上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有 20 个字段，我们要如何做呢？ 一个一个进行 set 数据吗？当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。</p>
<p>网上有很多工具，支持浅拷贝或深拷贝的 Utils。举个例子，我们可以使用 org.springframework.beans.BeanUtils#copyProperties 对代码进行重构和优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">public User addUser(UserInputDTO userInputDTO)&#123;</span><br><span class="line">    User user &#x3D; new User();</span><br><span class="line">    BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line"></span><br><span class="line">    return userService.addUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanUtils.copyProperties 是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。如果你在做 DTO 转化的时候一直使用 set 进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰!</p>
<p><strong>转化的语义</strong></p>
<p>上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写 Java 代码时，更多的需要考虑语义的操作，再看上边的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user &#x3D; new User();</span><br><span class="line">BeanUtils.copyProperties(userInputDTO,user);</span><br></pre></td></tr></table></figure>

<p>虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好，所以代码改成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line"> public User addUser(UserInputDTO userInputDTO)&#123;</span><br><span class="line">         User user &#x3D; convertFor(userInputDTO);</span><br><span class="line"></span><br><span class="line">         return userService.addUser(user);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private User convertFor(UserInputDTO userInputDTO)&#123;</span><br><span class="line"></span><br><span class="line">         User user &#x3D; new User();</span><br><span class="line">         BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line">         return user;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user &#x3D; convertFor(userInputDTO);</span><br><span class="line">return userService.addUser(user);</span><br></pre></td></tr></table></figure>

<p>这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。</p>
<p><strong>抽象接口定义</strong></p>
<p>当实际工作中，完成了几个 API 的 DTO 转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。</p>
<p>如果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。</p>
<p>看一下抽象后的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface DTOConvert&lt;S,T&gt; &#123;</span><br><span class="line">    T convert(S s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的 Java 程序员，请为你想做的抽象接口，做好泛型吧。</p>
<p>我们再来看接口实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class UserInputDTOConvert implements DTOConvert &#123;</span><br><span class="line">@Override</span><br><span class="line">public User convert(UserInputDTO userInputDTO) &#123;</span><br><span class="line">User user &#x3D; new User();</span><br><span class="line">BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line">return user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;v1&#x2F;api&#x2F;user&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class UserApi &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public User addUser(UserInputDTO userInputDTO)&#123;</span><br><span class="line">        User user &#x3D; new UserInputDTOConvert().convert(userInputDTO);</span><br><span class="line"></span><br><span class="line">        return userService.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>review code</strong></p>
<p>如果你是一个优秀的 Java 程序员，我相信你应该和我一样，已经数次重复 review 过自己的代码很多次了。</p>
<p>我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的，所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">public UserOutputDTO addUser(UserInputDTO userInputDTO)&#123;</span><br><span class="line">        User user &#x3D; new UserInputDTOConvert().convert(userInputDTO);</span><br><span class="line">        User saveUserResult &#x3D; userService.addUser(user);</span><br><span class="line">        UserOutputDTO result &#x3D; new UserOutDTOConvert().convertToUser(saveUserResult);</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样你的 API 才更健全。</p>
<p>不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的 Java 程序员，请看一下这段我们刚刚抽象完的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user &#x3D; new UserInputDTOConvert().convert(userInputDTO);</span><br></pre></td></tr></table></figure>

<p>你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢，看一下我的聚合结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class UserInputDTO &#123;</span><br><span class="line">private String username;</span><br><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public User convertToUser()&#123;</span><br><span class="line">        UserInputDTOConvert userInputDTOConvert &#x3D; new UserInputDTOConvert();</span><br><span class="line">        User convert &#x3D; userInputDTOConvert.convert(this);</span><br><span class="line">        return convert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class UserInputDTOConvert implements DTOConvert&lt;UserInputDTO,User&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public User convert(UserInputDTO userInputDTO) &#123;</span><br><span class="line">            User user &#x3D; new User();</span><br><span class="line">            BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line">            return user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 API 中的转化则由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user &#x3D; new UserInputDTOConvert().convert(userInputDTO);</span><br><span class="line">User saveUserResult &#x3D; userService.addUser(user);</span><br></pre></td></tr></table></figure>

<p>变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user &#x3D; userInputDTO.convertToUser();</span><br><span class="line">User saveUserResult &#x3D; userService.addUser(user);</span><br></pre></td></tr></table></figure>

<p>我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。</p>
<p><strong>再查工具类</strong></p>
<p>再来看 DTO 内部转化的代码，它实现了我们自己定义的 DTOConvert 接口，但是这样真的就没有问题，不需要再思考了吗？</p>
<p>我觉得并不是，对于 Convert 这种转化语义来讲，很多工具类中都有这样的定义，这中 Convert 并不是业务级别上的接口定义，它只是用于普通 bean 之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有 Convert 转化语义的代码。</p>
<p>我仔细阅读了一下 GUAVA 的源码，发现了 com.google.common.base.Convert 这样的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Converter&lt;A, B&gt; implements Function&lt;A, B&gt; &#123;</span><br><span class="line">    protected abstract B doForward(A a);</span><br><span class="line">    protected abstract A doBackward(B b);</span><br><span class="line">    &#x2F;&#x2F;其他略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以了解到，GUAVA 中的 Convert 可以完成正向转化和逆向转化，继续修改我们 DTO 中转化的这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static class UserInputDTOConvert implements DTOConvert&lt;UserInputDTO,User&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public User convert(UserInputDTO userInputDTO) &#123;</span><br><span class="line">                User user &#x3D; new User();</span><br><span class="line">                BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line">                return user;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static class UserInputDTOConvert extends Converter&lt;UserInputDTO, User&gt; &#123;</span><br><span class="line">         @Override</span><br><span class="line">         protected User doForward(UserInputDTO userInputDTO) &#123;</span><br><span class="line">                 User user &#x3D; new User();</span><br><span class="line">                 BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line">                 return user;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         protected UserInputDTO doBackward(User user) &#123;</span><br><span class="line">                 UserInputDTO userInputDTO &#x3D; new UserInputDTO();</span><br><span class="line">                 BeanUtils.copyProperties(user,userInputDTO);</span><br><span class="line">                 return userInputDTO;</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的 UserInputDTO 和 UserOutputDTO 都转成 UserDTO 展示给大家。</p>
<p>DTO：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class UserDTO &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">            return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">            this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">            return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public User convertToUser()&#123;</span><br><span class="line">            UserDTOConvert userDTOConvert &#x3D; new UserDTOConvert();</span><br><span class="line">            User convert &#x3D; userDTOConvert.convert(this);</span><br><span class="line">            return convert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UserDTO convertFor(User user)&#123;</span><br><span class="line">            UserDTOConvert userDTOConvert &#x3D; new UserDTOConvert();</span><br><span class="line">            UserDTO convert &#x3D; userDTOConvert.reverse().convert(user);</span><br><span class="line">            return convert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected User doForward(UserDTO userDTO) &#123;</span><br><span class="line">                    User user &#x3D; new User();</span><br><span class="line">                    BeanUtils.copyProperties(userDTO,user);</span><br><span class="line">                    return user;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            protected UserDTO doBackward(User user) &#123;</span><br><span class="line">                    UserDTO userDTO &#x3D; new UserDTO();</span><br><span class="line">                    BeanUtils.copyProperties(user,userDTO);</span><br><span class="line">                    return userDTO;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line"> public UserDTO addUser(UserDTO userDTO)&#123;</span><br><span class="line">         User user &#x3D;  userDTO.convertToUser();</span><br><span class="line">         User saveResultUser &#x3D; userService.addUser(user);</span><br><span class="line">         UserDTO result &#x3D; userDTO.convertFor(saveResultUser);</span><br><span class="line">         return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的 DTO 对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; &#123;</span><br><span class="line">         @Override</span><br><span class="line">         protected User doForward(UserDTO userDTO) &#123;</span><br><span class="line">                 User user &#x3D; new User();</span><br><span class="line">                 BeanUtils.copyProperties(userDTO,user);</span><br><span class="line">                 return user;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         protected UserDTO doBackward(User user) &#123;</span><br><span class="line">                 throw new AssertionError(&quot;不支持逆向转化方法!&quot;);</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看一下 doBackward 方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了。</p>
<p>关于异常处理的更详细介绍，可以参考我之前的文章：如何优雅的设计 Java 异常（<a target="_blank" rel="noopener" href="http://lrwinx.github.io/2016/04/28/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8/%EF%BC%89">http://lrwinx.github.io/2016/04/28/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8/）</a> ，应该可以帮你更好的理解异常。</p>
<p><strong>bean 的验证</strong></p>
<p>如果你认为我上边写的那个添加用户 API 写的已经非常完美了，那只能说明你还不是一个优秀的程序员。我们应该保证任何数据的入参到方法体内都是合法的。</p>
<p><strong>为什么要验证</strong></p>
<p>很多人会告诉我，如果这些 API 是提供给前端进行调用的，前端都会进行验证啊，你为什还要验证？</p>
<p>其实答案是这样的，我从不相信任何调用我 API 或者方法的人，比如前端验证失败了，或者某些人通过一些特殊的渠道(比如 Charles 进行抓包)，直接将数据传入到我的 API，那我仍然进行正常的业务逻辑处理，那么就有可能产生脏数据！</p>
<p>“对于脏数据的产生一定是致命”，这句话希望大家牢记在心，再小的脏数据也有可能让你找几个通宵！</p>
<p><strong>jsr 303验证</strong></p>
<p>hibernate 提供的 jsr 303 实现，我觉得目前仍然是很优秀的，具体如何使用，我不想讲，因为谷歌上你可以搜索出很多答案!</p>
<p>再以上班的 API 实例进行说明，我们现在对 DTO 数据进行检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class UserDTO &#123;</span><br><span class="line">    @NotNull</span><br><span class="line">    private String username;</span><br><span class="line">    @NotNull</span><br><span class="line">    private int age;</span><br><span class="line">        &#x2F;&#x2F;其他代码略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>API 验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">    public UserDTO addUser(@Valid UserDTO userDTO)&#123;</span><br><span class="line">            User user &#x3D;  userDTO.convertToUser();</span><br><span class="line">            User saveResultUser &#x3D; userService.addUser(user);</span><br><span class="line">            UserDTO result &#x3D; userDTO.convertFor(saveResultUser);</span><br><span class="line">            return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要将验证结果传给前端，这种异常应该转化为一个 api 异常(带有错误码的异常)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">public UserDTO addUser(@Valid UserDTO userDTO, BindingResult bindingResult)&#123;</span><br><span class="line">     checkDTOParams(bindingResult);</span><br><span class="line"></span><br><span class="line">     User user &#x3D;  userDTO.convertToUser();</span><br><span class="line">     User saveResultUser &#x3D; userService.addUser(user);</span><br><span class="line">     UserDTO result &#x3D; userDTO.convertFor(saveResultUser);</span><br><span class="line">     return result;</span><br><span class="line">&#125;</span><br><span class="line">private void checkDTOParams(BindingResult bindingResult)&#123;</span><br><span class="line">     if(bindingResult.hasErrors())&#123;</span><br><span class="line">             &#x2F;&#x2F;throw new 带验证码的验证错误异常</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BindingResult 是 Spring MVC 验证 DTO 后的一个结果集，可以参考spring 官方文档（<a target="_blank" rel="noopener" href="http://spring.io/%EF%BC%89%E3%80%82">http://spring.io/）。</a></p>
<p>检查参数后，可以抛出一个“带验证码的验证错误异常”，具体异常设计可以参考如何优雅的设计 Java 异常（<a target="_blank" rel="noopener" href="http://lrwinx.github.io/2016/04/28/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8/%EF%BC%89%E3%80%82">http://lrwinx.github.io/2016/04/28/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8/）。</a></p>
<p><strong>拥抱 lombok</strong></p>
<p>上边的 DTO 代码，已经让我看的很累了，我相信读者也是一样，看到那么多的 Getter 和 Setter 方法，太烦躁了，那时候有什么方法可以简化这些呢。</p>
<p>请拥抱 lombok,它会帮助我们解决一些让我们很烦躁的问题</p>
<p><strong>去掉 Setter 和 Getter</strong></p>
<p>其实这个标题，我不太想说，因为网上太多，但是因为很多人告诉我，他们根本就不知道 lombok 的存在，所以为了让读者更好的学习，我愿意写这样一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">public class UserDTO &#123;</span><br><span class="line">    @NotNull</span><br><span class="line">    private String username;</span><br><span class="line">    @NotNull</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public User convertToUser()&#123;</span><br><span class="line">        UserDTOConvert userDTOConvert &#x3D; new UserDTOConvert();</span><br><span class="line">        User convert &#x3D; userDTOConvert.convert(this);</span><br><span class="line">        return convert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UserDTO convertFor(User user)&#123;</span><br><span class="line">        UserDTOConvert userDTOConvert &#x3D; new UserDTOConvert();</span><br><span class="line">        UserDTO convert &#x3D; userDTOConvert.reverse().convert(user);</span><br><span class="line">        return convert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected User doForward(UserDTO userDTO) &#123;</span><br><span class="line">            User user &#x3D; new User();</span><br><span class="line">            BeanUtils.copyProperties(userDTO,user);</span><br><span class="line">            return user;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected UserDTO doBackward(User user) &#123;</span><br><span class="line">            throw new AssertionError(&quot;不支持逆向转化方法!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吧，烦人的 Getter 和 Setter 方法已经去掉了。</p>
<p>但是上边的例子根本不足以体现 lombok 的强大。我希望写一些网上很难查到，或者很少人进行说明的 lombok 的使用以及在使用时程序语义上的说明。</p>
<p>比如:@Data,@AllArgsConstructor,@NoArgsConstructor..这些我就不进行一一说明了，请大家自行查询资料。</p>
<p><strong>bean 中的链式风格</strong></p>
<p>什么是链式风格？我来举个例子，看下面这个 Student 的 bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student setAge(int age) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看一下 set 方法，这样的设置便是 chain 的 style，调用的时候，可以这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student student &#x3D; new Student()</span><br><span class="line">        .setAge(24)</span><br><span class="line">        .setName(&quot;zs&quot;);</span><br></pre></td></tr></table></figure>

<p>相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用 lombok 进行改善呢，请使用 @Accessors(chain = true)，看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了一个对于 bean 来讲很友好的链式操作。</p>
<p><strong>静态构造方法</strong></p>
<p>静态构造方法的语义和简化程度真的高于直接去 new 一个对象。比如 new 一个 List 对象，过去的使用是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>看一下 guava 中的创建方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Lists.newArrayList();</span><br></pre></td></tr></table></figure>

<p>Lists 命名是一种约定(俗话说：约定优于配置)，它是指 Lists 是 List 这个类的一个工具类，那么使用 List 的工具类去产生 List，这样的语义是不是要比直接 new 一个子类来的更直接一些呢，答案是肯定的，再比如如果有一个工具类叫做 Maps，那你是否想到了创建 Map 的方法呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; objectObjectHashMap &#x3D; Maps.newHashMap();</span><br></pre></td></tr></table></figure>

<p>好了，如果你理解了我说的语义，那么，你已经向成为 Java 程序员更近了一步了。</p>
<p>再回过头来看刚刚的 Student，很多时候，我们去写 Student 这个 bean 的时候，他会有一些必输字段，比如 Student 中的 name 字段，一般处理的方式是将 name 字段包装成一个构造方法，只有传入 name 这样的构造方法，才能创建一个 Student 对象。</p>
<p>接上上边的静态构造方法和必传参数的构造方法，使用 lombok 将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">@RequiredArgsConstructor(staticName &#x3D; &quot;ofName&quot;)</span><br><span class="line">public class Student &#123;</span><br><span class="line">    @NonNull private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student &#x3D; Student.ofName(&quot;zs&quot;);</span><br></pre></td></tr></table></figure>

<p>这样构建出的 bean 语义是否要比直接 new 一个含参的构造方法(包含 name 的构造方法)要好很多。</p>
<p>当然，看过很多源码以后，我想相信将静态构造方法 ofName 换成 of 会先的更加简洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">@RequiredArgsConstructor(staticName &#x3D; &quot;of&quot;)</span><br><span class="line">public class Student &#123;</span><br><span class="line">        @NonNull private String name;</span><br><span class="line">        private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student &#x3D; Student.of(&quot;zs&quot;);</span><br></pre></td></tr></table></figure>

<p>当然他仍然是支持链式调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student &#x3D; Student.of(&quot;zs&quot;).setAge(24);</span><br></pre></td></tr></table></figure>

<p>这样来写代码，真的很简洁，并且可读性很强。</p>
<p><strong>使用 builder</strong></p>
<p>Builder 模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。</p>
<p>今天其实要说的是一种变种的 builder 模式，那就是构建 bean 的 builder 模式，其实主要的思想是带着大家一起看一下 lombok 给我们带来了什么。</p>
<p>看一下 Student 这个类的原始 builder 状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">            return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Builder builder()&#123;</span><br><span class="line">            return new Builder();</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Builder&#123;</span><br><span class="line">            private String name;</span><br><span class="line">            private int age;</span><br><span class="line">            public Builder name(String name)&#123;</span><br><span class="line">                    this.name &#x3D; name;</span><br><span class="line">                    return this;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public Builder age(int age)&#123;</span><br><span class="line">                    this.age &#x3D; age;</span><br><span class="line">                    return this;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public Student build()&#123;</span><br><span class="line">                    Student student &#x3D; new Student();</span><br><span class="line">                    student.setAge(age);</span><br><span class="line">                    student.setName(name);</span><br><span class="line">                    return student;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student &#x3D; Student.builder().name(&quot;zs&quot;).age(24).build();</span><br></pre></td></tr></table></figure>

<p>这样的 builder 代码，让我是在恶心难受，于是我打算用 lombok 重构这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Builder</span><br><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student &#x3D; Student.builder().name(&quot;zs&quot;).age(24).build();</span><br></pre></td></tr></table></figure>

<p><strong>代理模式</strong></p>
<p>正如我们所知的，在程序中调用 rest 接口是一个常见的行为动作，如果你和我一样使用过 spring 的 RestTemplate，我相信你会我和一样，对他抛出的非 http 状态码异常深恶痛绝。<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247486759&idx=2&sn=6769d8ff9d163babe726b6213c6d15e4&chksm=eb538811dc240107bcf2a6e65b5381b2a68175af8ff12f4e2c1b0a06f7d16850db4acb64a18e&scene=21#wechat_redirect">详解 Java 中的三种代理模式</a>。</p>
<p>所以我们考虑将 RestTemplate 最为底层包装器进行包装器模式的设计：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FilterRestTemplate implements RestOperations &#123;</span><br><span class="line">        protected volatile RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">        protected FilterRestTemplate(RestTemplate restTemplate)&#123;</span><br><span class="line">                this.restTemplate &#x3D; restTemplate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;实现RestOperations所有的接口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再由扩展类对 FilterRestTemplate 进行包装扩展：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ExtractRestTemplate extends FilterRestTemplate &#123;</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    public ExtractRestTemplate(RestTemplate restTemplate) &#123;</span><br><span class="line">            super(restTemplate);</span><br><span class="line">            this.restTemplate &#x3D; restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; RestResponseDTO&lt;T&gt; postForEntityWithNoException(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables)</span><br><span class="line">                    throws RestClientException &#123;</span><br><span class="line">            RestResponseDTO&lt;T&gt; restResponseDTO &#x3D; new RestResponseDTO&lt;T&gt;();</span><br><span class="line">            ResponseEntity&lt;T&gt; tResponseEntity;</span><br><span class="line">            try &#123;</span><br><span class="line">                    tResponseEntity &#x3D; restTemplate.postForEntity(url, request, responseType, uriVariables);</span><br><span class="line">                    restResponseDTO.setData(tResponseEntity.getBody());</span><br><span class="line">                    restResponseDTO.setMessage(tResponseEntity.getStatusCode().name());</span><br><span class="line">                    restResponseDTO.setStatusCode(tResponseEntity.getStatusCodeValue());</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                    restResponseDTO.setStatusCode(RestResponseDTO.UNKNOWN_ERROR);</span><br><span class="line">                    restResponseDTO.setMessage(e.getMessage());</span><br><span class="line">                    restResponseDTO.setData(null);</span><br><span class="line">            &#125;</span><br><span class="line">            return restResponseDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包装器 ExtractRestTemplate 很完美的更改了异常抛出的行为，让程序更具有容错性。在这里我们不考虑 ExtractRestTemplate 完成的功能，让我们把焦点放在 FilterRestTemplate 上，“实现 RestOperations 所有的接口”,这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时,如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FilterRestTemplate implements RestOperations &#123;</span><br><span class="line"></span><br><span class="line">    protected volatile RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    protected FilterRestTemplate(RestTemplate restTemplate) &#123;</span><br><span class="line">            this.restTemplate &#x3D; restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123;</span><br><span class="line">            return restTemplate.getForObject(url,responseType,uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException &#123;</span><br><span class="line">            return restTemplate.getForObject(url,responseType,uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException &#123;</span><br><span class="line">            return restTemplate.getForObject(url,responseType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123;</span><br><span class="line">            return restTemplate.getForEntity(url,responseType,uriVariables);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;其他实现代码略。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用 lombok 提供的代理注解优化了我的代码(@Delegate)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">public abstract class FilterRestTemplate implements RestOperations &#123;</span><br><span class="line">    @Delegate</span><br><span class="line">    protected volatile RestTemplate restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几行代码完全替代上述那些冗长的代码。</p>
<p>是不是很简洁，做一个拥抱 lombok 的程序员吧。</p>
<h3 id="工具类的设计"><a href="#工具类的设计" class="headerlink" title="工具类的设计"></a>工具类的设计</h3><p>工具类：存放了某一类事物存放工具方法的类。封装了一些常用Java操作方法,便于重复开发利用</p>
<p>　　命名：XxxUtil，XxxUtils，XxxTool，XxxHelper，XxxHelpers等　　比如：JdbcUtil</p>
<p>工具类存放的包：存放工具类</p>
<p>　　命名：util，utils，tool，helper，helpers等</p>
<p>工具类如何设计？</p>
<p>工具在开发中只需要存在一份即可</p>
<p>　　1）如果工具类没有使用static修饰，说明工具方法要用工具类的对象来调用。</p>
<p>　　　　此时把工具类设计成单例模式。</p>
<p>　　2）如果工具类使用static修饰，说明工具方法只需要用工具类的类名来调用即可。</p>
<p>　　　　此时必须把工具类的构造方法私有化（防止工具类的对象来调用静态方法）。</p>
<p>一般首选第二种，简单，在JDK中提供的工具类都是第二种。如java.Util.Arrays类。</p>
<p>1.如果工具类中的方法全部是静态方法，那么可以将工具类作为一个 abstract 抽象类。Spring 框架中存在大量的这样的使用。</p>
<p>2.如果工具类中有异常，请抛出，不要自己去 try-catch。更不要 try 了之后 e.printStackTrace() 。</p>
<p>3.工具类中要不要打印日志问题，尽量不要打印，像 log4j 这样的一些第三方日志框架也不要用。降低于第三方类库的依赖。</p>
<p>4.工具类中的方法非 static 的。那你可以将工具类定义为 final class，考虑到工具类应该不能被继承。在私有化它的构造函数，提供一个单例。</p>
<p>5.工具类的命名应该用 Util 结尾，例如 LogUtil。</p>
<p>工具类中的方法应该设计为静态的还是非静态的，这个没有统一的标准。各有各的好，参加大多数开源框架，static 的多一些。</p>
<p>工具类的设计，推荐大家多看看 Guava、Apache Commons。</p>
<p>像大名鼎鼎的 Hutool，它提到了工具类的 6 大设计思想：</p>
<p>​    方法优先于对象、自动识别优于用户定义、便捷性与灵活性并存、适配与兼容、可选依赖原则、无侵入原则。</p>
<p>Hutool 中的工具类，既没有采用抽象类 abstract class 有没有采用 final class。所以我更喜欢 Spring、Guava、Apache Commons等框架的源码。</p>
<h3 id="权限的设计"><a href="#权限的设计" class="headerlink" title="权限的设计"></a>权限的设计</h3><p>权限控制主要分为两块，认证（Authentication）与授权（Authorization）。认证之后确认了身份正确，业务系统就会进行授权，现在业界比较流行的模型就是RBAC（Role-Based Access Control）。</p>
<p>RBAC包含为下面四个要素：用户、角色、权限、资源。用户是源头，资源是目标，用户绑定至角色，资源与权限关联，最终将角色与权限关联，就形成了比较完整灵活的权限控制模型。<br>资源是最终需要控制的标的物，但是我们在一个业务系统中要将哪些元素作为待控制的资源呢？我将系统中待控制的资源分为三类：</p>
<ol>
<li>URL访问资源（接口以及网页）</li>
<li>界面元素资源（增删改查导入导出的按钮，重要的业务数据展示与否等）</li>
<li>数据资源</li>
</ol>
<p> <img src="/10.2.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/597441af5c636b2fd27fb36c603a80d0.JPEG" alt="img"></p>
<p>用户对应角色，（用户多的时候可以用用户组扩展），角色对应多个权限，权限对应多个资源（每个资源都有各自的表和其维护表），权限操作需要有记录表</p>
<p>现在业内普遍的实现方案实际上很粗放，就是单纯的“<strong>菜单控制</strong>”，通过菜单显示与否来达到控制权限的目的。<br>我仔细分析过，现在大家做的平台分为To C和To B两种：</p>
<ol>
<li>To C一般不会有太多的复杂权限控制，甚至大部分连菜单控制都不用，全部都可以访问。</li>
<li>To B一般都不是开放的，只要做好认证关口，能够进入系统的只有内部员工。大部分企业内部的员工互联网知识有限，而且作为内部员工不敢对系统进行破坏性的尝试。</li>
</ol>
<p>所以针对现在的情况，考虑成本与产出，大部分设计者也不愿意在权限上进行太多的研发力量。<br>菜单和界面元素一般都是由前端编码配合存储数据实现，URL访问资源的控制也有一些框架比如SpringSecurity，Shiro。<br>目前我还没有找到过数据权限控制的框架或者方法，所以自己整理了一份。</p>
<h2 id="数据权限控制原理"><a href="#数据权限控制原理" class="headerlink" title="数据权限控制原理"></a>数据权限控制原理</h2><p>数据权限控制最终的效果是会要求在同一个数据请求方法中，根据不同的权限返回不同的数据集，而且无需并且不能由研发编码控制。这样大家的第一想法应该就是AOP，拦截所有的底层方法，加入过滤条件。这样的方式兼容性较强，但是复杂程度也会更高。我们这套系统中，采用的是利用Mybatis的plugin机制，在底层SQL解析时替换增加过滤条件。<br>这样一套控制机制存在很明显的优缺点，首先缺点：</p>
<ol>
<li>适用性有限，基于底层的Mybatis。</li>
<li>方言有限，针对了某种数据库（我们使用Mysql），而且由于需要在底层解析处理条件所以有可能造成不同的数据库不能兼容。当然Redis和NoSQL也无法限制。</li>
</ol>
<p>当然，假如你现在就用Mybatis，而且数据库使用的是Mysql，这方面就没有太大影响了。</p>
<p>接下来说说优点：</p>
<ol>
<li>减少了接口数量及接口复杂度。原本针对不同的角色，可能会区分不同的接口或者在接口实现时利用流程控制逻辑来区分不同的条件。有了数据权限控制，代码中只用写基本逻辑，权限过滤由底层机制自动处理。</li>
<li>提高了数据权限控制的灵活性。例如原本只有主管能查本部门下组织架构/订单数据，现在新增助理角色，能够查询本部门下组织架构，不能查询订单。这样的话普通的写法就需要调整逻辑控制，使用数据权限控制的话，直接修改配置就好。</li>
</ol>
<h2 id="数据权限实现"><a href="#数据权限实现" class="headerlink" title="数据权限实现"></a>数据权限实现</h2><p>上一节就提及了实现原理，是基于Mybatis的plugins<a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins">（查看官方文档）</a>实现。</p>
<blockquote>
<p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：<br>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)<br>ParameterHandler (getParameterObject, setParameters)<br>ResultSetHandler (handleResultSets, handleOutputParameters)<br>StatementHandler (prepare, parameterize, batch, update, query)</p>
</blockquote>
<p>Mybatis的插件机制目前比较出名的实现应该就是<a target="_blank" rel="noopener" href="https://github.com/pagehelper/Mybatis-PageHelper">PageHelper</a>项目了，在做这个实现的时候也参考了PageHelper项目的实现方式。所以权限控制插件的类命名为PermissionHelper。<br>机制是依托于Mybatis的plugins机制，实际SQL处理的时候基于jsqlparser这个包。<br>设计中包含两个类，一个是保存角色与权限的实体类命名为PermissionRule，一个是根据实体变更底层SQL语句的主体方法类PermissionHelper。</p>
<p>首先来看下PermissionRule的结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(PermissionRule.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * codeName&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 适用角色列表&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 格式如: ,RoleA,RoleB,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String roles;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * codeValue&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 主实体，多表联合</span></span><br><span class="line"><span class="comment">     * 格式如: ,SystemCode,User,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String fromEntity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * codeDesc&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 过滤表达式字段, &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;&#123;uid&#125;&lt;/code&gt;会自动替换为当前用户的userId&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;&#123;me&#125;&lt;/code&gt; main entity 主实体名称</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;&#123;me.a&#125;&lt;/code&gt; main entity alias 主实体别名</span></span><br><span class="line"><span class="comment">     * 格式如：</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;userId = &#123;uid&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;(userId = &#123;uid&#125; AND authType &gt; 3)&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;((userId = &#123;uid&#125; AND authType) &gt; 3 OR (dept in (select dept from depts where manager.id = &#123;uid&#125;)))&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String exps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * codeShowName&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 规则说明</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ruleComment;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完这个结构，基本能够理解设计的思路了。数据结构中保存如下几个字段：</p>
<ul>
<li>角色列表：需要使用此规则的角色，可以多个，使用英文逗号隔开。</li>
<li>实体列表：对应的规则应用的实体（这里指的是表结构中的表名，可能你的实体是驼峰而数据库是蛇形，所以这里要放蛇形那个），可以多个，使用英文逗号隔开。</li>
<li><strong>表达式</strong>：表达式就是数据权限控制的核心了。简单的说这里的表达式就是一段SQL语句，其中设置了一些可替换值，底层会用对应运行时的变量替换对应内容，从而达到增加条件的效果。</li>
<li>规则说明：单纯的一个说明字段。</li>
</ul>
<p><strong>核心流程</strong><br>系统启动时，首先从数据库加载出所有的规则。底层利用插件机制来拦截所有的查询语句，进入查询拦截方法后，首先根据当前用户的权限列表筛选出PermissionRule列表，然后循环列表中的规则，对语句中符合实体列表的表进行条件增加，最终生成处理后的SQL语句，退出拦截器，Mybatis执行处理后SQL并返回结果。</p>
<p>讲完PermissionRule，再来看看PermissionHelper，首先是头：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;),</span></span><br><span class="line"><span class="meta">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionHelper</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头部只是标准的Mybatis拦截器写法，注解中的Signature决定了你的代码对哪些方法拦截，update实际上针对<strong>修改（Update）、删除（Delete）</strong>生效，query是对<strong>查询（Select）</strong>生效。</p>
<p>下面给出针对<em>Select</em>注入查询条件限制的完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">processSelectSql</span><span class="params">(String sql, List&lt;PermissionRule&gt; rules, UserDefaultZimpl principal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String replaceSql = <span class="keyword">null</span>;</span><br><span class="line">        Select select = (Select) CCJSqlParserUtil.parse(sql);</span><br><span class="line">        PlainSelect selectBody = (PlainSelect) select.getSelectBody();</span><br><span class="line">        String mainTable = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (selectBody.getFromItem() <span class="keyword">instanceof</span> Table) &#123;</span><br><span class="line">            mainTable = ((Table) selectBody.getFromItem()).getName().replace(<span class="string">&quot;`&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectBody.getFromItem() <span class="keyword">instanceof</span> SubSelect) &#123;</span><br><span class="line">            replaceSql = processSelectSql(((SubSelect) selectBody.getFromItem()).getSelectBody().toString(), rules, principal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ValidUtil.isEmpty(replaceSql)) &#123;</span><br><span class="line">            sql = sql.replace(((SubSelect) selectBody.getFromItem()).getSelectBody().toString(), replaceSql);</span><br><span class="line">        &#125;</span><br><span class="line">        String mainTableAlias = mainTable;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mainTableAlias = selectBody.getFromItem().getAlias().getName();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;当前sql中， &quot;</span> + mainTable + <span class="string">&quot; 没有设置别名&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String condExpr = <span class="keyword">null</span>;</span><br><span class="line">        PermissionRule realRuls = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (PermissionRule rule :</span><br><span class="line">                rules) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object roleStr :</span><br><span class="line">                    principal.getRoles()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rule.getRoles().indexOf(<span class="string">&quot;,&quot;</span> + roleStr + <span class="string">&quot;,&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rule.getFromEntity().indexOf(<span class="string">&quot;,&quot;</span> + mainTable + <span class="string">&quot;,&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 若主表匹配规则主体，则直接使用本规则</span></span><br><span class="line">                        realRuls = rule;</span><br><span class="line"></span><br><span class="line">                        condExpr = rule.getExps().replace(<span class="string">&quot;&#123;uid&#125;&quot;</span>, UserDefaultUtil.getUserId().toString()).replace(<span class="string">&quot;&#123;bid&#125;&quot;</span>, UserDefaultUtil.getBusinessId().toString()).replace(<span class="string">&quot;&#123;me&#125;&quot;</span>, mainTable).replace(<span class="string">&quot;&#123;me.a&#125;&quot;</span>, mainTableAlias);</span><br><span class="line">                        <span class="keyword">if</span> (selectBody.getWhere() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            selectBody.setWhere(CCJSqlParserUtil.parseCondExpression(condExpr));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            AndExpression and = <span class="keyword">new</span> AndExpression(selectBody.getWhere(), CCJSqlParserUtil.parseCondExpression(condExpr));</span><br><span class="line">                            selectBody.setWhere(and);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String joinTable = <span class="keyword">null</span>;</span><br><span class="line">                        String joinTableAlias = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Join j :</span><br><span class="line">                                selectBody.getJoins()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (rule.getFromEntity().indexOf(<span class="string">&quot;,&quot;</span> + ((Table) j.getRightItem()).getName() + <span class="string">&quot;,&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="comment">// 当主表不能匹配时，匹配所有join，使用符合条件的第一个表的规则。</span></span><br><span class="line">                                realRuls = rule;</span><br><span class="line">                                joinTable = ((Table) j.getRightItem()).getName();</span><br><span class="line">                                joinTableAlias = j.getRightItem().getAlias().getName();</span><br><span class="line"></span><br><span class="line">                                condExpr = rule.getExps().replace(<span class="string">&quot;&#123;uid&#125;&quot;</span>, UserDefaultUtil.getUserId().toString()).replace(<span class="string">&quot;&#123;bid&#125;&quot;</span>, UserDefaultUtil.getBusinessId().toString()).replace(<span class="string">&quot;&#123;me&#125;&quot;</span>, joinTable).replace(<span class="string">&quot;&#123;me.a&#125;&quot;</span>, joinTableAlias);</span><br><span class="line">                                <span class="keyword">if</span> (j.getOnExpression() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    j.setOnExpression(CCJSqlParserUtil.parseCondExpression(condExpr));</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    AndExpression and = <span class="keyword">new</span> AndExpression(j.getOnExpression(), CCJSqlParserUtil.parseCondExpression(condExpr));</span><br><span class="line">                                    j.setOnExpression(and);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;当前sql没有join的部分！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (realRuls == <span class="keyword">null</span>) <span class="keyword">return</span> sql; <span class="comment">// 没有合适规则直接退出。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sql.indexOf(<span class="string">&quot;limit ?,?&quot;</span>) != -<span class="number">1</span> &amp;&amp; select.toString().indexOf(<span class="string">&quot;LIMIT ? OFFSET ?&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sql = select.toString().replace(<span class="string">&quot;LIMIT ? OFFSET ?&quot;</span>, <span class="string">&quot;limit ?,?&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sql = select.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSQLParserException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;change sql error .&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重点思路</strong><br>重点其实就在于Sql的解析和条件注入，使用开源项目<a target="_blank" rel="noopener" href="https://github.com/JSQLParser/JSqlParser">JSqlParser</a>。</p>
<ul>
<li>解析出MainTable和JoinTable。from之后跟着的称为MainTable，join之后跟着的称为JoinTable。这两个就是我们PermissionRule需要匹配的表名，<em>PermissionRule::fromEntity</em>字段。</li>
<li>解析出MainTable的where和JoinTable的on后面的条件。使用and连接原本的条件和待注入的条件，<em>PermissionRule::exps</em>字段。</li>
<li>使用当前登录的用户信息（放在缓存中），替换条件表达式中的值。</li>
<li>某些情况需要忽略权限，可以考虑使用ThreadLocal（单机）/Redis（集群）来控制。</li>
</ul>
<p>想要达到无感知的数据权限控制，只有机制控制这么一条路。本文选择的是通过底层拦截Sql语句，并且针对对应表注入条件语句这么一种做法。应该是非常经济的做法，只是基于文本处理，不会给系统带来太大的负担，而且能够达到理想中的效果。大家也可以提出其他的见解和思路</p>
<h2 id="电商项目"><a href="#电商项目" class="headerlink" title="电商项目"></a>电商项目</h2><h4 id="SPU表"><a href="#SPU表" class="headerlink" title="SPU表"></a>SPU表</h4><p><img src="/10.2.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/image-20210820094429308.png" alt="image-20210820094429308"></p>
<p>标题（商品名称），副标题（商品描述），几个ID（所属的目录），是否上架，是否有效，添加时间，删除时间。</p>
<h4 id="SKU表"><a href="#SKU表" class="headerlink" title="SKU表"></a>SKU表</h4><p><img src="/10.2.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/image-20210820094502744.png" alt="image-20210820094502744"></p>
<p>spu_id，商品标题，图片（多个以，分开），销售价格，参数，是否有效，创建时间和修改时间。</p>
<h4 id="kind表"><a href="#kind表" class="headerlink" title="kind表"></a>kind表</h4><p>商品的种类，上级菜单分类</p>
<h4 id="订单号的生成"><a href="#订单号的生成" class="headerlink" title="订单号的生成"></a>订单号的生成</h4><p>常见的订单基本都14-20位，(年月日时分秒和随机数)基本上就有14位</p>
<p>要求：</p>
<p>1.全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。<br>2.趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。<br>3.单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。<br>4.信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</p>
<p>123对应三类不同的场景，3和4需求还是互斥的，无法使用同一个方案满足</p>
<p>所以ID生产系统：</p>
<p>1.平均延迟和TP999延迟都要尽可能低；<br>2.可用性5个9；<br>3.高QPS。</p>
<p>考虑客户体验：</p>
<p>1.订单号无重复性；<br>2.如果方便客服的话，最好是“日期+自增数”样式的订单号，客服一看便知道订单是否在退货保障期限内容；<br>3.订单号长度尽量保持短（10位以内），方便用户，尤其电话投诉时，长的号码报错几率高，影响客服效率；<br>4.订单号尽量保持数字型(纯整数)，在数据库订单索引查询中，长整数字型的数据索引与检索效率，远远高于文本型，因此尽量避免“字母+数字字符串式”！</p>
<p>在复杂的分布式系统中，很多场景需要的都是全局唯一ID的场景，一般为了防止冲突可以考虑的有36位的UUID,twitter的snowflake（雪花算法）等。</p>
<ol>
<li>UUID, 组成：当前日期+时间+时钟序列+机器识别号（Mac地址或其他）没有mac网卡的话会有别的东西识别。在分布式系统中，所有元素（WEB服务器）都不需要通过中央控制端来判断数据唯一性。几十年之内可以达到全球唯一性。</li>
<li>Mysql通过AUTO_INCREMENT实现、Oracle通过Sequence序列实现。在数据库集群环境下，不同数据库节点可设置不同起步值、相同步长来实现集群下生产全局唯一、递增ID</li>
<li>Snowflake算法 雪花算法。41位时间戳+10位机器ID+12位序列号（自增） 转化长度为18位的长整型。Twitter为满足美秒上万条消息的创建，且ID需要趋势递增，方便客户端排序。Snowflake虽然有同步锁，但是比uuid效率高。</li>
<li>Redis自增ID。实现了incr(key)用于将key的值递增1，并返回结果。如果key不存在，创建默认并赋值为0。 具有原子性，保证在并发的时候。</li>
<li>拼接应用所在的网络ip。或者应用所在的端口号。或者进程ID。或者以上的组合保证唯一。</li>
</ol>
<p>例：</p>
<p>0/1:0为游客下单，1为公司下单</p>
<ul>
<li>商户ID的传入(传入商户ID是为了防止重复订单的，但是不起作用)</li>
<li>毫秒仅保留三位(缩减长度同时保证应用切换不存在重复的可能)</li>
<li>使用线程安全的计数器做数字递增(三位数最低保证并发800不重复,代码中我给了4位)</li>
<li>更换日期转换为java8的日期类以格式化(线程安全及代码简洁性考量) </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 订单号生成(NEW) **&#x2F;</span><br><span class="line">private static final AtomicInteger SEQ &#x3D; new AtomicInteger(1000);</span><br><span class="line">private static final DateTimeFormatter DF_FMT_PREFIX &#x3D; DateTimeFormatter.ofPattern(&quot;yyMMddHHmmssSS&quot;);</span><br><span class="line">private static ZoneId ZONE_ID &#x3D; ZoneId.of(&quot;Asia&#x2F;Shanghai&quot;);</span><br><span class="line">public static String generateOrderNo()&#123;</span><br><span class="line">    LocalDateTime dataTime &#x3D; LocalDateTime.now(ZONE_ID);</span><br><span class="line">    if(SEQ.intValue()&gt;9990)&#123;</span><br><span class="line">        SEQ.getAndSet(1000);</span><br><span class="line">    &#125;</span><br><span class="line">    return  dataTime.format(DF_FMT_PREFIX)+SEQ.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>雪花算法：100万个ID 耗时２秒</p>
<p><img src="/10.2.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/01888770c8f84b1df258ddd1d424535c68559.png@1112w_282h_80q" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> START_STMP = <span class="number">1530795377086L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分占用的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号占用的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> SEQUENCE_BIT = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器标识占用的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据中心占用的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATACENTER_BIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_DATACENTER_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATACENTER_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_MACHINE_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_SEQUENCE = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分向左的位移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据中心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> machineId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上一次时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastStmp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">(<span class="keyword">long</span> datacenterId, <span class="keyword">long</span> machineId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;datacenterId can&#x27;t be greater than MAX_DATACENTER_NUM or less than 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;machineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">        <span class="keyword">this</span>.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生下一个ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currStmp = getNewstmp();</span><br><span class="line">        <span class="keyword">if</span> (currStmp &lt; lastStmp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currStmp == lastStmp) &#123;</span><br><span class="line">            <span class="comment">//相同毫秒内，序列号自增</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line">            <span class="comment">//同一毫秒的序列数已经达到最大</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">                currStmp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不同毫秒内，序列号置为0</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastStmp = currStmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">                <span class="comment">//时间戳部分</span></span><br><span class="line">                currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT</span><br><span class="line">                <span class="comment">//数据中心部分</span></span><br><span class="line">                | datacenterId &lt;&lt; DATACENTER_LEFT</span><br><span class="line">                <span class="comment">//机器标识部分</span></span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT</span><br><span class="line">                <span class="comment">//序列号部分</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mill = getNewstmp();</span><br><span class="line">        <span class="keyword">while</span> (mill &lt;= lastStmp) &#123;</span><br><span class="line">            mill = getNewstmp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNewstmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IdWorker snowFlake = <span class="keyword">new</span> IdWorker(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="一致性和性能的思考"><a href="#一致性和性能的思考" class="headerlink" title="一致性和性能的思考"></a>一致性和性能的思考</h2><p>1、性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案</p>
<p>2、掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题</p>
<p>3、失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案</p>
<p>4、订阅变更日志的思想，本质是把权威数据源（例如 MySQL）当做 leader 副本，让其它异质系统（例如 Redis / Elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致</p>
<h2 id="项目的思考"><a href="#项目的思考" class="headerlink" title="项目的思考"></a>项目的思考</h2><p>1.如果前端需要多个DTO，而不同业务的DTO有99%可以复用，我是需要根据业务生成多个DTO（一个接口一个DTO）传还是都复用一个DTO（多个接口公用一个DTO，虽然很多属性没有用到）？</p>
<p>答：</p>
<p>2.向项目里使用新技术时，我在加的时候是否需要重写之前的方法以适用新技术？这是否违反了开闭原则？</p>
<p>答：</p>
<p>3.如果业务里只有一个方法需要处理，需要等待这个方法的结果再返回给前端，还是异步这个方法，交给其他线程去处理？哪种客户体验更好？</p>
<p>答：</p>
<p>4.web端项目后端怎么主动发消息给前端？前端可能关闭了网页则连接就断了</p>
<p>答：</p>
<p>5.延时处理：过期自动收货，到期自动删除？</p>
<p>答：</p>
<p>6.springboot项目的DTO和VO的分类？Controller层、Service层代码应该放什么？Service层的接口是否真的有必要？</p>
<p>7.业务代码里重复的方法太多，不知道怎么提取公共部分，如果提取了公共部分，一些切面就无法执行，如果为了执行再加切面，是否会影响性能？如果存在两个方法的大致逻辑都一样，只是一些不一样，我该怎么抽取公共？比如说一个方法A，参数是1，业务里根据参数1查对应的表得出11，在根据11继续逻辑；方法B，参数是2，业务里根据参数2查对应的表得出22，在根据22继续逻辑。11和22是不同的表，我该怎么抽取公共代码？</p>
<p>8.功能重要还是性能重要？比如加一个新东西可以实现某项功能，但是会严重消耗性能，我该怎么取舍？（这个功能可能有用可能鸡肋，这个功能和性能的平衡点在哪）</p>
<p>9.对于一个新功能或者新技术的引用，可能会耗费大量时间，在这期间产品不会更新或者进度很慢，是否值得？（怎么向老板解释长时间不出活是为了后期更高的性能）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/23/10.2.%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/" data-id="ckw61sdx2006ooswdffn8f6jz" data-title="PO,BO,VO，DTO,DAO与POJO" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-10.1.项目初建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/23/10.1.%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%BB%BA/" class="article-date">
  <time class="dt-published" datetime="2021-03-23T03:09:18.000Z" itemprop="datePublished">2021-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/23/10.1.%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%BB%BA/">项目初建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>​    程序员与代码密不可分，而代码又是为了项目服务的，项目又可以集合成一个产品，而产品最终是要为我们服务的。为什么会有计算机的存在，是因为人类想要一种机器帮助我们简化计算，为什么会有代码的存在，是因为人类想要计算机更易懂我们的想法，为什么会有项目的存在，是因为我们需要计算机可以将我们的想法完整表达出来，为什么会有产品存在，说到底，是人类的进化使我们想要更高效的生活。所以说，如何做一个产品？产品是我们最终想要的结果，项目明确了我们的需求，代码只是底层实现，计算机，执行者罢了。所以这篇文章，写一写怎样开始着手于写一个项目。</p>
<h2 id="项目前的准备"><a href="#项目前的准备" class="headerlink" title="项目前的准备"></a>项目前的准备</h2><p>​    写项目之前，首先要明确，你的需求是什么，你想要一个什么样的产品。明确需求很重要，否则你写出来的东西很有可能不是你或者别人想要的东西。<code>一千个哈姆雷特</code>，每个人都有自己的想法，而完成一个别人的项目，需要完成的，就是实现别人的想法。所以大方向很重要。</p>
<p>​    明确真实需求后，怎么样实现需求呢？要做到心中有数，需要我们在自己心中建立起一个框架。要明确分为几个模块，每个模块会用到什么东西,具体的流程是什么样的，做到心中有数，自可万法归一，行云流水。</p>
<p>​    <code>工欲善其事必先利其器</code>，为了更高效简洁的开发，我们需要准备好我们的工具。首先就是自己常用且顺手的各种工具，然后是可能已有的框架，一个逻辑的既定代码，造轮子固然可以提高自己的技术，但是重复造轮子就属实没有必要了。</p>
<p>需求文档，定义功能，界面，原型图，数据库设计，接口设计</p>
<p>具体流程</p>
<p>1.明确需求</p>
<p>2.搭建环境</p>
<p>3.找轮子</p>
<p>4.建数据库，建表</p>
<p>5.建类</p>
<p>6.思考设计模式</p>
<p>7.梳理接口，确定开发排期</p>
<p>8.写代码，写单测</p>
<p>9.前后端对接</p>
<p>10.产品验收，上线</p>
<h2 id="项目构思框架"><a href="#项目构思框架" class="headerlink" title="项目构思框架"></a>项目构思框架</h2><p>​    一个完整的项目，必定会有前后端。前端负责展示效果，后端负责处理逻辑。</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>1.router.js</p>
<p>路由页面。负责网页地址的跳转</p>
<p>2.main.js</p>
<p>导入资源页面。负责导入用到的相关框架或者包。</p>
<p>3.view</p>
<p>vue的前端显示的页面。</p>
<p>包括三部分：</p>
<pre><code>- html元素
- js代码
- css样式
</code></pre>
<p>components：部件。可以在这里设定上端、下端的固定样式，可以用到每个页面。</p>
<p>4.utils</p>
<p>工具类。</p>
<p>5.assets/static/public</p>
<p>存放静态资源。</p>
<p>6.request</p>
<p>跨域请求</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>1.pom.xml</p>
<p>maven的配置文件。</p>
<p>2.controller层</p>
<p>控制层，一般在src下的java下。</p>
<p>3.service层</p>
<p>逻辑层，一般在src下的java下。</p>
<p>4.Mapper层</p>
<p>数据库层，src下的resources下的是数据库表字段的配置文件，src下的java下的是sql语句。</p>
<p>5.entity，pojo</p>
<p>实体类，一般在src下的java下。</p>
<p>6.exception</p>
<p>异常</p>
<p>7.utils</p>
<p>工具</p>
<p>8.filter</p>
<p>过滤，拦截器</p>
<p>9.config</p>
<p>配置</p>
<p>10.dto</p>
<p>自定义数据结构</p>
<h4 id="用到的相关依赖"><a href="#用到的相关依赖" class="headerlink" title="用到的相关依赖"></a>用到的相关依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis-plus-boot-starter.version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">mybatis-plus-boot-starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.40<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.6<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hutool-all.version</span>&gt;</span>4.6.2<span class="tag">&lt;/<span class="name">hutool-all.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">springfox.version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">springfox.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fastjson.version</span>&gt;</span>1.2.13<span class="tag">&lt;/<span class="name">fastjson.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonatype-nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonatype-nexus-staging<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://oss.sonatype.org/service/local/staging/deploy/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span><span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span><span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 注：如提示报错，先升级基础包版，无法解决可联系技术支持 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-dysmsapi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mybatis-plus begin =================================== --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus-boot-starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis-plus end --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ========================= 数据库相关 ========================== --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- ========================= 常用库依赖 ========================== --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- lombok插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Hutool工具类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hutool-all.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- StringUtils工具类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 阿里FastJson转换工具依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;fastjson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- AOP依赖 【注：系统日记需要此依赖】 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--httpclient--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpmime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- swagger--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springfox.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springfox.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-bean-validators<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springfox.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--poi相关--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 注：maven默认是不编译，因此加上如下resources才会生产对应的xml文件 目的：解决mybatis映射关系不对应问题  start =============== --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否替换资源中的属性--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注：maven默认是不编译，因此加上如下resources才会生产对应的xml文件 目的：解决mybatis映射关系不对应问题  end =============== --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus-staging-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">serverId</span>&gt;</span>sonatype-nexus-staging<span class="tag">&lt;/<span class="name">serverId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">nexusUrl</span>&gt;</span>https://oss.sonatype.org/<span class="tag">&lt;/<span class="name">nexusUrl</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">autoReleaseAfterClose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">autoReleaseAfterClose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="前后端的对接规范"><a href="#前后端的对接规范" class="headerlink" title="前后端的对接规范"></a>前后端的对接规范</h3><p>1.使用MybatisPlus的R返回值。</p>
<p>R是com.baomidou.mybatisplus.extension.api中写好的一个统一结果返回集。主要包含code，data，msg</p>
<p>**R(IErrorCode errorCode)**：    {data:null,code:errorCode.getCode(),msg:errorCode.getMsg()}</p>
<p><strong>R.ok(T data)</strong>:         默认情况下：{data:data,code:0,msg:执行成功}  如果data为Boolean类型且就是false:{data:false,code:-1,msg:操作失败}</p>
<p><strong>R.failed(String msg)</strong>:        {data:null,code:-1,msg:msg}</p>
<p><strong>R.failed(IErrorCode errorCode)</strong> :            {data:null,code:errorCode.getCode(),msg:errorCode.getMsg()}</p>
<p><strong>R.restResult(T data, IErrorCode errorCode)</strong>  :            {data:data,code:errorCode.getCode(),msg:errorCode.getMsg()}</p>
<p><strong>R.restResult(T data, long code, String msg)</strong>:            {data:data,code:code,msg:msg}</p>
<p>可以自己定义枚举类实现IErrorCode接口,例如自定义一个IErrorCode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ResApiFailCode</span> <span class="keyword">implements</span> <span class="title">IErrorCode</span> </span>&#123;</span><br><span class="line">    FAILED(-<span class="number">1L</span>, <span class="string">&quot;出错了&quot;</span>),</span><br><span class="line">    INVALID_PARAM(-<span class="number">2L</span>, <span class="string">&quot;参数异常&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String msg;</span><br><span class="line"></span><br><span class="line">    ResApiFailCode(<span class="keyword">final</span> <span class="keyword">long</span> code, <span class="keyword">final</span> String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot; ErrorCode:&#123;code=%s, msg=%s&#125; &quot;</span>, <span class="keyword">this</span>.code, <span class="keyword">this</span>.msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    使用时使用：<span class="keyword">return</span> R.restResult(<span class="keyword">null</span>, ResApiFailCode.FAILED);</span><br></pre></td></tr></table></figure>

<p>对于异常也需要做处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@Component(&quot;myGlobalExceptionHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;?&gt; defaultExceptionHandler(Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;这里处理错误，错误信息是：&#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">        <span class="comment">//常见异常返回</span></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> CommonException) &#123;</span><br><span class="line">            String message = e.getMessage();</span><br><span class="line">            <span class="keyword">return</span> R.failed(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> UserNotExistException) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.failed(ResApiFailCode.NO_PERMISSION);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ClientException) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.failed(ResApiFailCode.WRONG_SERVER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//运行时异常返回</span></span><br><span class="line">        <span class="keyword">return</span> R.restResult(<span class="keyword">null</span>, ResApiFailCode.FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用SpringBoot提供的<code>ResponseBodyAdvice</code></p>
<p>ResponseBodyAdvice的作用：拦截Controller方法的返回值，统一处理返回值/响应体，一般用来统一返回格式，加解密，签名等等</p>
<p>首先需要定义返回格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/** 结果状态 ,具体状态码参见ResultData.java*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line">  <span class="keyword">private</span> T data;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> timestamp ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResultData</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResultData&lt;T&gt; <span class="title">success</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">    ResultData&lt;T&gt; resultData = <span class="keyword">new</span> ResultData&lt;&gt;();</span><br><span class="line">    resultData.setStatus(ReturnCode.RC100.getCode());</span><br><span class="line">    resultData.setMessage(ReturnCode.RC100.getMessage());</span><br><span class="line">    resultData.setData(data);</span><br><span class="line">    <span class="keyword">return</span> resultData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ResultData&lt;T&gt; <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, String message)</span> </span>&#123;</span><br><span class="line">    ResultData&lt;T&gt; resultData = <span class="keyword">new</span> ResultData&lt;&gt;();</span><br><span class="line">    resultData.setStatus(code);</span><br><span class="line">    resultData.setMessage(message);</span><br><span class="line">    <span class="keyword">return</span> resultData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义状态码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ReturnCode</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**操作成功**/</span></span><br><span class="line">    RC100(<span class="number">100</span>,<span class="string">&quot;操作成功&quot;</span>),</span><br><span class="line">    <span class="comment">/**操作失败**/</span></span><br><span class="line">    RC999(<span class="number">999</span>,<span class="string">&quot;操作失败&quot;</span>),</span><br><span class="line">    <span class="comment">/**服务限流**/</span></span><br><span class="line">    RC200(<span class="number">200</span>,<span class="string">&quot;服务开启限流保护,请稍后再试!&quot;</span>),</span><br><span class="line">    <span class="comment">/**服务降级**/</span></span><br><span class="line">    RC201(<span class="number">201</span>,<span class="string">&quot;服务开启降级保护,请稍后再试!&quot;</span>),</span><br><span class="line">    <span class="comment">/**热点参数限流**/</span></span><br><span class="line">    RC202(<span class="number">202</span>,<span class="string">&quot;热点参数限流,请稍后再试!&quot;</span>),</span><br><span class="line">    <span class="comment">/**系统规则不满足**/</span></span><br><span class="line">    RC203(<span class="number">203</span>,<span class="string">&quot;系统规则不满足要求,请稍后再试!&quot;</span>),</span><br><span class="line">    <span class="comment">/**授权规则不通过**/</span></span><br><span class="line">    RC204(<span class="number">204</span>,<span class="string">&quot;授权规则不通过,请稍后再试!&quot;</span>),</span><br><span class="line">    <span class="comment">/**access_denied**/</span></span><br><span class="line">    RC403(<span class="number">403</span>,<span class="string">&quot;无访问权限,请联系管理员授予权限&quot;</span>),</span><br><span class="line">    <span class="comment">/**access_denied**/</span></span><br><span class="line">    RC401(<span class="number">401</span>,<span class="string">&quot;匿名用户访问无权限资源时的异常&quot;</span>),</span><br><span class="line">    <span class="comment">/**服务异常**/</span></span><br><span class="line">    RC500(<span class="number">500</span>,<span class="string">&quot;系统异常，请稍后重试&quot;</span>),</span><br><span class="line"></span><br><span class="line">    INVALID_TOKEN(<span class="number">2001</span>,<span class="string">&quot;访问令牌不合法&quot;</span>),</span><br><span class="line">    ACCESS_DENIED(<span class="number">2003</span>,<span class="string">&quot;没有权限访问该资源&quot;</span>),</span><br><span class="line">    CLIENT_AUTHENTICATION_FAILED(<span class="number">1001</span>,<span class="string">&quot;客户端认证失败&quot;</span>),</span><br><span class="line">    USERNAME_OR_PASSWORD_ERROR(<span class="number">1002</span>,<span class="string">&quot;用户名或密码错误&quot;</span>),</span><br><span class="line">    UNSUPPORTED_GRANT_TYPE(<span class="number">1003</span>, <span class="string">&quot;不支持的认证模式&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**自定义状态码**/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="comment">/**自定义描述**/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    ReturnCode(<span class="keyword">int</span> code, String message)&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再需要编写一个具体实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object o, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            <span class="comment">//如果Controller直接返回String的话，SpringBoot是直接返回，故我们需要手动转换成json</span></span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsString(ResultData.success(o));</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> ResultData)&#123;</span><br><span class="line">   			<span class="keyword">return</span> o;</span><br><span class="line">  		&#125;</span><br><span class="line">        <span class="keyword">return</span> ResultData.success(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<code>@RestControllerAdvice</code>注解<code>@RestControllerAdvice</code>是<code>@RestController</code>注解的增强，可以实现三个方面的功能：</p>
<p>1.全局异常处理</p>
<p>2.全局数据绑定</p>
<p>3.全局数据预处理</p>
<p>对于异常，也需要统一返回格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认全局异常处理。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ResultData</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultData&lt;String&gt; <span class="title">exception</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;全局异常信息 ex=&#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> ResultData.fail(ReturnCode.RC500.getCode(),e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>1.@RestControllerAdvice，RestController的增强类，可用于实现全局异常处理器</p>
<p>2.@ExceptionHandler,统一处理某一类异常，从而减少代码重复率和复杂度，比如要获取自定义异常可以@ExceptionHandler(BusinessException.class)</p>
<p>3.@ResponseStatus指定客户端收到的http状态码</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/macoffee/p/13475320.html">https://www.cnblogs.com/macoffee/p/13475320.html</a></p>
<p>单表行数超过 500 万行或者单表容量超过 2GB，推荐进行分库分表。预计三年后的数据量根本达不到这个级别，不要在创建表时就分库分表</p>
<ul>
<li>1.数据库设计和表创建时就要考虑性能</li>
<li>2.sql的编写需要注意优化</li>
<li>4.分区</li>
<li>4.分表</li>
<li>5.分库</li>
</ul>
<p>设计表时要注意：</p>
<p>表字段避免null值出现，null值很难查询优化且占用额外的索引空间，推荐默认数字0代替null。<br>尽量使用INT而非BIGINT，如果非负则加上UNSIGNED（这样数值容量会扩大一倍），当然能使用TINYINT、SMALLINT、MEDIUM_INT更好。</p>
<p>数据库表的id的类型：最好int，数据量大的用bigint<br>使用枚举或整数代替字符串类型<br>尽量使用TIMESTAMP而非DATETIME<br>单表不要有太多字段，建议在20以内<br>用整型来存IP<br>索引</p>
<p>索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描<br>应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描<br>值分布很稀少的字段不适合建索引，例如”性别”这种只有两三个值的字段<br>字符字段只建前缀索引<br>字符字段最好不要做主键<br>不用外键，由程序保证约束<br>尽量不用UNIQUE，由程序保证约束<br>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引<br>简言之就是使用合适的数据类型，选择合适的索引</p>
<p>选择合适的数据类型</p>
<p>（1）使用可存下数据的最小的数据类型，整型 &lt; date,time &lt; char,varchar &lt; blob<br>（2）使用简单的数据类型，整型比字符处理开销更小，因为字符串的比较更复杂。如，int类型存储时间类型，bigint类型转ip函数<br>（3）使用合理的字段属性长度，固定长度的表会更快。使用enum、char而不是varchar<br>（4）尽可能使用not null定义字段<br>（5）尽量少用text，非用不可最好分表</p>
<p>选择合适的索引列</p>
<p>（1）查询频繁的列，在where，group by，order by，on从句中出现的列<br>（2）where条件中&lt;，&lt;=，=，&gt;，&gt;=，between，in，以及like 字符串+通配符（%）出现的列<br>（3）长度小的列，索引字段越小越好，因为数据库的存储单位是页，一页中能存下的数据越多越好<br>（4）离散度大（不同的值多）的列，放在联合索引前面。查看离散度，通过统计不同的列值来实现，count越大，离散程度越高：</p>
<p>2.sql的编写需要注意优化</p>
<p>使用limit对查询结果的记录进行限定<br>避免select *，将需要查找的字段列出来<br>使用连接（join）来代替子查询<br>拆分大的delete或insert语句<br>可通过开启慢查询日志来找出较慢的SQL<br>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边<br>sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库<br>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内<br>不用函数和触发器，在应用程序实现<br>避免%xxx式查询<br>少用JOIN<br>使用同类型进行比较，比如用’123’和’123’比，123和123比<br>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描<br>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5<br>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</p>
<p>引擎</p>
<p>目前广泛使用的是MyISAM和InnoDB两种引擎：</p>
<ol>
<li>MyISAM</li>
<li>MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：</li>
</ol>
<ul>
<li>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</li>
<li>不支持事务</li>
<li>不支持外键</li>
<li>不支持崩溃后的安全恢复</li>
<li>在表有读取查询的同时，支持往表中插入新纪录</li>
<li>支持BLOB和TEXT的前500个字符索引，支持全文索引</li>
<li>支持延迟更新索引，极大提升写入性能</li>
<li>对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用</li>
</ul>
<ol>
<li>InnoDB</li>
<li>InnoDB在MySQL 5.5后成为默认索引，它的特点是：</li>
</ol>
<ul>
<li>支持行锁，采用MVCC来支持高并发</li>
<li>支持事务</li>
<li>支持外键</li>
<li>支持崩溃后的安全恢复</li>
<li>不支持全文索引</li>
</ul>
<p>总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表</p>
<blockquote>
<p>MyISAM速度可能超快，占用存储空间也小，但是程序要求事务支持，故InnoDB是必须的，故该方案无法执行，放弃！</p>
</blockquote>
<p>3.分区</p>
<p>MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码</p>
<p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引</p>
<p>用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，我测试，查询时不带分区条件的列，也会提高速度，故该措施值得一试。</p>
<p>分区的好处是：</p>
<ul>
<li>可以让单表存储更多的数据</li>
<li>分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作</li>
<li>部分查询能够从查询条件确定只落在少数分区上，速度会很快</li>
<li>分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备</li>
<li>可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</li>
<li>可以备份和恢复单个分区</li>
</ul>
<p>分区的限制和缺点：</p>
<ul>
<li>一个表最多只能有1024个分区</li>
<li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li>
<li>分区表无法使用外键约束</li>
<li>NULL值会使分区过滤无效</li>
<li>所有分区必须使用相同的存储引擎</li>
</ul>
<p>分区的类型：</p>
<ul>
<li>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区</li>
<li>LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</li>
<li>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式</li>
<li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</li>
<li>具体关于mysql分区的概念请自行google或查询官方文档，我这里只是抛砖引玉了。</li>
</ul>
<blockquote>
<p>我首先根据月份把上网记录表RANGE分区了12份，查询效率提高6倍左右，效果不明显，故：换id为HASH分区，分了64个分区，查询速度提升显著。问题解决！</p>
<p>结果如下：PARTITION BY HASH (id)PARTITIONS 64</p>
<p>select count(<em>) from readroom_website; –11901336行记录</em></p>
<p><em>/</em> 受影响行数: 0 已找到记录: 1 警告: 0 持续时间 1 查询: 5.734 sec. <em>/</em></p>
<p><em>select * from readroom_website where month(accesstime) =11 limit 10;</em></p>
<p><em>/</em> 受影响行数: 0 已找到记录: 10 警告: 0 持续时间 1 查询: 0.719 sec. */</p>
</blockquote>
<p>4.分表</p>
<p>分表就是把一张大表，按照如上过程都优化了，还是查询卡死，那就把这个表分成多张表，把一次查询分成多次查询，然后把结果组合返回给用户。</p>
<p>分表分为垂直拆分和水平拆分，通常以某个字段做拆分项。比如以id字段拆分为100张表： 表名为 tableName_id%100</p>
<p>但：分表需要修改源程序代码，会给开发带来大量工作，极大的增加了开发成本，故：只适合在开发初期就考虑到了大量数据存在，做好了分表处理，不适合应用上线了再做修改，成本太高！！！而且选择这个方案，都不如选择我提供的第二第三个方案的成本低！故不建议采用。</p>
<p>5.分库</p>
<p>把一个数据库分成多个，建议做个读写分离就行了，真正的做分库也会带来大量的开发成本，得不偿失！不推荐使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/23/10.1.%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%BB%BA/" data-id="ckw61sdw00040oswd3xjkd9pl" data-title="项目初建" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-1.4.正确使用搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/22/1.4.%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2021-03-22T03:52:48.000Z" itemprop="datePublished">2021-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/22/1.4.%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2/">正确使用搜索</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="搜索的正确顺序"><a href="#搜索的正确顺序" class="headerlink" title="搜索的正确顺序"></a>搜索的正确顺序</h1><p>google</p>
<p>stackoverflow</p>
<h1 id="搜索结果的显示"><a href="#搜索结果的显示" class="headerlink" title="搜索结果的显示"></a>搜索结果的显示</h1><p>可以使用浏览器的脚本，将搜索结果的广告进行屏蔽，将结果更直观的展示出来。</p>
<p>谷歌浏览器需要先下载谷歌上网助手。</p>
<p>汇总了一些常用的浏览器插件：收藏猫插件：<a target="_blank" rel="noopener" href="https://chrome.pictureknow.com/">https://chrome.pictureknow.com/</a></p>
<p>脚本管理工具：油猴，暴力猴。</p>
<p>提供脚本的网站：<a target="_blank" rel="noopener" href="https://greasyfork.org/zh-CN">https://greasyfork.org/zh-CN</a></p>
<h1 id="搜索的格式"><a href="#搜索的格式" class="headerlink" title="搜索的格式"></a>搜索的格式</h1><h2 id="正常搜索"><a href="#正常搜索" class="headerlink" title="正常搜索"></a>正常搜索</h2><p>各个名词之间，加空格搜索。</p>
<p><code>手机 苹果</code></p>
<h2 id="英文半角双引号搜索"><a href="#英文半角双引号搜索" class="headerlink" title="英文半角双引号搜索"></a>英文半角双引号搜索</h2><p>是一种比较精确的搜索方法：最关键的是可以将推广页面剔除掉。双引号可以实现精确的查询，这种方法要求查询结果要精确匹配，不包括演变形式</p>
<p><code>&quot;手机&quot;</code></p>
<h2 id="圆括号搜索"><a href="#圆括号搜索" class="headerlink" title="圆括号搜索"></a>圆括号搜索</h2><p>是完全部分匹配搜索：完全，是不会将搜索结果拆开去搜索；部分，是将搜索结果去匹配部分内容符合的内容。这种方法针对搜索结果有特殊要求的内容,有圆括号的搜索方式，搜索结果的数量变少且范围缩小了。</p>
<p><code>(苹果手机)</code></p>
<h2 id="通配符搜索-建议在谷歌使用，百度不太适合"><a href="#通配符搜索-建议在谷歌使用，百度不太适合" class="headerlink" title="通配符搜索(建议在谷歌使用，百度不太适合)"></a>通配符搜索(建议在谷歌使用，百度不太适合)</h2><p>*号不限制字符匹配数量，?号正好与其相反，限制字符匹配数量</p>
<p><code>computer*</code>,可以找到“computer、computers、computerised、computerized”等单词，</p>
<p><code>comp?ter</code>，只能找到“computer、compater、competer”等单词。</p>
<h2 id="利用加号减号【-】、【-】搜索"><a href="#利用加号减号【-】、【-】搜索" class="headerlink" title="利用加号减号【+】、【-】搜索"></a>利用加号减号【+】、【-】搜索</h2><p>在想要搜索的关键词前使用加号，也就等于告诉搜索引擎你搜索的这个词<strong>必须出现在搜索结果的网页中</strong>，如果只是网页标题中含这个关键词的就不出现。在想要搜索的关键词前使用减号，实质是与上面有些相反的意思，则在搜索结果中不能出现前面带减号的关键词，</p>
<p><code>我+要去+英国+留学</code>,就表示要查找的网页内容中必须要同时包含“我、要去、英国、留学”这三个关键词</p>
<h2 id="搜索范围限定在网页标题中"><a href="#搜索范围限定在网页标题中" class="headerlink" title="搜索范围限定在网页标题中"></a>搜索范围限定在网页标题中</h2><p>网页标题就是在打开网站的时候浏览器上显示的文字，但是网页标题中所包含的关键词有可能是不出现在网页中的，所以你只想搜索网页标题里面的关键词，就需要用到intitle：语法</p>
<p><code>intitle+标题</code></p>
<h2 id="限定网站搜索方式"><a href="#限定网站搜索方式" class="headerlink" title="限定网站搜索方式"></a>限定网站搜索方式</h2><p><code>site:www.baidu.com 百度</code>  </p>
<p>“site:”后面跟的站点域名，不要带“//”;site:后面带不带www结果可能是不一样的，因为有些域名还包括二级域名，如：site:<a href="http://www.XX.com和site:XX.com，搜索结果就不一样。另外，site:和站点名之间，不要带空格。使用site:语法限定在某站上搜索特定关键词（只在当前网站进行搜索）">www.XX.com和site:XX.com，搜索结果就不一样。另外，site:和站点名之间，不要带空格。使用site:语法限定在某站上搜索特定关键词（只在当前网站进行搜索）</a></p>
<h2 id="限定链接url搜索"><a href="#限定链接url搜索" class="headerlink" title="限定链接url搜索"></a>限定链接url搜索</h2><p><code>inurl:douban 电影</code></p>
<p>与site的区别就是inurl中的所有网页URL中都包含了douban但是是不同的网站</p>
<p>inurl的作用是限定在url中搜索，利用这种相关性，来缩小范围，快速准确地找到所需信息</p>
<h2 id="专业文档搜索"><a href="#专业文档搜索" class="headerlink" title="专业文档搜索"></a>专业文档搜索</h2><p><code>filetype:doc 电脑</code></p>
<p>搜索结果都是word格式并且包含了 电脑 这个关键词</p>
<p>以上也可以在百度的高级搜索中进行设置。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/22/1.4.%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2/" data-id="ckw61sduk0001oswddbkeh8ov" data-title="正确使用搜索" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/10/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>