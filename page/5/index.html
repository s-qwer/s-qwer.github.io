<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/5/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-4.16.泛型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.16.%E6%B3%9B%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:12:27.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.16.%E6%B3%9B%E5%9E%8B/">泛型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JDK5以后出现了自动装箱，所以在需要引用类型的时候如果是个基本类型也是可以的，是因为有自动装箱。</p>
<p>当我们往集合中存储了String和Integer两种类型时的数据时，而在遍历时都进行String类型的转化时，就会报错。但这个报错在编译期间不会出现，在编译的时候只有警告，只有执行的时候才会出现。于是集合也开始在创建对象的时候明确元素的数据类型，这就是泛型。泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型</p>
<p>泛型：是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。参数化类型，把类型当作参数一样的传递。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数</p>
<p>格式：&lt;数据类型&gt;  此处的数据类型只能是引用类型</p>
<p>好处：</p>
<p>1.运行时期的问题提取到了编译期间</p>
<p>2.避免了强制类型转换</p>
<p>3.简化了程序设计，解决了黄色警告线</p>
<p>在API中，如果类，接口，抽象类中出现了<code>&lt;E&gt;</code>，就说明要使用泛型。一般来说就是在集合中使用。</p>
<p>JDK7的新特性：泛型推断。</p>
<p>早期我们使用Object类型可以接收任意的对象类型。但是在实际的使用中，会有类型转换的问题（向上转型是没有任何问题的，但是在向下转型的时候隐含了类型转换的问题），也就存在着隐患，这样的程序是不安全的，所以在JDK5以后Java提供了泛型来解决这个问题，提高程序的安全性。</p>
<p>应用：</p>
<p>1.泛型类：把泛型定义在类上</p>
<p>格式:public class 类名&lt;泛型类型1,…&gt;</p>
<p>注意:泛型类型必须是引用类型</p>
<p>2.泛型方法：把泛型定义在方法上</p>
<p>格式:public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .)</p>
<p>方法可以接收任意的类型</p>
<p>3.泛型接口：把泛型定义在接口上</p>
<p>格式:public  interface 接口名&lt;泛型类型1…&gt;</p>
<p>实现类在实现接口的时候：</p>
<p>1.已经知道是什么类型的了：</p>
<p>public class InterImpl implements Inter<String>{}</p>
<p>\2. 还不知道是什么类型：(这种情况用的比较多)</p>
<p>public class InterImpl<T> implements Inter<T>{}</p>
<p>泛型通配符：泛型如果写的时候，前后必须一致（ArrayList<T> array=new ArrayList<T>();  这里的前后两个T必须一致，？可以表示任意）</p>
<p>\1. &lt;?&gt;:任意类型，如果没有明确，那么就是Object以及任意的Java类了</p>
<p>\2. &lt;? extends E&gt;：向下限定，E及其子类</p>
<p>\3. &lt;? super E&gt;：向上限定，E及其父类</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class GlmapperGeneric&lt;T&gt; &#123;</span><br><span class="line">  	private T t;</span><br><span class="line">    public void set(T t) &#123; this.t &#x3D; t; &#125;</span><br><span class="line">    public T get() &#123; return t; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">    * 不指定类型</span><br><span class="line">    *&#x2F;</span><br><span class="line">  public void noSpecifyType()&#123;</span><br><span class="line">    GlmapperGeneric glmapperGeneric &#x3D; new GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(&quot;test&quot;);</span><br><span class="line">    &#x2F;&#x2F; 需要强制类型转换</span><br><span class="line">    String test &#x3D; (String) glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">    * 指定类型</span><br><span class="line">    *&#x2F;</span><br><span class="line">  public void specifyType()&#123;</span><br><span class="line">    GlmapperGeneric&lt;String&gt; glmapperGeneric &#x3D; new GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(&quot;test&quot;);</span><br><span class="line">    &#x2F;&#x2F; 不需要强制类型转换</span><br><span class="line">    String test &#x3D; glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> specifyType 方法中省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上</span><br></pre></td></tr></table></figure>



<p>通配符 <strong>T，E，K，V，？</strong></p>
<ul>
<li>？表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h4 id="？无界通配符"><a href="#？无界通配符" class="headerlink" title="？无界通配符"></a>？无界通配符</h4><p>一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>

<p>但是老板的想法确实这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>

<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static int countLegs (List&lt;? extends Animal &gt; animals ) &#123;</span><br><span class="line">    int retVal &#x3D; 0;</span><br><span class="line">    for ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal +&#x3D; animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int countLegs1 (List&lt; Animal &gt; animals )&#123;</span><br><span class="line">    int retVal &#x3D; 0;</span><br><span class="line">    for ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal +&#x3D; animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Dog&gt; dogs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  &#x2F;&#x2F; 不会报错</span><br><span class="line">    countLegs( dogs );</span><br><span class="line"> &#x2F;&#x2F; 报错</span><br><span class="line">    countLegs1(dogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 countLegs1 时，就会飘红，提示的错误信息如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffWPDTNara23zX7cQiaVrP6pQxcvjhcguhYzbJfdPVnmvPfLZ8ZfkQT1rhCJyy7MhiaCWsuQC8eU2Gg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h4 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h4><blockquote>
<p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private &lt;K extends A, E extends B&gt; E test(K arg1, E arg2)&#123;</span><br><span class="line">    E result &#x3D; arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    &#x2F;&#x2F;.....</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
</blockquote>
<h4 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h4><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src)&#123;</span><br><span class="line">    for (T t : src) &#123;</span><br><span class="line">        dst.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Dog&gt; dogs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Animal&gt; animals &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    new Test3().test(animals,dogs);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Dog 是 Animal 的子类</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h4 id="？和-T-的区别"><a href="#？和-T-的区别" class="headerlink" title="？和 T 的区别"></a>？和 T 的区别</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffWPDTNara23zX7cQiaVrP6ppFLte18yeOy2AVmqjqQibfiaKPOrb7WlFCmx1daNataCY6OfUpRJP04Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以</span><br><span class="line">T t &#x3D; operate();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不可以</span><br><span class="line">？car &#x3D; operate();</span><br></pre></td></tr></table></figure>

<p>简单总结下：</p>
<p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
<h5 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过 T 来 确保 泛型参数的一致性</span><br><span class="line">public &lt;T extends Number&gt; void</span><br><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span><br><span class="line">public void</span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure>

<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffWPDTNara23zX7cQiaVrP6pMt4NcHxGt9P99aicd0xswiajenBPzGzPX3tTTw4MLkErO5MHHn2bnGmQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlmapperGeneric&lt;String&gt; glmapperGeneric &#x3D; new GlmapperGeneric&lt;&gt;();</span><br><span class="line">List&lt;String&gt; dest &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt; src &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">glmapperGeneric.testNon(dest,src);</span><br></pre></td></tr></table></figure>

<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h5 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h5><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffWPDTNara23zX7cQiaVrP6pYkF50oMpa14emEsWmbMZfYEzV2GzIHOaORicHyfFwC2pL7k0DOQTh2g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h5 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h5><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure>

<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure>

<h3 id="Class-lt-T-gt-和-Class-lt-gt-区别"><a href="#Class-lt-T-gt-和-Class-lt-gt-区别" class="headerlink" title="Class&lt;T&gt;和 Class&lt;?&gt;区别"></a><code>Class&lt;T&gt;</code>和 <code>Class&lt;?&gt;</code>区别</h3><p>前面介绍了 ？和 T 的区别，那么对于，<code>Class&lt;T&gt;</code>和 <code>&lt;Class&lt;?&gt;</code>又有什么区别呢？<code>Class&lt;T&gt;</code>和 <code>Class&lt;?&gt;</code></p>
<p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过反射的方式生成  multiLimit</span><br><span class="line">&#x2F;&#x2F; 对象，这里比较明显的是，我们需要使用强制类型转换</span><br><span class="line">MultiLimit multiLimit &#x3D; (MultiLimit)</span><br><span class="line">Class.forName(&quot;com.glmapper.bridge.boot.generic.MultiLimit&quot;).newInstance();</span><br></pre></td></tr></table></figure>

<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p>
<p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffWPDTNara23zX7cQiaVrP6pOCdXlQ8PfQG8AXKK2Bs7ZpSaT6bNKcFWpc1oskSRuGw61YbPCSfLHg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><code>Class&lt;T&gt;</code>在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code>它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以</span><br><span class="line">public Class&lt;?&gt; clazz;</span><br><span class="line">&#x2F;&#x2F; 不可以，因为 T 需要指定类型</span><br><span class="line">public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>

<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffWPDTNara23zX7cQiaVrP6plpf3S7CqZbryddwWFQN3gzKYlAZtRAnn0ro78WBiciaHVgKicD0kpSCPQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code>这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Test3&lt;T&gt; &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    &#x2F;&#x2F; 不会报错</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.16.%E6%B3%9B%E5%9E%8B/" data-id="ckw61sdv6001ooswde7ql4pev" data-title="泛型" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.15.枚举" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.15.%E6%9E%9A%E4%B8%BE/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:12:20.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.15.%E6%9E%9A%E4%B8%BE/">枚举</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>枚举：是有限个值的集合。</p>
<p>是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内</p>
<p>如果没有枚举类，我们自己定义一个类的话，会非常麻烦。（//需要用到构造方法私有，静态方法调用，对象调用方法，匿名类重写方法等）</p>
<p>格式：</p>
<p>public enum 枚举类名 {</p>
<p>​            枚举项1，枚举项2，枚举项3…;</p>
<p>}</p>
<p>public String toString():  返回枚举常量的名称，它包含在声明中（枚举重写了toString方法，返回的是枚举项的名字）</p>
<p>注意事项</p>
<p>定义枚举类要用关键字enum</p>
<p>所有枚举类都是Enum的子类</p>
<p>枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略</p>
<p>枚举类可以有构造器，但必须是private的，它默认的也是private的。枚举项的用法比较特殊：枚举(“”);</p>
<p>枚举类也可以有抽象方法，但是枚举项必须重写该方法</p>
<p>枚举在switch语句中的使用</p>
<p>枚举类中的几个常见方法</p>
<p>int compareTo(E o) 比较此枚举与指定对象的顺序，枚举中隐含数字 1 2 3 …</p>
<p>String name() 返回此枚举常量的名称，在其枚举声明中对其进行声明</p>
<p>int ordinal()  返回枚举常量的序数（它在枚举声明中的位置，初始常量序数为0）</p>
<p>String toString() 返回枚举常量的名称，它包含在声明中</p>
<p><T> T valueOf(Class<T> type,String name)  静态方法，返回带指定名称的指定枚举类型的枚举常量</p>
<p>values()  此方法虽然在JDK文档中查找不到，但每个枚举类都具有该方法，它遍历枚举类的所有枚举值非常方便</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.15.%E6%9E%9A%E4%B8%BE/" data-id="ckw61sdv5001noswdfbdq6j87" data-title="枚举" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.23JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.23JVM/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:36:18.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.23JVM/">JVM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java语言是跨平台的，jvm不是跨平台的。</p>
<p>虚拟机（Virture Machine）指通过软件的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</p>
<p>Java的源代码经过编译后生成的不是特定CPU使用的本地代码，而是名为字节代码的程序。直接代码的运行环境就叫做java虚拟机（JVM），边转换边运行。</p>
<p>java中的内存分配：java程序在运行时，需要在内存中的分配空间。</p>
<p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p>
<h3 id="1-栈："><a href="#1-栈：" class="headerlink" title="1.栈："></a>1.栈：</h3><p>存储局部变量（加载的变量、方法）</p>
<p>结构：先进后出</p>
<p>特点：栈内存的数据用完（脱离数据域）就释放掉。（堆内存的数据可能要使用多次。）</p>
<h3 id="2-堆："><a href="#2-堆：" class="headerlink" title="2.堆："></a>2.堆：</h3><p>存储new出来的东西（里面含有该new类的成员变量、静态标记、方法标记）</p>
<p>特点：每一个new出来的东西都有地址值；每个变量都有默认值：</p>
<p>byte,short,int,long  0</p>
<p>float,double  0.0</p>
<p>char  \u000</p>
<p>boolean  false </p>
<p>引用类型  null</p>
<p>使用完毕就变成了垃圾，但是并没有立即回收，会在垃圾回收器空闲时候回收。</p>
<p>C++中用析构函数来回收释放空间。</p>
<p>栈内存的两个引用指向同一个堆内存空间，无论是它们谁的操作，都是针对同一个地方。</p>
<h3 id="3-方法区："><a href="#3-方法区：" class="headerlink" title="3.方法区："></a>3.方法区：</h3><p>class类区（包括类的成员变量和成员方法）、静态区（static）、常量池</p>
<h3 id="4-本地方法区："><a href="#4-本地方法区：" class="headerlink" title="4.本地方法区："></a>4.本地方法区：</h3><p>和系统相关</p>
<h3 id="5-寄存器："><a href="#5-寄存器：" class="headerlink" title="5.寄存器："></a>5.寄存器：</h3><p>CPU使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.23JVM/" data-id="ckw61sdv7001uoswd8oex7keh" data-title="JVM" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.24.JUC并发编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.24.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:36:12.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.24.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">JUC并发编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.24.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="ckw61sdv8001voswdaa0cb2az" data-title="JUC并发编程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.17.反射和注解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:57.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/">反射和注解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>类的加载</p>
<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。</p>
<p>加载 </p>
<p>就是指将class文件读入内存，并为之创建一个Class对象。</p>
<p>任何类被使用时系统都会建立一个Class对象。</p>
<p>连接</p>
<p>验证 是否有正确的内部结构，并和其他类协调一致</p>
<p>准备 负责为类的静态成员分配内存，并设置默认初始化值</p>
<p>解析 将类的二进制数据中的符号引用替换为直接引用</p>
<p>初始化 </p>
<p>就是我们以前讲过的初始化步骤</p>
<p>类初始化时机：</p>
<p>1.创建类的实例</p>
<p>2.访问类的静态变量，或者为静态变量赋值</p>
<p>3.调用类的静态方法</p>
<p>4.使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p>
<p>5.初始化某个类的子类</p>
<p>6.直接使用java.exe命令来运行某个主类</p>
<p>类加载器</p>
<p>负责将.class文件加载到内在中，并为之生成对应的Class对象。</p>
<p>虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行</p>
<p>类加载器的组成</p>
<p>Bootstrap ClassLoader 根类加载器 </p>
<p>也被称为引导类加载器，负责Java核心类的加载。比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</p>
<p>Extension ClassLoader 扩展类加载器</p>
<p>负责JRE的扩展目录中jar包的加载。在JDK中JRE的lib目录下ext目录</p>
<p>Sysetm ClassLoader 系统类加载器</p>
<p>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径</p>
<p>反射，一种计算机处理方式。是程序可以访问、检测和修改它本身状态或行为的一种能力。</p>
<p>反射：就是通过class文件对象，去使用该文件中的成员变量，构造方法，成员方法</p>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种****动态获取****的信息以及动态调用对象的方法的功能称为java语言的反射机制</p>
<p>//要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象</p>
<p>对于我们学习反射，我们在操作中一般会获取类的成员 Constructor  Field  Method。但是要想获取这些对象，必须首先得到其Class,通过Class再来获得其它对象</p>
<p>Java反射常用API</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps1.jpg" alt="img"> </p>
<p>Java中的Class可以代表任意的类或接口类型</p>
<p>在java.lang.reflect包下有三个类</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps2.jpg" alt="img"> </p>
<p>三种获取Class对象的方式</p>
<p>1:如果持有一个对象，可以直接从Object类继承的getClass()方法获取</p>
<p>Person p = new Person();</p>
<p> Class c = p.getClass();</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps3.jpg" alt="img"> </p>
<p>2:可以直接通过类包(接口)直接调用其静态属性.class获取</p>
<p>Class c2 = Person.class;</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps4.jpg" alt="img"> </p>
<p> 任意数据类型都具备一个class静态属性,看上去要比第一种方式简单.</p>
<p>3:可以通过Class类中提供的forName方法获取（将类名作为字符串传递给Class类中的静态方法forName即可）：</p>
<p>public static Class forName(String className)  这个类名必须是全路径：包名.类名（可以在外面写，会提示是否出错，没错的话沾过去；也可以点击类名下的类名右击copy Qualified name ）</p>
<p> Class c3 = Class.forName(“Person”);</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps5.jpg" alt="img"> </p>
<p>第三种和前两种的区别    ：前两种你必须明确Person类型；后面是一个字符串就行，而不需要是一个具体的类名.这种扩展更强.我不需要知道你的类.我只提供字符串,将这样的字符串配置到配置文件中，按照配置文件加载就可以了</p>
<p>所以开发中一般用第三种方法</p>
<p>Class类：</p>
<p>成员变量            Field</p>
<p>构造方法            Constructor</p>
<p>成员方法            Method</p>
<p>通过反射获取构造方法并使用：</p>
<p>获取构造方法：</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps6.jpg" alt="img"> </p>
<p>getConstructor它获取的是类的public构造</p>
<p>getConstructors它获取的是类的所有的public构造</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps7.jpg" alt="img"> </p>
<p>这两个方法不仅可以获取public，也可以获取其它权限的</p>
<p>获取单个构造方法</p>
<p>public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)  参数表示的是你要获取的构造方法的构造参数个数及数据类型的****class字节码****文件对象。…表示可以是0个（无参）一个（一个参数）多个（多个参数）</p>
<p>/*获取的单个构造方法实际上是一个对象，通过这个对象可以创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例</p>
<p>public T newInstance(Object… initargs)</p>
<p>反射可以获取私有的构造方法，成员方法，成员变量：</p>
<p>获取的如果是私有的构造方法，要用public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes),但是会显示非法的访问异常。所以还要用暴力访问：.setAccessible(true); 值为true指示反射的对象在使用时应该取消java语言访问检查  （XJAD软件就用到了反射）*/</p>
<p>我们得到构造器，就可以实例化对象</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps8.jpg" alt="img"> </p>
<p>如果不是public，那么我们需要构造器对象的实例调用AccessibleObject中的</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps9.jpg" alt="img"> </p>
<p>来取消语言检查</p>
<p>Reflect类继承于AccessibleObject类继承于Object类</p>
<p>通过反射获取成员变量并使用：Java.lang.reflect.Field它描述的属性对象</p>
<p>1.获取一个Field</p>
<p>获取所有成员</p>
<p>getFields  公共的</p>
<p>getDeclaredFields 所有的</p>
<p>获取单个成员</p>
<p>getField</p>
<p>getDeclaredField</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps10.jpg" alt="img"> </p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps11.jpg" alt="img"> </p>
<p>2.Field的操作</p>
<p>（1）对Field进行赋值</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps12.jpg" alt="img"> </p>
<p>赋值或修改成员的值</p>
<p>set(Object obj,Object value)<br>  将指定对象变量上此 Field 对象表示的字段设置为指定的新值。此处的obj需要通过构造方法创建一个obj对象，也可以直接通过Class的实例的newInstance方法直接获得obj对象（这个方法的底层就是使用了Class类额无参构造来实例化）</p>
<p>（2）对Field进行取值</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps13.jpg" alt="img"> </p>
<p>通过反射获取成员方法并使用：Java.lang.reflect.Method它描述的是类或接口中的方法</p>
<p>获取所有方法</p>
<p>​        getMethods 获取自己的包括父亲的公共方法</p>
<p>​        getDeclaredMethods 获取自己的所有方法</p>
<p>获取单个方法</p>
<p>​        getMethod（String name，Class&lt;?&gt;… parameterTypes）</p>
<p>​        getDeclaredMethod（String name，Class&lt;?&gt;… parameterTypes）</p>
<p>第一个参数是方法的名称，第二个参数是一个可变参数Class[]，它描述的是方法的参数Class</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps14.jpg" alt="img"> </p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps15.jpg" alt="img"> </p>
<p>Method的使用：public Object invoke (Object obj , Object… args)  返回值是Object接收，第一个参数表示对象是谁，第二个参数表示调用该方法的实际参数</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps16.jpg" alt="img"> </p>
<p>Method的invoke使用时注意事项?</p>
<p>\1. 如果方法是static，我们怎样调用？</p>
<p>如果方法是静态的，在通过invoke调用时不需要传递对象，传递null</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps17.jpg" alt="img"> </p>
<p>\2. 如果方法的参数是一个数组类型，怎样处理?</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps18.jpg" alt="img"> </p>
<p>为什么不能直接传args：因为数组也是object类型。在传递时，底层的invoke方法认为要调用的参数有四个。</p>
<p>为什么int[]直接传递args不报错，而Integer[]会报错：因为int[]数组中的每一个元素不是Object，只是基本数据类型，int[]被认为是一个对象。而Integer[]数组中的每一个元素都是Object</p>
<p>/*反射的调用和正常类的调用是恰好相反的。</p>
<p>正常类：p.show()    p.show(参数)</p>
<p>反射：show.invoke(p)   show.invoke(p，参数)</p>
<p>*/</p>
<p>案例：（这个案例可以帮助我们把集合中的值通过反射赋到一个类中）</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps19.jpg" alt="img"> </p>
<p>并提供get/set方法</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps20.jpg" alt="img"> </p>
<p>使用java中的反射技术将类中的属性与map中的key相同名称的，使用反射技术将key对应的value值赋值给属性.</p>
<p>采用两种方式完成操作：</p>
<p>1.直接操作属性 Field来完成操作（不常用）</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps21.jpg" alt="img"> </p>
<p>2.通过属性对应的setXxx方法来完成操作</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps22.jpg" alt="img"> </p>
<p>优点：</p>
<p>1、反射提高了程序的灵活性和扩展性。</p>
<p>2、降低耦合性，提高自适应能力。</p>
<p>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。<br>缺点：<br>    1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</p>
<p>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</p>
<p>反射：需要配置文件配合使用。 </p>
<p>配置文件是键值对。必须要有键，代码获取键；然后可以自己通过改变值，来使代码中的对象改变，从而获得不同的运行效果。</p>
<p>反射可以越过泛型检查。</p>
<p>真实的需求应该是在你调用方法后，每次操作前，都需要进行权限校验，在进行操作后，必须留下日志记录。</p>
<p>代理即Proxy Pattern，23种常用的面向对象软件的设计模式之一</p>
<p>代理模式的定义：为其他对象提供一种<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/24001.htm">代理</a>以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<p>组成：</p>
<p>抽象角色：通过接口或抽象类声明真实角色实现的业务方法。</p>
<p>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。</p>
<p>真实角色(目标对象)：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p>
<p>分类：</p>
<p>静态代理：是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p>
<p>动态代理：是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。</p>
<p>优点：</p>
<p>(1).职责清晰，真实的角色就是实现实际的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1642754.htm">业务逻辑</a>，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。</p>
<p>(2).代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。</p>
<p>(3).高扩展性</p>
<p>动态代理</p>
<p>代理：本来应该自己做的事情，却请了别人来做，被请的人就是代理对象。</p>
<p>动态代理：在程序运行过程中产生的这个对象</p>
<p>而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理</p>
<p>在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib（框架中学到，这个代理不仅仅是针对接口）</p>
<p>注意：在java中使用Proxy来完成动态代理对象的创建，只能为目标实现了接口的类创建代理对象。</p>
<p>Proxy类中的方法创建动态代理类对象：</p>
<p>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) </p>
<p>ClassLoader loader 是对象的字节码文件的类加载器：.getClass().getClassLoader()</p>
<p>Class&lt;?&gt;[] interfaces是对象的字节码文件的接口：.getClass().getInterfaces()</p>
<p>动态代理是在内存中直接生成代理对象。</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps23.jpg" alt="img"> </p>
<p>通过这个方法可以直接创建一个代理对象。</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps24.jpg" alt="img"> </p>
<p>//InvocationHandler应用了观察者模式，因为代理类没有实例，所以需要监听代理对象调用时，其底层实现的是目标行为</p>
<p>InvocationHandler h是一个接口，这里需要的是这个接口的实现类对象，所以需要创建一个类实现InvocationHandler接口。这个类中再重写InvocationHandler方法：public Object invoke(Object proxy,Method method,Object[] args)</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps25.jpg" alt="img"> </p>
<p>Invoke方法，它是在代理对象调用行为时，会执行的方法，而invoke方法上有三个参数：</p>
<p>proxy:代表动态代理对象</p>
<p>method:要访问的目标行为，代表要调用的方法对象</p>
<p>args:目标行为，代表调用目标方法时传入的实参</p>
<p>这个方法的主要作用是：当我们通过代理对象调用行为时，来控制目标行为是否可以被调用（可以自己写代码控制，return null 不让调，return method.invoke(target,args)控制目标对象的方法执行）。</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps26.jpg" alt="img"> </p>
<p>Proxy.newProxyInstance</p>
<p>创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。</p>
<p>System.out.println(u.getClass().getName());</p>
<p>案例:测试addUser方法的运行时间</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps27.jpg" alt="img"> </p>
<p>在开发中，在代理中通过目标来调用真实行为，我们使用动态代理可以完成性能监控（如上，进行时间的记录来监控性能），权限控制（在调用目标行为之前先判断是否有权限），日志记录（在调用方法之前，进行日志记录一些信息）等操作</p>
<p>注释（先写注释在写程序）</p>
<p>作用：用于解释说明程序的文字，提高程序的阅读性；可以帮助我们调试程序。</p>
<p>注释分类格式：</p>
<p>单行注释//  可以嵌套</p>
<p>多行注释/*   */  不能嵌套</p>
<p>文档注释/**   */</p>
<p>对于单行和多行注释，被注释的文字是不会被JVM解释执行</p>
<p>对于文档注释 是java特有的注释，其中的注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。</p>
<p>/*</p>
<p>需求：</p>
<p>分析：</p>
<p>实现：</p>
<p>*/</p>
<p>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的</p>
<p>它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。你可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现（SOURCE/CLASS/RUNTIME）。</p>
<p>作用：如果要对于元数据的作用进行分类，还没有明确的定义，不过我们可以根据它所起的作用，大致可分为三类：</p>
<p>编写文档：通过代码里标识的元数据生成文档。</p>
<p>代码分析：通过代码里标识的元数据对代码进行分析。</p>
<p>编译检查：通过代码里标识的元数据让<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/487018.htm">编译器</a>能实现基本的编译检查</p>
<p>在现在开发中使用注解，一般是用于将注解替换配置文件。（xml配置文件）</p>
<p>Java中基本内置注解:</p>
<p>1.@Override</p>
<p>它的作用是对覆盖超类中方法的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编译器会发出错误警告。</p>
<p>注意事项:</p>
<p>​    对于接口中的方法重写，<a href="mailto:在jdk1.5时@Override">在jdk1.5时@Override</a>它是会报错.</p>
<p>​    在jdk1.6后的版本就可以描述接口与类之间的重写</p>
<p>2.@Deprecated</p>
<p>它的作用是对不应该再使用的方法添加注解，当编程人员使用这些方法时，将会在编译时显示提示信息</p>
<p>问题:什么时候方法是过时的?</p>
<p>当前版本中这个方法存在隐患，在后续版本中对其进行了补充，这时前一个版本中的方法就会标注成过时的。</p>
<p>3.@SuppressWarnings</p>
<p>它的作用是去掉程序中的警告.</p>
<p>其参数有：</p>
<p>deprecation，使用了过时的类或方法时的警告</p>
<p>unchecked，执行了未检查的转换时的警告</p>
<p>fallthrough，当 switch 程序块直接通往下一种情况而没有 break 时的警告</p>
<p>path，在类路径、源文件路径等中有不存在的路径时的警告</p>
<p>serial，当在可序列化的类上缺少serialVersionUID 定义时的警告</p>
<p>finally ，任何 finally 子句不能正常完成时的警告</p>
<p>all，关于以上所有情况的警告</p>
<p>可以在方法之前加@SuppressWarnings（“rawtype”）</p>
<p>当一个类中出现了很多，可以在类上加@SuppressWarnings（“all”），一劳永逸</p>
<p>自定义注解</p>
<p>1.注解声明：声明一个注解格式：  修饰符 @interface 注解名{}</p>
<p>2.注解本质分析</p>
<p>分析一下注解的本质:将其.class文件找到，反编译.  (可以使用javap命令或反编译工具)</p>
<p>@interface MyAnnoation{}</p>
<p>反编译后的结果</p>
<p>interface MyAnnotation    extends Annotation</p>
<p>{</p>
<p>}</p>
<p>结论:注解本质上就是一个接口。它扩展了java.lang.annotation.Annotation接口;</p>
<p>在java中所有注解都是Annotation接口的子接口。</p>
<p>3.注解成员</p>
<p>注解本质上就是一个接口，那么它也可以有属性和方法。</p>
<p>但是接口中的属性是 public static final的，在注解中注解没有什么意义。</p>
<p>在开发中注解中经常存在的是方法（这个方法的返回值类型有要求）。而在注解中接口的方法叫做注解的属性.</p>
<p>4.自定义注解-属性操作</p>
<p>注解属性类型：</p>
<p>1.基本类型  byte short int long float double char boolean</p>
<p>​    2.String</p>
<p>​    3.枚举类型：可以自己创建一个枚举类，然后类名 方法名();</p>
<p>​    4.注解类型</p>
<p>​    5.Class类型</p>
<p>​    6.以上类型的一维数组类型</p>
<p>注解属性的使用</p>
<p>1.如果一个注解有属性，那么在使用注解时，要对属性进行赋值操作.</p>
<p>​    例如:@MyAnnotation(st = “aaa”)</p>
<p>2.如果一个注解的属性有多个，都需要赋值，使用”,”分开属性.</p>
<p>​    @MyAnnotation(st = “aaa”,i=10)</p>
<p>3.也可以给属性赋默认值</p>
<p>​    double d() <em><strong>*default 1.23*</strong></em>;</p>
<p>​    如果属性有默认值，在使用注解时，就可以不用为属性赋值。    </p>
<p>4.如果属性是数组类型</p>
<p>​        1.可以直接使用  属性名={值1,值2,。。。}方式,例如</p>
<p>​            @MyAnnotation(st = “aaa”,i=10,sts={“a”,”b”})</p>
<p>​        2.如果数组的值只有一个也可以写成下面方式</p>
<p>​            @MyAnnotation(st = “aaa”,i=10,sts=”a”)</p>
<p>​            注意sts属性它是数组类型，也就是说，只有一个值时，可以省略”{}”</p>
<p>​        </p>
<p>5.对于属性名称 value的操作.</p>
<p>​            1.如果属性名称叫value,那么在使用时，可以省略属性名称</p>
<p>​                @MyAnnotation(“hello”)</p>
<p>​            2.如果有多个属性，都需要赋值，其中一个叫value,这时，必须写属性名称</p>
<p>​                @MyAnnotation(value=”hello”,i=10)</p>
<p>​        </p>
<p>​            3.如果属性名称叫value,它的类型是数组类型.</p>
<p>​                1.只有这个value属性</p>
<p>​                可以直接赋值，不能写属性名称,但是，如果只有一个值</p>
<p>​                    @MyAnnotation({“abc”})或  @MyAnnotation(“abc”)</p>
<p>​                但是如果有多个值</p>
<p>​                    @MyAnnotation({“abc”,”def”})                        </p>
<p>​                2.如果有多个属性，属性名称叫value</p>
<p>​                    所有属性都需要赋值，那么必须写属性名称.</p>
<p>5.自定义注解-元注解</p>
<p>元注解及其作用：用于修饰注解的注解，可以描述注解在什么范围及在什么阶段使用等</p>
<p>四个元注解介绍：</p>
<p>@Retention</p>
<p>指定注解信息在哪个阶段存在 Source Class Runtime</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps1-1618812955705.jpg" alt="img"> </p>
<p>SOURCE它对应着编译阶段，可以帮助我们进行检查。</p>
<p>CLASS 它对应解析执行阶段</p>
<p>RUNTIME 它对应着在JVM中,在运行时结合反射技术，可以使注解具有一些功能</p>
<p>@Target</p>
<p>指定注解修饰目标对象的类型  </p>
<p>TYPE 类、接口   FIELD 成员变量   METHOD 方法</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps2-1618812955706.jpg" alt="img"> </p>
<p><a href="mailto:在接口的定义中前面进行元注解@Target(ElementType.TYPE)标注">在接口的定义中前面进行元注解@Target(ElementType.TYPE)标注</a>后，这个自定义注解只能用在TYPE即类、接口上，不能用于方法上。</p>
<p><a href="mailto:如果要求自定义的注解需要用在多个地方。可以@Target({ElementType.TYPE,ElementType.METHOD})">如果要求自定义的注解需要用在多个地方。可以@Target({ElementType.TYPE,ElementType.METHOD})</a></p>
<p>@Documented</p>
<p>使用该元注解修饰，该注解的信息可以生成到javadoc 文档中</p>
<p>@Inherited</p>
<p>如果一个注解使用该元注解修饰，应用注解目标类的子类会自动继承该注解 </p>
<p>@Retention @Target 是自定义注解必须使用两个元注解，并且，@Retention它的值应该是RUNTIME,因为我们会结合反射技术来使用。 @Target我们一般使用TYPE或METHOD</p>
<p>案例-获取Connection连接数据库</p>
<p>目的：让注解具有功能，必须结合反射技术来应用。</p>
<p>注解它可以替换配置文件。</p>
<p>第一步:创建注解</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps3-1618812955706.jpg" alt="img"> </p>
<p>第二步:使用注解</p>
<p>在方法上进行注解标注：</p>
<p>@JdbcProperty（driverClass=””,url=””,user=””,password=””）</p>
<p>我们可以通过getAnnotation()方法（这个方法在Class，Method。Field中都有）来获取注解对象</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps4-1618812955706.jpg" alt="img"> </p>
<p>通过jp.driverClass  jp.url 等就可以得到注解的值，然后在数据库连接中使用，进行数据库连接</p>
<p>这里的操作实际上相当于是以前在配置文件中写这些属性值，在代码中从配置文件中取。</p>
<p>问题:使用注解可以替换配置文件，为什么要替换?</p>
<p>​    配置文件中的信息，它会随着程序的变大，配置信息越来越多，不利于开发。而将配置信息通过注解来替换，便于开发与阅读。</p>
<p>缺点：如果需要更改，需要在源代码上修改注解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/" data-id="ckw61sdw8004moswd2s9j6i8b" data-title="反射和注解" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.21.GUI编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.21.GUI%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:41.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.21.GUI%E7%BC%96%E7%A8%8B/">GUI编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>GUI(图形用户界面)</p>
<p>Java为GUI提供的对象都存在java.Awt和javax.Swing两个包中</p>
<p>GUI：Graphical User Interface(图形用户接口)。</p>
<p>用图形的方式，来显示计算机操作的界面，这样更方便更直观。</p>
<p>CLI：Command line User Interface (命令行用户接口）</p>
<p>就是常见的Dos命令行操作。</p>
<p>需要记忆一些常用的命令，操作不直观。</p>
<p>java.awt：Abstract Window ToolKit (抽象窗口工具包)，需要调用本地系统方法实现功能。属重量级控件。</p>
<p>javax.swing：在AWT的基础上，建立的一套图形界面系统，其中提供了更多的组件，而且完全由Java实现。增强了移植性，属轻量级控件。</p>
<p>javax是java扩展包</p>
<p>和本地系统相关的，就是重量级控件，因为移植性很差。完全由java实现的，移植性就很好，属于轻量级控件。（这里的轻重是与操作系统的关系）</p>
<p><img src="/4.21.GUI%E7%BC%96%E7%A8%8B/wps1.jpg" alt="img"> </p>
<p>Component（组件）</p>
<p>Container：为容器，是一个特殊的组件，该组件中可以通过add方法添加其他组件进来。</p>
<p>Window：窗体  没有边界和标题</p>
<p>Panel：面板</p>
<p>Frame：框架  有边界和标题</p>
<p>Dialog：对话框</p>
<p>FileDialog：文件对话框</p>
<p>Button：按钮</p>
<p>Label：标签</p>
<p>Checkbox：复选框</p>
<p>TextComponent：文本组件</p>
<p>TextArea：文本域  多行多列</p>
<p>TextField：文本框  单行多列</p>
<p>Frame  f = new Frame(“my window”);//构造方法命名 setTile是方法命名</p>
<p>f.setLayout(new FlowLayout());//设置为流式布局</p>
<p>f.setSize(300,400);//设置窗体大小 Dimension</p>
<p>f.setLocation(300,200);//设置窗体出现在屏幕的位置 Point</p>
<p>f.setVisible(true);//设置窗体是否可见</p>
<p>一个方法：setBounds（int x,int y,int width,int height）</p>
<p>前后是有顺序关系的，如果f.setVisible(true);在前面就会先显示再加载到指定位置。一般是这个步骤：创建窗体对象；设置窗体属性；设置窗体可见</p>
<p>事件监听机制</p>
<p>事件源：事件发生的地方</p>
<p>事件：要发生的事情</p>
<p>事件处理：针对发生的事情做出的处理方案</p>
<p>事件监听器：就是把事件源和事件关联起来</p>
<p>窗体布局：窗体中组件的排列方式</p>
<p>流式布局FlowLayout：从上到下，从左到右。</p>
<p>边界布局BorderLayout：东西南北中</p>
<p>网格布局GridLayout：网格状，标准n行n列</p>
<p>网格包布局GridBagLayout：可以将任意个相连的网格状连在一起当一个</p>
<p>卡片布局CardLayout：类似于卡片，点一个卡片会在主界面加载一个</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.21.GUI%E7%BC%96%E7%A8%8B/" data-id="ckw61sdv7001soswddffshzqo" data-title="GUI编程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.18.网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:31.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>计算机网络：是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<p>网络编程：就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。</p>
<p>网络模型：</p>
<p>OSI（Open System Interconnection开放系统互连）参考模型</p>
<p>TCP/IP参考模型</p>
<p><img src="/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/wps1.png" alt="img"> </p>
<p>网络模型7层概述：</p>
<p> 1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 </p>
<ol start="2">
<li><p>数据链路层：主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 </p>
</li>
<li><p>网络层：主要将从下层接收到的数据进行IP地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 </p>
</li>
<li><p>传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 </p>
</li>
<li><p>会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） </p>
</li>
</ol>
<p>6.表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 </p>
<p>7.应用层： 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。</p>
<p>网络应用程序：网络编程、IO流、多线程组成。集合</p>
<p>网络通信三要素：</p>
<p>1.IP地址:InetAddress（找到电脑）</p>
<p>​    网络中设备的标识，不易记忆，可用主机名</p>
<p>2.端口号：（区分电脑的程序）</p>
<p>​    用于标识进程的逻辑地址，不同进程的标识</p>
<p>3.传输协议：（怎么交流传输）</p>
<p>​    通讯的规则，常见协议：TCP，UDP</p>
<p>IP地址</p>
<p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接受数据的计算机和识别发送的计算机，在TCP/IP协议中，这个标识号就是IP地址</p>
<p>所谓IP地址就是给每个连接在Internet上的主机分配的一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，比特换算成字节，就是4个字节。例如一个采用二进制形式的IP地址是“00001010000000000000000000000001”，这么长的地址，人们处理起来也太费劲了。为了方便人们的使用，IP地址经常被写成十进制的形式，中间使用符号“.”分开不同的字节。于是，上面的IP地址可以表示为“10.0.0.1”。IP地址的这种把IP地址的每一个字节的数据换算成十进制，然后用.分开来表示的方法叫做“点分十进制表示法”，这显然比1和0容易记忆得多。</p>
<p>IP地址的组成：IP地址 = 网络号码+主机地址</p>
<p>A类    1.0.0.1—127.255.255.254</p>
<p>(1)10.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)        </p>
<p>(2)127.X.X.X是保留地址，用做循环测试用的。</p>
<p>B类    128.0.0.1—191.255.255.254    </p>
<p>172.16.0.0—172.31.255.255是私有地址。</p>
<p>169.254.X.X是保留地址。</p>
<p>C类    192.0.0.1—223.255.255.254    192.168.X.X是私有地址</p>
<p>D类    224.0.0.1—239.255.255.254     </p>
<p>E类    240.0.0.1—247.255.255.254    </p>
<p>DOS命令 ipconfig:查看本机IP地址</p>
<p>ping+IP地址：测试本机与指定的ip地址间的通信是否有问题</p>
<p>127.0.0.1 回环地址,可用于测试本机的网络是否有问题. ping 127.0.0.1  </p>
<p>xxx.xxx.xxx.0 网络地址</p>
<p>xxx.xxx.xxx.255 广播地址</p>
<p>A类IP地址:第一段号码为网络号码，剩下的三段号码为本地计算机的号码</p>
<p>B类IP地址:前二段号码为网络号码，剩下的二段号码为本地计算机的号码</p>
<p>C类IP地址:前三段号码为网络号码，剩下的一段号码为本地计算机的号码</p>
<p>//A类大部分在美国，中国可能有几个。B类一般是校园网之类的。C类是平常我们用的。DE类是保留地址，不用。</p>
<p>为了方便我们对IP地址的获取和操作，java提供了一个类InetAddress 供我们使用。但是这个类没有构造方法</p>
<p>如果一个类没有构造方法：</p>
<p>A：成员全部是静态的（Math，Arrays，Collections）</p>
<p>B：单例设计模式（Runtime）</p>
<p>C：类中有静态方法返回该类的对象（InetAddress）</p>
<p>class Demo{</p>
<p>private Demo(){}</p>
<p>public static Demo getXxx(){</p>
<p>return new Demo();</p>
<p>}</p>
<p>}</p>
<p>成员方法：</p>
<p>public static InetAdress getByName(String host):根据主机名或者ip地址的字符串表示得到IP地址对象</p>
<p>主机名：getHostName</p>
<p>主机Ip地址：getHostAddress</p>
<p>端口号：正在运行的程序的标识</p>
<p>物理端口 网卡口</p>
<p>逻辑端口 我们指的就是逻辑端口</p>
<p>​    A:每个网络程序都会至少有一个逻辑端口</p>
<p>​    B:用于标识进程的逻辑地址，不同进程的标识</p>
<p>​    C:有效端口：0<del>65535，其中0</del>1024系统使用或保留端口。</p>
<p>​    通过一些应用程序就可以查看端口号</p>
<p>协议</p>
<p>UDP：将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小在限制在64k；因无连接，是不可靠协议；不需要建立连接，速度快</p>
<p>TCP：建立连接，形成传输数据的通道；在连接中进行大数据量传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍低</p>
<p>Socket套接字</p>
<p>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</p>
<p>Socket原理机制：</p>
<p>通信的两端都有Socket。</p>
<p>网络通信其实就是Socket间的通信。</p>
<p>数据在两个Socket间通过IO传输。</p>
<p>原则上是先存在接收端。</p>
<p>UDP协议发送数据：</p>
<p>A：创建发送端Socket对象</p>
<p>B：创建数据，并把数据打包</p>
<p>C：调用Socket对象的发送方法发送数据包</p>
<p>D：释放资源</p>
<p>UDP协议接收数据：</p>
<p>A：创建接收端Socket对象</p>
<p>B：创建一个数据包（接收容器）</p>
<p>C：调用Socket对象的接收方法接收数据  阻塞式方法</p>
<p>D：解析数据包，并显示在控制台</p>
<p>E：释放资源</p>
<p>运行的时候先运行接收端，在运行发送端。第二次运行接收端会报错：该端口已经被占用</p>
<p>TCP协议发送数据：</p>
<p>A：创建发送端的Socket对象</p>
<p>B：获取输出流，写数据</p>
<p>C：释放资源</p>
<p>运行的话会出现连接被拒绝的错误。所以TCP协议一定要先开服务器</p>
<p>TCP协议发送数据：</p>
<p>A：创建接收端的Socket对象  ServerSocket</p>
<p>B：监听客户端连接，返回一个对应的Socket对象  阻塞式方法</p>
<p>C：获取输入流，读取数据显示在控制台</p>
<p>D：释放资源</p>
<p>TCP传输容易出现的问题：</p>
<p>客户端连接上服务端，两端都在等待，没有任何数据传输：</p>
<p>因为read方法或者readLine方法是阻塞式。</p>
<p>解决办法：A：再多写一条数据告诉服务器，读到这条就结束（不推荐）</p>
<p>B：Socket提供了一个终止功能：public void shutdownOutput()</p>
<p>shutdownInput（）方法</p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。</p>
<h5 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h5><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OKUeiaP72uRyLxLtgCJqzyegqJrXr5UdiaLB9wpXuEpfjflJAG5ALCN2um0YKmxJeNZfJejcECbfocuwrsKuttOw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>特点：</p>
<ol>
<li>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</li>
<li>无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</li>
<li>基于请求和响应：基本的特性，由客户端发起请求，服务端响应</li>
<li>简单快速、灵活</li>
<li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="ckw61sdv6001qoswdg2nrb9xo" data-title="网络编程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.19.多线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.19.%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:24.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.19.%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>程序只有一个执行流程，所以这样的程序就是单线程程序。</p>
<p>假如一个程序有多条执行流程，那么，该程序就是多线程程序。</p>
<p>线程是依赖于进程而存在的</p>
<p>进程：就是正在运行的程序。</p>
<p>是系统进行资源分配和调用的独立单位，每一个进程都有它自己的内存空间和系统资源。</p>
<p>单进程的计算机只能做一件事情，现在的计算机都是支持多进程的。可以在一个时间段内执行多个任务，并且可以提高CPU的使用率。</p>
<p>单CPU在某个时间点只能做一件事情，CPU在做程序间的高效切换让我们觉得是同时进行的。</p>
<p>线程：在同一个进程内又可以执行多个任务，而这每一个任务就可以看作是一个线程。是进程中的单个顺序控制流，是一条执行路径</p>
<p>线程是程序的执行单元，执行路径。是程序使用CPU的最基本的单位。</p>
<p>一个进程如果只有一条执行路径，则称为单线程程序。</p>
<p>一个进程如果有多条执行路径，则称为多线程程序。</p>
<p>多线程的存在不是提高程序的执行速度，其实是为了提高应用程序的使用率。</p>
<p>程序的执行其实都是在抢CPU的资源，CPU的执行权，多个线程都在抢这个资源，而其中的某一个进程如果执行路径比较多，就会有更高的几率抢到CPU的执行权。我们不敢保证哪一个线程能够在哪个时刻抢到，所以线程的执行有随机性。</p>
<p>并行：逻辑上同时发生，指在某一个时间内同时运行多个程序</p>
<p>并发：物理上同时发生。指在某一个时间点同时运行多个程序</p>
<p>java程序的运行原理：由java命令启动了JVM，JVM启动就相当于启动了一个进程。接着由该进程创建了一个主线程去调用main方法</p>
<p>jvm虚拟机的启动是单线程的还是多线程的？</p>
<p>多线程的。因为垃圾回收线程也要先启动，否则就会出现内存溢出。</p>
<p>如何实现多线程的程序：</p>
<p>A：继承Thread类</p>
<p>步骤：1.自定义类继承Thread类</p>
<p>\2. 在自定义类内重写run()方法</p>
<p>\3. 创建该类的对象</p>
<p>\4. 启动线程</p>
<p>为什么要重写run()方法：不是类中的所有代码都需要被线程执行的。为了区分哪些代码能够被线程执行，java提供了Thread类中的run()方法用来包含那些被线程执行的代码</p>
<p>//一般来说，被线程执行的代码肯定是比较耗时的。所以用循环改进</p>
<p>run()和start()方法的区别：</p>
<p>run()仅仅是封装被线程执行的代码，直接调用是普通方法</p>
<p>start()首先启动了线程，然后由jvm去调用该线程的run()方法</p>
<p>如何获取和设置线程名称</p>
<p>public final String getName() 获取线程的名称</p>
<p>public final void setName(String name) </p>
<p>通过构造方法也可以给线程起名字，带参构造</p>
<p>如何获取main方法所在的线程名称呢?</p>
<p>public static Thread currentThread() 返回当前正在执行的线程对象</p>
<p>Thread.currentThread().getName() 这样就可以获取任意方法所在的线程名称</p>
<p>线程有两种调度模型：</p>
<p>分时调度模型:所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</p>
<p>抢占式调度模型:优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 </p>
<p>Java使用的是抢占式调度模型。</p>
<p>如何设置和获取线程优先级</p>
<p>public final int getPriority() 返回线程对象的优先级 线程默认优先级是5</p>
<p>public final void setPriority(int newPriority) 更改线程的优先级 线程优先级的范围是1-10</p>
<p>线程优先级仅仅表示线程获取CPU时间片的几率高，但是要在次数比较多或者多次运行的时候才能看到比较好的效果</p>
<p>线程控制</p>
<p>线程休眠</p>
<p>public static void sleep(long millis)</p>
<p>线程加入</p>
<p>public final void join() 等待该线程终止</p>
<p>线程礼让</p>
<p>public static void yield() 暂停当前正在执行的线程对象，并执行其他线程</p>
<p>让多个线程的执行更和谐，但是不能靠它保证一人一次</p>
<p>后台线程</p>
<p>public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程</p>
<p>当正在运行的线程都是守护线程时，java虚拟机退出，该方法必须在启动线程前调用</p>
<p>中断线程</p>
<p>public final void stop() 已过时。具有不安全性，不建议使用</p>
<p>public void interrupt() 中断线程。把线程状态终止，并抛出一个InterruptedException</p>
<p>线程的生命周期：</p>
<p>新建：创建线程对象</p>
<p>就绪：有执行资格，没有执行权</p>
<p>运行：有执行资格，有执行权</p>
<p>阻塞：由于一些操作让线程处于该状态，没有执行资格，没有执行权。而另一些操作却可以把它激活，激活后处于就绪状态</p>
<p>死亡：线程对象变为垃圾，等待回收</p>
<p>B：实现Runnable接口</p>
<p>步骤：1.自定义类实现Runnable接口</p>
<p>\2. 重写run()方法</p>
<p>\3. 创建自定义类对象</p>
<p>\4. 创建Thread类对象，并把3中的对象作为构造参数传递</p>
<p>B方式的好处，实现接口方式的好处：</p>
<p>可以避免由于Java单继承带来的局限性。</p>
<p>适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。</p>
<p>电影院售票出现问题：</p>
<p>1.相同的票出现多次：CPU的一次操作必须是原子性的</p>
<p>2.还出现了负数的票：随机性和延迟导致的</p>
<p>判断是否有多线程问题的标准：</p>
<p>1.是否是多线程环境</p>
<p>2.是否有共享数据</p>
<p>3.是否有多条语句操作共享数据</p>
<p>解决线程安全问题实现：</p>
<p>1.同步代码块</p>
<p>格式：</p>
<p>​        synchronized(对象){需要同步的代码;}</p>
<p>同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。这个对象可以是任意对象。</p>
<p>同步的前提：多个线程，多个线程使用的是同一个锁对象</p>
<p>同步的好处：同步的出现解决了多线程的安全问题。</p>
<p>同步的弊端：当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</p>
<p>2.同步方法</p>
<p>就是把同步关键字加到方法上（一般在权限修饰符后面）</p>
<p>同步方法的锁对象是：this</p>
<p>静态方法的同步方法的锁对象：是当前类的字节码文件对象。（反射）</p>
<p>如果锁对象是this，就可以考虑使用同步方法。</p>
<p>否则能使用同步代码块的尽量使用同步代码块。</p>
<p>线程安全的类：</p>
<p>StringBuffer  </p>
<p>Vector&lt;&gt; 即使要安全，也不用。可以用Collections工具类中的静态方法synchronizedXxx方法</p>
<p>Hashtable&lt;,&gt;</p>
<p>JDK5以后提供了一个新的锁对象Lock</p>
<p>Lock是一个接口</p>
<p>void lock() 获取锁</p>
<p>void unlock() 释放锁</p>
<p>ReentrantLock Lock的实现类。这个类同时也实现了序列化Serializable接口</p>
<p>可能加锁后的代码会出问题，导致无法释放锁。所以可以选择加try…finally语句</p>
<p>同步弊端：效率低；如果出现了同步嵌套，就容易产生死锁问题</p>
<p>死锁问题：是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> DieLock <em><strong>*extends*</strong></em> Thread {</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*boolean*</strong></em> flag;</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> main(String[] args) {</p>
<p>​        DieLock l1 = <em><strong>*new*</strong></em> DieLock(<em><strong>*true*</strong></em>);</p>
<p>​        DieLock l2 = <em><strong>*new*</strong></em> DieLock(<em><strong>*false*</strong></em>);</p>
<p>​        l1.start();</p>
<p>​        l2.start();</p>
<p>​    }</p>
<p>​    <em><strong>*public*</strong></em> DieLock(<em><strong>*boolean*</strong></em> flag) {</p>
<p>​        <em><strong>*this*</strong></em>.flag = flag;</p>
<p>​    }</p>
<p>​    @Override</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> run() {</p>
<p>​        <em><strong>*if*</strong></em> (flag) {</p>
<p>​            <em><strong>*synchronized*</strong></em> (MyLock.****<em>objA*</em>***) {</p>
<p>​                System.****<em>out*</em>***.println(“if的ogjA”);</p>
<p>​                <em><strong>*synchronized*</strong></em> (MyLock.****<em>objB*</em>***) {</p>
<p>​                    System.****<em>out*</em>***.println(“if的ogjB”);</p>
<p>​                }</p>
<p>​            }</p>
<p>​        } <em><strong>*else*</strong></em> {</p>
<p>​            <em><strong>*synchronized*</strong></em> (MyLock.****<em>objB*</em>***) {</p>
<p>​                System.****<em>out*</em>***.println(“else的ogjB”);</p>
<p>​                <em><strong>*synchronized*</strong></em> (MyLock.****<em>objA*</em>***) {</p>
<p>​                    System.****<em>out*</em>***.println(“else的ogjA”);</p>
<p>​                }</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>线程间通信问题：不同种类的线程间针对同一个资源的操作</p>
<p>通过设置线程(生产者)和获取线程(消费者)针对同一个对象进行操作</p>
<p>1.如何保证是同一个对象的操作：在外界把这个对象创建出来，然后通过构造方法传递给其他的类。</p>
<p>2.CPU的时间片在很短的时间内可以执行很多条代码会产生相同的数据，线程抢占的随机性也会导致安全问题：所以要加锁。不同种类的线程都要加锁，而且这加的锁必须是同一把才能保证安全。（传的对象要是同一个）</p>
<p>3.如果消费者先抢到执行权，就会先执行，但是会输出默认值，无意义。如果生产者先抢到先执行后再抢到会继续生产，不合常理。所以应该：生产者先看是否有数据，有就等待，没有就生产，生产完之后通知消费者来消费数据。消费者先看是否有数据，有就消费，没有就等待，通知生产者生产数据。</p>
<p>所以java提供了一种机制：等待唤醒机制实现数据依次出现</p>
<p>Object类中提供了三个方法：</p>
<p>wait()  等待  会立即释放锁，当唤醒时从此处继续执行</p>
<p>notify()  唤醒单个线程  唤醒并不代表立即执行，还需要抢夺执行权</p>
<p>notifyAll()  唤醒所有线程</p>
<p>为什么这些方法不定义在Thread类中：因为这些方法的调用必须通过锁对象调用，而我们使用的同步块锁对象是任意锁对象。所以这些方法必须定义在Object类中</p>
<p>把同步代码块改进为同步方法实现，以后只需要调用方法即可</p>
<p>ThreadGroup 线程组：把多个线程组合到一起。它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制</p>
<p>线程类里面的方法：</p>
<p>public final ThreadGroup getThreadGroup() </p>
<p>线程组里面的方法：public final String getName()</p>
<p>默认情况下，所有的线程都属于主线程组main</p>
<p>也可以给线程设置分组:创建一个线程组；创建其他线程的时候，把其他线程的组指定为我们自己新建线程组</p>
<p>Thread(ThreadGroup group, Runnable target, String name) </p>
<p>线程组的意义：通过组名称调用方法，可以设置此线程组的各种优先级，状态等等。</p>
<p>线程池</p>
<p>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。</p>
<p>好处：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</p>
<p>在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</p>
<p>JDK5新增了一个Executors工厂类来产生线程池</p>
<p>public static ExecutorService newCachedThreadPool() 创建一个新的缓存线程池</p>
<p>public static ExecutorService newFixedThreadPool(int nThreads) 创建一个int值的线程池</p>
<p>public static ExecutorService newSingleThreadExecutor() 创建一个线程池 相当于是int=1</p>
<p>如何实现线程池的代码：</p>
<p>\1. 创建一个线程池对象，控制要创建几个线程对象</p>
<p>public static ExecutorService newFixedThreadPool(int nThreads) </p>
<p>\2. 这种线程池的线程可以执行：</p>
<p>Runnable对象或者Callable对象代表的线程</p>
<p>做一个类实现Runnable接口</p>
<p>\3. 线程池调用方法：</p>
<p>Future&lt;?&gt; submit(Runnable task)</p>
<p><T> Future<T> submit(Callable<T> task)</p>
<p>4.线程池结束：shutdown()方法</p>
<p>第三种实现线程的方式：实现Callable接口（是带泛型的接口）</p>
<p>这里指定的泛型是call()方法的返回值类型（这里的call()方法相当于那两个方法的run()方法）</p>
<p>好处：</p>
<p>可以有返回值</p>
<p>可以抛出异常</p>
<p>弊端：</p>
<p>代码比较复杂，必须依赖线程池，所以一般不用</p>
<p>匿名内部类方式使用多线程</p>
<p>继承Thread类来实现多线程：</p>
<p>new Thread(){代码…}.start();</p>
<p>实现Runnable接口来实现多线程：</p>
<p>new Thread(new Runnable(){代码…}){}.start();</p>
<p>(如果既继承了Thread类，又实现了Runnable接口，则输出是以继承的Thread类为主，但这是毫无意义的代码)</p>
<p>定时器：可以让我们在指定的时间做某件事情，还可以重复的做某件事情</p>
<p>定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行。在Java中，可以通过Timer和TimerTask类来实现定义调度的功能</p>
<p>Timer类：定时</p>
<p>public Timer() 构造方法</p>
<p>public void schedule(TimerTask task, long delay) delay毫秒后执行任务</p>
<p>public void schedule(TimerTask task,long delay,long period) delay毫秒后执行任务，period毫秒后重复执行</p>
<p>public void cancel()</p>
<p>TimerTask类（抽象类）：任务</p>
<p>public abstract void run()</p>
<p>public boolean cancel()</p>
<p>开发中（基本不用上两种方法，而是使用框架）</p>
<p><strong>Quartz</strong>是一个完全由java编写的开源调度框架</p>
<p>sleep()和wait()的区别：</p>
<p>sleep()：必须指时间；不释放锁</p>
<p>wait():可以不指时间，也可以指时间；释放锁</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><strong>共享锁（S锁）：</strong> 又称为读锁，可以查看但无法修改和删除的一种数据锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。共享锁下其它用户可以并发读取，查询数据。但不能修改，增加，删除数据。资源共享.</p>
<p><strong>排它锁（X锁）：</strong>　又称为写锁、独占锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A</p>
<p><strong>互斥锁：</strong> 在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为” 互斥锁” 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</p>
<p><strong>悲观锁、乐观锁：</strong></p>
<p><strong>悲观锁：</strong> 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI2ODkxMTc5OA==&mid=2247483850&idx=1&sn=398b0e3d4687fa7fce10e525e41f7ba6&chksm=eae91413dd9e9d05135e8427bfc18937175ccf948972cd9ddb96dbb9faae268b90499f8817d9&scene=21#wechat_redirect">《LeetCode刷题Java版答案》pdf来了</a></p>
<p><strong>乐观锁：</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<p><strong>行级锁：</strong> 行级锁是 MySQL 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p><strong>表级锁：</strong> 表级锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MyISAM 与 InnoDB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p><strong>页级锁：</strong>　页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。BDB 支持页级锁。开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
<p><strong>丢失修改：</strong> 指事务1和事务2同时读入相同的数据并进行修改，事务2提交的结果破坏了事务1提交的结果，导致事务1进行的修改丢失。</p>
<p><strong>不可重复读：</strong> 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！</p>
<p><strong>读脏数据：</strong> 事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤消，这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，则T2读到的数据就为”脏”数据，即不正确的数据。<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI2ODkxMTc5OA==&mid=2247483850&idx=1&sn=398b0e3d4687fa7fce10e525e41f7ba6&chksm=eae91413dd9e9d05135e8427bfc18937175ccf948972cd9ddb96dbb9faae268b90499f8817d9&scene=21#wechat_redirect">《LeetCode刷题Java版答案》pdf来了</a></p>
<p><strong>死锁：</strong> 两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p>
<p>死锁四个产生条件：</p>
<p><strong>1）互斥条件：</strong>　指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p>
<p><strong>2）请求和保持条件：</strong> 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
<p><strong>3）不剥夺条件：</strong> 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>
<p><strong>4）环路等待条件：</strong> 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.19.%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="ckw61sdw8004noswd6glxajlh" data-title="多线程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.13.IO流" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.13.IO%E6%B5%81/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:16.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.13.IO%E6%B5%81/">IO流</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>上传操作：IO读取客户端数据写到服务器。</p>
<p>IO也可以读取服务器数据显示到客户端。</p>
<p>我们要实现IO的操作，就必须知道硬盘上文件的表现形式，所以java提供了File类</p>
<p>File类：io包下，文件和目录路径名的抽象表示形式（未必真实存在）</p>
<p>构造方法：（路径名中的\要用\表示）</p>
<p>public File(String pathname) 根据一个路径得到File对象</p>
<p>public File(String parent,String child) 根据一个目录和一个子文件/目录得到File对象</p>
<p>public File(File parent,String child) 根据一个父File对象和一个子文件/目录得到File对象</p>
<p>File类的成员方法：</p>
<p>1.创建功能</p>
<p>public boolean createNewFile()  创建文件  如果存在这样的文件，就不创建（这个方法有异常，错的话会抛出）</p>
<p>public boolean mkdir()  创建文件夹  如果存在这样的文件夹，就不创建了（这个方法没有异常，错的话就是false）</p>
<p>要想在某个目录下创建内容，该目录首先必须存在，所以有了这个方法：</p>
<p>public boolean mkdirs()  创建文件夹 如果父文件夹不存在，会帮你创建出来（创建多级文件夹）</p>
<p>注意：创建文件还是文件夹要搞清楚，方法不要调错了</p>
<p>如果创建文件或者文件夹没有写盘符，那么默认在项目路径下。（项目中就能看到）</p>
<p>2.删除功能</p>
<p>public boolean delete()  </p>
<p>java中的删除不走回收站</p>
<p>要删除一个文件夹，注意该文件夹内不能包含文件或者文件夹</p>
<p>3.重命名功能</p>
<p>public boolean renameTo(File dest)</p>
<p>如果路径名相同就是改名。如果路径名不同，就是改名并剪切</p>
<p>路径以盘符开始：绝对路径  c:\a.txt</p>
<p>路径不以盘符开始：相对路径  a.txt</p>
<p>4.判断功能</p>
<p>public boolean isDirectory()  判断是否是目录</p>
<p>public boolean isFile()</p>
<p>public boolean exists()</p>
<p>public boolean canRead()</p>
<p>public boolean canWrite()</p>
<p>public boolean isHidden()</p>
<p>5.基本获取功能</p>
<p>public String getAbsolutePath() 获取绝对路径</p>
<p>public String getPath()  获取相对路径</p>
<p>public String getName()  获取名称</p>
<p>public long length()  获取长度（字节数）</p>
<p>public long lastModified()  获取最后一次的修改时间（毫秒值）</p>
<p>6.高级获取功能</p>
<p>public String[] list()  获取指定目录下的所有文件或者文件夹的名称数组</p>
<p>public File[] listFiles()  获取指定目录下的所有文件或者文件夹的File数组</p>
<p>1.判断E盘下是否有后缀名为.txt的文件，如果有，就输出此文件名称：</p>
<p>A：先获取所有的E盘目录中的文件和文件夹，然后在遍历的时候判断是否是文件，是否是后缀为txt，满足条件就输出（用public File[] listFiles()方法）</p>
<p>B：文件名称过滤器获取E盘目录下的所有数组名称，判断满足条件的元素并直接输出  （用public String[] list()方法）</p>
<p>\2. 批量修改一系列文件的名字：</p>
<p>封装目录；获取该目录下所有文件的File数组；遍历该数组得到每一个File对象；拼接一个新的名称；调用方法重命名即可。 </p>
<p>7.文件名称过滤器：FilenameFilter是一个接口，可以写这个接口的匿名实现类</p>
<p>public String[] list(FilenameFilter filter)</p>
<p>public File[] listFiles(FilenameFilter filter)</p>
<p>IO流用来处理设备之间的数据传输：上传文件和下载文件</p>
<p>Java对数据的操作是通过流的方式</p>
<p>Java用于操作流的对象都在IO包中</p>
<p>IO流分类：</p>
<p>1.按照数据流向：</p>
<p>输入流    读入数据  从数据源</p>
<p>输出流    写出数据  到目的地</p>
<p>2.按照数据类型</p>
<p>字节流</p>
<p>字符流（为了方便操作文本数据）</p>
<p>如果数据所在的文件通过windows自带的记事本打开并能读懂里面的内容，就用字符流。其他用字节流。如果你什么都不知道，就用字节流</p>
<p>所以要学四个类：</p>
<p>\1. 字节输入流  InputStream（抽象类）  Xxx InputStream（实现子类）</p>
<p>\2. 字节输出流  OutputStream   Xxx OutputStream </p>
<p>\3. 字符输入流  Reader    Xxx Reader</p>
<p>\4. 字符输出流  Writer    Xxx Writer</p>
<p>一般我们在探讨IO流的时候，如果没有明确说明按照哪种分类来说的，是按数据类型即字节流、字符流分的</p>
<p>这四个类派生出来的子类名称都是以其父类名作为子类名的后缀。</p>
<p>FileOutputStream的构造方法</p>
<p>FileOutputStream(File file)</p>
<p>FileOutputStream(String name)  （一般用这种）</p>
<p>例子：FileOutputStream fos = new FileOutputStream(“fos.txt”);创建字节流对象坐的事情：A：调用系统功能去创建文件B：创建fos对象C：把fos对象指向这个文件  （会有编译异常，抛出即可）</p>
<p>字节流写数据的方法：</p>
<p>public void write(int b)  输出b对应的字符值</p>
<p>public void write(byte[] b) 输出b[]对应的字符值</p>
<p>public void write(byte[] b,int off,int len) 输出b[]对应的从off开始的len长度的字符值</p>
<p>例子：fos.write(“sadfag”.getBytes());  （会有编译异常，抛出即可）</p>
<p>最后要释放资源fos.close（）；方法：关闭此文件输出流并释放与此流有关的所有系统资源</p>
<p>为什么一定要close()呢：A：让流对象变成垃圾，这样就可以垃圾回收器回收了B：通知系统去释放该文件相关的资源</p>
<p>所以自己输出流操作步骤：1.创建字节输出流对象2.写数据3.释放资源</p>
<p>fos.write(97);  会输出a：97–底层二进制数据–通过记事本打开–97对应的字符值–a</p>
<p>如何实现数据的换行：写入换行符号的话，有的会显示有的不会显示（因为不同的系统针对不同的换行符号是不一样的:windows:\r\n  linux:\n  Mac:\r  一些常见的高级记事本软件可以识别任意换行符号）</p>
<p>如何实现数据的追加写入（再一次运行就会追加写一次）：用构造方法第二个参数是true的情况</p>
<p>public FileOutputStream(String name,boolean append) throws FileNotFoundException  当为true时，追加写入</p>
<p>字节流写数据加入异常处理：throws方法</p>
<p>try…catch…finally…方法：可以把finally中放入close语句（必须在外面初始化赋值null；也可能出现异常导致值为null无法调用close方法，所以加个！=null判断）</p>
<p>字节流读取数据：把数据读取出来显示在控制台</p>
<p>InputStream下的FileInputStream：</p>
<p>FileInputStream的构造方法</p>
<p>FileInputStream(File file)</p>
<p>FileInputStream(String name)</p>
<p>FileInputStream的成员方法</p>
<p>public int read() 一次读取一个字节  如果没有了，返回-1</p>
<p>中文会出问题，因为每次获取一个字节数据，就把该字节数据转换为了字符数据，然后输出到控制台，而汉字是两个字节数据，所以会出问题。</p>
<p>复制文本文件： 数据源：从哪里来  目的地：到哪里去</p>
<p>封装数据源，封装目的地，int by=0; while循环调用Input的read方法并判断不为-1的话，再调用Output的write方法，最后释放资源（谁先谁后都行，我一般先关输出流再关输入流。）</p>
<p>这次汉字转化没有出问题：因为不涉及转换，读一个字节就写一个字节，最后输出的时候自己转换为汉字了。</p>
<p>计算机是什么时候判断两个字节该转换为一个中文的呢：中文的存储分两个字节，第一个字节肯定是负数，第二个字节常见的是负数，也可能是正数，但是无影响。（因为碰到第一个负数就会把后面那个数字一起拼汉字）</p>
<p>复制mp4的时候发现文件太大，复制很慢，所以可以考虑使用一次读取一个字节数组。</p>
<p>public int read(byte[] b) 一次读取一个字节数组 每次可以读取多个数据，提高了操作效率</p>
<p>返回值其实是实际读取的字节个数  </p>
<p>数组的长度byte[]一般是1024或者它的倍数</p>
<p>输出的值可以调用String的截取方法，长度为数组的长度</p>
<p>方式一：一次读取一个字节</p>
<p><em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> main(String[] args) <em><strong>*throws*</strong></em> IOException {</p>
<p>​        FileInputStream fr = <em><strong>*new*</strong></em> FileInputStream(“aaa.txt”);</p>
<p>​        <em><strong>*int*</strong></em> by = 0;</p>
<p>​        <em><strong>*while*</strong></em> ((by = fr.read()) != -1) {</p>
<p>​            System.<em><strong>*<em>out*</em>***.print((</strong></em>*char****) by);</p>
<p>​        }</p>
<p>​        fr.close();</p>
<p>​    }</p>
<p>方式二：一次读取一个字节数组</p>
<p><em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> main(String[] args) <em><strong>*throws*</strong></em> IOException {</p>
<p>​        FileInputStream fr = <em><strong>*new*</strong></em> FileInputStream(“aaa.txt”);</p>
<p>​        <em><strong>*byte*</strong></em>[] bys = <em><strong>*new*</strong></em> <em><strong>*byte*</strong></em>[5];</p>
<p>​        <em><strong>*int*</strong></em> len = 0;</p>
<p>​        <em><strong>*while*</strong></em> ((len = fr.read(bys)) != -1) {</p>
<p>​            System.<em><strong>*<em>out*</em>***.print(</strong></em>*new**** String(bys, 0, len));</p>
<p>​        }</p>
<p>​        fr.close();</p>
<p>​    }</p>
<p>字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，这是加入了数组这样的缓冲区效果，java本身在设计的时候，也考虑到了这样的设计思想(装饰设计模式)，所以专门提供了带缓冲区的字节类，这种类称为缓冲区类（高效类）</p>
<p>字节缓冲输出流 写数据</p>
<p>BufferedOutputStream</p>
<p>字节缓冲输入流 读数据</p>
<p>BufferedInputStream</p>
<p>构造方法可以指定缓冲区的大小，但是我们一般用不上，因为默认缓冲区大小就足够了。</p>
<p>BufferedOutputStream bos =new BufferedOutputStream(new FileOutputStream (“aaa.txt”));</p>
<p>BufferedInputStream bis =new BufferedInputStream(new FileInputStream (“aaa.txt”));</p>
<p>由于字节流操作中文不是特别方便，所以，java就提供了转换流。（也可以用转换char数组来读取中文）</p>
<p>字符流=字节流+编码表。</p>
<p>编码表：由现实世界的字符及其对应的数值组成的一张表</p>
<p>常见编码表</p>
<p>ASCII：美国标准信息交换码  用一个字节的7位可以表示。最高位为符号位，其余为数值位</p>
<p>ISO-8859-1：拉丁码表。欧洲码表  用一个字节的8位表示</p>
<p>GB2312：中国的中文编码表</p>
<p>GBK：中国的中文编码表升级，融合了更多的中文文字符号</p>
<p>GB18030：GBK的取代版本</p>
<p>BIG-5码：通行于台湾、香港地球的一个繁体字编码方案，俗称“大五码”</p>
<p>Unicode 字符集：国际标准码，融合了多种文字。所有的文字都用两个字节来表示，java语言采用的就是unicode</p>
<p>UTF-8：最多用三个字节来表示一个字符 能用一个的就用一个（ASCII兼容）一个表示不了的就用两个，实在不行的用三个字节。（国际化都用这个）</p>
<p>String(byte[] bytes,String charsetName)  通过指定的字符集解码字节数组</p>
<p>byte[] getBytes(String charsetName)  使用指定的字符集把字符串编码为字节数组</p>
<p>编码：把看得懂的变成看不懂的  String – byte[]</p>
<p>解码：把看不懂的变成看得懂的  byte[] –String</p>
<p>只要编码解码格式一致就不会有任何问题，即使中间的文档一点看不懂。</p>
<p>OutputStreamWriter 字符输出流（把字节流转换为字符流）</p>
<p>public OutputStreamWriter(OutputStream out) 根据默认编码把字节流的数据转换为字符流</p>
<p>public OutputStreamWriter(OutputStream out,String charsetName) 根据指定编码把字节流的数据转换为字符流</p>
<p>InputStreamReader 字符输入流</p>
<p>public InputStreamReader(InputStream in) 用默认的编码读取数据</p>
<p>public InputStreamReader(InputStream in,String charsetName) 用制定的编码读取数据</p>
<p>OutputStreamWriter写数据：父类是io.Writer</p>
<p>方法：public void write(int c)  写一个字符</p>
<p>public void write(char[] cbuf)  写一个字符数组</p>
<p>public void write(char[] cbuf,int off,int len)  写一个字符数组的一部分</p>
<p>public void write(String str)  写一个字符串</p>
<p>public void write(String str,int off,int len)  写一个字符串的一部分</p>
<p>字符流写数据，有可能不会出现，因为是字符，而文件中数据存储的基本单位是字节，所以需要刷新缓存区void flush（）方法（close方法也能刷新，刷新完并关闭）</p>
<p>flush()和close()的区别：</p>
<p>close（）关闭流对象，但是先刷新一次缓冲区，关闭后，该对象不可以继续在使用。</p>
<p>flush（）仅仅刷新缓冲区，刷新后，流对象还可继续使用（仅在数据量巨大的时候调用此方法，一般使用close方法就够了，因为每调用一次这个方法就会在内存中多占一点位置）</p>
<p>InputStreamReader读数据</p>
<p>方法：public int read()  一次读取一个字符</p>
<p>public int read(char[] cbuf)  一次读取一个字符数组</p>
<p>转换流的名字比较长，而我们常见的操作都是按照本地默认编码实现的，所以，为了简化我们的书写，转换流提供了对应的子类。</p>
<p>FileWriter 是 OutputStreamWriter的子类</p>
<p>因为OutputStreamWriter= FileOutputStream +编码表（GBK）</p>
<p>所以FileWriter=FileOutputStream +编码表（GBK）</p>
<p>FileReader 是InputStreamReader的子类</p>
<p>字符流为了高效读写，提供了字符缓冲流：</p>
<p>BufferedWriter：字符缓存输出流</p>
<p>BufferedReader：字符缓存输入流</p>
<p>复制图片，视频时不能用字符流。</p>
<p>字符缓存流的特殊方法：</p>
<p>BufferedWriter：public void newLine() 根据系统来决定换行符</p>
<p>BufferedReader：public String readLine() 一次读取一行数据  包含该行内容的字符串，不包含任何终止符，如果已达到流末尾，则返回null</p>
<p>一般写数据，换行，刷新连写（第五种方法）。</p>
<p>LineNumberReader 是BufferedReader的子类，他有2个特有的方法：</p>
<p>public int getLineNumber()  获得当前行号</p>
<p>public void setLineNumber(int lineNumber) 设置行号从这开始</p>
<p>操作基本数据类型：可以读写基本数据类型的数据</p>
<p>DataInputStream(OutputStream out) 数据输入流</p>
<p>DataOutputStream(InputStream in)  数据输出流</p>
<p>内存操作流:用于处理临时存储信息的，程序结束，数据就从内存中消失</p>
<p>操作字节数组:无需关闭流（源码中close()方法中什么都没有是个空方法）</p>
<p>ByteArrayInputStream</p>
<p>ByteArrayOutputStream</p>
<p>操作字符数组</p>
<p>CharArrayReader</p>
<p>CharArrayWrite</p>
<p>操作字符串</p>
<p>StringReader</p>
<p>StringWriter</p>
<p>打印流：</p>
<p>字节打印流 PrintStream</p>
<p>字符打印流  PrintWriter</p>
<p>打印流特点:实现了Buffered的快速</p>
<p>只有写数据的，没有读数据的。只能操作目的地，不能操作数据源。</p>
<p>可以操作任意类型的数据。print  println方法</p>
<p>如果启动了自动刷新，能够自动刷新。（构造方法（，true ）但是只要println可以自动刷新，print不能自动刷新。此时的println就相当于write();newLine();flush()）</p>
<p>该流可以直接操作文本文件。看API，查看流对象的构造方法，如果同时有File类型和String类型的参数，一般来说就是可以直接操作文件的。</p>
<p>流：基本流：就是能够直接读写文件的</p>
<p>高级流：在基本流基础上提供了一些其他的功能</p>
<p>标准输入输出流</p>
<p>System类中的两个成员变量：</p>
<p>public static final InputStream in: “标准”输入流  InputStream is=System.in</p>
<p>public static final PrintStream out: “标准”输出流 PrintStream ps=System.out</p>
<p>键盘录入数据：</p>
<p>A：main方法的args接收参数</p>
<p>java HelloWorld hell world java</p>
<p>B：Scanner（JDK5以后的）</p>
<p>Scanner sc=new Scanner(System.in);</p>
<p>String s=sc.nextLine();</p>
<p>int x=sc.nextInt();</p>
<p>C：通过字符缓冲流包装标准输入流实现</p>
<p>BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</p>
<p>随机访问流:RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。支持对随机访问文件的读取和写入。</p>
<p>pubic RandomAccessFile(String name , String mode): 第一个参数是文件路径，第二个参数是操作文件的模式</p>
<p>模式有4中，“r” 只读  “rw” 可读可写（常用） “rws” “rw”</p>
<p>该文件指针可以通过getFilePointer方法读取，并通过seek方法设置</p>
<p>合并流：SequenceInputStream类可以将多个输入流串流在一起，合并为一个输入流，因此，该流也被称为合并流</p>
<p>构造方法：SequenceInputStream(InputStream s1, InputStream s2)  将2个文件合并</p>
<p>SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) 多个文件的集合</p>
<p>序列化流：把对象按照流一样的方式存入文本文件或者在网络中传输。对象–流数据</p>
<p>ObjectOutputStream</p>
<p>反序列化流：把文本文件中的流对象数据或者网络中的流对象还原成对象。流数据–对象</p>
<p>ObjectInputStream</p>
<p>类通过java.io.Serializable接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。该接口没有任何方法。类似于这种没有方法的接口称为标记接口。</p>
<p>当类实现了序列化接口的时候，这个类会产生一个序列化id值，当你在修改类的时候，这个值就会发生改变，而会产生与序列化时不匹配的错误，需要在运行重新序列化或者反序列化才能匹配。所以要想解决这个问题，就得在实现序列化接口的类上自动产生一个固定的序列化值，再生成这个值后，在对类进行任何改动，它读取以前的数据是没有问题的。</p>
<p>使用transient关键字可以声明不需要序列化的成员变量，输出的是默认值</p>
<p>Properties：属性集合类。是一个可以和IO流相结合使用的集合类</p>
<p>Properties可保存在流中或者从流中加载。属性列表中每个键及其对应值都是一个字符串。</p>
<p>是Hashtable的子类是一个Map集合。</p>
<p>特殊功能</p>
<p>public Object setProperty(String key,String value) 添加元素</p>
<p>public String getProperty(String key) 根据键获取对应值</p>
<p>public Set<String> stringPropertyNames() 获取所有的键的集合</p>
<p>Properties和IO流的结合使用</p>
<p>public void load(Reader reader) 把文件中的数据读取到集合中</p>
<p>public void store(Writer writer,String comments) 把集合中的数据存储到文件</p>
<p>这里的集合必须是Properties集合，数据必须是键值对形式</p>
<p>可以利用这个方法进行单机游戏的存储和读取</p>
<p>NIO其实就是新IO的意思，JDK4出现，提高了IO流的操作效率（在内存中）：Buffer（缓冲）和Channer（通道）</p>
<p>JDK7的IO改进</p>
<p>Path（接口）：与平台无关的路径</p>
<p>Paths（类）：有一个静态方法返回一个路径</p>
<p>Files：操作文件的工具类，提供了静态方法供我们使用</p>
<p>public static long copy(Path source,OutputStream out):复制文件</p>
<p>public static Path write(Path path,Iterable&lt;? extends CharSequence&gt; lines, Charset cs, OpenOption… options):  把集合的数据写到文件</p>
<h2 id="try-with-resource语法糖"><a href="#try-with-resource语法糖" class="headerlink" title="try-with-resource语法糖"></a>try-with-resource语法糖</h2><p>在java开发中，一些网络链接或者是文件资源都需要程序员去手动调用close方法关闭，比如InputStream、OutputStream和java.sql.Connection。</p>
<p>如果忘关了就可能造成严重的性能后果。而关闭的方法有很多种。比如finalizer、try-catch-finally、try-with-resources等等。</p>
<p>try-with-resources<br>try-with-resources是jdk1.7引入的语法糖，使得关闭资源操作无需层层嵌套在finally。</p>
<p>finalizer 会引发内存泄漏<br>垃圾回收器发现对象实现了finalize()方法并把它们添加到java.lang.ref.Finalizer.ReferenceQueue队列中。</p>
<p>然后Finalizer线程 会把ReferenceQueue里面的对象逐个弹出。</p>
<p>不过由于它的优先级比主线程较低，获取到的CPU时间较少，因此它永远也赶不上主线程创建对象的步伐。</p>
<p>所以会引发内存泄漏，所以finalize()并不适合用作普通的清理工作，一般只用于当java中调用非java代码时重写finalize()方法，并在里面调用本地方法的free()等函数。</p>
<p>或者在一下时候有某些用处：</p>
<p>存在一系列对象，对象中有一个状态为false，如果我们已经处理过这个对象，状态会变为true，为了避免有被遗漏而没有处理的对象，就可以使用finalize()方法：</p>
<p>class MyObject{</p>
<pre><code>boolean state = false;
 
public void deal()&#123;
    //...一些处理操作
    state = true;
&#125;
 
@Override
protected void finalize()&#123;
    if(!state)&#123;
        System.out.println(&quot;ERROR:&quot; + &quot;对象未处理！&quot;);
    &#125;
&#125;
//...
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>finally的执行顺序<br>1、finally不是必要条件<br>也就是说try-catch-finally中，可以只有try-catch，也可以只有try-finally。</p>
<p>2、假设基于try-catch-finally：<br>第一：代码没有异常<br>执行顺序：try执行完整-&gt;catch不执行-&gt;finally执行</p>
<p>第二：代码有异常且catch进行捕获**<br>执行顺序：try执行部分-&gt;跳转catch捕获处理-&gt;finally执行</p>
<p>第三：代码有异常且catch不捕获：这种情况没有catch**<br>执行顺序：try执行部分-&gt;finally执行<br>从上面的执行顺序可以看出，finally语句不管在哪种情况是一定会执行的。基于这个认识，现在我们再来分析。</p>
<p>题外话： 当finally有return时，会直接返回。不会再去返回try或者catch中的返回值，而finally没有return时，try和catch 的return语句并不会马上执行，而是执行完finally代码块之后再返回try和catch里面的值。</p>
<p>try-finally的缺点<br>同时打开了多个资源，那么将会出现噩梦般的场景：</p>
<p>public class Demo {<br>        public static void main(String[] args) {<br>            BufferedInputStream bin = null;<br>            BufferedOutputStream bout = null;<br>            try {<br>                bin = new BufferedInputStream(new FileInputStream(new File(“test.txt”)));<br>                bout = new BufferedOutputStream(new FileOutputStream(new File(“out.txt”)));<br>                int b;<br>                while ((b = bin.read()) != -1) {<br>                    bout.write(b);<br>                }<br>            }<br>            catch (IOException e) {<br>                e.printStackTrace();<br>            }<br>            finally {<br>                if (bin != null) {<br>                    try {<br>                        bin.close();<br>                    }<br>                    catch (IOException e) {<br>                        throw e;<br>                    }<br>                    finally {<br>                        if (bout != null) {<br>                            try {<br>                                bout.close();<br>                            }<br>                            catch (IOException e) {<br>                                throw e;<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>    }<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>我们不仅需要关闭 BufferedInputStream ，还需要保证如果关闭 BufferedInputStream 时出现了异常， BufferedOutputStream 也要能被正确地关闭。所以我们不得不借助finally中嵌套finally大法。可以想到，打开的资源越多，finally中嵌套的将会越深。</p>
<p>主要是这样子写代码是真的丑。</p>
<p>用try-with-resource来改写刚才的例子：</p>
<pre><code>要使用try-with-resource的资源，必须先实现AutoCloseable接口，其中包含了单个返回void的close方法，Java类库与第三方类库中的许多类和接口，现在都实现或扩展了AutoCloseable接口，因此我们现在不必实现了。
</code></pre>
<p>1<br>public class TryWithResource {<br>  public static void main(String[] args) {<br>    try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(“test.txt”)));<br>       BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(“out.txt”)))) {<br>      int b;<br>      while ((b = bin.read()) != -1) {<br>        bout.write(b);<br>      }<br>    }<br>    catch (IOException e) {<br>      e.printStackTrace();<br>    }<br>  }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>原理<br>编译器会自动帮我们补全close()，而且可以避免异常屏蔽<br>看一下反编译出来的代码：</p>
<p>package com.codersm.trywithresource;</p>
<pre><code>public class TryWithResource &#123;
    public TryWithResource() &#123;
    &#125;

    public static void main(String[] args) &#123;
        try &#123;
            Connection conn = new Connection();
            Throwable var2 = null;

            try &#123;
                conn.sendData();
            &#125; catch (Throwable var12) &#123;
                var2 = var12;
                throw var12;
            &#125; finally &#123;
                if (conn != null) &#123;
                    if (var2 != null) &#123;
                        try &#123;
                            conn.close();
                        &#125; catch (Throwable var11) &#123;
                            var2.addSuppressed(var11);
                        &#125;
                    &#125; else &#123;
                        conn.close();
                    &#125;
                &#125;

            &#125;
        &#125; catch (Exception var14) &#123;
            var14.printStackTrace();
        &#125;

    &#125;
&#125;
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>在第15~27行，编译器自动帮我们生成了finally块，并且在里面调用了资源的close方法，所以例子中的close方法会在运行的时候被执行。</p>
<p>异常屏蔽<br>我们将刚才的代码改回远古时代手动关闭异常的方式，并且在 sendData 和 close 方法中抛出异常：</p>
<p>public class Connection implements AutoCloseable {<br>        public void sendData() throws Exception {<br>            throw new Exception(“send data”);<br>        }<br>        @Override<br>        public void close() throws Exception {<br>            throw new MyException(“close”);<br>        }<br>    }<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>修改main方法：</p>
<p>public class TryWithResource {<br>  public static void main(String[] args) {<br>    try {<br>      test();<br>    }<br>    catch (Exception e) {<br>      e.printStackTrace();<br>    }<br>  }<br>  private static void test() throws Exception {<br>    Connection conn = null;<br>    try {<br>      conn = new Connection();<br>      conn.sendData();<br>    }<br>    finally {<br>      if (conn != null) {<br>        conn.close();<br>      }<br>    }<br>  }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>运行之后我们发现：</p>
<p>basic.exception.MyException: close<br> at basic.exception.Connection.close(Connection.java:10)<br> at basic.exception.TryWithResource.test(TryWithResource.java:82)<br> at basic.exception.TryWithResource.main(TryWithResource.java:7)<br> ……<br>1<br>2<br>3<br>4<br>5<br>问题来了，由于我们一次只能抛出一个异常，所以在最上层看到的是最后一个抛出的异常——也就是 close 方法抛出的 MyException ，而 sendData 抛出的 Exception 被忽略了。这就是所谓的异常屏蔽。由于异常信息的丢失，异常屏蔽可能会导致某些bug变得极其难以发现，程序员们不得不加班加点地找bug，如此毒瘤，怎能不除！幸好，为了解决这个问题，从Java 1.7开始，大佬们为 Throwable 类新增了 addSuppressed 方法，支持将一个异常附加到另一个异常身上，从而避免异常屏蔽。那么被屏蔽的异常信息会通过怎样的格式输出呢？我们再运行一遍刚才用try-with-resource包裹的main方法：</p>
<p>java.lang.Exception: send data</p>
<p> at basic.exception.Connection.sendData(Connection.java:5)<br> at basic.exception.TryWithResource.main(TryWithResource.java:14)<br> ……<br> Suppressed: basic.exception.MyException: close<br> at basic.exception.Connection.close(Connection.java:10)<br> at basic.exception.TryWithResource.main(TryWithResource.java:15)<br> … 5 more<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>可以看到，异常信息中多了一个 Suppressed 的提示，告诉我们这个异常其实由两个异常组成， MyException 是被Suppressed的异常。可喜可贺！</p>
<p>仔细对比发现，是因为反编译的代码（第21行）多了一个 addSuppressed ：var2.addSuppressed(var11);<br>从而避免了异常屏蔽的问题。</p>
<p>结论<br>处理必须关闭的资源时，始终要优先考虑使用try-with-resources，而不是try-finally。这样得到的代码将更简洁，清晰，产生的异常也更有价值，这些也是try-finally无法做到的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.13.IO%E6%B5%81/" data-id="ckw61sdw7004koswddcsp0u8r" data-title="IO流" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.12.集合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.12.%E9%9B%86%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:08.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.12.%E9%9B%86%E5%90%88/">集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，而想要存储多个对象，就不能是一个基本的变量，而应该是一个容器类的变量，StringBuffer的结果是一个字符串，对象数组的长度是固定的，为了适应变化的需求，即创造一个可变的对象的容器，Java就提供了集合类。</p>
<p>数组和集合的区别：</p>
<p>A：长度区别：数组的长度固定  集合长度可变</p>
<p>B：内容不同：数组存储的是同一种类型的元素  集合可以存储不同类型的元素</p>
<p>C：元素的数据类型：数组可以存储基本数据类型，也可以存储引用数据类型  集合只能存储引用类型</p>
<p>集合类的特点</p>
<p>集合只用于存储对象，集合长度是可变的，集合可以存储不同类型的对象。</p>
<h1 id="Collection（单列集合）"><a href="#Collection（单列集合）" class="headerlink" title="Collection（单列集合）"></a>Collection（单列集合）</h1><p>总接口：Collection  （util包下）</p>
<p>是集合的顶层接口，它的子体系有重复的，有唯一的，有有序的，有无序的。</p>
<p>功能：</p>
<ol>
<li><p>添加功能 </p>
<p>boolean add(Object obj)  添加一个元素（这个方法永远返回的是true，把object作为一个元素添加）</p>
<p>boolean addAll(Collection c)  添加一个集合的元素(无论重复与否，把collection中的每一个元素添加)</p>
</li>
<li><p>删除功能  </p>
<p>void clear() 移除所有元素</p>
<p>boolean remove(Object o)  移除一个元素</p>
<p>boolean removeAll(Collection c) 移除一个集合的元素（只要有一个元素被移除了就会返回true）</p>
</li>
<li><p>判断功能  </p>
<p>boolean contains（Object obj） 判断集合中是否包含指定的元素<br>boolean containsAll （Collection c） 判断集合中是否包含指定的集合元素（只有包含所有的元素才叫包含）</p>
<p>boolean isEmpty（）  判断集合是否为空</p>
</li>
<li><p>获取功能<br><strong>Iterator<E>  iterator()</strong> 迭代器，集合的专用遍历方式</p>
</li>
<li><p>长度功能  </p>
<p>int size() 元素的个数（数组和字符串的长度方法都是length方法，集合是size方法）</p>
</li>
<li><p>交集功能 </p>
<p>boolean retainAll(Collection c)  两个集合都有的元素（假设有两个集合A,B，A对B做交集，最终的结果保存在A中，B不变，返回值表示的是A是否发生过改变）</p>
</li>
<li><p>把集合转换为数组 </p>
<p>Object[] toArray（）</p>
</li>
</ol>
<p>集合的遍历：依次获取集合中的每一个元素</p>
<p>1.Object[] toArray（）：把集合转换为数组，通过对数组的遍历，可以实现集合的遍历 （然而这种方法object中没有length方法，所以无法得到元素的长度，所以还需要对object进行转换为字符串，这种转型是向下转型，需要强转，转完就可以调用字符串的length方法得到长度）</p>
<p>2.<strong>Iterator<E>  iterator()</strong></p>
<p>Object next()  获取元素，并移动到下一个位置</p>
<p>boolean hasNext()  如果仍有元素可以迭代，则返回true</p>
<p>可以用while循环while(it.hasNext){}，也可以用for循环for(Iterator it= c.iterator;it.hasNext();){}遍历</p>
<p>不要多次使用it.next()方法，因为每次使用都是调用下一个对象</p>
<p>迭代器：是遍历集合的一种方式。迭代器是依赖于集合而存在的。</p>
<p>迭代器在真正的具体的子类中，以内部类的方式实现的。</p>
<p>集合的使用步骤：</p>
<ol>
<li><p>创建集合对象</p>
</li>
<li><p>创建元素对象</p>
</li>
<li><p>把元素添加到集合</p>
</li>
<li><p>遍历集合：</p>
<p>a.通过集合对象获取迭代器对象</p>
<p>b.通过迭代器对象的hasNext()方法判断是否有元素</p>
<p>c.通过迭代器对象的next()方法获取元素并移动到下一个位置</p>
</li>
</ol>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><strong>有序</strong>的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p>
<p>与 set 不同，列表通常允许<strong>重复</strong>的元素。</p>
<p>特点：有序（存储和取出的元素一致），可重复的。</p>
<p>List接口的特有功能：</p>
<p>1.添加功能：</p>
<p>​    void add(int index,Object element)  在指定的位置添加元素（index是length长度的值就不会报错，超过这个值就会出现越界）</p>
<p>2.获取功能：</p>
<p>​    Object get(int index) 获取指定位置的元素</p>
<p>3.列表迭代器：</p>
<p>​    ListIterator listIterator()  List集合特有的迭代器（该迭代器继承了Iterator迭代器，所以可以直接使用hasNext()和next()方法）</p>
<p>​    特有功能：</p>
<p>​        Object  previous()  获取上一个元素</p>
<p>​        boolean hasPrevious()  判断是否有元素</p>
<p>​        ListIterator可以实现逆向遍历，但是必须先正向遍历，才能逆向遍历，否则没有输出（因为刚开始指针在第一个位置上，上一个元素没有值）无意义，所以一般不使用。</p>
<p>4.删除功能：</p>
<p>​    Object remove(int index) 根据索引删除元素，返回被删除的元素</p>
<p>5.修改功能：</p>
<p>​    Object set(int index,Object element) 根据索引修改元素，返回被修改的元素</p>
<p>List集合的特有遍历：size()和get()方法的结合</p>
<p>并发修改异常：迭代器是依赖于集合而存在的，在判断成功后，集合添加了新的元素，而迭代器不知道，所以会报错。</p>
<p>解决方案：</p>
<p>A：迭代器迭代元素，迭代器修改元素（Iterator迭代器没有添加功能，而ListIterator迭代器有add方法，但是这种方法添加的元素是在迭代的元素后面的）</p>
<p>B：集合遍历元素，集合修改元素（普通for循环，元素是在最后添加的）</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>底层数据结构是数组，查询快，增删慢。线程不安全，效率高。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>底层数据结构是数组，查询快，增删慢。线程安全，效率低。（基本不用了，后面有替代）</p>
<p>特有功能：</p>
<p>1.添加功能：</p>
<p>public void addElement(Object obj)</p>
<p>2.获取功能：</p>
<p>public Object elementAt(int index)</p>
<p>public Enumeration elements() （相当于迭代器）有两个方法：</p>
<p>​    boolean hasMoreElements()</p>
<p>​    object  nextElement()</p>
<p>这个麻烦，所以用现在的迭代器</p>
<p>JDK升级的原因：安全，效率，简化书写</p>
<h3 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h3><p>底层数据结构是链表，查询慢，增删快。线程不安全，效率高。</p>
<p>LinkedList类特有功能：</p>
<ol>
<li><p>添加功能：</p>
<p>public void addFirst( Object obj)  可以实现栈的先进后出</p>
<p>public void addLast( Object obj)</p>
</li>
<li><p>获取功能：</p>
<p>public Object getFirst()<br>public Object getLast()</p>
</li>
<li><p>删除功能：</p>
<p>public Object removeFirst()<br>public Object removeLast()</p>
</li>
</ol>
<p>三种选用的话，一般情况下，用的是ArrayList，vector基本不用，查询多用ArrayList，增删多用LinkList。</p>
<p>例子：</p>
<p>1.ArrayList去除集合中字符串的重复值（字符串的内容相同）</p>
<p>A：常见集合对象</p>
<p>B：添加多个字符串元素（包含内容相同的）</p>
<p>C：创建新集合</p>
<p>D：遍历旧集合，获得每一个元素</p>
<p>E：拿这个元素到新集合去找，看有没有：有，就不管，没有就添加到新集合</p>
<p>F：遍历新集合</p>
<p>如果要求不能创建新的集合呢：可以借鉴选择排序思想，注意如果有连续的字符情况，替换后会少判断一次，所以再加个y–</p>
<p>2.ArrayList去除集合中自定义对象的重复值(对象的成员变量值都相同时才算重复)</p>
<p>如果用字符串的判断方法，会发现做不出来：因为contains()方法的底层依赖的是equals()方法，而自定义方法没有equals()方法时调用的是父类Object类的方法，该方法没有被重写，比较的是地址值，每个对象的地址值都不一样，所以无法去除重复值。</p>
<p>3.用LinkedList模拟栈（stack）数据结构的集合，并测试</p>
<p>是要自己构建一个类，底层实现使用的是LinkedList，这个类的功能要完成的是栈数据结构的功能。</p>
<p>集合的toString方法源码：子类中没有某一种方法的时候，去父类中查找。</p>
<h3 id="Java8-使用-stream-filter-过滤List对象（查找符合条件的对象集合）"><a href="#Java8-使用-stream-filter-过滤List对象（查找符合条件的对象集合）" class="headerlink" title="Java8 使用 stream().filter()过滤List对象（查找符合条件的对象集合）"></a>Java8 使用 stream().filter()过滤List对象（查找符合条件的对象集合）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;StudentInfo&gt; boys = studentList.stream().filter(s-&gt;s.getGender() &amp;&amp; s.getHeight() &gt;= <span class="number">1.8</span>).collect(Collectors.toList());</span><br><span class="line">vo = userSVO.stream().filter(o-&gt; <span class="string">&quot;red&quot;</span>.equals(o.getHatColor())).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>





<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>一个不包含重复元素的 collection（即使存储了多个重复元素，打印时候仍是不重复的元素）。</p>
<p>无序（存储顺序和取出顺序不一致）</p>
<p>唯一：存储时的顺序可能和读取时的数据一致，但这代表不了有序，因为这是特例，还有可能其他情况</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>它不保证set的迭代顺序；特别是不保证该顺序恒久不变。</p>
<p>HashSet如何保证元素唯一性：底层数据结构是哈希表(元素是链表的数组)；哈希表依赖于哈希值存储</p>
<p>添加功能add()底层依赖两个方法：</p>
<p>int hashCode()</p>
<p>boolean equals(Object obj)</p>
<p>首先比较哈希值hashCode()值：</p>
<p>如果相同：比较地址值或者equals()：true则重复不添加，false则不重复，添加到集合中</p>
<p>如果不同：就直接添加到集合中</p>
<p>如果直接写自定义案例HasSet还是会出现重复的元素，是因为你自定义的类没有重写hashCode()方法和equals()方法，所以不会进行判断，会直接添加到集合中。可以直接快捷键alt+shift+h构造hashCode()方法和equals()方法。</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>元素<strong>有序</strong>唯一，底层数据结构由哈希表和链表组成</p>
<p>由链表保证元素有序</p>
<p>由哈希表保证元素唯一</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>能够对元素按照某种规则进行排序</p>
<p>使用元素的自然顺序对元素进行排序（自然排序，无参构造）或者根据创建 set 时提供的 Comparator 进行排序（比较器排序，带参构造），具体取决于使用的构造方法。 </p>
<p>当实现带参构造的这个构造时，可以放在基本类中，也可以单独定义一个类实现Comaprator接口，但推荐的是直接使用内部类，在new TreeSet的时候直接在()写这个接口的实现类</p>
<p>特点：排序和唯一</p>
<p>TreeSet是如何保证元素的排序和唯一性的：底层数据结构是红黑树(红黑树是一种自平衡的二叉树)</p>
<p>唯一性：</p>
<p>是根据比较的返回值是否是0来决定的。</p>
<p>排序：</p>
<p>A.自然排序（元素具备比较性）：让元素所属的类实现自然排序接口Comaprable</p>
<p>B.比较器排序（集合具备比较性）：让集合的构造方法接收一个比较器接口的子类对象Comparator（实现的时候注意主要条件，次要条件（字面意思和隐含的意思都要实现）可以用多个三目运算符实现）</p>
<p>源码：看TreeMap的方法。真正的比较是依赖于元素的compareTo()方法，而这个方法是定义在Comparable里面的，所以要重写该方法必须实现Comparable接口。这个接口的默认就是自然排序</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般用HashSet</p>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><h1 id="Map（双列集合）"><a href="#Map（双列集合）" class="headerlink" title="Map（双列集合）"></a>Map（双列集合）</h1><p>特点：将键映射到值的对象，一个映射不能包含重复的键，每个键最多只能映射到一个值。可以存储键值对的元素。</p>
<p>Map集合存储元素是成对出现的；键是唯一的，值是可重复的。</p>
<p>Collection集合存储元素是单独出现的；Collection集合下Set是唯一的，List是可重复的。</p>
<p>注意：Map集合的数据结构值仅仅针对键有效，跟值无关；Collection集合的数据结构是针对元素有效</p>
<p>基本功能</p>
<ol>
<li><p>添加功能：</p>
<p>V put(K key,V value)  添加元素；修改元素</p>
</li>
</ol>
<p>如果键是第一次存储，就直接存储元素，并返回null</p>
<p>如果键不是第一次存储，就用值把以前的值替换掉，返回以前的值</p>
<ol start="2">
<li><p>删除功能：</p>
<p>void clear()  移除所有的键值对元素（太暴力不建议使用）</p>
<p>V remove(Object key) 根据键删除键值对元素，并把值返回</p>
</li>
<li><p>判断功能：</p>
<p>boolean containsKey(Object key) 判断集合是否包含指定的键</p>
<p>boolean containsValue(Object value) 判断集合是否包含指定的值    boolean isEmpty()  判断集合是否为空</p>
</li>
<li><p>获取功能：</p>
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt;  entrySet()返回的是键值对对象的集合（entry是条目的意思）</p>
<p>V get(Object key) 根据键获取值（如果不存在返回null）</p>
<p>Set<K> keySet() 获取集合中所有键的集合</p>
<p>Collection<V> values() 获取集合中所有值的集合</p>
</li>
<li><p>长度功能：</p>
<p>int size()  返回集合中的键值对的对数</p>
</li>
</ol>
<p>Map集合的遍历：</p>
<p>A. 根据键找值：</p>
<p>（1）获取所有的键的集合<br>（2）遍历键的集合，获取得到每一个键值</p>
<p>（3）根据键去找值</p>
<p>B. 根据键值对对象找键和值</p>
<p>（1）获取所有键值对对象的集合</p>
<p>（2）遍历键值对对象的集合，得到每一个键值对对象</p>
<p>（3）根据键值对对象获取键和值</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>是基于哈希表的Map接口实现</p>
<p>哈希表的作用是用来保证键的唯一性。</p>
<p>以0开头的是八进制，注意后面的数字中不能超过8。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。</p>
<p>由链表保证键的有序（有序指的是存储和取出的顺序一致）</p>
<p>由哈希表保证键的唯一性</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>是基于红黑树的Map接口的实现</p>
<p>键是红黑树结构，可以保证键的排序和唯一性</p>
<p>集合的嵌套遍历：</p>
<p>HashMap嵌套HashMap</p>
<p>HashMap嵌套ArrayList</p>
<p>ArrayList嵌套HashMap</p>
<p>HashMap：先创建HashMap的集合，再获取key的set集合，再遍历的时候增强for循环遍历得到key对应的value，最后再输出。</p>
<p>ArrayList：先创建ArrayList的集合，再遍历的时候直接增强for循环。</p>
<p>HashMap和Hashtable的区别（t就是小写）：</p>
<p>HashMap：线程不安全，效率高。允许null键和null值</p>
<p>Hashtable：线程安全，效率低。不允许null键和null值</p>
<p>List，Set不是继承自Map接口，它们继承自Collection接口。Map接口本身就是一个顶层接口。</p>
<p>Collections类是Object包下由静态方法组成。是针对集合进行操作的工具类。</p>
<p>Collections成员方法：</p>
<p>public static <T> void sort(List<T> list) 排序，默认情况下是自然排序</p>
<p>public static <T> int binarySearch(List&lt;?&gt; list,T key) 二分查找</p>
<p>public static <T> T max(Collection&lt;?&gt; coll) 最大值</p>
<p>public static void reverse(List&lt;?&gt; list) 反转</p>
<p>public static void shuffle(List&lt;?&gt; list) 随机置换（每调一次方法就会对List中的元素随机排序）</p>
<p>如果同时有自然排序和比较器排序，以比较器排序为主</p>
<p>Collection和Collections的区别：</p>
<p>Collection：是单列集合的顶层接口，有子接口List和Set</p>
<p>Collections:是针对集合进行操作的工具类，有对集合进行排序和二分查找的方法。</p>
<p>该使用哪种集合：看需求</p>
<p>是否是键值对象形式：</p>
<p>是：Map</p>
<p>键是否需要排序：</p>
<p>是：TreeMap</p>
<p>否：HashMap</p>
<p>否：Collection</p>
<p>元素是否唯一：</p>
<p>是：Set</p>
<p>元素是否需要排序：</p>
<p>是：TreeSet</p>
<p>否：HashSet</p>
<p>不知道就用HashSet</p>
<p>否：List</p>
<p>线程要安全吗：</p>
<p>是：Vector（其实也不用，多线程中有个更好的方法）</p>
<p>否：ArrayList或者LinkedList</p>
<p>增删多：LinkedList</p>
<p>查询多：ArrayList</p>
<p>不知道就用ArrayList</p>
<p>不知道就用ArrayList</p>
<p>集合的常见方法及遍历方式：</p>
<p>Collection：</p>
<p>add()</p>
<p>remove()</p>
<p>contains()</p>
<p>iterator()</p>
<p>size()</p>
<p>遍历：增强for和迭代器</p>
<p>|–List</p>
<p>get()</p>
<p>遍历：多了个普通for</p>
<p>|–Set</p>
<p>Map：</p>
<p>put()</p>
<p>remove()</p>
<p>containsKey(),containsValue()</p>
<p>keySet()</p>
<p>get()</p>
<p>value()</p>
<p>entrySet()</p>
<p>size()</p>
<p>遍历：根据键找值；根据键值对对象分别找键和值</p>
<p>map.merge()</p>
<p>将新的值赋值到 key （如果不存在）或更新给定的key 值对应的 value</p>
<p>分组求和这类的操作，虽然 stream 中有相关 groupingBy() 方法，但如果你想在循环中做一些其他操作的时候，merge() 还是一个挺不错的选择的。</p>
<p>常规：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        List&lt;StudentScore&gt; studentScoreList &#x3D; buildATestList();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; studentScoreMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        studentScoreList.forEach(studentScore -&gt; &#123;</span><br><span class="line">            if (studentScoreMap.containsKey(studentScore.getStuName())) &#123;</span><br><span class="line">                studentScoreMap.put(studentScore.getStuName(), </span><br><span class="line">                                    studentScoreMap.get(studentScore.getStuName()) + studentScore.getScore());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                studentScoreMap.put(studentScore.getStuName(), studentScore.getScore());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(studentScoreMap));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结果如下：</span><br><span class="line">&#x2F;&#x2F; &#123;&quot;李四&quot;:228,&quot;张三&quot;:215,&quot;王五&quot;:235&#125;</span><br></pre></td></tr></table></figure>

<p>merge方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        Map&lt;String, Integer&gt; studentScoreMap2 &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        studentScoreList.forEach(studentScore -&gt; studentScoreMap2.merge(</span><br><span class="line">          studentScore.getStuName(),</span><br><span class="line">          studentScore.getScore(),</span><br><span class="line">          Integer::sum));</span><br><span class="line"></span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(studentScoreMap2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结果如下：</span><br><span class="line">&#x2F;&#x2F; &#123;&quot;李四&quot;:228,&quot;张三&quot;:215,&quot;王五&quot;:235&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.12.%E9%9B%86%E5%90%88/" data-id="ckw61sdw7004joswd7fj6cxpe" data-title="集合" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>