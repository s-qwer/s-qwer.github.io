<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/5/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-18.1.Postman" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/18.1.Postman/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T05:02:01.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/18.1.Postman/">Postman</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>postman是一款支持http协议的接口调试与测试工具，其主要特点就是功能强大，使用简单且易用性好 。</p>
<p>无论是开发人员进行接口调试，还是测试人员做接口测试，postman都是我们的首选工具之一 。</p>
<p>那么接下来就介绍下postman到底有哪些功能，它们分别都能干些什么 。下面先通过一张图来直观的来看下postman中所包含的功能 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FljLG8vcmXEoBc5Zy02HzOk50Vz3YsGq2cCLuBhKhPwfWsWaicjL2oSbQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当然，以上功能也只是展示了postman的一部分功能，为了能更加全面的体现这款工具的特点，我将从以下三个维度来加以说明。它们分别是：</p>
<ul>
<li><p>基础功能</p>
</li>
<li><ul>
<li>常见类型的接口请求</li>
<li>接口响应数据的解析</li>
<li>接口管理(Collection)</li>
<li>批量执行接口请求</li>
<li>日志调试</li>
<li>断言</li>
<li>变量</li>
<li>请求前置脚本</li>
<li>接口关联</li>
<li>常见的返回值获取</li>
</ul>
</li>
<li><p>便捷功能快</p>
</li>
<li><ul>
<li>速填写查询参数</li>
<li>快速填写请求头信息</li>
<li>快速实现添加一个请求</li>
<li>如何继承集合认证</li>
<li>批量断言</li>
<li>快速查询和替换</li>
</ul>
</li>
<li><p>高级功能</p>
</li>
<li><ul>
<li>读取文件进行参数化</li>
<li>生成测试报告</li>
<li>代码中发送请求</li>
<li>编写接口文档</li>
<li>mock服务</li>
<li>监控</li>
<li>使用工作空间</li>
<li>代码同步与分支管理</li>
<li>连接数据库</li>
<li>apis</li>
</ul>
</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="一-postman安装说明"><a href="#一-postman安装说明" class="headerlink" title="一. postman安装说明"></a><strong>一. postman安装说明</strong></h1><p>postman 在 2018 年之后就不再支持浏览器版本，所以，想要使用它就必须先下载客户端再安装使用，下面就以 Windows 系统为例进行安装 。</p>
<p><strong>1. 下载与安装</strong></p>
<p>postman安装步骤：</p>
<p>\1. 访问postman官方网站，下载最新版本</p>
<p>访问地址：<a target="_blank" rel="noopener" href="https://www.getpostman.com/">https://www.getpostman.com/</a></p>
<p>\2. 进入到下载页面，根据自己电脑下载对应的版本</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Flo5FzPWSpwW8L1UozoTf4MJtPadpMEQtSiaqLECarT9ZeUBIGhFJiceBA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>\3. 双击下载的安装包，进入到安装界面，直到用户登录和注册界面。</p>
<p>若个人使用，选择跳过即可，这时会进入到postman主界面，至此postman安装成功(下图)。</p>
<p>若团队使用，可以进行注册，注册后使用账号可以加入团队工作区</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Fl3qRTwy57vlII9FEOiaUjBWXCn2iaSwIn5Os3iapje8TmItZCQ5sAoFxibg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>2.界面导航说明</strong></p>
<p>初次使用postman的朋友可能对界面上的一些元素不太熟悉，下面就通过一张图来说明这些元素的含义 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Flu2buNNHaeoxxruibkucBWxjVPx22P2nUHHaW5vxRCSmuWj0nd4bHMzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>3.发送第一个请求</strong></p>
<p>如果你是第一次使用postman发送请求，下面这个例子可以作为一个最基本的入门，可以帮我们建立一个初始印象 。</p>
<p>\1. 打开postman，点击+加号打开一个新的请求页。</p>
<p>\2. 在请求的URL中输入请求地址：</p>
<p><a target="_blank" rel="noopener" href="http://www.weather.com.cn/data/sk/101010100.html">http://www.weather.com.cn/data/sk/101010100.html</a></p>
<p>\3. 点击Send按钮，这时就可以在下部的窗格中看到来自服务器的json响应数据。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Fl5icYWjQgcB1EOsu1Jmt3gicYPTXPxia5tibDvhxDCODFW3UbMZic1up1VGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h1 id="二-postman基础功能"><a href="#二-postman基础功能" class="headerlink" title="二.postman基础功能"></a><strong>二.postman基础功能</strong></h1><p><strong>1.常见类型的接口请求</strong></p>
<p>常见的接口有如下四种类型，分别是含有查询参数的接口，表单类型的接口，json类型的接口以及含有上传文件的接口，以下就对这四种类型接口及如何在postman中请求进行说明 。</p>
<p><strong>1.1 .查询参数的接口请求</strong></p>
<p><strong>什么是查询参数?</strong></p>
<p>所谓的查询参数，其实就是URL地址中问号（?）后面的部分就叫查询参数，比如：<a target="_blank" rel="noopener" href="http://cx.shouji.360.cn/phonearea.php?number=13012345678">http://cx.shouji.360.cn/phonearea.php?number=13012345678</a> 。在这个接口中，查询参数就是:<strong>number=13012345678</strong> 。</p>
<p>而这一部分是由有键值对组成，格式为：key1=value1&amp;key2=value2, 如果有多组键值对，要用&amp;隔开 。</p>
<p><strong>postman如何请求</strong></p>
<p>在postman中实现对这类接口请求非常简单，一般就需要明确俩个参数即可，一个是请求方法，一个请求地址。</p>
<p>针对上面的那个接口，地址已经给出 ，而它的请求方法是get 。那么在postman中只需要把这俩个参数填写上即可请求 。</p>
<p>具体实现步骤：</p>
<p>\1. 打开postman，新建一个请求。</p>
<p>\2. 在请求方法中选择请求方法：GET,因为在postman中默认的请求方法就是GET,所以这一步可以忽略</p>
<p>\3. 接口URL中输入地址，点击Send按钮就可以发送请求了 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlibV1Mf2OLgxcuwUTHdrISFm1cjYqyITROnbniafQUveJEqwmAiaBmV1ag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>说明：查询参数的URL一般直接拷贝到输入的URL地址栏中就可以了，当然也可以把查询参数在Params中输入，俩者的效果是一样的 。</p>
<p><strong>1.2 表单类型的接口请求</strong></p>
<p><strong>什么是表单 ？</strong></p>
<p>我们都知道，在发送HTTP请求的时候，一个请求中一般包含三个部分，分别是请求行，请求头，请求体 。</p>
<p>不同的接口，请求体的数据类型是不一样的，比较常见的一种就是表单类型，那么什么是表单类型呢 ？简单理解就是在请求头中查看<strong>Content-Type，它的值如果是:application/x-www-form-urlencoded</strong> .那么就说明客户端提交的数据是以表单形式提交的 。见下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlVPe9tFf87Udh16SQn2IAl13VWTueDkV2VLpSzjtSsre74BtBG1St2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>postman中如何请求？</strong></p>
<p>如果在postman请求上图的接口，我们只需要填写四个参数，分别是(可以参考上图)：</p>
<ul>
<li><p>请求方法：POST</p>
</li>
<li><p>请求URL：</p>
<p><a target="_blank" rel="noopener" href="http://localhost/index.php?m=Home&amp;c=User&amp;a=do_login&amp;t=0.21942974229794432">http://localhost/index.php?m=Home&amp;c=User&amp;a=do_login&amp;t=0.21942974229794432</a></p>
</li>
<li><p>请求头：Content-Type：application/x-www-form-urlencode</p>
</li>
<li><p>请求体：username=13088888888&amp;password=123456&amp;verify_code=8888</p>
</li>
</ul>
<p>实现步骤：</p>
<ol>
<li>打开postman，新建一个请求 。</li>
<li>在请求中设置以上四个参数，点击Send按钮。在postman中设置请求体类型为，需要<strong>选择body-&gt; x-www-form-urlencoded</strong></li>
<li>查看响应数据。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Fl4KnApVbx69fbFOyN4cicNt3DlnR4P6E2KQdAwm3H8A4nL4jMMJ5OrwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>1.3 上传文件的表单请求</strong></p>
<p>在做接口测试时，我们经常会遇到需要上传文件的接口，比如微信的更新头像。这就需要用到：multipart/form-data。它也属于一种表单，但它既支持表单请求，也支持文件上传。它的请求报文中数据往往是下面这样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;localhost&#x2F;index.php&#x2F;home&#x2F;Uploadify&#x2F;imageUp&#x2F;savepath&#x2F;head_pic&#x2F;pictitle&#x2F;banner&#x2F;dir&#x2F;images.html HTTP&#x2F;1.1</span><br><span class="line">Content-Type: multipart&#x2F;form-data</span><br><span class="line"></span><br><span class="line">file&#x3D;a1.jpg</span><br></pre></td></tr></table></figure>

<p>这种类型的接口，在postman中该如何请求呢 ？我们先分析需要填写的参数 。</p>
<ul>
<li><p>请求方法：POST</p>
</li>
<li><p>请求URL：</p>
<p><a target="_blank" rel="noopener" href="http://localhost/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html">http://localhost/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html</a></p>
</li>
<li><p>请求类型：multipart/form-data</p>
</li>
<li><p>请求体：file=a1.jpg</p>
</li>
</ul>
<p>实现步骤：</p>
<ol>
<li>打开postman，新建一个请求 。</li>
<li>在请求中设置以上四个参数，点击Send按钮。注意：在postman中设置请求体类型，需要<strong>选择body-&gt; form-data</strong> 。file中要选择File类型，然后上传本地的文件 。</li>
<li>查看响应数据。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlmbvvEP8osueINea3jABEAYrVes8AU13fj0h5MnP3SRlQhqxdia7785w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>1.4 json类型的接口请求</strong></p>
<p>这应该是接口测试中最常见的一种情况了 ， 也就是请求体类型为json,我们来看下这个请求报文 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;xxx&#x2F;api&#x2F;sys&#x2F;login HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class="line"></span><br><span class="line">&#123;&quot;account&quot;:&quot;root&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上报文，我们可以分析出，我们在postman只需要填写四个参数即可，具体如下：</p>
<ul>
<li>请求方法：POST</li>
<li>请求地址：<a target="_blank" rel="noopener" href="http://xxx/api/sys/login">http://xxx/api/sys/login</a></li>
<li>请求体类型：json</li>
<li>请求体数据：{“account”:”root”,”password”:”123456”}</li>
</ul>
<p>实现步骤：</p>
<ol>
<li>打开postman，新建一个请求 。</li>
<li>在请求中设置以上四个参数，点击Send按钮。注意：在postman中设置请求体类型，需要<strong>选择body-&gt; raw -JSON</strong></li>
<li>查看响应数据。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlKEyT3hrRLxClerL9ribBQfSeFrcV4bu8rp9dEv5tAmQ7xmu4GiaxL5Ng/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>2.接口响应数据解析</strong></p>
<p>响应数据是发送请求后经过服务器处理后返回的结果，响应由三部分组成，分别是状态行、响应头、响应体。我们来看下postman的响应数据展示。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlfT37Gy9Qsfc62iaicTtTx7SFbM8tDK4rcvjKhkJL2asf5SCf9xm3rPhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在postman中的响应数据展示：</p>
<ul>
<li>状态行：Status：200 OK</li>
<li>响应头：Headers + Cookies，需要注意的是Cookies是包含在响应头中的，但是为了明显，工具会分开显示</li>
<li>响应体：Body</li>
</ul>
<p>那么这些数据对我们做接口测试有什么作用呢 ？</p>
<ul>
<li>Body和Status是我们做接口测试的重点，一般来说我们都会验证响应体中的数据和响应状态码</li>
<li>Test Results 是我们编写断言后，可以查看断言的执行结果 ，所以这个对我们也很有用 。</li>
<li>Time 和Size 是我们做性能测试时，可以根据这两个参数来对所测接口的性能做一个简单的判断。</li>
</ul>
<p>接下来我们再来关注下Body中的几个显示主题，分别是：Pretty，Raw，Preview .</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Fldya46bWMCiaZEocvuLUKS4kpZ4bJia8AYe4OiaaDWgoGbxoCbbibDkVyUw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Pretty:翻译成中文就是漂亮 ， 也就是说返回的Body数据在这个标签中查看 ，都是经过格式化的，格式化后的数据看起来更加直观，所以postman默认展示的也是这个选项。比如返回html页面，它会经过格式化成HTML格式后展示，比如返回json，那么也会格式化成json格式展示 。</p>
<p>Raw：翻译成中文未经过加工的，也就是原始数据 ，原始数据一般都是本文格式的，未经过格式化处理的，一般在抓包工具中都有这个选项 。</p>
<p>Preview：翻译成中文就是预览，这个选项一般对返回HTML的页面效果特别明显，如请求百度后返回结果，点击这个选项后就直接能查看到的页面 ，如下图 。同时这个选项和浏览器抓包中的Preview也是一样的 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Fl6BGgoTRORufMic6V8c2YEm5mzDauicgTdr3megI5lNc6zO7JYpqaUzBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>3. 接口管理（Collection）</strong></p>
<p>当我们对一个或多个系统中的很多用例进行维护时，首先想到的就是对用例进行分类管理，同时还希望对这批用例做回归测试 。在postman也提供了这样一个功能，就是Collection 。通过这个Collection就可以满足我们的上面说的需求。</p>
<p>先对Collection功能的使用场景做个简单总结 。</p>
<ul>
<li>用例分类管理，方便后期维护</li>
<li>可以进行批量用例回归测试 。</li>
</ul>
<p>那么Collection是如何去管理用例的呢 ？先想象我们要测试一个系统，系统下有多个模块，每个模块下有很多的被测接口用例 。那么基于这个场景，我们来通过Collection来进行实现：</p>
<p>\1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlF4W4b5gHTEp9ibQFxHzvaBnhEOeWwm9szUn7fdkNJKgrF8srXFAvPjA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>\2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FljpiaOpL0k0UXiaLj4NChLgkrw0KGYAyK1EhfCgFT4uF2VzkqZ7RiaIS6g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>\3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Flh7DP0X6alp6uhCzMmzaRxLgh4aBDfooGlGzQ8t7nWYTiaPrzCf8SZBQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>那么通过以上三个步骤，达到的效果就是如图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlMKJf6o0cNlH8BiccQK7Xdn6E1UaQR6Rym6lZkfY022hrduEdTk1cggQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>总结，通过上面的操作，我们实现了一个最简单的demo模型。但实际上，有了这个功能才是postman学习的开始，因为很多功能都是基础这个功能的基础上进行的，比如用例的批量执行，Mock ，接口文档等功能 。</p>
<p><strong>4. 批量执行接口请求</strong></p>
<p>当我们在一个Collection中编写了很多的接口测试用例，想一起执行这批用例，在postman中是如何操作呢 ？</p>
<p>实现步骤：</p>
<p>\1. 选中一个Collection，点击右三角，在弹出的界面点击RUN</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Flzec1dGXM233VrM4W3dDu0vic8ib2MjdbOzN8o8Wk8BU07VDqtOVHLKfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>\2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选中 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlUVXVIrJF4HXOibun27kmsUSYS5PrNqqjLOQZpbwdFDv32o33Rjcibc2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>\3. 点击界面下方的RUN Collection，就会对Collection中选中的所有测试用例运行 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Fl6b4kwTE3lypBbt8AZOzHicYWnkWjbeK2tdDGAgvUo68Zwr3NzfGjCrg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>对上面的几个红框内的功能进行简单说明：</p>
<ul>
<li><strong>断言统计</strong>：左上角的两个0是统计当前Collection中断言成功的执行数和失败的执行数，如果没有编写断言默认都为0 。</li>
<li>Run Summary: 运行结果总览，点击它可以看到每个请求中具体的测试断言详细信息 。Export Result：导出运行结果，默认导出的结果json文件 。</li>
<li>Retry: 重新运行，点击它会把该Collection重新运行一遍</li>
<li>New：返回到Runner，可以重新选择用例的组合 。</li>
</ul>
<p>总体来说，这个功能主要是用于对一个Collection中的所有用例或部分用例进行批量运行，已达到手工回归测试的目的。</p>
<p><strong>5.日志调试</strong></p>
<p>在做接口测试时，经常会因为代码写的有问题导致报错，这时通过查看日志就显得非常重要了，postman也提供了这样的功能，它允许我们在脚本中编写打印语句，查看打印的结果 ; 同时也可以查看每个请求的日志信息 。</p>
<p>在postman中编写日志打印语句使用的是JavaScript，编写的位置可以是Pre-request Script 或Tests标签中。编写打印语句如：console.log(“我是一条日志”)</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlPJiauFRraOVSibfXSBicganibSkHeicJQzyE3n4R1Yicr4Ovu3GVM4galic1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>那么打印的日如何看呢 ？在postman中有俩个入口，第一个入口就是：view-show postman console 。</p>
<p>第二个入口就是左下角第三个图标 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlsNmeiaCqkGIwLX2JRUgSaOTxyoMOrIEEd6H7uLC0QmCSrqjY4qL78Hg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>打开的日志界面：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Fl1ClyeJtoia7OxjLqMYTMvyoia3xicAXgJTXd8Phgx7Bo1qT8mrC7nkXRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里面有几个比较实用的功能：</p>
<ul>
<li>搜索日志：输入URL或者打印的日志就能直接搜索出我们想要的请求和日志，这对我们在众多日志中查找某一条日志是非常方便的 。</li>
<li>按级别搜索：可以查询log,info,warning,error级别的日志 ，有助于我们更快定位到错误 。</li>
<li>查看原始报文(Show raw log)：如果习惯看原始请求报文的话，这个功能可能更方便些 。</li>
<li>隐藏请求(Hide network)：把请求都隐藏掉，只查看输出日志 。</li>
</ul>
<p>总之，通过这个功能，我们在请求接口报错时，通过打印响应的日志，就能很轻松的找到问题原因了 。</p>
<p><strong>6.断言</strong></p>
<p>如果没有断言，我们只能做接口的功能测试，但有了断言后，就为我们做自动化提供了条件，并且在postman中的断言是非常方便和强大的 。</p>
<p>我们先来了解下postman断言的一些特点 ，具体如下</p>
<ul>
<li>断言编写位置：Tests标签</li>
<li>断言所用语言：JavaScript</li>
<li>断言执行顺序：在响应体数据返回后执行 。</li>
<li>断言执行结果查看：Test Results</li>
</ul>
<p>在上面我们介绍到，编写的断言代码是JavaScript，那如果不会写怎么办 ？不用担心，因为postman已经给我们内置了一些常用的断言 。用的时候，只需从右侧点击其中一个断言，就会在文本框中自动生成对应断言代码块 。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlGf6DyNBU8C9eyBXT3Whk0TgmG58Nibp9SEMVPrnqgfUYBwLM3X7293g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。</p>
<p>状态行中又包括状态码，状态消息 。在postman也可以对这两个进行断言</p>
<p><strong>状态行中的断言</strong>：</p>
<ul>
<li>断言状态码：<strong>Status code: code is 200</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(&quot;Status code is 200&quot;, function () &#123;</span><br><span class="line">    pm.response.to.have.status(200); &#x2F;&#x2F;这里填写的200是预期结果，实际结果是请求返回结果</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<ul>
<li>断言状态消息：<strong>Status code：code name has string</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(&quot;Status code name has string&quot;, function () &#123;</span><br><span class="line">    pm.response.to.have.status(&quot;OK&quot;); &#x2F;&#x2F;断言响应状态消息包含OK</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>响应头中的断言</strong></p>
<ul>
<li>断言响应头中包含：Response headers:Content-Type header check</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(&quot;Content-Type is present&quot;, function () &#123;</span><br><span class="line">    pm.response.to.have.header(&quot;Content-Type&quot;); &#x2F;&#x2F;断言响应头存在&quot;Content-Type&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>断言响应体(重点)</strong></p>
<ul>
<li>断言响应体中包含XXX字符串：Response body:Contains string</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pm.test(&quot;Body matches string&quot;, function () &#123;</span><br><span class="line">    pm.expect(pm.response.text()).to.include(&quot;string_you_want_to_search&quot;);</span><br><span class="line">&#125;); </span><br><span class="line">&#x2F;&#x2F;注解</span><br><span class="line">pm.expect(pm.response.text()).to.include(&quot;string&quot;) 获取响应文本中包含string</span><br></pre></td></tr></table></figure>



<ul>
<li>断言响应体等于XXX字符串：Response body : is equal to a string</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pm.test(&quot;Body is correct&quot;, function () &#123;</span><br><span class="line">    pm.response.to.have.body(&quot;response_body_string&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;注解</span><br><span class="line">pm.response.to.have.body(&quot;response_body_string&quot;); 获取响应体等于response_body_string</span><br></pre></td></tr></table></figure>



<ul>
<li>断言响应体(json)中某个键名对应的值：Response body : JSON value check</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pm.test(&quot;Your test name&quot;, function () &#123;</span><br><span class="line">    var jsonData &#x3D; pm.response.json();</span><br><span class="line">    pm.expect(jsonData.value).to.eql(100);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;注解</span><br><span class="line">var jsonData &#x3D; pm.response.json() 获取响应体，以json显示，赋值给jsonData .注意：该响应体必须返会是的json，否则会报错</span><br><span class="line">pm.expect(jsonData.value).to.eql(100) 获取jsonData中键名为value的值，然后和100进行比较</span><br></pre></td></tr></table></figure>



<p><strong>响应时间(一般用于性能测试)</strong></p>
<ul>
<li>断言响应时间：Response time is less than 200ms</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(&quot;Response time is less than 200ms&quot;, function () &#123;</span><br><span class="line">    pm.expect(pm.response.responseTime).to.be.below(200); &#x2F;&#x2F;断言响应时间&lt;200ms</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>案例说明</strong>：</p>
<p>针对以下接口返回的数据进行断言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cityid&quot;: &quot;101120101&quot;,</span><br><span class="line">    &quot;city&quot;: &quot;济南&quot;,</span><br><span class="line">    &quot;update_time&quot;: &quot;2020-04-17 10:50&quot;,</span><br><span class="line">    &quot;wea&quot;: &quot;晴&quot;,</span><br><span class="line">    &quot;wea_img&quot;: &quot;qing&quot;,</span><br><span class="line">    &quot;tem&quot;: &quot;16&quot;,</span><br><span class="line">    &quot;tem_day&quot;: &quot;20&quot;,</span><br><span class="line">    &quot;tem_night&quot;: &quot;9&quot;,</span><br><span class="line">    &quot;win&quot;: &quot;东北风&quot;,</span><br><span class="line">    &quot;win_speed&quot;: &quot;3级&quot;,</span><br><span class="line">    &quot;win_meter&quot;: &quot;小于12km&#x2F;h&quot;,</span><br><span class="line">    &quot;air&quot;: &quot;113&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>断言响应状态码为200</li>
<li>断言city等于济南</li>
<li>断言update_time包含2020-04-17</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlLFewBCYqrlHW20UmKudtFx9g8aOKia7ibEypul6AFseCFeicIics9Mak9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>总结，整体来说，如果用postman做接口测试，这个断言功能必不可少，其中我们常断言的响应体包含和JSON这俩个断言又是重重之重。</p>
<p><strong>7. 变量（全局/集合/环境）</strong></p>
<p>变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。</p>
<p>对我们做接口测试来说，又是一个非常重要的功能 。</p>
<p>在postman常用的三种变量分别是全局变量，环境变量，集合变量 。</p>
<ul>
<li><strong>全局变量</strong>：一旦申明了全局变量，全局有效，也就是说postman中的任何集合，任何请求中都可以使用这个变量。它的作用域是最大的 。</li>
<li><strong>环境变量</strong>：要申明环境变量，首先的创建环境，然后在环境中才能创建变量 。如果要想使用环境变量，必须先选择(导入)这个环境，这样就可以使用这个环境下的变量了 。需要说明的是环境也可以创建多个 。每个环境下又可以有多个变量 。</li>
<li><strong>集合变量</strong>：集合变量是针对集合的，也就是说申明的变量必须基于某个集合，它的使用范围也只是针对这个集合有效 。</li>
</ul>
<p>其中，他们的作用域范围依次从大到小：全局变量&gt;集合变量&gt;环境变量 。当在几个不同的范围内都申明了相同的变量时，则会优先使用范围最小的变量使。</p>
<p>想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。</p>
<ol>
<li>定义变量（设置变量）</li>
<li>获取变量（访问变量）</li>
</ol>
<p><strong>定义变量</strong></p>
<p>定义全局变量和环境变量，点击右上角的小齿轮，弹出如下界面，就可以根据需求定义全局变量或者环境变量了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Flx1HD6IJ11YoKCQav7eHoAic0qf8hbI1dbMB1nCxWSRmuP3deruv1how/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>已经定义的全局变量和环境变量，可以进行快速查看：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlTnuA0aOnQzo0wHQb0iaXEHfpQkod92E9zMOfVw0MZUNtibH8KZZqWJsA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>定义集合变量</strong></p>
<p>选择一个集合，打开查看更多动作(<strong>…</strong>)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Flwfwfc4K53NlbDpwhicnM1vwhGqrxCicHDMyqSoHuibDJ9rXKqPYmfxricw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。</p>
<p>在URL，Params , Authorization , Headers , Body中定义：</p>
<p>\1. 手工方式创建一个空的变量名</p>
<p>\2. 在以上的位置把想要的值选中右击，选中Set：环境|全局 ，选中一个变量名，点击后就会保存到这个变量中</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlYNjEy0GI4H1UNMMqdsydqb0OfIFqqFGDE85TxVrIQxuxOYD9ic2INIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在Tests，Pre-requests Script：</p>
<ul>
<li>定义全局变量：pm.collectionVariables.set(“变量名”,变量值)</li>
<li>定义环境变量：pm.environment.set(“变量名”，变量值)</li>
<li>定义集合变量：pm.variables.set(“变量名”,变量值)</li>
</ul>
<p><strong>获取变量</strong></p>
<p>定义好变量，接下来就可以使用变量了 。需要注意的是，在不同的位置获取变量，编写的规则也是不一样的 。</p>
<p>如果在<strong>请求参数中</strong>获取变量，无论是获取全局变量，还是环境变量，还是集合变量，获取的方式都是一样的编写规则： 。</p>
<ul>
<li>请求参数指的是：URL，Params , Authorization , Headers , Body</li>
</ul>
<p>如果是在编写代码的位置(Tests,Pre-requests Script)获取变量，获取不同类型的变量，编写的代码都不相同，具体如下：</p>
<ul>
<li>获取环境变量：pm.environment.get(‘变量名’)</li>
<li>获取全局变量：pm.globals.get(‘变量名’)</li>
<li>获取集合变量：pm.pm.collectionVariables.get.get(‘变量名’)</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Fl0YA8QPHDpsdWAMfkWAxticSOeiax1HP8Sqnb4qu6nibiapXKTtyUeYnRqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>变量的使用场景非常广泛，比如我们后面要提到的接口关联，请求前置脚本都会使用到变量 。</p>
<p><strong>8. 请求前置脚本</strong></p>
<p>前置脚本其实就是在Pre-requests Script中编写的JavaScript脚本，想要了解这个功能，需要先了解它的执行顺序。那么下面就来看下它的执行顺序 。</p>
<p>可以看出，一个请求在发送之前，会先去执行Pre Request Script（前置脚本）中的代码 。那么这个功能在实际工作中有什么作用呢 ？</p>
<p>主要场景：一般情况下，在发送请求前需要对接口的数据做进一步处理，就都可以使用这个功能，比如说，登录接口的密码，在发送前需要做加密处理，那么就可以在前置脚本中做加密处理，再比如说，有的接口的输入参数有一些随机数，每请求一次接口参数值都会发送变化，就可以在前置脚本中编写生成随机数的代码 。</p>
<p>总体来说，就是在请求接口之前对我们的请求数据进行进一步加工处理的都可以使用前置脚本这个功能。</p>
<p>接下来通过一个案例来看下该功能是如何使用 ？</p>
<p>案例：</p>
<ul>
<li><p>请求的登录接口URL，参数t的值要求的规则是每次请求都必须是一个随机数。</p>
</li>
<li><p>接口地址：</p>
<p><a target="_blank" rel="noopener" href="http://localhost/index.php%EF%BC%9Fm=Home&amp;c=User&amp;a=do_login&amp;t=0.7102045930338428">http://localhost/index.php？m=Home&amp;c=User&amp;a=do_login&amp;t=0.7102045930338428</a></p>
</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8Fl90JA0Trd0rMBeq5HJcrlZBC4WfoqRIBqic1Gsib5GJLc32DUvTBTUg3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>实现步骤：</p>
<ol>
<li>在前置脚本中编写生成随机数</li>
<li>将这个值保存成环境变量</li>
<li>将参数t的值替换成环境变量的值 。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FliaWAtcJKFaOia5VfHSPk7ZBNhVDq1IQ7GGoR7DR43D4v77hdLlTxibp6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>总之，这个前置脚本对我们做接口测试也非常有用，对一些复杂的场景，都可以使用前置脚本进行处理后再请求接口 。</p>
<p><strong>9. 接口关联</strong></p>
<p>在我们测试的接口中，经常出现这种情况 。上一个接口的返回数据是下一个接口的输入参数 ，那么这俩个接口就产生了关联。这种关联在做接口测试时非常常见，那么在postman中，如何实现这种关联关系呢 ？</p>
<p>实现思路：</p>
<ol>
<li>提取上一个接口的返回数据值，</li>
<li>将这个数据值保存到环境变量或全局变量中</li>
<li>在下一个接口获取环境变量或全局变量</li>
</ol>
<p>案例：</p>
<ul>
<li>用户上传头像功能，需要用户先上传一张图片，然后会自动预览 。那么在这个过程中，会调用到俩个接口 ，第一个上传头像接口，第二个预览图像接口 。</li>
<li>其中调用上传头像接口成功后会返回如下信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;url&quot;: &quot;&#x2F;public&#x2F;upload&#x2F;user&#x2F;&#x2F;head_pic&#x2F;&#x2F;ba51d1c2f7f7b98dfb5cad90846e2d79.jpg&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;banner&quot;,</span><br><span class="line">    &quot;original&quot;: &quot;&quot;,</span><br><span class="line">    &quot;state&quot;: &quot;SUCCESS&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;images&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而图像预览接口URL为：</p>
<p><a target="_blank" rel="noopener" href="http://localhost/public/upload/user//head_pic//ba51d1c2f7f7b98dfb5cad90846e2d79.jpg">http://localhost/public/upload/user//head_pic//ba51d1c2f7f7b98dfb5cad90846e2d79.jpg</a> 。可以看出这个接口的URL后半部分其实是上一个接口返回的url的值 。那么这俩个接口就产生了关联。那么在postman 可以通过以下三步完成这俩个接口的关联实现 。</p>
<p>实现步骤：</p>
<ol>
<li>获取上传头像接口返回url的值</li>
<li>将这个值保存成全局变量(环境变量也可以)</li>
<li>在图像预览中使用全局变量</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KO86E3YaibgVlWrpeia0uc8FlehOIJJubLWOiczR2Zzib3y1iac2I1R3fxmGPU8O6orVSbjj0gdSPD1p2Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以看出，接口的关联的解决方案都是用的是变量中的知识，也就是说只要你明确了要提取的值，后面就是保存该值，然后在其他接口使用该值就可以了。</p>
<p><strong>10.常见返回值获取</strong></p>
<p>在做接口测试时，请求接口返回的数据都是很复杂的json数据，有着多层嵌套，这样的数据层级在postman怎么获取呢 ？</p>
<p>案例1：多层json嵌套, 获取user_id的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;message&quot;: &quot;请求成功！&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;user_id&quot;: &quot;1252163151781167104&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取json体数据</span><br><span class="line">var jsonData &#x3D; pm.response.json()</span><br><span class="line">&#x2F;&#x2F; 获取user_id的值,通过.获取</span><br><span class="line">var user_id &#x3D; jsonData.data.user_id</span><br></pre></td></tr></table></figure>



<p>案例2：json中存在列表，获取points中的第二个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;message&quot;: &quot;请求成功！&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;roles&quot;: &#123;</span><br><span class="line">            &quot;api&quot;: [</span><br><span class="line">                &quot;API-USER-DELETE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;points&quot;: [</span><br><span class="line">                &quot;point-user-delete&quot;,</span><br><span class="line">                &quot;POINT-USER-UPDATE&quot;,</span><br><span class="line">                &quot;POINT-USER-ADD&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;authCache&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取json体数据</span><br><span class="line">var jsonData &#x3D; pm.response.json()</span><br><span class="line">&#x2F;&#x2F; 获取user_id的值,通过下标获取列表中某个元素</span><br><span class="line">var user_id &#x3D; jsonData.data.roles.points[1]</span><br></pre></td></tr></table></figure>



<p>案例3：列表中取最后一个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;message&quot;: &quot;请求成功！&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 24,</span><br><span class="line">        &quot;rows&quot;: [</span><br><span class="line">           </span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;1066370498633486336&quot;,</span><br><span class="line">                &quot;mobile&quot;: &quot;15812340003&quot;,</span><br><span class="line">                &quot;username&quot;: &quot;zbz&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;1071632760222810112&quot;,</span><br><span class="line">                &quot;mobile&quot;: &quot;16612094236&quot;,</span><br><span class="line">                &quot;username&quot;: &quot;llx&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;1075383133106425856&quot;,</span><br><span class="line">                &quot;mobile&quot;: &quot;13523679872&quot;,</span><br><span class="line">                &quot;username&quot;: &quot;test001&quot;,</span><br><span class="line">       </span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取json体数据</span><br><span class="line">var jsonData &#x3D; pm.response.json()</span><br><span class="line">&#x2F;&#x2F; 获取id的值,通过slice(-1)获取列表中最后一个元素。</span><br><span class="line">var id &#x3D; jsonData.data.rows.slice(-1)[0]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/18.1.Postman/" data-id="ckno8ff5z003wswwd02fhg05c" data-title="Postman" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-17.1.Maven" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/17.1.Maven/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T05:01:48.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/17.1.Maven/">Maven</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/17.1.Maven/" data-id="ckno8ff4v000tswwd7jxzdtu8" data-title="Maven" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-16.1.Docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/16.1.Docker/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T05:01:17.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/16.1.Docker/">Docker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="容器简介"><a href="#容器简介" class="headerlink" title="容器简介"></a><strong>容器简介</strong></h2><h3 id="什么是-Linux-容器"><a href="#什么是-Linux-容器" class="headerlink" title="什么是 Linux 容器"></a><strong>什么是 Linux 容器</strong></h3><p>Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。</p>
<p>容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNJHb3Q3iaoePFedxGK0NdPncQfl6aotsbonTG2FicsX4Bziaw97H4FgQUw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>更加详细地来说，请您假定您在开发一个应用。您使用的是一台笔记本电脑，而且您的开发环境具有特定的配置。其他开发人员身处的环境配置可能稍有不同。您正在开发的应用依赖于您当前的配置，还要依赖于某些特定文件。</p>
<p>与此同时，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。</p>
<p>您希望尽可能多在本地模拟这些环境，而不产生重新创建服务器环境的开销。</p>
<p>因此，您要如何确保应用能够在这些环境中运行和通过质量检测，并且在部署过程中不出现令人头疼的问题，也无需重新编写代码和进行故障修复？答案就是使用容器。</p>
<p>容器可以确保您的应用拥有必需的配置和文件，使得这些应用能够在从开发到测试、再到生产的整个流程中顺利运行，而不出现任何不良问题。这样可以避免危机，做到皆大欢喜。</p>
<p>虽然这只是简化的示例，但在需要很高的可移植性、可配置性和隔离的情况下，我们可以利用 Linux 容器通过很多方式解决难题。</p>
<p>无论基础架构是在企业内部还是在云端，或者混合使用两者，容器都能满足您的需求。</p>
<h3 id="容器不就是虚拟化吗"><a href="#容器不就是虚拟化吗" class="headerlink" title="容器不就是虚拟化吗"></a><strong>容器不就是虚拟化吗</strong></h3><p>是，但也不竟然。我们用一种简单方式来思考一下：</p>
<p>虚拟化使得许多操作系统可同时在单个系统上运行。</p>
<p>容器则可共享同一个操作系统内核，将应用进程与系统其他部分隔离开。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNttwRxBsGRT1zsefq4qcWZO9lPmsSpiaS9VIMRSF7a20APn22Vn4lNqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图 - 普通虚拟化技术和Docker的对比</p>
<p>这意味着什么？首先，让多个操作系统在单个虚拟机监控程序上运行以实现虚拟化，并不能达成和使用容器同等的轻量级效果。</p>
<p>事实上，在仅拥有容量有限的有限资源时，您需要能够可以进行密集部署的轻量级应用。</p>
<p>Linux 容器可从单个操作系统运行，在所有容器中共享该操作系统，因此应用和服务能够保持轻量级，并行快速运行。</p>
<h3 id="容器发展简史"><a href="#容器发展简史" class="headerlink" title="容器发展简史"></a><strong>容器发展简史</strong></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNNC2uBib5YZeRTnyY86wBNeOVicVUQDj8LKpD5TUibRBArAxd2M6tHtDrw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们现在称为容器技术的概念最初出现在 2000 年，当时称为 FreeBSD jail，这种技术可将 FreeBSD 系统分区为多个子系统（也称为 Jail）。</p>
<p>Jail 是作为安全环境而开发的，系统管理员可与企业内部或外部的多个用户共享这些 Jail。</p>
<p>Jail 的目的是让进程在经过修改的 chroot 环境中创建，而不会脱离和影响整个系统 — 在 chroot 环境中，对文件系统、网络和用户的访问都实现了虚拟化。</p>
<p>尽管 Jail 在实施方面存在局限性，但最终人们找到了脱离这种隔离环境的方法。</p>
<p>但这个概念非常有吸引力。</p>
<p>2001 年，通过 Jacques Gélinas 的 VServer 项目，隔离环境的实施进入了 Linux 领域。</p>
<p>正如 Gélinas 所说，这项工作的目的是“在高度独立且安全的单一环境中运行多个通用 Linux 服务器 [sic]。” </p>
<p>在完成了这项针对 Linux 中多个受控制用户空间的基础性工作后，Linux 容器开始逐渐成形并最终发展成了现在的模样。</p>
<h2 id="什么是-Docker？"><a href="#什么是-Docker？" class="headerlink" title="什么是 Docker？"></a><strong>什么是 Docker？</strong></h2><p>“Docker” 一词指代多种事物，包括开源社区项目、开源项目使用的工具、主导支持此类项目的公司 Docker Inc. 以及该公司官方支持的工具。技术产品和公司使用同一名称，的确让人有点困惑。</p>
<p>我们来简单说明一下：</p>
<p>🎍 IT 软件中所说的 “Docker” ，是指容器化技术，用于支持创建和使用 Linux 容器。</p>
<p>🎍 开源 Docker 社区致力于改进这类技术，并免费提供给所有用户，使之获益。</p>
<p>🎍 Docker Inc. 公司凭借 Docker 社区产品起家，它主要负责提升社区版本的安全性，并将改进后的版本与更广泛的技术社区分享。此外，它还专门对这些技术产品进行完善和安全固化，以服务于企业客户。</p>
<p>借助 Docker ，您可将容器当做重量轻、模块化的虚拟机使用。同时，您还将获得高度的灵活性，从而实现对容器的高效创建、部署及复制，并能将其从一个环境顺利迁移至另一个环境。</p>
<h3 id="Docker-如何工作？"><a href="#Docker-如何工作？" class="headerlink" title="Docker 如何工作？"></a><strong>Docker 如何工作？</strong></h3><p>Docker 技术使用 Linux 内核和内核功能（例如 Cgroups 和 namespaces）来分隔进程，以便各进程相互独立运行。</p>
<p>这种独立性正是采用容器的目的所在；它可以独立运行多种进程、多个应用程序，更加充分地发挥基础设施的作用，同时保持各个独立系统的安全性。</p>
<p>容器工具（包括 Docker）可提供基于镜像的部署模式。这使得它能够轻松跨多种环境，与其依赖程序共享应用或服务组。Docker 还可在这一容器环境中自动部署应用程序（或者合并多种流程，以构建单个应用程序）。</p>
<p>此外，由于这些工具基于 Linux 容器构建，使得 Docker 既易于使用，又别具一格 —— 它可为用户提供前所未有的高度应用程访问权限、快速部署以及版本控制和分发能力。</p>
<h3 id="Docker-技术是否与传统的-Linux-容器相同？"><a href="#Docker-技术是否与传统的-Linux-容器相同？" class="headerlink" title="Docker 技术是否与传统的 Linux 容器相同？"></a><strong>Docker 技术是否与传统的 Linux 容器相同？</strong></h3><p>否。Docker 技术最初是基于 LXC 技术构建（大多数人都会将这一技术与“传统的” Linux 容器联系在一起），但后来它逐渐摆脱了对这种技术的依赖。</p>
<p><strong>就轻量级 虚拟化 这一功能来看，LXC 非常有用</strong>，但它无法提供出色的开发人员或用户体验。除了运行容器之外，Docker 技术还具备其他多项功能，包括简化用于构建容器、传输镜像以及控制镜像版本的流程。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNSTduDPY6VjYcM953tjoDMvSQ7NQRIB4iadxRetGb582Fz7t2wBkJIyw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>传统的 Linux 容器使用 init 系统来管理多种进程。这意味着，所有应用程序都作为一个整体运行。与此相反，Docker 技术鼓励应用程序各自独立运行其进程，并提供相应工具以实现这一功能。这种精细化运作模式自有其优势。</p>
<h3 id="docker的目标"><a href="#docker的目标" class="headerlink" title="docker的目标"></a><strong>docker的目标</strong></h3><p>docker的主要目标是”Build,Ship and Run any App,Angwhere”,构建，运输，处处运行</p>
<ul>
<li><strong>构建：</strong>做一个docker镜像</li>
<li><strong>运输：</strong>docker pull</li>
<li><strong>运行：</strong>启动一个容器</li>
</ul>
<p>每一个容器，他都有自己的文件系统rootfs.</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a><strong>安装Docker</strong></h2><p>环境说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 需要两台几点进行安装</span><br><span class="line">[root@docker01 ~]# cat &#x2F;etc&#x2F;redhat-release </span><br><span class="line">CentOS Linux release 7.2.1511 (Core) </span><br><span class="line">[root@docker01 ~]# uname  -r </span><br><span class="line">3.10.0-327.el7.x86_64</span><br><span class="line">[root@docker01 ~]# hostname -I</span><br><span class="line">10.0.0.100 172.16.1.100 </span><br><span class="line">[root@docker02 ~]# hostname -I</span><br><span class="line">10.0.0.101 172.16.1.101</span><br></pre></td></tr></table></figure>



<p>在<strong>两个节点</strong>上都进行操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line">sed -i &#39;s#download.docker.com#mirrors.ustc.edu.cn&#x2F;docker-ce#g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo</span><br><span class="line">yum install docker-ce -y</span><br></pre></td></tr></table></figure>



<p>修改在docker01配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 修改启动文件，监听远程端口</span><br><span class="line">vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock -H tcp:&#x2F;&#x2F;10.0.0.100:2375</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable docker.service </span><br><span class="line">systemctl restart docker.service</span><br><span class="line"># ps -ef检查进行，是否启动</span><br></pre></td></tr></table></figure>



<p>在docker02测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker -H 10.0.0.100 info</span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 17.12.0-ce</span><br><span class="line">Storage Driver: devicemapper</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="Docker基础命令操作"><a href="#Docker基础命令操作" class="headerlink" title="Docker基础命令操作"></a><strong>Docker基础命令操作</strong></h3><p>查看docker相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]#  docker version  </span><br><span class="line">Client:</span><br><span class="line"> Version:    17.12.0-ce</span><br><span class="line"> API version:    1.35</span><br><span class="line"> Go version:    go1.9.2</span><br><span class="line"> Git commit:    c97c6d6</span><br><span class="line"> Built:    Wed Dec 27 20:10:14 2017</span><br><span class="line"> OS&#x2F;Arch:    linux&#x2F;amd64</span><br><span class="line">Server:</span><br><span class="line"> Engine:</span><br><span class="line">  Version:    17.12.0-ce</span><br><span class="line">  API version:    1.35 (minimum version 1.12)</span><br><span class="line">  Go version:    go1.9.2</span><br><span class="line">  Git commit:    c97c6d6</span><br><span class="line">  Built:    Wed Dec 27 20:12:46 2017</span><br><span class="line">  OS&#x2F;Arch:    linux&#x2F;amd64</span><br><span class="line">  Experimental:    false</span><br></pre></td></tr></table></figure>



<p>配置docker镜像加速</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="启动第一个容器"><a href="#启动第一个容器" class="headerlink" title="启动第一个容器"></a><strong>启动第一个容器</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 80:80 nginx</span><br><span class="line">Unable to find image &#39;nginx:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;nginx</span><br><span class="line">e7bb522d92ff: Pull complete </span><br><span class="line">6edc05228666: Pull complete </span><br><span class="line">cd866a17e81f: Pull complete </span><br><span class="line">Digest: sha256:285b49d42c703fdf257d1e2422765c4ba9d3e37768d6ea83d7fe2043dad6e63d</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br><span class="line">8d8f81da12b5c10af6ba1a5d07f4abc041cb95b01f3d632c3d638922800b0b4d</span><br><span class="line"># 容器启动后，在浏览器进行访问测试 </span><br></pre></td></tr></table></figure>



<p>参数说明</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNjMMEyibP61FMtxGnq1XdbQH5fiaYBtyQfQ1gew4gzqQbc9QnzRIuibEdw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="Docker镜像生命周期"><a href="#Docker镜像生命周期" class="headerlink" title="Docker镜像生命周期"></a><strong>Docker镜像生命周期</strong></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNSxPFC21wFyyxKXFJRmXXwg45brbOIr6oI52Xo12opMk4YKmtLICv5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="Docker镜像相关操作"><a href="#Docker镜像相关操作" class="headerlink" title="Docker镜像相关操作"></a><strong>Docker镜像相关操作</strong></h2><h3 id="搜索官方仓库镜像"><a href="#搜索官方仓库镜像" class="headerlink" title="搜索官方仓库镜像"></a><strong>搜索官方仓库镜像</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]#  docker search centos</span><br><span class="line">NAME                      DESCRIPTION                    STARS    OFFICIAL               AUTOMATED</span><br><span class="line">centos                    The official build of CentOS.  3992     [OK]      </span><br><span class="line">ansible&#x2F;centos7-ansible   Ansible on Centos7             105                              [OK]</span><br></pre></td></tr></table></figure>



<p>列表说明</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNYehuNNwtQs3FPDfhGoocqoic7OuBpAicn1SOW3ANVkQDxb9LMsDGicUYg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a><strong>获取镜像</strong></h3><p>根据镜像名称拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library&#x2F;centos</span><br><span class="line">af4b0a2388c6: Downloading  34.65MB&#x2F;73.67MB</span><br></pre></td></tr></table></figure>



<p>查看当前主机镜像列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker image list </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              ff426288ea90        3 weeks ago         207MB</span><br><span class="line">nginx               latest              3f8a4339aadd        5 weeks ago         108MB</span><br></pre></td></tr></table></figure>



<p>拉第三方镜像方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull index.tenxcloud.com&#x2F;tenxcloud&#x2F;httpd</span><br></pre></td></tr></table></figure>

<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a><strong>导出镜像</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker image list </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              ff426288ea90        3 weeks ago         207MB</span><br><span class="line">nginx               latest              3f8a4339aadd        5 weeks ago         108MB</span><br><span class="line"># 导出</span><br><span class="line">[root@docker01 ~]# docker image save centos &gt; docker-centos.tar.gz</span><br></pre></td></tr></table></figure>



<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a><strong>删除镜像</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker image rm centos:latest</span><br><span class="line">[root@docker01 ~]# docker image list </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              3f8a4339aadd        5 weeks ago         108MB</span><br></pre></td></tr></table></figure>



<h3 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a><strong>导入镜像</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker image load -i docker-centos.tar.gz  </span><br><span class="line">e15afa4858b6: Loading layer  215.8MB&#x2F;215.8MB</span><br><span class="line">Loaded image: centos:latest</span><br><span class="line">[root@docker01 ~]# docker image list </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              ff426288ea90        3 weeks ago         207MB</span><br><span class="line">nginx               latest              3f8a4339aadd        5 weeks ago         108MB</span><br></pre></td></tr></table></figure>



<h3 id="查看镜像的详细信息"><a href="#查看镜像的详细信息" class="headerlink" title="查看镜像的详细信息"></a><strong>查看镜像的详细信息</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker image inspect centos</span><br></pre></td></tr></table></figure>

<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h2 id="容器的日常管理"><a href="#容器的日常管理" class="headerlink" title="容器的日常管理"></a><strong>容器的日常管理</strong></h2><h3 id="容器的起-停"><a href="#容器的起-停" class="headerlink" title="容器的起/停"></a><strong>容器的起/停</strong></h3><p>最简单的运行一个容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run nginx</span><br></pre></td></tr></table></figure>



<p>创建容器，两步走（不常用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker create centos:latest  &#x2F;bin&#x2F;bash</span><br><span class="line">bb7f32368ecf0492adb59e20032ab2e6cf6a563a0e6751e58930ee5f7aaef204</span><br><span class="line">[root@docker01 ~]# docker start stupefied_nobel</span><br><span class="line">stupefied_nobel</span><br></pre></td></tr></table></figure>



<p>快速启动容器方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run  centos:latest  &#x2F;usr&#x2F;bin&#x2F;sleep 20;</span><br></pre></td></tr></table></figure>



<p><strong>容器内的第一个进程必须一直处于运行的状态，否则这个容器，就会处于退出状态！</strong></p>
<p>查看正在运行的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker container ls</span><br><span class="line">    或</span><br><span class="line">[root@docker01 ~]# docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">8708e93fd767        nginx               &quot;nginx -g &#39;daemon of…&quot;   6 seconds ago       Up 4 seconds        80&#x2F;tcp              keen_lewin</span><br></pre></td></tr></table></figure>





<p>查看你容器详细信息/ip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker container  inspect  容器名称&#x2F;id</span><br></pre></td></tr></table></figure>





<p>查看你所有容器（包括未运行的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">8708e93fd767        nginx               &quot;nginx -g &#39;daemon of…&quot;   4 minutes ago       Exited (0) 59 seconds ago                       keen_lewin</span><br><span class="line">f9f3e6af7508        nginx               &quot;nginx -g &#39;daemon of…&quot;   5 minutes ago       Exited (0) 5 minutes ago                        optimistic_haibt</span><br><span class="line">8d8f81da12b5        nginx               &quot;nginx -g &#39;daemon of…&quot;   3 hours ago         Exited (0) 3 hours ago                          lucid_bohr</span><br></pre></td></tr></table></figure>



<p>停止容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker stop 容器名称&#x2F;id </span><br><span class="line">或</span><br><span class="line">[root@docker01 ~]# docker container  kill  容器名称&#x2F;id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="进入容器方法"><a href="#进入容器方法" class="headerlink" title="进入容器方法"></a><strong>进入容器方法</strong></h3><p><strong>启动时进去方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -it #参数：-it 可交互终端</span><br><span class="line">[root@docker01 ~]# docker run -it nginx:latest  &#x2F;bin&#x2F;bash</span><br><span class="line">root@79241093859e:&#x2F;#</span><br></pre></td></tr></table></figure>



<p>退出/离开容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+p &amp; ctrl+q</span><br></pre></td></tr></table></figure>



<p><strong>启动后进入容器的方法</strong></p>
<p>启动一个docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -it centos:latest </span><br><span class="line">[root@1bf0f43c4d2f &#x2F;]# ps -ef </span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 15:47 pts&#x2F;0    00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line">root         13      1  0 15:47 pts&#x2F;0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>



<p>attach进入容器，使用pts/0 ，会让所用通过此方法进如放入用户看到同样的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker attach 1bf0f43c4d2f</span><br><span class="line">[root@1bf0f43c4d2f &#x2F;]# ps -ef </span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 15:47 pts&#x2F;0    00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line">root         14      1  0 15:49 pts&#x2F;0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>



<p>自命名启动一个容器 –name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker attach 1bf0f43c4d2f</span><br><span class="line">[root@1bf0f43c4d2f &#x2F;]# ps -ef </span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 15:47 pts&#x2F;0    00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line">root         14      1  0 15:49 pts&#x2F;0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>



<p>exec 进入容器方法（推荐使用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker exec -it clsn1  &#x2F;bin&#x2F;bash </span><br><span class="line">[root@b20fa75b4b40 &#x2F;]# 重新分配一个终端</span><br><span class="line">[root@b20fa75b4b40 &#x2F;]# ps -ef </span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 16:11 pts&#x2F;0    00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line">root         13      0  0 16:14 pts&#x2F;1    00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line">root         26     13  0 16:14 pts&#x2F;1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<h3 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a><strong>删除所有容器</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker rm -f  &#96;docker ps -a -q&#96;</span><br><span class="line"># -f 强制删除</span><br></pre></td></tr></table></figure>



<h3 id="启动时进行端口映射"><a href="#启动时进行端口映射" class="headerlink" title="启动时进行端口映射"></a><strong>启动时进行端口映射</strong></h3><p>-p参数端口映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 8888:80  nginx:latest </span><br><span class="line">287bec5c60263166c03e1fc5b0b8262fe76507be3dfae4ce5cd2ee2d1e8a89a9</span><br></pre></td></tr></table></figure>



<p>不同指定映射方法</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNuZQOkTKHYyYzsuYxRnOgYo1VXicesHlyCghOXo4sj5zaiaHry6jqcZSw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>随机映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -P （大P）# 需要镜像支持</span><br></pre></td></tr></table></figure>

<h2 id="Docker-数据卷的管理"><a href="#Docker-数据卷的管理" class="headerlink" title="Docker 数据卷的管理"></a><strong>Docker 数据卷的管理</strong></h2><h3 id="挂载时创建卷"><a href="#挂载时创建卷" class="headerlink" title="挂载时创建卷"></a><strong>挂载时创建卷</strong></h3><p>挂载卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 80:80 -v &#x2F;data:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx:latest</span><br><span class="line">079786c1e297b5c5031e7a841160c74e91d4ad06516505043c60dbb78a259d09</span><br></pre></td></tr></table></figure>



<p>容器内站点目录: /usr/share/nginx/html</p>
<p>在宿主机写入数据，查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# echo &quot;http:&#x2F;&#x2F;www.nmtui.com&quot; &gt;&#x2F;data&#x2F;index.html</span><br><span class="line">[root@docker01 ~]# curl 10.0.0.100</span><br><span class="line">http:&#x2F;&#x2F;www.nmtui.com</span><br></pre></td></tr></table></figure>



<p>设置共享卷，使用同一个卷启动一个新的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 8080:80 -v &#x2F;data:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx:latest </span><br><span class="line">351f0bd78d273604bd0971b186979aa0f3cbf45247274493d2490527babb4e42</span><br><span class="line">[root@docker01 ~]# curl 10.0.0.100:8080</span><br><span class="line">http:&#x2F;&#x2F;www.nmtui.com</span><br></pre></td></tr></table></figure>



<p>查看卷列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br></pre></td></tr></table></figure>

<h3 id="创建卷后挂载"><a href="#创建卷后挂载" class="headerlink" title="创建卷后挂载"></a><strong>创建卷后挂载</strong></h3><p>创建一个卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker volume create </span><br><span class="line">f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521</span><br><span class="line">[root@docker01 ~]# docker volume ls </span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521</span><br></pre></td></tr></table></figure>



<p>指定卷名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker volume ls </span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               clsn</span><br><span class="line">local               f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521</span><br></pre></td></tr></table></figure>



<p>查看卷路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker volume inspect clsn </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2018-02-01T00:39:25+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;clsn&#x2F;_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;clsn&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>使用卷创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 9000:80 -v clsn:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx:latest </span><br><span class="line">1434559cff996162da7ce71820ed8f5937fb7c02113bbc84e965845c219d3503</span><br><span class="line"># 宿主机测试</span><br><span class="line">[root@docker01 ~]# echo &#39;blog.nmtui.com&#39; &gt;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;clsn&#x2F;_data&#x2F;index.html </span><br><span class="line">[root@docker01 ~]# curl 10.0.0.100:9000</span><br><span class="line">blog.nmtui.com</span><br></pre></td></tr></table></figure>



<p>设置卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run  -d  -P  --volumes-from 079786c1e297 nginx:latest </span><br><span class="line">b54b9c9930b417ab3257c6e4a8280b54fae57043c0b76b9dc60b4788e92369fb</span><br></pre></td></tr></table></figure>



<p>查看使用的端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# netstat -lntup </span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1400&#x2F;sshd           </span><br><span class="line">tcp        0      0 10.0.0.100:2375         0.0.0.0:*               LISTEN      26218&#x2F;dockerd       </span><br><span class="line">tcp6       0      0 :::9000                 :::*                    LISTEN      32015&#x2F;docker-proxy  </span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      31853&#x2F;docker-proxy  </span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      31752&#x2F;docker-proxy  </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1400&#x2F;sshd           </span><br><span class="line">tcp6       0      0 :::32769                :::*                    LISTEN      32300&#x2F;docker-proxy  </span><br><span class="line">[root@docker01 ~]# curl 10.0.0.100:32769</span><br><span class="line">http:&#x2F;&#x2F;www.nmtui.com</span><br></pre></td></tr></table></figure>



<h3 id="手动将容器保存为镜像"><a href="#手动将容器保存为镜像" class="headerlink" title="手动将容器保存为镜像"></a><strong>手动将容器保存为镜像</strong></h3><p>本次是基于docker官方centos 6.8 镜像创建</p>
<p>官方镜像列表：</p>
<p><a target="_blank" rel="noopener" href="https://hub.docker.com/explore/">https://hub.docker.com/explore/</a></p>
<p>启动一个centos6.8的镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker pull  centos:6.8</span><br><span class="line">[root@docker01 ~]# docker run -it -p 1022:22 centos:6.8  &#x2F;bin&#x2F;bash</span><br><span class="line"># 在容器种安装sshd服务，并修改系统密码</span><br><span class="line">[root@582051b2b92b ~]# yum install  openssh-server -y </span><br><span class="line">[root@582051b2b92b ~]# echo &quot;root:123456&quot; |chpasswd</span><br><span class="line">[root@582051b2b92b ~]#  &#x2F;etc&#x2F;init.d&#x2F;sshd start</span><br></pre></td></tr></table></figure>



<p>启动完成后镜像ssh连接测试</p>
<p>将容器提交为镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker commit brave_mcclintock  centos6-ssh</span><br></pre></td></tr></table></figure>





<p>使用新的镜像启动容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d  -p 1122:22  centos6-ssh:latest  &#x2F;usr&#x2F;sbin&#x2F;sshd -D </span><br><span class="line">5b8161fda2a9f2c39c196c67e2eb9274977e7723fe51c4f08a0190217ae93094</span><br></pre></td></tr></table></figure>





<p>在容器安装httpd服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@5b8161fda2a9 &#x2F;]#  yum install httpd -y</span><br></pre></td></tr></table></figure>



<p>编写启动脚本脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@5b8161fda2a9 &#x2F;]# cat  init.sh </span><br><span class="line">#!&#x2F;bin&#x2F;bash </span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;httpd start </span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;sshd -D</span><br><span class="line">[root@5b8161fda2a9 &#x2F;]# chmod +x init.sh </span><br><span class="line"># 注意执行权限</span><br></pre></td></tr></table></figure>





<p>再次提交为新的镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker commit  5b8161fda2a9 centos6-httpd </span><br><span class="line">sha256:705d67a786cac040800b8485cf046fd57b1828b805c515377fc3e9cea3a481c1</span><br></pre></td></tr></table></figure>





<p>启动镜像，做好端口映射。并在浏览器中测试访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -d -p 1222:22 -p 80:80  centos6-httpd &#x2F;init.sh </span><br><span class="line">46fa6a06644e31701dc019fb3a8c3b6ef008d4c2c10d46662a97664f838d8c2c</span><br></pre></td></tr></table></figure>



<h2 id="Dockerfile自动构建docker镜像"><a href="#Dockerfile自动构建docker镜像" class="headerlink" title="Dockerfile自动构建docker镜像"></a><strong>Dockerfile自动构建docker镜像</strong></h2><p>官方构建dockerffile文件参考</p>
<p><a target="_blank" rel="noopener" href="https://github.com/CentOS/CentOS-Dockerfiles">https://github.com/CentOS/CentOS-Dockerfiles</a></p>
<h3 id="Dockerfile指令集"><a href="#Dockerfile指令集" class="headerlink" title="Dockerfile指令集"></a><strong>Dockerfile指令集</strong></h3><p>dockerfile主要组成部分：</p>
<ul>
<li>基础镜像信息 FROM centos:6.8</li>
<li>制作镜像操作指令RUN yum insatll openssh-server -y</li>
<li>容器启动时执行指令 CMD [“/bin/bash”]</li>
</ul>
<p>dockerfile常用指令：</p>
<ul>
<li>FROM 这个镜像的妈妈是谁？（指定基础镜像）</li>
<li>MAINTAINER 告诉别人，谁负责养它？（指定维护者信息，可以没有）</li>
<li>RUN 你想让它干啥（在命令前面加上RUN即可）</li>
<li>ADD 给它点创业资金（COPY文件，会自动解压）</li>
<li>WORKDIR 我是cd,今天刚化了妆（设置当前工作目录）</li>
<li>VOLUME 给它一个存放行李的地方（设置卷，挂载主机目录）</li>
<li>EXPOSE 它要打开的门是啥（指定对外的端口）</li>
<li>CMD 奔跑吧，兄弟！（指定容器启动后的要干的事情）</li>
</ul>
<p>dockerfile其他指令： </p>
<ul>
<li>COPY 复制文件</li>
<li>ENV 环境变量</li>
<li>ENTRYPOINT 容器启动后执行的命令</li>
</ul>
<h3 id="创建一个Dockerfile"><a href="#创建一个Dockerfile" class="headerlink" title="创建一个Dockerfile"></a><strong>创建一个Dockerfile</strong></h3><p>创建第一个Dockerfile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建目录</span><br><span class="line">[root@docker01 base]# cd &#x2F;opt&#x2F;base</span><br><span class="line"># 创建Dcokerfile文件，注意大小写</span><br><span class="line">[root@docker01 base]# vim Dockerfile</span><br><span class="line">FROM centos:6.8</span><br><span class="line">RUN yum install openssh-server -y </span><br><span class="line">RUN echo &quot;root:123456&quot; |chpasswd</span><br><span class="line">RUN &#x2F;etc&#x2F;init.d&#x2F;sshd start </span><br><span class="line">CMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;,&quot;-D&quot;]</span><br></pre></td></tr></table></figure>



<p>构建docker镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 base]# docker image build  -t centos6.8-ssh . </span><br><span class="line">-t 为镜像标签打标签  . 表示当前路径</span><br></pre></td></tr></table></figure>



<p>使用自构建的镜像启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 base]# docker run  -d -p 2022:22 centos6.8-ssh-b </span><br><span class="line">dc3027d3c15dac881e8e2aeff80724216f3ac725f142daa66484f7cb5d074e7a</span><br></pre></td></tr></table></figure>



<h3 id="使用Dcokerfile安装kodexplorer"><a href="#使用Dcokerfile安装kodexplorer" class="headerlink" title="使用Dcokerfile安装kodexplorer"></a><strong>使用Dcokerfile安装kodexplorer</strong></h3><p>Dockerfile文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:6.8</span><br><span class="line">RUN yum install wget unzip php php-gd php-mbstring -y &amp;&amp; yum clean all</span><br><span class="line"># 设置工作目录，之后的操作都在这个目录中</span><br><span class="line">WORKDIR &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">RUN wget -c http:&#x2F;&#x2F;static.kodcloud.com&#x2F;update&#x2F;download&#x2F;kodexplorer4.25.zip</span><br><span class="line">RUN unzip kodexplorer4.25.zip &amp;&amp; rm -f kodexplorer4.25.zip</span><br><span class="line">RUN chown -R apache.apache .</span><br><span class="line">CMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;apachectl&quot;,&quot;-D&quot;,&quot;FOREGROUND&quot;]</span><br></pre></td></tr></table></figure>



<p>更多的Dockerfile可以参考官方方法。</p>
<h2 id="Docker中的镜像分层"><a href="#Docker中的镜像分层" class="headerlink" title="Docker中的镜像分层"></a><strong>Docker中的镜像分层</strong></h2><p>参考文档：</p>
<p><a target="_blank" rel="noopener" href="http://www.maiziedu.com/wiki/cloud/dockerimage/">http://www.maiziedu.com/wiki/cloud/dockerimage/</a></p>
<p>Docker 支持通过扩展现有镜像，创建新的镜像。实际上，Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNibl4DQ5TJSKSloMYjYBFUd7pAKNFNJib9icRyhJtar11gYTl3l84Uc4Ew/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>从上图可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p>
<h3 id="Docker-镜像为什么分层"><a href="#Docker-镜像为什么分层" class="headerlink" title="Docker 镜像为什么分层"></a><strong>Docker 镜像为什么分层</strong></h3><p>镜像分层最大的一个好处就是共享资源。</p>
<p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 /etc 下的文件，这时其他容器的 /etc 是不会被修改的，修改只会被限制在单个容器内。这就是容器 Copy-on-Write 特性。</p>
<h3 id="可写的容器层"><a href="#可写的容器层" class="headerlink" title="可写的容器层"></a><strong>可写的容器层</strong></h3><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNz0xkGTOibTgYUxoHsGCYquqrg1eWfSV2gibNKb4xAibJ07OvGluaCtX5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有<strong>容器层是可写的，容器层下面的所有镜像层都是只读的。</strong></p>
<h3 id="容器层的细节说明"><a href="#容器层的细节说明" class="headerlink" title="容器层的细节说明"></a><strong>容器层的细节说明</strong></h3><p>镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。</p>
<p>文件操作的</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNKtF3xCJ5nxAmYVavUW4uSFBoPaZFhSMqEWFkfhkyTTgjEMht0dqqkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p>
<p>这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</p>
<h2 id="使用docker运行zabbix-server"><a href="#使用docker运行zabbix-server" class="headerlink" title="使用docker运行zabbix-server"></a><strong>使用docker运行zabbix-server</strong></h2><h3 id="容器间的互联"><a href="#容器间的互联" class="headerlink" title="容器间的互联"></a><strong>容器间的互联</strong></h3><p>在运行zabbix之前务必要了解容器间互联的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个nginx容器</span><br><span class="line">docker run -d -p 80:80 nginx</span><br><span class="line"># 创建容器，做link，并进入容器中</span><br><span class="line">docker run -it --link quirky_brown:web01 centos-ssh &#x2F;bin&#x2F;bash</span><br><span class="line"># 在容器中访问nginx容器可以ping通</span><br><span class="line">ping web01 </span><br></pre></td></tr></table></figure>



<p>命令执行过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 启动apache容器</span><br><span class="line">[root@docker01 ~]# docker run -d httpd:2.4  </span><br><span class="line">3f1f7fc554720424327286bd2b04aeab1b084a3fb011a785b0deab6a34e56955</span><br><span class="line">^[[A[root@docker01 docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS               NAMES</span><br><span class="line">3f1f7fc55472        httpd:2.4           &quot;httpd-foreground&quot;   6 seconds ago       Up 5 seconds        80&#x2F;tcp              determined_clarke</span><br><span class="line"># 拉取一个busybox 镜像</span><br><span class="line">[root@docker01 ~]# docker pull busybox </span><br><span class="line"># 启动容器</span><br><span class="line">[root@docker01 ~]# docker run -it  --link determined_clarke:web busybox:latest   &#x2F;bin&#x2F;sh </span><br><span class="line">&#x2F; # </span><br><span class="line"># 使用新的容器访问最初的web容器</span><br><span class="line">&#x2F; # ping web </span><br><span class="line">PING web (172.17.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.2: seq&#x3D;0 ttl&#x3D;64 time&#x3D;0.058 ms</span><br><span class="line">^C</span><br><span class="line">--- web ping statistics ---</span><br><span class="line">1 packets transmitted, 1 packets received, 0% packet loss</span><br><span class="line">round-trip min&#x2F;avg&#x2F;max &#x3D; 0.058&#x2F;0.058&#x2F;0.058 ms   </span><br></pre></td></tr></table></figure>



<h3 id="启动zabbix容器"><a href="#启动zabbix容器" class="headerlink" title="启动zabbix容器"></a><strong>启动zabbix容器</strong></h3><p>1、启动一个mysql的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql-server -t \</span><br><span class="line">      -e MYSQL_DATABASE&#x3D;&quot;zabbix&quot; \</span><br><span class="line">      -e MYSQL_USER&#x3D;&quot;zabbix&quot; \</span><br><span class="line">      -e MYSQL_PASSWORD&#x3D;&quot;zabbix_pwd&quot; \</span><br><span class="line">      -e MYSQL_ROOT_PASSWORD&#x3D;&quot;root_pwd&quot; \</span><br><span class="line">      -d mysql:5.7 \</span><br><span class="line">      --character-set-server&#x3D;utf8 --collation-server&#x3D;utf8_bin </span><br></pre></td></tr></table></figure>



<p>2、启动java-gateway容器监控java服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name zabbix-java-gateway -t \</span><br><span class="line">      -d zabbix&#x2F;zabbix-java-gateway:latest</span><br></pre></td></tr></table></figure>



<p>3、启动zabbix-mysql容器使用link连接mysql与java-gateway。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run --name zabbix-server-mysql -t \</span><br><span class="line">      -e DB_SERVER_HOST&#x3D;&quot;mysql-server&quot; \</span><br><span class="line">      -e MYSQL_DATABASE&#x3D;&quot;zabbix&quot; \</span><br><span class="line">      -e MYSQL_USER&#x3D;&quot;zabbix&quot; \</span><br><span class="line">      -e MYSQL_PASSWORD&#x3D;&quot;zabbix_pwd&quot; \</span><br><span class="line">      -e MYSQL_ROOT_PASSWORD&#x3D;&quot;root_pwd&quot; \</span><br><span class="line">      -e ZBX_JAVAGATEWAY&#x3D;&quot;zabbix-java-gateway&quot; \</span><br><span class="line">      --link mysql-server:mysql \</span><br><span class="line">      --link zabbix-java-gateway:zabbix-java-gateway \</span><br><span class="line">      -p 10051:10051 \</span><br><span class="line">      -d zabbix&#x2F;zabbix-server-mysql:latest</span><br></pre></td></tr></table></figure>



<p>4、启动zabbix web显示，使用link连接zabbix-mysql与mysql。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run --name zabbix-web-nginx-mysql -t \</span><br><span class="line">      -e DB_SERVER_HOST&#x3D;&quot;mysql-server&quot; \</span><br><span class="line">      -e MYSQL_DATABASE&#x3D;&quot;zabbix&quot; \</span><br><span class="line">      -e MYSQL_USER&#x3D;&quot;zabbix&quot; \</span><br><span class="line">      -e MYSQL_PASSWORD&#x3D;&quot;zabbix_pwd&quot; \</span><br><span class="line">      -e MYSQL_ROOT_PASSWORD&#x3D;&quot;root_pwd&quot; \</span><br><span class="line">      --link mysql-server:mysql \</span><br><span class="line">      --link zabbix-server-mysql:zabbix-server \</span><br><span class="line">      -p 80:80 \</span><br><span class="line">      -d zabbix&#x2F;zabbix-web-nginx-mysql:latest</span><br></pre></td></tr></table></figure>



<h3 id="关于zabbix-API"><a href="#关于zabbix-API" class="headerlink" title="关于zabbix API"></a><strong>关于zabbix API</strong></h3><p>关于zabbix API可以参考官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://www.zabbix.com/documentation/3.4/zh/manual/api">https://www.zabbix.com/documentation/3.4/zh/manual/api</a></p>
<p>1、获取token方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 获取token</span><br><span class="line">[root@docker02 ~]# curl -s -X POST -H &#39;Content-Type:application&#x2F;json&#39; -d &#39;</span><br><span class="line">&#123;</span><br><span class="line">&quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">&quot;method&quot;: &quot;user.login&quot;,</span><br><span class="line">&quot;params&quot;: &#123;</span><br><span class="line">&quot;user&quot;: &quot;Admin&quot;,</span><br><span class="line">&quot;password&quot;: &quot;zabbix&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;id&quot;: 1</span><br><span class="line">&#125;&#39; http:&#x2F;&#x2F;10.0.0.100&#x2F;api_jsonrpc.php</span><br><span class="line">&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;d3be707f9e866ec5d0d1c242292cbebd&quot;,&quot;id&quot;:1&#125;</span><br></pre></td></tr></table></figure>



<h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><h2 id="docker-仓库（registry）"><a href="#docker-仓库（registry）" class="headerlink" title="docker 仓库（registry）"></a><strong>docker 仓库（registry）</strong></h2><h3 id="创建一个普通仓库"><a href="#创建一个普通仓库" class="headerlink" title="创建一个普通仓库"></a><strong>创建一个普通仓库</strong></h3><p>1、创建仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart&#x3D;always --name registry -v &#x2F;opt&#x2F;myregistry:&#x2F;var&#x2F;lib&#x2F;registry  registry </span><br></pre></td></tr></table></figure>





<p>2、修改配置文件，使之支持http</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# cat  &#x2F;etc&#x2F;docker&#x2F;daemon.json </span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;10.0.0.100:5000&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重启docker让修改生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# systemctl restart  docker.service</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、修改镜像标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker tag  busybox:latest  10.0.0.100:5000&#x2F;clsn&#x2F;busybox:1.0</span><br><span class="line">[root@docker01 ~]# docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos6-ssh                     latest              3c2b1e57a0f5        18 hours ago        393MB</span><br><span class="line">httpd                           2.4                 2e202f453940        6 days ago          179MB</span><br><span class="line">10.0.0.100:5000&#x2F;clsn&#x2F;busybox    1.0                 5b0d59026729        8 days ago          1.15MB</span><br></pre></td></tr></table></figure>



<p>4、将新打标签的镜像上传镜像到仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker push   10.0.0.100:5000&#x2F;clsn&#x2F;busybox</span><br></pre></td></tr></table></figure>



<h3 id="带basic认证的仓库"><a href="#带basic认证的仓库" class="headerlink" title="带basic认证的仓库"></a><strong>带basic认证的仓库</strong></h3><p>1、安装加密工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 clsn]# yum install httpd-tools  -y</span><br></pre></td></tr></table></figure>



<p>2、设置认证密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;opt&#x2F;registry-var&#x2F;auth&#x2F; -p</span><br><span class="line">htpasswd  -Bbn clsn 123456  &gt; &#x2F;opt&#x2F;registry-var&#x2F;auth&#x2F;htpasswd</span><br></pre></td></tr></table></figure>



<p>3、启动容器，在启动时传入认证参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v &#x2F;opt&#x2F;registry-var&#x2F;auth&#x2F;:&#x2F;auth&#x2F; -e &quot;REGISTRY_AUTH&#x3D;htpasswd&quot; -e &quot;REGISTRY_AUTH_HTPASSWD_REALM&#x3D;Registry Realm&quot; -e REGISTRY_AUTH_HTPASSWD_PATH&#x3D;&#x2F;auth&#x2F;htpasswd registry</span><br></pre></td></tr></table></figure>



<p>4、使用验证用户测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 登陆用户</span><br><span class="line">[root@docker01 ~]# docker login 10.0.0.100:5000 </span><br><span class="line">Username: clsn  </span><br><span class="line">Password: 123456</span><br><span class="line">Login Succeeded</span><br><span class="line"># 推送镜像到仓库</span><br><span class="line">[root@docker01 ~]# docker push 10.0.0.100:5000&#x2F;clsn&#x2F;busybox </span><br><span class="line">The push refers to repository [10.0.0.100:5000&#x2F;clsn&#x2F;busybox]</span><br><span class="line">4febd3792a1f: Pushed </span><br><span class="line">1.0: digest: sha256:4cee1979ba0bf7db9fc5d28fb7b798ca69ae95a47c5fecf46327720df4ff352d size: 527</span><br><span class="line">#认证文件的保存位置</span><br><span class="line">[root@docker01 ~]# cat .docker&#x2F;config.json </span><br><span class="line">&#123;</span><br><span class="line">    &quot;auths&quot;: &#123;</span><br><span class="line">        &quot;10.0.0.100:5000&quot;: &#123;</span><br><span class="line">            &quot;auth&quot;: &quot;Y2xzbjoxMjM0NTY&#x3D;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F;&quot;: &#123;</span><br><span class="line">            &quot;auth&quot;: &quot;Y2xzbjpIenNAMTk5Ng&#x3D;&#x3D;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;HttpHeaders&quot;: &#123;</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Docker-Client&#x2F;17.12.0-ce (linux)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此，一个简单的docker镜像仓库搭建完成</p>
<h2 id="docker-compose编排工具"><a href="#docker-compose编排工具" class="headerlink" title="docker-compose编排工具"></a><strong>docker-compose编排工具</strong></h2><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a><strong>安装docker-compose</strong></h3><p>安装docker-compose</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载pip软件</span><br><span class="line">yum install -y python2-pip</span><br><span class="line"># 下载 docker-compose</span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure>



<p>国内开启pip 下载加速：</p>
<p><a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/help/pypi">http://mirrors.aliyun.com/help/pypi</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~&#x2F;.pip&#x2F;</span><br><span class="line">cat &gt; ~&#x2F;.pip&#x2F;pip.conf &lt;&lt;&#39;EOF&#39;</span><br><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>



<h3 id="编排启动镜像"><a href="#编排启动镜像" class="headerlink" title="编排启动镜像"></a><strong>编排启动镜像</strong></h3><p>1、创建文件目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# mkdir &#x2F;opt&#x2F;my_wordpress&#x2F;</span><br><span class="line">[root@docker01 ~]# cd &#x2F;opt&#x2F;my_wordpress&#x2F;</span><br></pre></td></tr></table></figure>



<p>2、编写编排文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 my_wordpress]# vim docker-compose.yml</span><br><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">   db:</span><br><span class="line">     image: mysql:5.7</span><br><span class="line">     volumes:</span><br><span class="line">       - &#x2F;data&#x2F;db_data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">     restart: always</span><br><span class="line">     environment:</span><br><span class="line">       MYSQL_ROOT_PASSWORD: somewordpress</span><br><span class="line">       MYSQL_DATABASE: wordpress</span><br><span class="line">       MYSQL_USER: wordpress</span><br><span class="line">       MYSQL_PASSWORD: wordpress</span><br><span class="line">   wordpress:</span><br><span class="line">     depends_on:</span><br><span class="line">       - db</span><br><span class="line">     image: wordpress:latest</span><br><span class="line">     volumes:</span><br><span class="line">       - &#x2F;data&#x2F;web_data:&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">     ports: </span><br><span class="line">       - &quot;8000:80&quot;</span><br><span class="line">     restart: always</span><br><span class="line">     environment:</span><br><span class="line">       WORDPRESS_DB_HOST: db:3306</span><br><span class="line">       WORDPRESS_DB_USER: wordpress</span><br><span class="line">       WORDPRESS_DB_PASSWORD: wordpress</span><br></pre></td></tr></table></figure>



<p>3、启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 my_wordpress]# docker-compose up</span><br><span class="line">　　#启动方法：docker-compose up</span><br><span class="line">　　#后台启动方法：docker-compose up -d</span><br></pre></td></tr></table></figure>



<p>4、浏览器上访问<a target="_blank" rel="noopener" href="http://10.0.0.100:8000/">http://10.0.0.100:8000</a></p>
<p>进行wordpress的安装即可</p>
<h3 id="haproxy代理后端docker容器"><a href="#haproxy代理后端docker容器" class="headerlink" title="haproxy代理后端docker容器"></a><strong>haproxy代理后端docker容器</strong></h3><p>1、修改编排脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 my_wordpress]# cat docker-compose.yml </span><br><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">   db:</span><br><span class="line">     image: mysql:5.7</span><br><span class="line">     volumes:</span><br><span class="line">       - &#x2F;data&#x2F;db_data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">     restart: always</span><br><span class="line">     environment:</span><br><span class="line">       MYSQL_ROOT_PASSWORD: somewordpress</span><br><span class="line">       MYSQL_DATABASE: wordpress</span><br><span class="line">       MYSQL_USER: wordpress</span><br><span class="line">       MYSQL_PASSWORD: wordpress</span><br><span class="line">   wordpress:</span><br><span class="line">     depends_on:</span><br><span class="line">       - db</span><br><span class="line">     image: wordpress:latest</span><br><span class="line">     volumes:</span><br><span class="line">       - &#x2F;data&#x2F;web_data:&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">     ports: </span><br><span class="line">       - &quot;80&quot;</span><br><span class="line">     restart: always</span><br><span class="line">     environment:</span><br><span class="line">       WORDPRESS_DB_HOST: db:3306</span><br><span class="line">       WORDPRESS_DB_USER: wordpress</span><br><span class="line">       WORDPRESS_DB_PASSWORD: wordpress</span><br></pre></td></tr></table></figure>



<p>2、同时启动两台wordpress</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 my_wordpress]# docker-compose scale wordpress&#x3D;2 </span><br><span class="line">WARNING: The scale command is deprecated. Use the up command with the --scale flag instead.</span><br><span class="line">Starting mywordpress_wordpress_1 ... done</span><br><span class="line">Creating mywordpress_wordpress_2 ... done</span><br></pre></td></tr></table></figure>



<p>3、安装haproxy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# yum install haproxy -y</span><br></pre></td></tr></table></figure>



<p>4、修改haproxy配置文件</p>
<p>关于配置文件的详细说明，参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MacoLee/p/5853413.html">https://www.cnblogs.com/MacoLee/p/5853413.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]#cp &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg&#123;,.bak&#125;</span><br><span class="line">[root@docker01 ~]# vim &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</span><br><span class="line">global</span><br><span class="line">    log         127.0.0.1 local2</span><br><span class="line">    chroot      &#x2F;var&#x2F;lib&#x2F;haproxy</span><br><span class="line">    pidfile     &#x2F;var&#x2F;run&#x2F;haproxy.pid</span><br><span class="line">    maxconn     4000</span><br><span class="line">    user        haproxy</span><br><span class="line">    group       haproxy</span><br><span class="line">    daemon</span><br><span class="line">    stats socket &#x2F;var&#x2F;lib&#x2F;haproxy&#x2F;stats level admin  #支持命令行控制</span><br><span class="line">defaults</span><br><span class="line">    mode                    http</span><br><span class="line">    log                     global</span><br><span class="line">    option                  httplog</span><br><span class="line">    option                  dontlognull</span><br><span class="line">    option http-server-close</span><br><span class="line">    option forwardfor       except 127.0.0.0&#x2F;8</span><br><span class="line">    option                  redispatch</span><br><span class="line">    retries                 3</span><br><span class="line">    timeout http-request    10s</span><br><span class="line">    timeout queue           1m</span><br><span class="line">    timeout connect         10s</span><br><span class="line">    timeout client          1m</span><br><span class="line">    timeout server          1m</span><br><span class="line">    timeout http-keep-alive 10s</span><br><span class="line">    timeout check           10s</span><br><span class="line">    maxconn                 3000</span><br><span class="line">listen stats</span><br><span class="line">    mode http</span><br><span class="line">    bind 0.0.0.0:8888</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri     &#x2F;haproxy-status </span><br><span class="line">    stats auth    admin:123456</span><br><span class="line">frontend frontend_www_example_com</span><br><span class="line">    bind 10.0.0.100:8000</span><br><span class="line">    mode http</span><br><span class="line">    option httplog</span><br><span class="line">    log global</span><br><span class="line">    default_backend backend_www_example_com</span><br><span class="line">backend backend_www_example_com</span><br><span class="line">    option forwardfor header X-REAL-IP</span><br><span class="line">    option httpchk HEAD &#x2F; HTTP&#x2F;1.0</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server web-node1  10.0.0.100:32768 check inter 2000 rise 30 fall 15</span><br><span class="line">    server web-node2  10.0.0.100:32769 check inter 2000 rise 30 fall 15</span><br></pre></td></tr></table></figure>



<p>5、启动haproxy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start haproxy</span><br><span class="line">systemctl enable haproxy</span><br></pre></td></tr></table></figure>



<p>6、使用浏览器访问hapeoxy监听的8000端口可以看到负载的情况</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNic9DpCJXcR95mfbGbd9FGYfuIDH4vibYWmBCqTCVdDmlyiaP8j7PBkw3w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>7、使用浏览器访问 </p>
<p><a target="_blank" rel="noopener" href="http://10.0.0.100:8888/haproxy-status">http://10.0.0.100:8888/haproxy-status</a></p>
<p>可以看到后端节点的监控状况，</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNEnaATu6gVIjdjfqpZlrk5uhiaKM9yTYic80Q3Pq4qibnrWBibeiauLGDuwQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="安装socat-直接操作socket控制haproxy"><a href="#安装socat-直接操作socket控制haproxy" class="headerlink" title="安装socat 直接操作socket控制haproxy"></a><strong>安装socat 直接操作socket控制haproxy</strong></h3><p>1、安装软件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install socat.x86_64 -y</span><br></pre></td></tr></table></figure>



<p>2、查看帮助</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 web_data]# echo &quot;help&quot;|socat stdio &#x2F;var&#x2F;lib&#x2F;haproxy&#x2F;stats</span><br></pre></td></tr></table></figure>



<p>3、下线后端节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;disable server backend_www_example_com&#x2F;web-node2&quot;|socat stdio &#x2F;var&#x2F;lib&#x2F;haproxy&#x2F;stats</span><br></pre></td></tr></table></figure>



<p>4、上线后端节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;enable server backend_www_example_com&#x2F;web-node3&quot;|socat stdio &#x2F;var&#x2F;lib&#x2F;haproxy&#x2F;stats</span><br></pre></td></tr></table></figure>



<p>5、编写php测试页，放到/data/web_data下，在浏览器中访问可以查看当前的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 web_data]# vim check.php</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;PHP测试&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;?php  echo &#39;&lt;p&gt;Hello World &lt;&#x2F;p&gt;&#39;; ?&gt;</span><br><span class="line">        &lt;?php  echo &quot;访问的服务器地址是:&quot;.&quot;&lt;fontcolor&#x3D;red&gt;&quot;.$_SERVER[&#39;SERVER_ADDR&#39;].&quot;&lt;&#x2F;font&gt;&quot;.&quot;&lt;br&gt;&quot;;</span><br><span class="line">        echo&quot;访问的服务器域名是:&quot;.&quot;&lt;fontcolor&#x3D;red&gt;&quot;.$_SERVER[&#39;SERVER_NAME&#39;].&quot;&lt;&#x2F;font&gt;&quot;.&quot;&lt;br&gt;&quot;;</span><br><span class="line">        ?&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>



<h2 id="重启docker服务，容器全部退出的解决办法"><a href="#重启docker服务，容器全部退出的解决办法" class="headerlink" title="重启docker服务，容器全部退出的解决办法"></a>重启docker服务，容器全部退出的解决办法</h2><h3 id="在启动是指定自动重启"><a href="#在启动是指定自动重启" class="headerlink" title="在启动是指定自动重启"></a><strong>在启动是指定自动重启</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  --restart&#x3D;always</span><br></pre></td></tr></table></figure>



<h3 id="修改docker默认配置文件"><a href="#修改docker默认配置文件" class="headerlink" title="修改docker默认配置文件"></a><strong>修改docker默认配置文件</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 添加上下面这行</span><br><span class="line">&quot;live-restore&quot;: true</span><br></pre></td></tr></table></figure>





<p>docker server配置文件 /etc/docker/daemon.json 参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# cat  &#x2F;etc&#x2F;docker&#x2F;daemon.json </span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;],</span><br><span class="line">  &quot;graph&quot;: &quot;&#x2F;opt&#x2F;mydocker&quot;, # 修改数据的存放目录到&#x2F;opt&#x2F;mydocker&#x2F;，原&#x2F;var&#x2F;lib&#x2F;docker&#x2F;</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;10.0.0.100:5000&quot;],</span><br><span class="line">  &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重启生效，只对在此之后启动的容器生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# systemctl restart  docker.service</span><br></pre></td></tr></table></figure>



<h2 id="Docker网络类型"><a href="#Docker网络类型" class="headerlink" title="Docker网络类型"></a><strong>Docker网络类型</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyN3O8G4N3W0f7o9MMbdtXhrkok419zbBSNicK98KFOeuibry2onlibKMxAw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="docker的网络类型"><a href="#docker的网络类型" class="headerlink" title="docker的网络类型"></a><strong>docker的网络类型</strong></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNecj4bBrkKJa3jfnpKxpicTtyPGbqbbLBZ2Pp3Bp3BCC0xCT2QIRVPTw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Bridge默认docker网络隔离基于网络命名空间，在物理机上创建docker容器时会为每一个docker容器分配网络命名空间，并且把容器IP桥接到物理机的虚拟网桥上。</p>
<h3 id="不为容器配置网络功能"><a href="#不为容器配置网络功能" class="headerlink" title="不为容器配置网络功能"></a><strong>不为容器配置网络功能</strong></h3><p>此模式下创建容器是不会为容器配置任何网络参数的，如：容器网卡、IP、通信路由等，全部需要自己去配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run  -it --network none busybox:latest  &#x2F;bin&#x2F;sh </span><br><span class="line">&#x2F; # ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue </span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>





<h3 id="与其他容器共享网络配置-Container）"><a href="#与其他容器共享网络配置-Container）" class="headerlink" title="与其他容器共享网络配置(Container）"></a><strong>与其他容器共享网络配置(Container）</strong></h3><p>此模式和host模式很类似，只是此模式创建容器共享的是其他容器的IP和端口而不是物理机，此模式容器自身是不会配置网络和端口，创建此模式容器进去后，你会发现里边的IP是你所指定的那个容器IP并且端口也是共享的，而且其它还是互相隔离的，如进程等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run  -it --network container:mywordpress_db_1  busybox:latest  &#x2F;bin&#x2F;sh </span><br><span class="line">&#x2F; # ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue </span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">105: eth0@if106: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue </span><br><span class="line">    link&#x2F;ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.3&#x2F;16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>





<h3 id="使用宿主机网络"><a href="#使用宿主机网络" class="headerlink" title="使用宿主机网络"></a><strong>使用宿主机网络</strong></h3><p>此模式创建的容器没有自己独立的网络命名空间，是和物理机共享一个Network Namespace，并且共享物理机的所有端口与IP，并且这个模式认为是不安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run  -it --network host  busybox:latest  &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>



<h3 id="查看网络列表"><a href="#查看网络列表" class="headerlink" title="查看网络列表"></a><strong>查看网络列表</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker network list </span><br><span class="line">NETWORK ID          NAME                  DRIVER              SCOPE</span><br><span class="line">b15e8a720d3b        bridge                bridge              local</span><br><span class="line">345d65b4c2a0        host                  host                local</span><br><span class="line">bc5e2a32bb55        mywordpress_default   bridge              local</span><br><span class="line">ebf76eea91bb        none                  null                local</span><br></pre></td></tr></table></figure>





<h3 id="用PIPEWORK为docker容器配置独立IP"><a href="#用PIPEWORK为docker容器配置独立IP" class="headerlink" title="用PIPEWORK为docker容器配置独立IP"></a><strong>用PIPEWORK为docker容器配置独立IP</strong></h3><ul>
<li><p>参考文档：</p>
<p>blog.csdn.net/design321/article/details/48264825</p>
</li>
</ul>
<ul>
<li><p>官方网站：</p>
<p>github.com/jpetazzo/pipework</p>
</li>
</ul>
<ul>
<li>宿主环境：centos7.2</li>
</ul>
<p>1、安装pipework</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;jpetazzo&#x2F;pipework&#x2F;archive&#x2F;master.zip</span><br><span class="line">unzip master.zip </span><br><span class="line">cp pipework-master&#x2F;pipework  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pipework</span><br></pre></td></tr></table></figure>



<p>2、配置桥接网卡</p>
<p>安装桥接工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bridge-utils.x86_64 -y</span><br></pre></td></tr></table></figure>



<p>修改网卡配置，实现桥接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 修改eth0配置，让br0实现桥接</span><br><span class="line">[root@docker01 ~]# cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0 </span><br><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">NAME&#x3D;eth0</span><br><span class="line">DEVICE&#x3D;eth0</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">BRIDGE&#x3D;br0</span><br><span class="line">[root@docker01 ~]# cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-br0 </span><br><span class="line">TYPE&#x3D;Bridge</span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">NAME&#x3D;br0</span><br><span class="line">DEVICE&#x3D;br0</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">IPADDR&#x3D;10.0.0.100</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">GATEWAY&#x3D;10.0.0.254</span><br><span class="line">DNS1&#x3D;223.5.5.5</span><br><span class="line"># 重启网络</span><br><span class="line">[root@docker01 ~]# &#x2F;etc&#x2F;init.d&#x2F;network restart</span><br></pre></td></tr></table></figure>



<p>3、运行一个容器镜像测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipework br0 $(docker run -d -it -p 6880:80 --name  httpd_pw httpd) 10.0.0.220&#x2F;24@10.0.0.254</span><br></pre></td></tr></table></figure>



<p>在其他主机上测试端口及连通性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# curl 10.0.0.220</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</span><br><span class="line">[root@docker01 ~]# ping 10.0.0.220 -c 1</span><br><span class="line">PING 10.0.0.220 (10.0.0.220) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.220: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.043 ms</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4、再运行一个容器，设置网路类型为none：</span><br><span class="line">pipework br0 $(docker run -d -it --net&#x3D;none --name test httpd:2.4) 10.0.0.221&#x2F;24@10.0.0.254</span><br></pre></td></tr></table></figure>





<p>进行访问测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# curl 10.0.0.221</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>



<p>5、重启容器后需要再次指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipework br0 testduliip  172.16.146.113&#x2F;24@172.16.146.1</span><br><span class="line">pipework br0 testduliip01  172.16.146.112&#x2F;24@172.16.146.1</span><br></pre></td></tr></table></figure>



<p>Dcoker跨主机通信之overlay可以参考：</p>
<p>cnblogs.com/CloudMan6/p/7270551.html</p>
<h3 id="Docker跨主机通信之macvlan"><a href="#Docker跨主机通信之macvlan" class="headerlink" title="Docker跨主机通信之macvlan"></a><strong>Docker跨主机通信之macvlan</strong></h3><p>创建网络</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker network  create --driver macvlan  --subnet 10.1.0.0&#x2F;24 --gateway 10.1.0.254 -o parent&#x3D;eth0  macvlan_1</span><br><span class="line">33a1f41dcc074f91b5bd45e7dfedabfb2b8ec82db16542f05213839a119b62ca</span><br></pre></td></tr></table></figure>



<p>设置网卡为混杂模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link set eth0 promisc on</span><br></pre></td></tr></table></figure>



<p>创建使用macvlan网络容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker run  -it --network macvlan_1  --ip&#x3D;10.1.0.222 busybox &#x2F;b</span><br></pre></td></tr></table></figure>



<h2 id="docker企业级镜像仓库harbor"><a href="#docker企业级镜像仓库harbor" class="headerlink" title="docker企业级镜像仓库harbor"></a><strong>docker企业级镜像仓库harbor</strong></h2><p>容器管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 harbor]# pwd</span><br><span class="line">&#x2F;opt&#x2F;harbor</span><br><span class="line">[root@docker01 harbor]# docker-compose stop</span><br></pre></td></tr></table></figure>



<p>1、安装docker、docker-compose</p>
<p>下载 harbor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;opt &amp;&amp; https:&#x2F;&#x2F;storage.googleapis.com&#x2F;harbor-releases&#x2F;harbor-offline-installer-v1.3.0.tgz</span><br><span class="line">tar xf harbor-offline-installer-v1.3.0.tgz</span><br></pre></td></tr></table></figure>



<p>2、修改主机及web界面密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 harbor]# vim harbor.cfg </span><br><span class="line">    ···</span><br><span class="line">    hostname &#x3D; 10.0.0.100</span><br><span class="line">    harbor_admin_password &#x3D; Harbor12345</span><br><span class="line">    ···</span><br></pre></td></tr></table></figure>



<p>3、执行安装脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 harbor]# .&#x2F;install.sh</span><br></pre></td></tr></table></figure>



<p>浏览器访问 <a target="_blank" rel="noopener" href="http://10.0.0.11/">http://10.0.0.11</a></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNdibRRbq9WzbzMkicCf1xrbuZgmXVIQFxrvsalTniaFibq0XVnuxezP4JRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>添加一个项目</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyND9aeaeciacdebb7mWbrm4lGHHju8zVianusKOBbbJic3vcY3o7nLbV8tQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>4、镜像推送到仓库的指定项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker  tag centos:6.8  10.0.0.100&#x2F;clsn&#x2F;centos6.8:1.0</span><br><span class="line">[root@docker02 ~]#  </span><br><span class="line">[root@docker02 ~]# docker images </span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">busybox                     latest              5b0d59026729        8 days ago          1.15MB</span><br><span class="line">10.0.0.100&#x2F;clsn&#x2F;centos6.8   1.0                 6704d778b3ba        2 months ago        195MB</span><br><span class="line">centos                      6.8                 6704d778b3ba        2 months ago        195MB</span><br><span class="line">[root@docker02 ~]# docker login 10.0.0.100</span><br><span class="line">Username: admin</span><br><span class="line">Password: </span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>



<p>5、推送镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker push 10.0.0.100&#x2F;clsn&#x2F;centos6.8 </span><br><span class="line">The push refers to repository [10.0.0.100&#x2F;clsn&#x2F;centos6.8]</span><br><span class="line">e00c9229b481: Pushing  13.53MB&#x2F;194.5MB</span><br></pre></td></tr></table></figure>



<p>6、在web界面里查看</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaicIibGNyuxJNbNay2XqjcyNQAAEboIdByNZWVv08D9ibvalrm9vefENnpY5lCWhEYQWS7oMK7cJx4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<h3 id="使用容器的建议"><a href="#使用容器的建议" class="headerlink" title="使用容器的建议"></a><strong>使用容器的建议</strong></h3><p>\1. 不要以拆分方式进行应用程序发布</p>
<p>\2. 不要创建大型镜像</p>
<p>\3. 不要在单个容器中运行多个进程</p>
<p>\4. 不要再镜像内保存凭证，不要依赖IP地址</p>
<p>\5. 以非root用户运行进程</p>
<p>\6. 不要使用“最新”标签</p>
<p>\7. 不要利用运行中的容器创建镜像</p>
<p>\8. 不要使用单层镜像</p>
<p>\9. 不要将数据存放在容器内</p>
<h3 id="关于Docker容器的监控"><a href="#关于Docker容器的监控" class="headerlink" title="关于Docker容器的监控"></a><strong>关于Docker容器的监控</strong></h3><p><strong>容器的基本信息</strong></p>
<ul>
<li>包括容器的数量、ID、名称、镜像、启动命令、端口等信息</li>
</ul>
<p><strong>容器的运行状态</strong></p>
<ul>
<li>统计各状态的容器的数量，包括运行中、暂停、停止及异常退出</li>
</ul>
<p><strong>容器的用量信息</strong></p>
<ul>
<li>统计容器的CPU使用率、内存使用量、块设备I/O使用量、网络使用情况等资源的使用情况</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/16.1.Docker/" data-id="ckno8ff6e004xswwd8m6342hz" data-title="Docker" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ElasticSearch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/ElasticSearch/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T05:00:52.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/ElasticSearch/">ElasticSearch</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>ElasticSearch 入门</strong></p>
<ul>
<li>新增数据</li>
<li>查询数据</li>
<li>更新数据</li>
<li>删除数据</li>
<li>批量操作</li>
</ul>
<p><strong>ElasticSearch 高级使用</strong></p>
<ul>
<li>聚合操作</li>
<li>映射操作</li>
<li>分词操作</li>
</ul>
<p><strong>Spring Boot 整合 ElasticSearch</strong></p>
<ul>
<li> <strong>…</strong></li>
</ul>
<blockquote>
<p>本篇文章的内容均以 Docker 环境为基础。</p>
</blockquote>
<p>首先拉取镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.4.2</span><br></pre></td></tr></table></figure>

<p>然后下载kibana，这是一个可视化检索数据的工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:7.4.2</span><br></pre></td></tr></table></figure>

<p>创建两个文件夹用作数据卷：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;mydata&#x2F;elasticsearch&#x2F;config</span><br><span class="line">mkdir -p &#x2F;mydata&#x2F;elasticsearch&#x2F;data</span><br></pre></td></tr></table></figure>

<p>创建一个配置文件并写入配置，使得外部机器能够访问 elasticsearch：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;http.host: 0.0.0.0&quot; &gt;&gt; &#x2F;mydata&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure>

<p>这样就可以启动 elasticsearch 了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e &quot;discovery.type&#x3D;single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS&#x3D;&quot;-Xms64m -Xmx128m&quot; \</span><br><span class="line">-v &#x2F;mydata&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml \</span><br><span class="line">-v &#x2F;mydata&#x2F;elasticsearch&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data \</span><br><span class="line">-v &#x2F;mydata&#x2F;elasticsearch&#x2F;plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br></pre></td></tr></table></figure>

<p>其中开放的 <code>9200</code> 端口为向elasticsearch发送请求的端口，而 <code>9300</code> 为集群环境下elasticsearch之间互相通信的端口；<code>&quot;discovery.type=single-node&quot;</code> 表示以单节点运行elasticsearch；<code>ES_JAVA_OPTS=&quot;-Xms64m -Xmx128m&quot;</code> 用于指定elasticsearch的内存占用，而且必须指定，否则elasticsearch将占用系统的全部内存；最后设置elasticsearch的挂载点。</p>
<p>若是启动报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Caused by: java.nio.file.AccessDeniedException: &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data&#x2F;nodes&quot;,</span><br></pre></td></tr></table></figure>

<p>这是因为我们的挂载点权限不足导致的，此时修改挂载点权限重新启动elasticsearch即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 &#x2F;mydata&#x2F;elasticsearch&#x2F;data&#x2F;</span><br></pre></td></tr></table></figure>

<p>然后启动 Kibana：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS&#x3D;http:&#x2F;&#x2F;www.ithui.top:9200 -p 5601:5601 -d kibana:7.4.2</span><br></pre></td></tr></table></figure>

<p>启动完成后访问 <a target="_blank" rel="noopener" href="http://www.ithui.top:5601/%EF%BC%9A">http://www.ithui.top:5601/：</a></p>
<p><strong>ElasticSearch 入门</strong></p>
<p>ElasticSearch 通过接收请求的方式来对数据进行处理，接下来对elasticsearch进行一个简单的入门。首先是 <code>_cat</code> 请求，通过该请求能够查询elasticsearch的一些基本信息，具体如下：</p>
<ul>
<li>GET   /_cat/nodes：查看所有节点</li>
<li>GET   /_cat/health：查看elasticsearch的健康状况</li>
<li>GET   /_cat/master：查看主节点</li>
<li>GET   /_cat/indices：查看所有索引</li>
</ul>
<p>比如查看 elasticsearch 的所有节点，则需要发送 <a target="_blank" rel="noopener" href="http://www.ithui.top/_cat/nodes">http://www.ithui.top/_cat/nodes</a> 请求，结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYYCgx7Mr24OE1uricCibBTgrnPGXpSF7zoe63LK8l4ibPHXIggHKA9eE5g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>若是想查看 elasticsearch 的健康状态，则发送 <a target="_blank" rel="noopener" href="http://www.ithui.top:9200/_cat/health">http://www.ithui.top:9200/_cat/health</a> 请求，结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYCGicdO6fXicBKqibNd7icibicJzOboF6ZMlO1cPqL4qu7EWTickPIb9ibjaOCA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h2><p>elasticsearch通过接收PUT和POST请求来新增数据，然而在新增数据之前，我们需要来了解elasticsearch中的几个概念：</p>
<ul>
<li>索引</li>
<li>类型</li>
<li>文档</li>
<li>属性</li>
</ul>
<p>我们可以类比一下mysql中的概念来更形象地理解它们。在mysql中，若是想保存一条数据，我们首先需要创建数据库，然后在数据库中创建数据表，最后将数据作为一条记录插入数据表；而elasticsearch中的索引就相当于mysql中的数据库，类型就相当于数据表，文档就相当于一条记录。</p>
<p>所以，若是想在elasticsearch中新增一条数据，我们就需要指定这条数据放在哪个索引的哪个类型下，该条数据也被称为一个文档，而且这些数据是json格式的，json中的键被称为属性。</p>
<p>在elasticsearch中新增一条数据我们有更加专业的说法，称其为 <code>索引一个文档</code> ，接下来就可以发送一个请求 <a target="_blank" rel="noopener" href="http://www.ithui.top:9200/customer/external/1">http://www.ithui.top:9200/customer/external/1</a> ，该请求表示向customer索引下的external文档存放一个标识为1的数据，数据可以存放在请求体中携带过去：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYIuEnrjuHLFtYdQFAzv9s5OMScURf3WMNiaF52oVHqcbaxgF5BhtUQqQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们来分析一下该请求的返回结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;customer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;external&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;created&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;_seq_no&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;_primary_term&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中以 <code>_</code> 开头的属性称为元数据，它表示的是elasticsearch中的基本信息，比如 <code>_index</code> 表示当前索引；<code>_type</code> 表示当前类型；<code>_id</code> 表示当前数据的标识；<code>_version</code> 表示版本；<code>result</code> 表示当前操作的状态，这里是新建状态，若是索引的文档已经存在，则状态为更新状态。</p>
<p>PUT请求方式同样也能够新增数据，然而它与POST有些许不同，POST能够不携带id进行数据的保存，比如：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYHcqBIEf8ywlbBCPXnVJBczmkFxmXz0FPUtFmpQeXDHOJJCHveicDW6w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>此时elasticsearch会自动为我们分配一个唯一的id，所以若是不携带id，则每次请求都将是一次新增数据的操作。然而PUT请求方式是无法实现这样的效果的，也就是说，若是使用PUT方式发送请求，则必须携带id，否则就会报错：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIY6DA3hBB9GnF19uZWh8pauaTlXNbt4KjTGQEILhNfnicdRzcvepAibuCw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>elasticsearch接收GET请求用于查询数据，比如发送 <a target="_blank" rel="noopener" href="http://www.ithui.top:9200/customer/external/1">http://www.ithui.top:9200/customer/external/1</a> ：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYJBjaqcJia8m721wZia0xcUr5D0ZcYYzU2K9voVoYSstibIK0B04cbBr7w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其中数据存放在 <code>_source</code> 中， <code>_seq_no</code> 属性和 <code>_primary_term</code> 属性是用来做并发控制的，数据在每次更新之后都会加1，是乐观锁机制。</p>
<p>它的原理是这样的，假设此时有两个请求同时来到并且均想要修改id为1的数据，那么可以让这两个请求去判断一下当前的数据是否是最新的，怎么知道数据是最新的呢？</p>
<p>就是判断 <code>seq_no</code> 和 <code>_primary_term</code> 属性，比如这个请求：<a target="_blank" rel="noopener" href="http://www.ithui.top:9200/customer/external/1?if_seq_no=0&amp;if_primary_term=1">http://www.ithui.top:9200/customer/external/1?if_seq_no=0&amp;if_primary_term=1</a> 。</p>
<p>它在更新数据前会去判断 <code>seq_no</code> 是否等于0， <code>_primary_term</code> 是否等于1，若成立，则证明数据是最新的，所以它能够修改成功：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYVXicgTUz21KT7A16H9CGLN7uYkIUiaJaCLxfwVRLysdfHZOSudOS4HdQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>此时需要注意了，当数据更新成功后， <code>_seq_no</code> 属性便会自动向上递增，此时第二个请求就无法更新了：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYAzMN5obb1GS91mz9esw5shJzfYDgGTLEIDqciaRR6eOJrxhcZPJdMkQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>原因就是当前的版本与期望的版本不一致，此时若想继续更新，就需要重新查询数据，得到并发控制属性值，再进行更新。</p>
<p><strong>更新数据</strong></p>
<p>在新增数据中我们已然接触了更新数据，当要新增的数据已经存在时，新增操作就会变为更新操作，当然了，elasticsearch还是为我们提供了另外一种更新方式。比如 <a target="_blank" rel="noopener" href="http://www.ithui.top:9200/customer/external/1/_update">http://www.ithui.top:9200/customer/external/1/_update</a> ：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYfssgzP3mibvUTNlTY2QbTjh9QdoHp5qWazcn8F6ZqXxWAxv1RGeYZhQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>需要注意的是，若是以这样的方式进行数据更新，则请求体数据必须用 <code>doc</code> 属性进行封装，它与不携带 <code>_update</code> 进行数据更新的方式有什么区别呢？</p>
<p>若是不携带 <code>_update</code> 更新数据，则每次发送请求elasticsearch都认为是一次更新，而携带 <code>_update</code> 更新数据，则elasticsearch会检查当前数据是否与原数据一致，若一致，则不会进行任何的操作，包括版本号、并发控制属性等都不会发生变化。</p>
<p>这里的PUT方式与POST方式效果一样，没有任何区别。</p>
<p><strong>删除数据</strong></p>
<p>elasticsearch通过接收DELETE请求来完成数据的删除操作。比如 <a target="_blank" rel="noopener" href="http://www.ithui.top:9200/customer/external/1">http://www.ithui.top:9200/customer/external/1</a> ，通过该请求能够删除id为1的数据；elasticsearch还支持直接删除索引，比如 <a target="_blank" rel="noopener" href="http://www.ithui.top:9200/customer">http://www.ithui.top:9200/customer</a> ，该请求将删除customer索引；但是我们无法直接删除类型，elasticsearch是不支持直接删除类型的。</p>
<p><strong>批量操作</strong></p>
<p>elasticsearch还支持批量操作，不过批量操作我们就需要在kibana中进行测试了，我们在前面已经启动了kibana的镜像，只需访问 <a target="_blank" rel="noopener" href="http://www.ithui.top:5601/">http://www.ithui.top:5601/</a> 即可来到kibana的界面：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYia7rb9xv7Ric9z64r8ckVMLic23rCKR3843PF3HqeQ1yQUOiauK3Ricnnwg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击左侧导航栏的 <code>Dev Tools</code> 进入到开发工具：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYkJdlCQCic3kvjo2Jlia6YuY9bgLIeoXjbic10thd5ictEzAQSGtr4HBZPg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>编写好请求后点击运行图标即可发送请求，批量操作的数据格式非常有讲究：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;lisi&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&quot;index&quot;</code> 表示新增操作，并且指定了数据的id为1，而具体需要新增的数据值是在第二行存放着：<code>&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;</code> ；第三行也是如此，仍然是新增操作，指定数据id为2，数据值为：<code>&#123;&quot;name&quot;:&quot;lisi&quot;&#125;</code>，这样运行之后elasticsearch会执行两个新增操作，将这两个数据保存起来。</p>
<p>再比如这样一段复杂的批量操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;_bulk</span><br><span class="line">&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;website&quot;,&quot;_type&quot;:&quot;blog&quot;,&quot;_id&quot;:&quot;123&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;create&quot;:&#123;&quot;_index&quot;:&quot;website&quot;,&quot;_type&quot;:&quot;blog&quot;,&quot;_id&quot;:&quot;123&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;Test Title&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;website&quot;,&quot;_type&quot;:&quot;blog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;Test Title2&quot;&#125;</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;website&quot;,&quot;_type&quot;:&quot;blog&quot;,&quot;_id&quot;:&quot;123&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;title&quot;:&quot;Update Title&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>首先是第一行， <code>_bulk</code> 指定了这次操作为批量操作，因为没有设置其它的任何信息，所以接下来的所有操作都需要指定索引、类型等信息；</p>
<p>第二行 <code>delete</code> 表示一个删除操作，其后指定了索引、类型以及要删除的数据id，因为删除操作不需要携带请求体数据，所以我们可以直接在下一行编写第二个操作；</p>
<p>第三行 <code>create</code> 表示一个新增操作，并指定了索引、类型、数据id，第四行就是需要新增的数据值了；第五行与第六行也是一个新增操作；第七行和第八行是一个更新操作，而且因为是update更新，所以请求体数据需要用 <code>doc</code> 属性包装。</p>
<p>运行该操作，得到结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIY7r7ThL49nhG1e6WZLx14lKamwicjXuBPjsslTDuiaEvVxUyHwyJfoqAQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>第一个删除操作，因为不存在这样的一个数据，所以删除失败了，状态为404，但是后面的操作却成功了，从这里可以说明，elasticsearch批量操作中的每个操作都是相互独立的，互相不会造成任何影响。</p>
<p><strong>ElasticSearch高级使用</strong></p>
<p>elasticsearch有两种检索方式，一种是前面说过的，发送REST请求，将数据以请求体的方式携带，还有一种方式就是直接将数据拼接在url路径上，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_search?q&#x3D;*&amp;sort&#x3D;account_number:asc</span><br></pre></td></tr></table></figure>

<p>它表示这是一个GET请求，要操作的索引是bank， <code>_search</code> 表示这是一次检索， <code>q=*</code> 表示查询所有， <code>sort=account_number:asc</code> 表示以 <code>account_number</code> 的值进行升序排序。</p>
<p>我们还可以这样进行检索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;account_number&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种检索方式得到的结果是一样的，来介绍一下这种检索方式的语法。首先是 <code>query</code> ，它用于指定查询条件， <code>match_all</code> 表示匹配所有，大括号后面可以编写匹配的规则；其次是 <code>sort</code> ，它用于指定排序条件， <code>account_number:asc</code> 则表示以该属性的值进行升序排序，若是想指定多个规则，可以继续在 <code>sort</code> 属性中进行编写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;account_number&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;balance&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>此时则表示先按 <code>account_number</code> 进行升序，再按 <code>balance</code> 进行降序排序。</p>
<p>通过请求体数据进行检索的方式被称为 <code>Query DSL</code> ，即：查询领域对象语言，在elasticsearch中我们将会大量地编写这种语言。查询领域对象语言的基本语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> QUERY_NAME:&#123;</span><br><span class="line">   ARGUMENT:VALUE,</span><br><span class="line">    ARGUMENT:VALUE,</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先整个语句需要被一对大括号包含，在大括号内需要编写对应的操作，比如查询，就编写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;query&quot;:&#123;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>query</code> 中又需要指定查询的条件，比如匹配部分、匹配所有，以及匹配的规则等等，若是想要排序，则编写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;sort&quot;:[</span><br><span class="line">  </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sort</code> 是一个数组，表示可以指定多个排序的规则。在其中还可以指定分页，只需要设置 <code>from</code>和<code>size</code> 属性值即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里表示从第一条数据开始，每页显示5条数据。我们还能通过指定 <code>_source</code> 属性来决定 elasticsearch 检索出的数据中包含哪些属性值，以剔除不必要的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;account_number&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 5,</span><br><span class="line">  &quot;_source&quot;: [&quot;balance&quot;,&quot;firstname&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时表示只返回 <code>balance</code> 和 <code>firstname</code> 属性值。匹配规则中除了可以指定匹配全部外，还可以匹配指定的属性值，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;account_number&quot;: &quot;20&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时表示检索 <code>account_number</code> 为20的数据，这是一个精确检索的操作。它当然还支持模糊检索，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;address&quot;: &quot;mill lane&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时表示检索 <code>address</code> 中包含mill和lane的数据，我们来看看elasticsearch返回的结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYBB3AnlOrTxSgiag803nbuOyuYvyAb23ZueCiatM2VsvSbP0ziaXjMSVDA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>来观察一下这两条数据，第一条数据有一个 <code>_score</code> 的属性，它表示的是当前数据的得分情况，因为该数据中包含了Mill lane字符串，所以能够最大程度地匹配上我们的匹配规则，故它的得分最高；再看第二条数据，因为该数据中只包含了Mill而没有Lane，所以它的匹配度更低一些，故而得分低一些。</p>
<p>由此可知，elasticsearch会将匹配规则中包含的所有字符串都去与待检索的数据进行匹配，实际上，elasticsearch底层采用的是分词策略，具体是如何进行分词的我们暂且先不做了解。我们还可以根据得分情况去获知哪些数据与我们想要的数据匹配度更接近。</p>
<p>虽然elasticsearch可以进行分词模糊匹配，但我们若是就想查询哪些数据中含有mill road呢？这个时候，我们可以采用 <code>match_phrase</code> 来实现短语匹配，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;address&quot;: &quot;mill lane&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以进行多字段匹配，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;mill&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;address&quot;,&quot;city&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时表示在 <code>address</code> 和 <code>city</code> 属性中匹配mill字符串，倘若有一个满足，都符合我们的匹配规则。</p>
<p>当我们需要同时指定多个检索规则的时候，我们可以使用 <code>bool</code> 属性完成复合检索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;gender&quot;: &quot;F&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;address&quot;: &quot;mill&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;age&quot;: &quot;28&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;lastname&quot;: &quot;Wallace&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段语句中，首先是 <code>bool</code> 属性复合了四个检索条件，然后是 <code>must</code> 属性，它表示必须满足检索条件，条件为 <code>gender</code> 等于F， <code>address</code> 包含mill；而 <code>must_not</code> 表示必须排除检索条件，条件为 <code>age</code> 等于28；最后是 <code>should</code> ，它表示应该满足检索条件，检索条件为<code>lastname</code> 等于Wallace。</p>
<p>它的关键在于即使不满足该条件，这条数据也可以被查询出来，但如果某条数据满足了 <code>should</code>指定的条件，它就会得到相应的得分，可以认为这是一个加分项。</p>
<p>我们还可以通过 <code>filter</code> 过滤器实现检索，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 18,</span><br><span class="line">            &quot;lte&quot;: 30</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段语句表示检索年龄在18~30之间的数据，但需要注意的是，使用 <code>filter</code> 属性并不会影响数据的得分。</p>
<p>使用 <code>match</code> 能够实现精确检索，但elasticsearch推荐我们使用 <code>match</code> 属性进行模糊检索，而使用 <code>term</code> 进行精确检索，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;balance&quot;: &quot;32838&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>聚合</strong></p>
<p>elasticsearch 除了能够检索数据，它还能够对数据进行分析，elasticsearch 中的聚合就提供了从数据中分组和提取数据的能力。</p>
<p>比如这样的一个需求，检索地址中包含mill的所有人的年龄分布以及平均年龄，该如何编写语句呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;address&quot;: &quot;mill&quot;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;ageAgg&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;,</span><br><span class="line">        &quot;size&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ageAvg&quot;:&#123;</span><br><span class="line">      &quot;avg&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过 <code>query</code> 属性检索地址中包含mill的人，然后通过 <code>aggs</code> 指定聚合操作，第一个聚合为 <code>ageAgg</code> ，这是聚合操作的名字，可以取任意值，其中 <code>terms</code> 表示分布情况；第二个聚合为 <code>ageAvg</code> ，其中 <code>avg</code> 表示平均值，来看检索得到的结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYcGjVhJKWv1sLTyBNZRa31BGoFqdUd4iaLINfS9LZkXMnaHwH8xP8Ifw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其中 <code>buckers</code> 中的数据是每种年龄的分布情况，比如38岁的有2人，28岁的有1人；<code>ageAvg</code>中的就是年龄的平均值了，为34.0。</p>
<p>又比如这个需求，按照年龄聚合，并求这些年龄段的人的平均薪资，语句就该这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;ageAgg&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;,</span><br><span class="line">        &quot;size&quot;: 100</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;ageAvg&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个嵌套的聚合操作，首先通过 <code>terms</code> 按照年龄聚合， <code>size</code> 表示分布有多少种情况，这里假设有100种，然后在该聚合的基础上进行平均聚合，这里需要注意平均聚合语句的位置是在年龄聚合的里面的。</p>
<p><strong>映射</strong></p>
<p>映射是用来定义一个文档，以及它所包含的属性是如何存储和索引的，但我们发现，在使用elasticsearch的过程中，我们并没有对数据进行类型的指定，这是因为elasticsearch会自动猜测映射类型，我们可以通过请求查看映射信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET bank&#x2F;_mapping</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bank&quot; : &#123;</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">      &quot;properties&quot; : &#123;</span><br><span class="line">        &quot;account_number&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;long&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;address&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;text&quot;,</span><br><span class="line">          &quot;fields&quot; : &#123;</span><br><span class="line">            &quot;keyword&quot; : &#123;</span><br><span class="line">              &quot;type&quot; : &quot;keyword&quot;,</span><br><span class="line">              &quot;ignore_above&quot; : 256</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;age&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;long&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个属性的 <code>type</code> 中都显示了它的类型。然而有些属性的类型并不是我们想要的，这个时候我们可以修改指定属性的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:&#123;&quot;type&quot;: &quot;integer&quot;&#125;,</span><br><span class="line">      &quot;email&quot;:&#123;&quot;type&quot;: &quot;keyword&quot;&#125;,</span><br><span class="line">      &quot;name&quot;:&#123;&quot;type&quot;: &quot;text&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照我们获取到的映射规则对其进行设置即可。此时我们获取my_index索引的映射信息进行查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;my_index&quot; : &#123;</span><br><span class="line">    &quot;aliases&quot; : &#123; &#125;,</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">      &quot;properties&quot; : &#123;</span><br><span class="line">        &quot;age&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;integer&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;email&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;text&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明设置是成功的。但这种方式仅限于设置不存在的索引，若是需要设置的索引已经存在，则我们无法通过这种方式来改变属性的类型。我们需要采用另外一种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;my_index&#x2F;_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;:&#123;</span><br><span class="line">    &quot;id&quot;:&#123;&quot;type&quot;:&quot;long&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这种方式只能用于添加新的映射规则， 而不能修改之前属性的类型。所以若是想要修改已存在的属性类型，只能再创建一个新的索引，并指定好映射规则，再将之前的数据迁移到新的索引中来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 创建新的映射规则索引</span><br><span class="line">PUT &#x2F;newbank</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;address&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;age&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;balance&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;city&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 数据迁移</span><br><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;bank&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;newbank&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><p>在前面有说到elasticsearch是通过分词来进行模糊检索的，而分词在elasticsearch中是通过tokenizer分词器实现的，分词器通过接收一个字符流，将其分割为独立的tokens词元。</p>
<p>elasticsearch中默认有一些分词器，但它们都只支持英文的分词，对于中文，我们需要额外安装一个分词器，这里以 <code>ik</code> 分词器为例，首先下载ik分词器，下载地址：<a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIY62y3nibUQHvUJvceyjPC0xQXlW1ghYe4JPj7ud9kiadianpiabb2ocpib8Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>同样下载 7.4.2 版本的 ik 分词器：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYbWoJCYJgfwMVicMRealpxaQel40T4SRAA0u94maCXVDicyarAUjYgJuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在该位置复制下载地址，然后在服务器上进行安装，因为在启动 elasticsearch 镜像的时候我们做了数据卷的映射，所以只需将其下载好存放在 <code>/mydata/elasticsearch/plugins</code> 目录下即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;mydata&#x2F;elasticsearch&#x2F;plugins</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases&#x2F;download&#x2F;v7.4.2&#x2F;elasticsearch-analysis-ik-7.4.2.zip</span><br></pre></td></tr></table></figure>

<p>下载完成后解压一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip elasticsearch-analysis-ik-7.4.2.zip</span><br></pre></td></tr></table></figure>

<p>解压完成后重启elasticsearch，这样我们就安装好了ik分词器，可以来测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;分词器检索。&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分词结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;分词器&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;检索&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 3,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看elasticsearch默认使用的分词器的分词效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;分词器检索。&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分词结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;分&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 1,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;词&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 1,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;器&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;检&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 3,</span><br><span class="line">      &quot;end_offset&quot; : 4,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;索&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 4,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，默认的分词器只是把每个字都当成了一个词而已，在中文的处理上与ik分词器相比就要逊色很多了。</p>
<p>但有时候ik分词器仍然达不到我们的需求，比如最近才流行起来的网络热词，ik分词器肯定是没有办法对其进行分词的，所以我们需要对其定制扩展词库，找到nginx映射目录下的html文件夹，在该文件夹下创建es文件夹用于存放ik分词器需要使用到的一些资源( <code>关于nginx的运行与配置请看文章最后一节</code> )：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd cd &#x2F;mydata&#x2F;nginx&#x2F;html&#x2F;</span><br><span class="line">mkdir es</span><br></pre></td></tr></table></figure>

<p>然后在es目录下新建一个文本信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@izrcf5u3j3q8xaz es]# vim fenci.txt</span><br><span class="line">[root@izrcf5u3j3q8xaz es]# cat fenci.txt </span><br><span class="line">乔碧萝</span><br></pre></td></tr></table></figure>

<p>将需要定制的词放在该文本中即可，此时我们测试一下访问</p>
<p><a target="_blank" rel="noopener" href="http://www.ithui.top/es/fenci.txt">http://www.ithui.top/es/fenci.txt</a> ：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYRt3nHT9iaEVob3nenSh9IKtJpnKvvnwq030rst9eI4SqtC2OvMytyAQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>没有问题，我们继续下一步，来到ik分词器的配置目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;mydata&#x2F;elasticsearch&#x2F;plugins&#x2F;ik&#x2F;config&#x2F;</span><br></pre></td></tr></table></figure>

<p>修改它的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim IKAnalyzer.cfg.xml</span><br></pre></td></tr></table></figure>

<p>修改内容如下，将定制的文本地址配置进去即可：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/oTKHc6F8tsiaYGUf1UmD6zrc4MdzwGcIYxheBH9aKhfIWOuIxjsn1DqX6wKKJRKniaxdFa0zjY6kC23T2WopzdAw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置完成后一定要重启elasticsearch，此时我们来测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;乔碧萝殿下。&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分词结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;乔碧萝&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;殿下&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 3,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring Boot 整合 elasticsearch</strong></p>
<p>前面介绍了elasticsearch的一些基础知识，接下来我们来看看如何在SpringBoot应用中使用elasticsearch。</p>
<p>想要通过Java程序操作elasticsearch，我们也需要发送请求给elasticsearch进行操作，这里我们使用ElasticSearch-Rest-Client对elasticsearch进行操作。</p>
<p>首先引入依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;7.4.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>因为SpringBoot管理了elasticsearch的依赖版本，所以我们需要指定一下elasticsearch的版本与其一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;elasticsearch.version&gt;7.4.2&lt;&#x2F;elasticsearch.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>

<p>然后编写一个配置类，向容器中注册一个操作elasticsearch的组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class GuliMailElasticSearchConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RestHighLevelClient esRestClient() &#123;</span><br><span class="line">        return new RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        new HttpHost(&quot;www.ithui.top&quot;, 9200, &quot;http&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们就可以通过它操作 elasticsearch 了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void index() throws IOException &#123;</span><br><span class="line">    IndexRequest indexRequest &#x3D; new IndexRequest(&quot;users&quot;);</span><br><span class="line">    indexRequest.id(&quot;1&quot;);</span><br><span class="line">    &#x2F;&#x2F; indexRequest.source(&quot;name&quot;,&quot;zhangsan&quot;,&quot;age&quot;,20,&quot;gender&quot;,&quot;男&quot;);</span><br><span class="line">    User user &#x3D; new User();</span><br><span class="line">    user.setName(&quot;zhangsan&quot;);</span><br><span class="line">    user.setAge(20);</span><br><span class="line">    user.setGender(&quot;男&quot;);</span><br><span class="line">    String json &#x3D; JSON.toJSONString(user);</span><br><span class="line">    indexRequest.source(json, XContentType.JSON);</span><br><span class="line">    &#x2F;&#x2F; 执行保存操作</span><br><span class="line">    IndexResponse index &#x3D; client.index(indexRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#x2F;&#x2F; 响应数据</span><br><span class="line">    System.out.println(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RestHighLevelClient提供了非常多的方式用于保存数据，但比较常用的是通过json数据直接保存，首先需要指定索引， <code>IndexRequest indexRequest = new IndexRequest(&quot;users&quot;);</code> 指定了users索引，然后指定数据id，接着指定数据值，最后使用client执行保存操作，然后可以拿到响应数据。</p>
<p>elasticsearch的其它简单操作，诸如：更新、删除等，都只需要转换一下调用方法即可，如更新操作，就需要使用client调用update方法，接下来我们看看Java程序该如何实现较为复杂的检索操作。</p>
<p>比如现在想聚合出年龄的分布情况，并求出每个年龄分布人群的平均薪资，就应该这样进行编写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void search() throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建检索请求</span><br><span class="line">    SearchRequest searchRequest &#x3D; new SearchRequest(&quot;bank&quot;);</span><br><span class="line">    &#x2F;&#x2F; 指定需要检索的索引</span><br><span class="line">    &#x2F;&#x2F; searchRequest.indices(&quot;bank&quot;);</span><br><span class="line">    &#x2F;&#x2F; 指定检索条件</span><br><span class="line">    SearchSourceBuilder builder &#x3D; new SearchSourceBuilder();</span><br><span class="line">    &#x2F;&#x2F; 查询条件</span><br><span class="line">    builder.query(QueryBuilders.matchQuery(&quot;address&quot;,&quot;mill&quot;));</span><br><span class="line">    &#x2F;&#x2F; 聚合条件</span><br><span class="line">    builder.aggregation(AggregationBuilders.terms(&quot;ageAgg&quot;).field(&quot;age&quot;));</span><br><span class="line">    builder.aggregation(AggregationBuilders.avg(&quot;balanceAvg&quot;).field(&quot;balance&quot;));</span><br><span class="line">    searchRequest.source(builder);</span><br><span class="line">    &#x2F;&#x2F; 执行检索请求</span><br><span class="line">    SearchResponse searchResponse &#x3D; client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#x2F;&#x2F; 分析结果</span><br><span class="line">    System.out.println(searchResponse.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这些语法我们在最开始接触elasticsearch的时候都已经了解过了，只不过这里是一个链式的方法调用而已。</p>
<p><strong>Nginx</strong></p>
<p>首先拉取 nginx 的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:1.10</span><br></pre></td></tr></table></figure>

<p>然后随意地启动一个 nginx 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name nginx -d nginx:1.10</span><br></pre></td></tr></table></figure>

<p>启动该 nginx 实例的目的是将 nginx 中的配置文件复制出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container cp nginx:&#x2F;etc&#x2F;nginx .</span><br></pre></td></tr></table></figure>

<p>这样当前目录下就会产生一个nginx文件夹，将其先重命名为conf，然后再创建一个nginx文件夹，并将conf文件夹移动进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv nginx conf</span><br><span class="line">mkdir nginx</span><br><span class="line">mv conf&#x2F; nginx&#x2F;</span><br></pre></td></tr></table></figure>

<p>然后正式启动一个新的 nginx 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">        -v &#x2F;mydata&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">        -v &#x2F;mydata&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \</span><br><span class="line">        -v &#x2F;mydata&#x2F;nginx&#x2F;conf:&#x2F;etc&#x2F;nginx \</span><br><span class="line">                -d nginx:1.10</span><br></pre></td></tr></table></figure>

<p>将刚才准备好的 nginx 文件夹与 nginx 容器内的文件夹作一个一一映射。</p>
<p>索引=数据库   类型=数据表  属性=表字段   文档=一条条的数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/ElasticSearch/" data-id="ckno8ff6a004lswwdf9tsgcx3" data-title="ElasticSearch" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-json" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/json/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T07:29:29.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/json/">json</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson">FastJson</a>: 阿里巴巴开发的 JSON 库，性能十分优秀</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在 Maven 构建的项目中，在 pom.xml 文件中加入以下依赖即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>从 Java 变量到 JSON 格式的编码过程如下：</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">	JSONObject object = <span class="keyword">new</span> JSONObject();    </span><br><span class="line">    <span class="comment">//string    </span></span><br><span class="line">	object.put(<span class="string">&quot;string&quot;</span>,<span class="string">&quot;string&quot;</span>);    </span><br><span class="line">    <span class="comment">//int    </span></span><br><span class="line">	object.put(<span class="string">&quot;int&quot;</span>,<span class="number">2</span>);    </span><br><span class="line">    <span class="comment">//boolean    </span></span><br><span class="line">	object.put(<span class="string">&quot;boolean&quot;</span>,<span class="keyword">true</span>);    </span><br><span class="line">    <span class="comment">//array    </span></span><br><span class="line">	List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);    </span><br><span class="line">	object.put(<span class="string">&quot;list&quot;</span>,integers);    </span><br><span class="line">    <span class="comment">//null    </span></span><br><span class="line">	object.put(<span class="string">&quot;null&quot;</span>,<span class="keyword">null</span>);     </span><br><span class="line">	System.out.println(object); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，首先建立一个 JSON 对象，然后依次添加字符串、整数、布尔值以及数组，最后将其打印为字符串。</p>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;boolean&quot;:true,&quot;string&quot;:&quot;string&quot;,&quot;list&quot;:[1,2,3],&quot;int&quot;:2&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>从 JSON 对象到 Java 变量的解码过程如下：</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    JSONObject object = JSONObject.parseObject(<span class="string">&quot;&#123;\&quot;boolean\&quot;:true,\&quot;string\&quot;:\&quot;string\&quot;,\&quot;list\&quot;:[1,2,3],\&quot;int\&quot;:2&#125;&quot;</span>);  </span><br><span class="line">    <span class="comment">//string  </span></span><br><span class="line">    String s = object.getString(<span class="string">&quot;string&quot;</span>);  System.out.println(s);  </span><br><span class="line">    <span class="comment">//int  </span></span><br><span class="line">    <span class="keyword">int</span> i = object.getIntValue(<span class="string">&quot;int&quot;</span>);  System.out.println(i);  </span><br><span class="line">    <span class="comment">//boolean  </span></span><br><span class="line">    <span class="keyword">boolean</span> b = object.getBooleanValue(<span class="string">&quot;boolean&quot;</span>);  System.out.println(b);  </span><br><span class="line">    <span class="comment">//list  </span></span><br><span class="line">    List&lt;Integer&gt; integers = JSON.parseArray(object.getJSONArray(<span class="string">&quot;list&quot;</span>).toJSONString(),Integer.class);  			              integers.forEach(System.out::println);  </span><br><span class="line">    <span class="comment">//null  </span></span><br><span class="line">    System.out.println(object.getString(<span class="string">&quot;null&quot;</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，首先从 JSON 格式的字符串中构造一个 JSON 对象，之后依次读取字符串、整数、布尔值以及数组，最后分别打印，打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string</span><br><span class="line">2</span><br><span class="line">true</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="JSON-对象与字符串的相互转化"><a href="#JSON-对象与字符串的相互转化" class="headerlink" title="JSON 对象与字符串的相互转化"></a>JSON 对象与字符串的相互转化</h2><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>JSON.parseObject()</code></td>
<td align="left">从字符串解析 JSON 对象</td>
</tr>
<tr>
<td align="left"><code>JSON.parseArray()</code></td>
<td align="left">从字符串解析 JSON 数组</td>
</tr>
<tr>
<td align="left"><code>JSON.toJSONString(obj/array)</code></td>
<td align="left">将 JSON 对象或 JSON 数组转化为字符串</td>
</tr>
</tbody></table>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从字符串解析JSON对象  String转JSONObject</span></span><br><span class="line">JSONObject obj = JSON.parseObject(<span class="string">&quot;&#123;\&quot;runoob\&quot;:\&quot;菜鸟教程\&quot;&#125;&quot;</span>); </span><br><span class="line">JSONObject jSONObject = JSONObject.parseObject(<span class="string">&quot;&#123;\&quot;runoob\&quot;:\&quot;菜鸟教程\&quot;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串解析JSON数组  String转JSONArray</span></span><br><span class="line">JSONArray arr = JSON.parseArray(<span class="string">&quot;[\&quot;菜鸟教程\&quot;,\&quot;RUNOOB\&quot;]\n&quot;</span>); </span><br><span class="line">JSONArray jsonArray= JSONArray.parseArray(<span class="string">&quot;[\&quot;菜鸟教程\&quot;,\&quot;RUNOOB\&quot;]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSONObject中的数组提取为JSONArray</span></span><br><span class="line">JSONArray jsonArray= jsonObject.getJSONArray(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSONArray提取为JSONObject</span></span><br><span class="line">JSONObject jsonObject = jsonArray.getJSONObject(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将JSON对象转化为字符串 </span></span><br><span class="line">String objStr = JSON.toJSONString(obj); </span><br><span class="line"><span class="comment">//将JSON数组转化为字符串 </span></span><br><span class="line">String arrStr = JSON.toJSONString(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map转为JSON格式的字符串</span></span><br><span class="line">Map&lt;String, Object&gt; paraMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">JSONObject.toJSONString(paraMap)</span><br><span class="line">自动过滤参数为<span class="keyword">null</span>的数值</span><br><span class="line">    </span><br><span class="line"><span class="comment">//javaBean转为JSONObject</span></span><br><span class="line">JSONObject.parseObject(JSONObject.toJSON(javaBean对象).toString())；</span><br><span class="line">    </span><br><span class="line"><span class="comment">//List&lt;实体类&gt;转String</span></span><br><span class="line">    List&lt;实体类&gt; value1 = 。。。。。。</span><br><span class="line">JSONObject.toJSONString(value1 )</span><br><span class="line">    </span><br><span class="line"><span class="comment">//JSONArray转List&lt;实体类&gt;</span></span><br><span class="line">JSONArray objects = JSONArray.parseArray(categoryConstantInfoFromRedis);</span><br><span class="line">List&lt;实体类&gt; categoryConstantInfos = objects.toJavaList(实体类名.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>找不到方法的时候，去看看JSONArray，JSONObject的源码，很多都有封装好的，你不会失望的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/16/json/" data-id="ckno8ff5w003oswwd94d50pum" data-title="json" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/json/" rel="tag">json</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.11.java类型转换" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/4.11.java%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T07:17:42.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/4.11.java%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">java类型转换</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>类型列举</p>
<table>
<thead>
<tr>
<th>类型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>object</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>short</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>string</td>
<td></td>
</tr>
<tr>
<td>xml</td>
<td></td>
</tr>
<tr>
<td>json</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>bigDecimal</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/16/4.11.java%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" data-id="ckno8ff57001kswwd3t65h7ba" data-title="java类型转换" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.10.java扩展类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/4.10.java%E6%89%A9%E5%B1%95%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T07:17:29.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/4.10.java%E6%89%A9%E5%B1%95%E7%B1%BB/">java扩展类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/16/4.10.java%E6%89%A9%E5%B1%95%E7%B1%BB/" data-id="ckno8ff56001hswwd6atie4la" data-title="java扩展类" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-19.1.git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/19.1.git/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T04:46:21.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/19.1.git/">git</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git是目前世界上最先进的分布式版本控制系统。<br>Linus在1991年创建了开源的Linux,从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux,但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，<strong>在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus,然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN,这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper,BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</strong>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个）,被BitMover公司发现了（监控工作做得不错！),于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后会严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：<br>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git!一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub,包括jQuery,PHP,Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>版本控制：可以解决多人同时开发的代码问题，也可以解决找回历史代码的问题。</p>
<p>分布式：Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。首先找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器“仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。可以自已搭建这台服务器，也可以使用GitHub网站。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>傻瓜式安装</p>
<h1 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h1><h2 id="在Windows的cmd-中使用linux的命令"><a href="#在Windows的cmd-中使用linux的命令" class="headerlink" title="在Windows的cmd 中使用linux的命令"></a>在Windows的cmd 中使用linux的命令</h2><p>cmd的命令功能肯定没有linux的命令功能好用，这点毋庸置疑。现在装好了Git，就可以在Windows的cmd中使用linux命令了。<br>关键词：环境变量 Git命令<br>怎么玩？如下2步操作：<br>假如你按照上述步骤将Git装在C盘，那么做如下操作：<br>操作1：找Git命令的【.exe文件】。</p>
<p>操作2：添加到环境变量，就可以在cmd里使用linux命令了。</p>
<p>最终效果：</p>
<p>PyCharm也可以使用linux命令。【环境变量–全局—使用】</p>
<p>备注：你可能需要关闭之前打开的cmd窗口/PyCharm窗口，重新打开新的cmd窗口//PyCharm窗口，使用命令才可能生效。<br>【效率会提高一点点】</p>
<h2 id="创建一个版本库"><a href="#创建一个版本库" class="headerlink" title="创建一个版本库"></a>创建一个版本库</h2><p>(1)新建一个目录git_test,在git_test目录下创建一个版本库，命令如下：</p>
<p>接着初始化仓库</p>
<p>说明：可以看到在git_test目录下创建了一个.git隐藏目录，这就是版本库目录。</p>
<p>4.版本的创建与回退<br>4.1 使用<br>(1)在git_test目录下创建一个文件code.txt,编辑内容如下：</p>
<p>(2)使用如下两条命令可以创建一个版本：<br>git add code.txt<br>git commit -m “版本1”</p>
<p>(3)使用如下命令可以查看版本记录：<br>git log</p>
<p>(4)继续编辑code.txt,在里面增加一行。</p>
<p>(5)使用如下命令再创建一个版本并查看版本记录：</p>
<p>(6)现在若想回到某一个版本，可以使用如下命令：</p>
<p>其中HEAD表示当前最新版本【请记死】，HEAD^表示当前版本的前一个版本，HEAD^^表示当前版本的前前个版本，也可以使用HEAD<del>1表示当前版本的前一个版本，HEAD</del>100表示当前版本的前100版本。</p>
<p>因为版本1的内容是1行：<br>this is the first line</p>
<p>因为版本2的内容是2行：<br>this is the first line<br>this is the second line</p>
<p>因为<br>$ git reset –hard HEAD^ HEAD is now at 51d36c7 版本1<br>使指针HEAD指向（倒退）到版本1，<br>因此打印的内容就是版本1的内容，即this is the first line</p>
<p>(7)假如我们现在又想回到版本2,这个时候怎么办？可以使用如下命令：<br>git reset –hard 版本号</p>
<p>（8）在终端执行如下命令：</p>
<p>版本2又回来了，内容也是原来的内容。</p>
<p>接着玩</p>
<p>退出终端，再重进：</p>
<p>这个重进终端的操作让我们看不到版本2的版本号，要回到版本2怎么办？<br>命令：git reflog来查看操作记录。</p>
<p>错误示例：<br>原因是按照当前版本1倒退的话，怎么也不会前进到版本2吧？逻辑错误。</p>
<p>正确实例：<br>要用到版本号。</p>
<p>查看版本2的内容：</p>
<p>不理解版本1，版本2有啥区别？<br>这个东西像游戏更新一样，版本2是在版本1的基础上添加新功能的，版本1内容不发生改变。例如王者荣耀版本更新，界面总会变化，但是英雄的属性（技能，名字）一般不会改变。</p>
<p>4.2 工作区和缓存区<br>4.2.1 工作区（WorkingDirectory)<br>工作区（WorkingDirectory) 电脑中的目录，比如我们的git_test,就是一个工作区。</p>
<p>4.2.2 版本库（Repository)<br>工作区有一个隐藏目录.git,这个不是工作区，而是git的版本库。git的版本库里存了很多东西，其中最重要的就是称为stage(或者叫index)的<br>暂存区，<br>还有git为我们自动创建的第一个分支master,以及指向master的一个指针叫HEAD。</p>
<p>因为我们创建git版本库时，git自动为我们创建了唯一一个master分 支，所以，现在，git commit就是往master分支上提交更改。<br>你可以简单理解为，需要提交的文件修改通通放到暂存区【计算机的缓存区】，然后，一次性提交暂存区的所有修改。</p>
<p>前面讲了我们把文件往版本库里添加的时候，是分两步执行的：<br>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区<br>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>(1)下面在git test目录下再创建一个文件code2.txt,然后编辑内容如下：</p>
<p>(2)然后编辑code.txt,操作如下：</p>
<p>注意的是创建文件和编辑文件都是在工作区里完成。<br>（3）使用如下命令查看当前工作树的状态：<br>git status</p>
<p>翻译一下：</p>
<p>上面提示我们code.txt被修改，而code2.txt没有被跟踪。</p>
<p>(4)我们使用如下命令把code.txt和code2.txt加入到暂存区，然后再执行git status命令，结果如下：</p>
<p>注意：所有的 git add 命令是把所有提交的修改存放到暂存区。</p>
<p>(5)然后，执行git commit就可以一次性把暂存区的所有修改提交到分支并创建一个版本。</p>
<p>注意：指针HEAD永远指向当前版本。此时当前版本是版本3。</p>
<p>(6)一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。执行如下命令可以发现：</p>
<p>现在我们的版本库变成了酱紫：</p>
<p>4.3 管理修改<br>git管理的文件的修改，它只会提交暂存区的修改来创建版本。<br>(1)编辑code.txt,并使用git add命令将其添加到暂存区中。</p>
<p>(2)继续编辑code.txt,并在其中添加一行。</p>
<p>(3)git commit创建一个版本，并使用git status查看，发现第二次修改code.txt内容之后，并没有将其添加的工作区，所以创建版本的时候并没有被提交。</p>
<p>注意：对于code.txt里的四行内容，每一个版本对应一行，例如版本1对应first line，以此类推。</p>
<p>4.4 撤销修改<br>(1)继续上面的操作，提示我们可使用git checkout – &lt;文件&gt;来丢弃工作区的改动。执行如下命令，发现工作区干净了，第二次的改动内容也没了。</p>
<p>(2)我们继续编辑code.txt,并在其中添加如下内容，并将其添加的暂存区。</p>
<p>(3)git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉，重新放回工作区。</p>
<p>(4)现在若想丢弃code.txt的修改，执行如下命令即可。</p>
<p>现在，如果你不但改错了东西，还从暂存区提交到了版本库，则需要进行版本回退。</p>
<p>小结：<br>场景1:当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用 命令git checkout – file<br>场景2:当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步：<br>第一步用命令git reset HEAD – file,就回到了场景1,<br>第二步按场景1操作。<br>场景3:已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节。</p>
<p>4.5 对比文件的不同<br>对比工作区和某个版本中文件的不同：</p>
<p>(1)继续编辑文件code.txt,在其中添加一行内容。</p>
<p>(2)现在要对比工作区中code.txt和HEAD版本中code.txt的不同。使用如下命令：</p>
<p>(3)使用如下命令丢弃工作区的改动。</p>
<p>对比两个版本间文件的不同：<br>(1)现在要对比HEAD和HEAD ^版本中code.txt的不同，使用如下命令：</p>
<p>反过来</p>
<p>4.6 删除文件<br>(1)我们把目录中的code2.txt删除。</p>
<p>这个时候，git知道删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻提示哪些文件被删除了。</p>
<p>(2)现在你有两个选择，一种情况是确实要从版本库中删除该文件，那就用命令 gitrm删掉【永久删除，无法撤消】，并且 git commit:</p>
<p>另一种情况是删错了，可以直接使用git checkout – code2.txt,这样文件code2.txt又回来了。<br>注意：两种情况有区别：<br>当执行第一种情况时【永久删除，无法撤消】，再执行第二种情况，会报错：</p>
<p>加长版：</p>
<p>简短版：</p>
<p>小结：<br>命令rm 删除是永久删除，要恢复数据的话可以恢复/扫描硬盘；<br>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<ol start="5">
<li>分支管理</li>
<li>1概念<br>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。<br>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了git又学会了SVN!</li>
</ol>
<p>分支在实际中有什么用呢？<br>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>5.2 创建与合并分支<br>git把我们之前每次提交的版本串成一条时间线，这条时间线就是一个分支。截止到目前只有一条时间线，在git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master,master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>(1)一开始的时候，master分支是一条线，git用master指向最新的提交，再用HEAD指向master,就能确定当前分支，以及当前分支的提交点：</p>
<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。<br>(2)当我们创建新的分支，例如dev时，git新建了一个指针叫dev,指向master相同的提交，再把HEAD指向dev,就表示当前分支在dev上：</p>
<p>git创建一个分支很快，因为除了增加一个dev指针，改变HEAD的指向，工作区的文件都没有任何变化。</p>
<p>(3)不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p>
<p>(4)假如我们在dev上的工作完成了，就可以把dev合并到master上。git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<p>git合并分支也很快，就改改指针，工作区内容也不变。<br>（5）合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<p>(1)执行如下命令可以查看当前有几个分支并且看到在哪个分支下工作。</p>
<p>(2)下面创建一个分支dev并切换到其上进行工作。</p>
<p>(3)下面我们修改code.txt内容，在里面添加一行，并进行提交。</p>
<p>(4)dev分支的工作完成，我们就可以切换回master分支：</p>
<p>查看code.txt,发现添加的内容没有了。因为那个提交是在dev分支上，而master分支此刻的提交点并没有变。【这里需要细细品味一下】</p>
<p>(5)现在，我们把dev分支的工作成果合并到master分支上：<br>git merge命令用于合并指定分支到当前分支。合并后，再查看code.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的rast-forward信息，Git告诉我们，这次合并是“快进模式“，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>(6)合并完成后，就可以放心地删除dev分支了，删除后，查看branch,就只剩下master分支了。</p>
<p>小结：<br>查看分支：git branch<br>创建分支：git branch <name><br>切换分支：git checkout <name><br>创建+切换分支：git checkout -b <name><br>合并某分支到当前分支：git merge <name><br>删除分支：git branch -d <name></p>
<p>5.3 解决冲突<br>合并分支往往也不是一帆风顺的。<br>(1)再创建一个新分支dev。</p>
<p>(2)修改code.txt内容，并进行提交。</p>
<p>(3)切换回master分支。</p>
<p>(4)在master的code.txt添加一行内容并进行提交。</p>
<p>这种情况下，git无法执行”快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。</p>
<p>(5)执行如下命令尝试将dev分支合并到master分支上来。</p>
<p>冲突原因：<br>现在，master分支和dev分支各自都分别有新的提交，并且编辑了同一个文件，变成了这样：</p>
<p>git告诉我们，code.txt文件存在冲突，必须手动解决冲突后再提交。</p>
<p>最重要的一步：</p>
<p>(6)git status也可以告诉我们冲突的文件：</p>
<p>(7)查看code.txt的内容。</p>
<p>(8)git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,========,&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记不同分支的内容，我们修改如下后保存：</p>
<p>(9)再提交。</p>
<p>(10)现在，master分支和dev分支变成了下图所示：</p>
<p>(11)用带参数的git log也可以看到分支的合并情况：</p>
<p>(12)最后工作完成，可以删除dev分支：</p>
<p>5.4 分支管理策略<br>通常，合并分支时，如果可能，git会用fast forward模式，但是有些快速合并不能成功而且合并时没有冲突，这个时候git会帮我们在合并之后做一次新的提交，但这种模式下，删除分支后，会丢掉分支信息。【弹窗说明信息】</p>
<p>(1)创建切换到dev分支下。</p>
<p>(2)新建一个文件code3.txt,编辑内容如下，并提交一个commit。</p>
<p>(3)切换回master分支，编辑code.txt并进行一个提交。</p>
<p>(4)合并dev分支的内容到master分支。</p>
<p>(5)出现如下提示时，这是因为这次不能进行快速合并，所以git提示输入合并说明信息，输入之后合并内容之后git会自动创建一次新的提交。</p>
<p>按 :x保存并退出。</p>
<p>(6)使用分支命令查看分支信息。</p>
<p>(7)删除dev分支。</p>
<p>如果要强制禁用fast forward模式，git就会在merge时生成一个新的commit,这样，从分支历史上就可以看出分支信息。<br>(1)创建并切换到dev分支。</p>
<p>(2)修改code.txt内容，并提交一个commit。</p>
<p>(3)切换回master分支。</p>
<p>（4）准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward:</p>
<p>因为本次合并要创建一个新的commit,所以加上-m参数，把commit描述写进去。</p>
<p>5.5 Bug分支<br>软件开发中，bug就像家常便饭一样，有了bug就需要修复，在git中，由于分支是如此的强大，所以，<br>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>(1)当你接到一个修复一个代号001的bug的任务时，很自然地，你想创建一个分支bug-001来修复它，但是，等等，当前正在dev上进行的工作还没有提交：<br>建议先敲clear清屏。</p>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug,怎么办？</p>
<p>(2)git还提供了一个stash功能，可以把当前工作现场“储藏“起来，等以后恢复现场后继续工作：【工作中可能会用到，在git pull之前先用这条命令。放入缓存是git stash，相对应的git stash pop从缓存中释放出来】</p>
<p>更多请参考：传送门<br>(3)首先确定要在哪个分支上修复bug,假定需要在master分支上修复，就从master创建临时分支：</p>
<p>(4)现在修复bug,这里假设把code.txt里的第9行删掉，然后提交。</p>
<p>(5)修复完成后，切换到master分支，并完成合并，最后删除bug-001分支。</p>
<p>(6)现在bug-001修复完成，是时候接着回到dev分支干活了！</p>
<p>(7)工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：【帮助我们列出保存的工作现场】</p>
<p>工作现场还在，git把stash内容存在某个地方了，需要恢复一下：</p>
<p>小结：<br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug,修复后，再git stash pop,恢复工作现场。</p>
<p>6.使用github<br>6.1 创建仓库<br>(1)注册github账户</p>
<p>登录后，点击”New respository”</p>
<p>(2)在新页面中，输入项目的名称【如2020】，勾选’readme.md’,点击’Create repository’</p>
<p>这里完成。</p>
<p>6.2 添加ssh账户<br>(1)点击账户头像后的下拉三角，选择’settings’如果某台机器需要与github上的仓库交互，那么就要把这台机器的ssh公钥添加到这个github账户上。</p>
<p>(2)在git的命令行中，回到用户的主目录下，编辑文件.gitconfig,修改某台机器的git配置。<br>修改为注册github时的邮箱，填写用户名。</p>
<p>完美：</p>
<p>6.3 克隆项目</p>
<p>接着：</p>
<p>6.4 上传分支/推送代码<br>(1)项目克隆到本地之后，执行如下命令创建分支：</p>
<p>(2)创建一个views.py并提交一个版本：</p>
<p>(3)推送前github上文件列表如下图:</p>
<p>(4)推送前github上分支列表如下图:</p>
<p>(5)推送分支，就是把该分支上的所有本地提交推送到远程库，推送时要指定本地分支，这样，git就会把该分支推送到远程库对应的远程分支上：<br>git push origin 分支名称<br>例：<br>git push origin smart</p>
<p>（6）再次查看github分支：<br>接下来操作重新加载页面：</p>
<p>点击smart,再点击views.py,如图所示：</p>
<p>6.5 将本地分支跟踪服务器分支<br> git branch –set-upstream-to=origin/远程分支名称 本地分支名称<br>1<br>例：</p>
<p>  git branch –set-upstream-to=origin/smart smart<br>1</p>
<p>我的社交网址：<a target="_blank" rel="noopener" href="https://github.com/Keegan-y">https://github.com/Keegan-y</a></p>
<p>6.6 从远程分支上拉取代码<br>git pull orgin 分支名称<br>例：<br>git pull orgin smart<br>使用上述命令会把远程分支smart上的代码下载并合并到本地所在分支。</p>
<p>7.工作使用git<br>不墨迹直接上代码：<br>loading…<br>项目经理：<br>(1)项目经理搭建项目的框架。<br>(2)搭建完项目框架之后，项目经理把项目框架代码放到服务器。</p>
<p>普通员工：<br>(1)在自己的电脑上，生成ssh公钥，然后把公钥给项目经理，项目经理把它添加的服务器上面。<br>(2)项目经理会给每个组员的项目代码的地址，组员把代码下载到自己的电脑上。<br>(3)创建本地的分支dev,在dev分支中进行每天的开发。<br>(4)每一个员工开发完自己的代码之后，都需要将代码发布远程的dev分支上。</p>
<p>项目里一般会有两个分支，如：<br>Master:用于保存发布的项目代码。<br>Dev:用于保存开发过程中的代码。所有的组员开发完自己的代码提交到该分支上。<br>补充小技巧：<br>首先，整体认知一下工作中git常用的就这么几个命令：<br>步骤1.创建项目目录，如git_test【强烈建议返回到2.安装配置一节，学一学在windows中用mkdir git_test。工作中点来点去，文件夹一多就不爽了，学会在windows上用linux命令，工作效率谁用谁知道<del>】<br>步骤2.git init【如果你考皮github上别人的代码，必须将别人的.git文件删掉。步骤：进入项目目录，如git_test，cd git_test，ls -al，rm -rf .git】【工作中linux必会的，赶快回到2.安装配置一节，学一学在windows使用linux命令，这样就不用装linux环境了，简单胜于复杂</del>】<br>步骤3.git add .<br>步骤4.git commit -m “整体提交”<br>步骤5.git remote add origin 【你的github/gitlab仓库地址】<br>步骤6.git checkout -b dev<br>步骤7.git push origin dev<br>当然不止于这7步，这些步骤会在你的实践中不断升华，壮大<del>。<br>先把git玩起来再说，否则很容易从入门到放弃。先玩起来</del><br>步骤操作如图所示：</p>
<p>可以看到，代码推到仓库了。<br>掌握了上面基本命令，记住使用步骤，强烈建议建议建议你在PyCharm/Goland上操作git，能可视化+带提示帮你提交代码，解决冲突【你在git bash里搞不定冲突，在PyCharm/Goland上操作一看就知道怎么做了，人家可视化+提示，你只需要手指点一点即可，很简单，节约你的时间】，工具是个好东西，前面的步骤都是为了这样一句话铺垫：【PyCharm/Goland上玩git】<br>【不会的可以在评论区留言，我看到后会继续在后文补充。既然是git使用教程，那就是成体系的，知识技能是结构化安放的，方便查，方便增，是不？】</p>
<p>到此，git使用教程就写完了，既是自己的实践记录【记不住哈哈】，也能帮助更多的道友管理控制代码，如果内容对读者有用，请关注我，为思考点赞！</p>
<p>最后奉上导图笔记：</p>
<p>8.思维导图笔记</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/16/19.1.git/" data-id="ckno8ff60003xswwd4eq5f5bk" data-title="git" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-5.4.MySQL工具之Navicat" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/5.4.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:39:28.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/5.4.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/">MySQL工具之Navicat</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>安装Navicat</strong></p>
<p>因为工作原因，需要经常连接不同的数据库，这里我安装的是Navicat Premium版本，在公众号后台回复 <strong>Navicat</strong> 即可获取。</p>
<p>安装过程很简单，只要你能看懂中文，不停的下一步，等待安装完成即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2xKluMyr9zsylJ1bbEy5kAicNwLkqjO2V3j6G3XFBLhiaozUuKYzLCVkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>连接不同数据库</strong></p>
<p>这里分别介绍Oracle，MySQL，SQL Server这三种数据库的连接方法</p>
<p><strong>连接Oracle</strong></p>
<p>在连接Oracle之前我们需要先配置一下OCI文件，具体如下：</p>
<p>点开主菜单里的【工具】——【选项…】,在弹出的对话框中找的OCI选项</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ayiavVhGWNUtCxzSv7nRAL32mTpAlsHmG6XrhvA5NfV7JIUia6FnBDWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里就要把你安装的oracle的安装目录下的bin文件夹里面的oci.dll文件导入</p>
<p>E:\software\oracle\Oracle_win64\product\11.2.0\dbhome_1\BIN\oci.dll</p>
<p>以上是我的安装目录下的文件，大家根据自己的安装目录不同来导进来</p>
<p>导进来之后就重启Navicat，重启后会自动生效。</p>
<p>重启Navicat后，点击菜单栏的连接，选择Oracle，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2v4ibO1bTE1sICWwbjoGlYjlPrbKGNmCazdqNG3U4SJDY4lNvydb8vGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中做如下配置，其中连接名可以随意起，然后输入你要连接的主机名或IP地址，最后输入账号密码。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO26DXvmnuAFhema70Vibkj2nhLc13TEpb2SwxMibrVuY9ECoP4BudbRf0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你是使用DBA角色登录的，还需要点开高级选项卡，将角色选为DBA</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO225C85ic0Bd8oYibzpBoHLKtmog0ZBdlib7Pd8grxHDIia7aNwEVdfw46uA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置完了以后，我们可以点击连接测试</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2pBzAsdJSbnWUI9La2k8icmAKIbnMWpOMicy9FsgFO1CdKCiaC2p3OqUOA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">这样Oracle的连接就配置好了。</p>
<p><strong>连接MySQL和SQL Server</strong></p>
<p>MySQL和SQL Server的连接相对比较简单，只需要输入主机名或IP地址，账号密码即可，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2HxIZHHUhGKML0TC1mgA7djpa5KZ2cqyJyrW5HUAtr9xIwxAJBWxobg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2UzsMibLp6NUbiaAE5dNa09XeOjh61qyCmUib1uRzpy8p1PnwZd3FMuUxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置好后，点击连接测试，在弹出连接成功窗口就表示我们配置好了。</p>
<p>数据库连接成功后，下面是各个功能的介绍，我们以SQL Server数据库作为案例来介绍各个功能的使用。</p>
<p><strong>创建数据库</strong></p>
<p>右键我们刚新建的数据库连接——选择【新建数据库…】即可开始创建数据库了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO25lWoNb7icSiaocd6c07JMQRVdvqrXHpnPpmOWMkEXk5lSUPhTxCvE3Fg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以根据你的要求来进行配置，配置完以后，还可以在【SQL预览】看到完整的SQL代码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2f6LfOqSt2tKhHUhxV089tAicnqGw6gQr1ic6JpNzic21UDxVbicm2pul5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>数据传输</strong></p>
<p>数据传输，顾名思义就是将数据从其他地方传输到当前数据库，例如我们将SQL_Road数据库中的数据传输到刚才新建的Test数据库中。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO29JIouv6OTsvv1tVHEARMD95v6JjKVnvJ2Cw07xzqUAOPp9ktxpNueQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>右键刚才创建好的Test数据库，在弹出的选项中选择【数据传输…】，在弹出的窗口中我们配置源数据库为【SQL_Road】,目标数据库配置为【Test】，这样就可以将SQL_Road中的对象传输到Test了，支持传输的对象包括：表，视图，函数和存储过程，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2a5ovyOCg7icHWslZj0ZH0icOZG0GG2zF5McQWlWxXhb0h7IH8ScszhyQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始即可开始进行数据传输，传输效率还是很快的，即使你的数据量很大，也可以使用该方法进行数据传输，这里使用了不到2秒钟就将整个数据库对象迁移到新的数据库中了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2gYlkicBOLCHXSicuics171YBiaBM06vu5TsoxFD1v8tMiatk27AFnl8icDBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>此外如果你想导出整个数据库中的对象到文件，也可以使用该方法，只需要将方式改为文件即可，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2dKibsOAkMktKzv4RcEnGCzF21WvhA8u23aO8mxQoXNGpbLRXkjrrasw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你想自定义导出的内容，可以点击该窗口的【高级】选项进行自定义配置，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ibkdpgmia7AP9ciadmUt0kIpKZHJWBicQibibicdibEtaZFkHcicEGtjG1OSUCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置完成后，点击开始，就会将你选择的数据库对象以脚本的形式导出到文件中。</p>
<p>但是数据传输到文件有个不足的地方，就是会将数据记录也会一并导出，而很多时候，我们其实只需要表结构，那么我们可以使用下面的这个功能。</p>
<p><strong>转储SQL文件</strong></p>
<p>双击打开数据库后，我们右键架构名dbo，在弹出的选项中选择【转储SQL文件…】，这里还有两个子选项：【结构和数据…】和【仅结构…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2klrr7KbWlHjd8oVYVaFhibky2ywFHxDfGbU0SNr80OElzF5bTVOor1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>他们的区别就是一个有数据记录，一个没有数据记录，如果你只要数据结构可以只选择【仅结构…】，这样就可以大大节省导出时间了。</p>
<p><strong>打印模式/数据字典*<em>生成*</em></strong></p>
<p>做数据库仓库往往面对的不是几张表，往往是成百上千张数据表，该怎么维护对DBA是个非常头疼的事，如果有个数据表结构或数据字典之类的就非常完美了。</p>
<p>打印模式可以<strong>完美的生成所有表的数据表结构</strong>的。这里我们选择表数量较多的数据库ReportServer。右键dbo后，选择【打印模式…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2NIZlTicjuVONVpYrhO0W1IqAeicswxic28stRoicXeJokqNTBNSQ3L0zWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以看到右侧窗口里面出现了所有数据表的表结构，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2TvxbdBAlYHmoILKSDia33M0MIm0IAghtK3LXibzq5icU19hqlFYkESx0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>足足有10页之多，我们点击左上方的【打印】，将表结构打印成PDF文件，就可以得到一份非常完成的数据字典了，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2aud0pqYSgMzwR3nXRMTNGibYQP3zXkCDrbTEU8UhTKDUhwZ2UDZxrSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>内容中主键和索引也有仔细的标注出来，其中<strong>P代表主键</strong>，下面的<strong>index表示索引</strong>。</p>
<p>这个功能绝对是一个神器！</p>
<p><strong>在模式中查找</strong></p>
<p>这个功能主要用来查找数据或结果，当你需要从当前数据库中查找数据记录或对象中包含某些字符时，可以使用该功能，具体如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO26F4rBdtKPq3pM6kk4v0iboN54ExFSJ6P0A8JrFI9x7Aj1zEICJeYw3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中，我们查找pre的结构，就可以将当前数据库符合要求的的所有对象都查找出来，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2zfWey0meibpxuwyU8ljtT6r0JIvHybx1e5rCDeAHwty4T2PIEKdQ1uw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>逆向模式到模型</strong></p>
<p>这又是一个神仙技能，谁用谁知道，右键dbo在弹出的选项中选择【逆向模式到模型..】,如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2gqmyJ95SwfRD1sZgybhd30aOiaV4LFDDSSKG7icQyHRGbTicMvBSqYjMQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>它可以<strong>将当前数据库中创建的所有表，以E-R图的模型清楚的告诉你每个表之间的关联关系</strong>，包括主外键，表结构，关联关系等，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2uQjNXTMRT6dVMkyT4tsO8Bb1CnibJgJfWDEePaGpVe8sicmkHdib245iaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>你以为就这？</p>
<p>还支持<strong>模型转换，模型导出</strong>，说白了就是你可以<strong>将该模型转换成其他数据库的模型</strong>，从SQL Server转换成MySQL，Oracle，Postgresql都可以。点击左上角的三短横，选择【文件】——【模型转换】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2cyYKRyxc5KAibxWfnU2zWdvUn7wAicn2lxZCBSP8mibaOaiaUbW9TzWn9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中选择你要转换的类型，比如我们想转换成MySQL 5.6的，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2x6TSHrBrmkymXceib25CkBfqVibGJlYibS0PL6VpSrOBPiacP71D1iciaBHw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击确定后，即可将当前的SQL Server模型立马转换成MySQL 5.6。给大家看下对比效果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2BUAibtGeIM6N5WXroknLPhTjT4k0r9EaZA8QRgCKzsnnUHsfqict08Tw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>SQL Server模型</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ImacDMUrYmibib6ZwhWa5hSwhtVXIhEUia6z4XxSz6chIVaeTzxmQcicuw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>MySQL模型</p>
<p>转换成功后可以直接将转换后的模型导出成对应的SQL。</p>
<p>点击【工具】——【导出SQL…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2SmPTTmH3LNPNNlmst71wAL7cpjlJuicBexVXBLh230wCzz2j3PGfvBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择导出位置，点确定即可，导出的SQL文件里面就是MySQL的建库代码了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2pvSqyJrD6aqeYmPh2lrIt56UXRL4RKyxzukKiaJ8GvaE2JGyjrKZx6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>能导出肯定就可以打印，同样如果需要将模型文件保存，也可以导出为PDF，PNG，SVG等格式，但是建议打印成PNG图片格式，因为PDF会分页，导致模型不完整。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2v0WVtdIJS4Qnj98H6rZwSic0mpKNvY4ML8OQEb4S5Y1cFk7icCmctdnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>打印出来的图片如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2VXiacibexrSpbeY1Y7kANuyIKGGobrsFNTiaolsaEMXRaDt8kXdeoibNLA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>新建表</strong></p>
<p>这个是比较常见的功能，相比其他管理工具，Navicat将建表过程中所涉及的各种常用功能都包含进去了，包含新字段，索引，主键，外键，唯一键等等与表有关的内容，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgQEuibfiaJMxTYlVaxYzphdW6VfpKYm6uLw3X8dyOIWryib4Aw8OYCicCbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>针对表的几个常用功能，我们再详细给大家介绍一下</p>
<p><strong>字段</strong></p>
<p>字段的功能很多，也是其他功能的前提，意思是你必须先创建了字段才能使用后面的一些功能。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgNIZBSp4nV53ZvBRxLqcpa9YunxHyn1qtDLf9lmialP9BQsZN1zELt6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其中第一排的添加字段，插入字段，删除字段，可以通过字面意思来理解。</p>
<p>主键：选中某个字段，点击主键即可设置为主键</p>
<p>标识：勾选后一般用作自增长列来使用</p>
<p>注释：对字段的备注，通常为中文</p>
<p>名：字段存在表里的字段名</p>
<p>类型：字段数据类型</p>
<p>长度：字段的长度，通常int和datetime可以不设置长度。</p>
<p>比例：小数位数</p>
<p>不是Null：该字段是否为空，勾选不为空，不勾选为空。</p>
<p><strong>索引</strong></p>
<p>用来创建索引，只需要选定指定的列，就可以在对应的列上创建索引了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgZQSnF3fd6xNaee5ibV4VXEQ1u7cibJfo2D0NvfGbcic9C1l056rOP9fcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>名：索引的名称，通常按命名规范以index或idx开头，当然你也可以自定义。</p>
<p>字段：选择在哪个字段上创建索引。还可以选择排序规则，默认是升序ASC。</p>
<p>索引类型：不同的数据库索引类型不同，SQL Server类型一般为聚集索引（Clustered）和非聚集索引（Non-Clustered）</p>
<p>唯一键：用来限制字段的记录是否可以重复，勾选就是不可重复。</p>
<p><strong>外键</strong></p>
<p>用来创建外键约束的功能，目前的数据库设计中，通常不设置外键约束了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgYfEockSvWia9MOegfNXLnFeSzJLnO0GgDqBTouNbAAnx2xP7SFVKU9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>名：外键名称，通常以fk开头</p>
<p>字段：用来设置外键的字段</p>
<p>参考表：与之相关联的表</p>
<p>参考字段：与之相关联表中的字段</p>
<p>删除时：是否级联删除</p>
<p>更新时：是否级联更新</p>
<p><strong>唯一键</strong></p>
<p>区别于主键，唯一键具有唯一性</p>
<p>与主键的区别有：</p>
<p>1.主键不允许空值，唯一索引允许空值</p>
<p>2.主键只允许一个，唯一索引允许多个</p>
<p>3.主键产生唯一的聚集索引，唯一索引产生唯一的非聚集索引</p>
<p><strong>检查</strong></p>
<p>用来约束数据插入的合法性，对应SQL中的CHECK或DEFAULT</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgxCROXWLcic26pQfMYHDX8K5Let2XYlibrAYzYtiaMwElzkX17mt1mFrvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>触发器</strong></p>
<p>用来创建与表相关的触发器，其中触发器的使用可以查看历史文章：</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA3MTg4NjY4Mw==&mid=2457301529&idx=2&sn=b3881753e41e401ac374057bce52e768&chksm=88a5602dbfd2e93bcae925b00130230e7e8f1b957f29ce2f3e7471c4076ebba3bf36ad2b4ab1&scene=21#wechat_redirect">SQL高级知识V2——触发器</a></p>
<p><strong>选项</strong></p>
<p>这里主要用来设置自增长的种子值（起始值）和增量</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgTr5rCyPoOtCZKcLA7ibtWLy8M1o4opjVATrsNBelsORc2SoBQ3elGjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>SQL预览</strong></p>
<p>这里可以看到我们刚才对表做的配置所对应的SQL语句</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgVe1icibSk4HTrcOZKR3hnXwUqL22Ofo1XfLtpfbibYTI0jMdBhUcn5kQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>查看对象模式</strong></p>
<p>创建好的表有三种查看方式：列表，详细信息和ER图，如下图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIovQPPbZyXibIAxiaY94ey9NUBALdy7jiaghl9WczAyTSFrLYB8dbNpJzibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>列表模式</strong></p>
<p>只显示表名，是表的默认显示方式</p>
<p><strong>详细信息模式</strong></p>
<p>会显示除了表名以为的其他信息，记录数，修改日期和表的注释等</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2vc7yZjic33zyty6PylhMMA9icpMGjtGb8croq8uo47TuF9RjtSyd3zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>ER图模式</strong></p>
<p>会以ER图的形式显示每个表之间的关联关系，如下图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoApicGEtFC7zxyYETTOrtKYs06TTTic2SNpsnEAKp99kTS3UvXYzXqFzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>导入向导</strong></p>
<p>用来引导用户导入数据到数据库对应的表</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgZSuMc6TCjM8JAytt1BYL0RvBNn7k1Lxafshibm5libYAUCzycBfmMc6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们打算将Customers.xlsx里的数据导入到表Customers中，具体操作如下：</p>
<p>在导入向导中选择要导入的文件类型，Navicat支持多种导入类型，这里我们选择导入Excel文档，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo4kDbmWv2gicpicrUlQtmq33Zua6RkT4sZQXhXr9ibCkPnp6lw50Y29a4g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>找的需要导入的文件，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo1oic8nEeeSjQic5fIqLcGETvcWeJAra33SRQ2dNJouJ9ePIpNZJyIVdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置字段名等内容，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIofmn6WiaXl270ic5y07kUErIXsYd4jy7a7YmbxyxfxguW716fRKJcnoDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择要导入的目标表，你也可以直接新建一张表，这里我们导入到目标表Orders，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoTQ7UYQWjlr4dC3iaqrVkqWKVPNmptZrjAU6u9ZlrnP1vPLqLUVuJckA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置源表和目标表之间的字段对应关系，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoAo5sT3zWIOWYGCVKeC2DSPW0E0tM6z7GBM2XHwbTjo7HibAgXtzPYsw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择一个导入模式，如果是直接添加，可以选择添加模式，如果是要先清空目标表再导入可以选择复制模式，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJzoC5vQ9mb05YrSUsAoTR6FRGpgGmrSZIgq2Hke2Q1ZgA7a5xP0alA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始就可以导入数据了</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoqhr3jY27uwVkalMIMw3VNtY2ZsZsrMgXQCKoJFDPDH66By1IxYCHnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>导出向导</strong></p>
<p>需要将数据库里的数据导出可以使用导出向导，具体如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIosDqVIic9Fyw1GIzhhynAp1gj2YfBHUgEE53B03vdPOgDARQUsqBicvBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中选择导出文件类型，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo5SsBEomUrzic3fvd4TJr8Ig4sFTGGdHxtjCJMPjXU63pVEbmNUicexzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择需要导出的表，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIocqzcibg1sEPdpbx0f0FqziaiahGak5Iz24y2kWFtzm3BfOcEkalwDCKIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择需要导出的列，默认全部字段，也可以选择指定字段，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJuTZ3MzwxnY7PAbyvQypMRE4X4266DicRFzccGgKDibib8bwzHjBJ0VkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>定义一些附加选项，导出包含标题，遇到导出错误继续等，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoDqcgLqHnEASje1LdH85fxzASTibKuiaPuItStfxzjXKsydBho1xUpfQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始执行导出操作</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIotFkCMS4qmA9ZaU9lQV72kd9yf3xQuXH8tNQYy0Trjc89OaPJVfbODw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>新建查询</strong></p>
<p>新建查询有两种方式，可以直接右键选择新建查询，也可以点击菜单栏的查询-新建查询，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoZge8TTPMzoYaMaichOUmddo9OkwHGwIoVHSb7TpiauRtIgCHtnzZcoXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>查询功能</strong></p>
<p>查询是我们用的比较频繁的一个功能，在查询窗口里面有许多好用的功能</p>
<p><strong>智能提醒</strong></p>
<p>根据我们输入的字符来自动提醒一些关键字，字段名，表名，视图名，函数名等，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIodFO8VeLldjRGdxUUCu7JqaVDcZhpzu3ET8A2urodtyUE674d2P9R8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>美化SQL</strong></p>
<p>当你看到一段代码写的很复杂且都堆在一起，可以使用美化SQL功能，一键帮你把堆在一起的SQL美化得整整齐齐。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2ws81EQbUEv6OwTZVUCVv0SkYeQ4ibU7Mia0oUqubE856t8QFTYTZnkg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>美化前</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIop5eiciaJ9kT4iaL8sxibNmWaRI68twNTKSAUsiaF8lmc2N9OkJnhBb5lNGg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>美化后</p>
<p><strong>其他功能</strong></p>
<p>此外查询窗口还有很多其他功能，都集中在左上角的三短横上面，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoZfZE8m5xAlAiaWyiaoaB5ib4FJPHB48teicrvpL1iaZUc3mtIQ4ImHnBpKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里将查询窗口的所有功能都汇集在一起，比如注释，查看执行计划，简化SQL等都在这里可以找到，小伙伴们可以一一尝试一下。</p>
<p><strong>创建视图</strong></p>
<p>Navicat提供一套创建视图的模板，主要是针对新手朋友。如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIotlErKxibGVngibLqbKfAmZmJgao6RMMOEOf1buYlRthMN4EMV1emOnRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里我们只需要写查询语句即可，在SQL预览里可以看到完整的SQL语句。如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo58Z7WQHwWh2LicjJAsBAAbEUictk2oYmex5u79n1C4SlHzmSsK6JA4MQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击预览，可以看到我们刚定义的视图结果，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoobd6t9vLPcZRnteqc9v8N0jeYhS5gtyCkicTPnh8ymjLHr5sKPjolgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>创建函数和存储过程</strong></p>
<p>函数和存储过程是类似的，区别是函数必须要有返回值，而存储过程可有可无。</p>
<p>他们也有一套模板，选择函数后点击新建函数，弹出如下对话框：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJibuYXzHaia6wiaN41LwF9BQoqtteicJj4sDF5lFibicE6vXkYbT6F3ypGww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>输入函数名或过程名，然后选择你想是想创建函数还是存储过程。然后输入参数名称和类型，也可以不带参数，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoMVGCWGLLdRfME5vtAb7GP7jiaSZJ4bgwsmcZHVM1Cn1aCaEFVTDF6vg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>函数必须要有返回值，这里需要定义返回值类型，点击下一步或完成。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoc3Jq9L01h8luBsFpIPcibrqXOs4A6ibXqK5GEHQsibB8cRW5kia1FdO90A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里会配置函数的一些附加信息，通常不用配置，直接点击完成即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoTFmlaHv2ZIP9t0icQd6pMjFOAOHTibicYRdNXGTo18gyP0MPzDJueXRBQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后我们就可以看到函数的编辑窗口了</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIog39HtbibClCyegtdt1zjN8nIvxbIYcvpeLuaMI6oL7Dw5ic0copYAN2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>写好函数里的语句后点击运行即可开始测试了。</p>
<p><strong>备份和还原</strong></p>
<p>通过Navicat，我们可以很方便的完成备份和还原操作，我们先来备份一个文件。</p>
<p><strong>备份</strong></p>
<p>点击菜单栏的SQL Server备份——新建备份，在弹出的窗口中配置备份内容，然后点击生成SQL即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIowFVnb9HfcicQHiagCnb3HLzyvpicUpF7Cf9S5qBB7CmfUfFtpckMdcRQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在这里我们可以看到备份的代码，然后点备份就会开始备份</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2N7mdeSiaMqEKbib8784hD9cYszwMFVrU2k1eqOdWqfF3Qib2UGvkiabhw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>还原</strong></p>
<p>在备份完成后，我们可以选择还原该备份包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoFbj8G9rvic4Pod7YeTzZDFm4hFEh6eibImpO9KF62UYuunZGOlC6qV7g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中可以配置相关信息</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoYkYWtRVp2H7l25ib5NPT6nQmdyx0v2eU6Rzmng4jvLFoQYnvWRYDn6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击生成SQL就会看到执行备份的SQL命令，点击还原即可开始执行</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoOXxlnPcECCGib8L7RGNOMze8FPzDmHiaib7BgGGlXQr0Yd6s0kLiaVzicqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>历史日志记录</strong></p>
<p>该功能可以很方便的查看到你在数据库中执行了哪些操作。点击菜单栏中的工具——历史日志，就可以看到我们的操作记录了，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoNM11YDOPrBnV7ibs8eQwJorWiaTRo1icrlFZu2rIjjjssomNk5dAZlIuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/5.4.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/" data-id="ckno8ff63004aswwd7uhbdzse" data-title="MySQL工具之Navicat" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-21.1.微信开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:36:09.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/">微信开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="微信公众平台开发"><a href="#微信公众平台开发" class="headerlink" title="微信公众平台开发"></a>微信公众平台开发</h1><h2 id="订阅号和服务号和企业号"><a href="#订阅号和服务号和企业号" class="headerlink" title="订阅号和服务号和企业号"></a>订阅号和服务号和企业号</h2><p>订阅号每天一条，收拢至订阅号文件夹，不强制推送；服务号每月一条，消息仍展示在聊天列表，但下发消息将即时提醒用户。</p>
<p>1、订阅号：主要偏于为用户传达资讯（类似报纸杂志），认证前后都是每天只可以群发一条消息。</p>
<p>2、服务号：主要偏于服务交互（类似银行，114，提供服务查询），认证前后都是每个月可群发4条消息；</p>
<p>3、企业号：主要用于公司内部通讯使用，需要先验证身份才可以关注成功企业号。</p>
<h2 id="验证登录和授权：AccessToken"><a href="#验证登录和授权：AccessToken" class="headerlink" title="验证登录和授权：AccessToken"></a>验证登录和授权：AccessToken</h2><h3 id="1-查看appid及appsecret"><a href="#1-查看appid及appsecret" class="headerlink" title="1.查看appid及appsecret"></a>1.查看appid及appsecret</h3><p>公众号后台界面查看</p>
<h3 id="2-获取accessToken"><a href="#2-获取accessToken" class="headerlink" title="2.获取accessToken"></a>2.获取accessToken</h3><p>1.临时方法获取</p>
<p>临时通过<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/debug/">在线测试</a> 或者 浏览器/postman等方式发送get请求获取返回结果里的accessToken</p>
<p>2.接口获取</p>
<p>第三方需要一个access_token获取和刷新的中控服务器（这个服务器会提前进行刷新，确保无缝连接）。</p>
<p>并发获取access_token会导致AccessToken互相覆盖，影响具体的业务功能，所以需要加并发锁</p>
<h2 id="用户标识：openid和UnionID"><a href="#用户标识：openid和UnionID" class="headerlink" title="用户标识：openid和UnionID"></a>用户标识：openid和UnionID</h2><p>为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID。如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下。绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID，可以在用户管理-获取用户基本信息（UnionID机制）文档了解详情。</p>
<p>​    <strong>一个用户对于一个公众号只会存在一个openid，即使取消关注了再关注，openid也不会改变。如果一个大公司下有多个公众号，会产生不同的openid，为了实现该公司下公众号间的数据互通，会有一个唯一的UnionID作为用户的唯一标识</strong></p>
<h2 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h2><p>公众号主要通过公众号消息会话和公众号内网页来为用户提供服务的：</p>
<h3 id="1、公众号消息会话"><a href="#1、公众号消息会话" class="headerlink" title="1、公众号消息会话"></a><strong>1、公众号消息会话</strong></h3><p>公众号是以微信用户的一个联系人形式存在的，消息会话是公众号与用户交互的基础。</p>
<p>目前公众号内主要有这样几类消息服务的类型，分别用于不同的场景。</p>
<p>1）群发消息：公众号可以以一定频次（订阅号为每天1次，服务号为每月4次），向用户群发消息，包括文字消息、图文消息、图片、视频、语音等。</p>
<p><strong>在公众号后台管理界面的创作管理可以编辑后选择群发</strong></p>
<p>2）被动回复消息：在用户给公众号发消息后，微信服务器会将消息发到开发者预先在开发者中心设置的服务器地址（开发者需要进行消息真实性验证），公众号可以在5秒内做出回复，可以回复一个消息，也可以回复命令告诉微信服务器这条消息暂不回复。被动回复消息可以设置加密（在公众平台官网的开发者中心处设置，设置后，按照消息加解密文档来进行处理。其他3种消息的调用因为是API调用而不是对请求的返回，所以不需要加解密）。</p>
<p>3）客服消息：在用户给公众号发消息后的48小时内，公众号可以给用户发送不限数量的消息，主要用于客服场景。用户的行为会触发事件推送，某些事件推送是支持公众号据此发送客服消息的，详见微信推送消息与事件说明文档。</p>
<p>4）模板消息：在需要对用户发送服务通知（如刷卡提醒、服务预约成功通知等）时，公众号可以用特定内容模板，主动向用户发送消息。</p>
<h3 id="2、公众号内网页"><a href="#2、公众号内网页" class="headerlink" title="2、公众号内网页"></a><strong>2、公众号内网页</strong></h3><p>许多复杂的业务场景，需要通过网页形式来提供服务，这时需要用到：</p>
<p>1）网页授权获取用户基本信息：通过该接口，可以获取用户的基本信息（获取用户的OpenID是无需用户同意的，获取用户的基本信息则需用户同意）</p>
<p>2）微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。</p>
<h2 id="全局返回码"><a href="#全局返回码" class="headerlink" title="全局返回码"></a>全局返回码</h2><p>公众号每次调用接口时，可能获得正确或错误的返回码，开发者可以根据返回码信息调试接口，排查错误</p>
<p>-1：系统繁忙，此时请开发者稍候再试</p>
<p>0：请求成功</p>
<p>4xxxx，6xxxx，9xxxx：各种问题的返回码</p>
<h2 id="开始开发"><a href="#开始开发" class="headerlink" title="开始开发"></a>开始开发</h2><h3 id="1-申请服务器"><a href="#1-申请服务器" class="headerlink" title="1.申请服务器"></a>1.申请服务器</h3><h3 id="2-搭建服务"><a href="#2-搭建服务" class="headerlink" title="2.搭建服务"></a>2.搭建服务</h3><p>后端程序配置微信的设置</p>
<h3 id="3-申请公众号"><a href="#3-申请公众号" class="headerlink" title="3.申请公众号"></a>3.申请公众号</h3><h3 id="4-开发者基本配置"><a href="#4-开发者基本配置" class="headerlink" title="4.开发者基本配置"></a>4.开发者基本配置</h3><h4 id="1-填写服务器配置"><a href="#1-填写服务器配置" class="headerlink" title="1.填写服务器配置"></a>1.填写服务器配置</h4><p>服务器地址（URL）、Token和EncodingAESKey</p>
<p>URL是开发者用来接收微信消息和事件的接口URL。</p>
<p>Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。</p>
<p>EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥</p>
<p>填写并提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求：signature（微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数），timestamp（时间戳），nonce（随机数），echostr（随机字符串）</p>
<p>通过检验signature对请求进行校验：</p>
<p>1）将token、timestamp、nonce三个参数进行字典序排序 </p>
<p>2）将三个参数字符串拼接成一个字符串进行sha1加密</p>
<p> 3）将加密后的字符串与signature对比，true表示是微信发来的，false表示不是微信。</p>
<p>若确认此次GET请求来自微信服务器，原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败</p>
<h4 id="2-后续可以在公众号后台的开发-基本配置里修改配置："><a href="#2-后续可以在公众号后台的开发-基本配置里修改配置：" class="headerlink" title="2.后续可以在公众号后台的开发/基本配置里修改配置："></a>2.后续可以在公众号后台的开发/基本配置里修改配置：</h4><p>开发者ID（AppID）：自动生成</p>
<p>开发者密码(AppSecret)：可以重置自动生成复制</p>
<p>IP白名单：配置自己的白名单以便调用测试接口获得access_token</p>
<p>服务器地址(URL)：http://外网IP/wx ，端口固定为80（http://外网IP/wx）</p>
<p>令牌(Token)：自主设置，这个token与前面的access_token不是一回事。这个token只用于验证开发者服务器</p>
<p>消息加解密密钥(EncodingAESKey)</p>
<h3 id="5-后端进行框架构思"><a href="#5-后端进行框架构思" class="headerlink" title="5.后端进行框架构思"></a>5.后端进行框架构思</h3><p>主要有三个部分：负责业务逻辑部分的服务器，负责对接微信API的API-Proxy服务器，以及唯一的AccessToken中控服务器</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xnC7SUbrIRwI8NhEGFeax6HoPcTMDqKGYxaSoNqBwocrj70Pt1EcKnQ/0?wx_fmt=png" alt="img"></p>
<p>1）AccessToken中控服务器：</p>
<p>负责： 提供主动刷新和被动刷新机制来刷新accessToken并存储（为了防止并发刷新，注意加并发锁），提供给业务逻辑有效的accessToken。</p>
<p>优点： 避免业务逻辑方并发获取access_token，避免AccessToken互相覆盖，提高业务功能的稳定性。</p>
<p>2）API-Proxy服务器：</p>
<p>负责：专一与微信API对接，不同的服务器可以负责对接不同的业务逻辑，更可进行调用频率、权限限制。</p>
<p>优点：某台API-proxy异常，还有其余服务器支持继续提供服务，提高稳定性，避免直接暴漏内部接口，有效防止恶意攻击，提高安全性</p>
<p>3）后端服务的服务器</p>
<h3 id="6-码代码"><a href="#6-码代码" class="headerlink" title="6.码代码"></a>6.码代码</h3><h3 id="7-在线测试"><a href="#7-在线测试" class="headerlink" title="7.在线测试"></a>7.在线测试</h3><p>在线测试接口可以输入access_token，进行接口测试，返回”请求失败”，说明代码有问题，检查代码逻辑。</p>
<p>“请求成功”，然后根据返回结果查看是否符合预期</p>
<h3 id="8-真实体验"><a href="#8-真实体验" class="headerlink" title="8.真实体验"></a>8.真实体验</h3><p>手机端微信关注测试</p>
<h2 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h2><ol>
<li>自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。</li>
<li>一级菜单最多4个汉字，二级菜单最多7个汉字，多出来的部分将会以“…”代替。</li>
<li>创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile（简介）页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果</li>
</ol>
<h3 id="设置类型："><a href="#设置类型：" class="headerlink" title="设置类型："></a>设置类型：</h3><ol>
<li><p>click：点击推事件。用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互；</p>
</li>
<li><p>view：跳转URL。用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。</p>
</li>
<li><p>scancode_push：扫码推事件用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。</p>
</li>
<li><p>scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>pic_sysphoto：弹出系统拍照发图用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>pic_photo_or_album：弹出拍照或者相册发图用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。</p>
</li>
<li><p>pic_weixin：弹出微信相册发图器用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>location_select：弹出地理位置选择器用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>media_id：下发消息（除文本消息）用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频、图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</p>
</li>
<li><p>view_limited：跳转图文消息URL用户点击view_limited类型按钮后，微信客户端将打开开发者在按钮中填写的永久素材id对应的图文消息URL，永久素材类型只支持图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</p>
</li>
</ol>
<p>view类型：弹出网页（pc版本）</p>
<p>media_id类型：显示图文消息</p>
<p>click类型：发现公众号系统提示：“该公众号暂时无法提供服务“</p>
<p>点击click类型button，微信后台会推送一个event类型的xml 给开发者，需要开发者进一步完善后台代码逻辑，增加对自定义菜单事件推送的响应，必须设置key值</p>
<h3 id="创建-修改接口："><a href="#创建-修改接口：" class="headerlink" title="创建/修改接口："></a>创建/修改接口：</h3><p>这里的url应该是直接的url，不包含二级菜单</p>
<p>POST（使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN%EF%BC%8C%E8%AF%B7%E6%B1%82%E4%BD%93%E4%B8%BA%EF%BC%9A">https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN，请求体为：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;button&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;绑定安全帽&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;wxcc4bc1fc3f1774c4redirect_uri&#x3D;http%3A%2F%2felinktech.cn%2Fabout.htmlresponse_type&#x3D;codescope&#x3D;snsapi_basestate&#x3D;123#wechat_redirect&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;运营服务&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;wxcc4bc1fc3f1774c4redirect_uri&#x3D;http%3A%2F%2felinktech.cn%2Fdaohang.htmlresponse_type&#x3D;codescope&#x3D;snsapi_basestate&#x3D;123#wechat_redirect&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;E联商城&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;wxcc4bc1fc3f1774c4redirect_uri&#x3D;http%3a%2f%2felinktech.cn%2fshop.htmlresponse_type&#x3D;codescope&#x3D;snsapi_basestate&#x3D;123#wechat_redirect&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回0成功。</p>
<h3 id="查询接口："><a href="#查询接口：" class="headerlink" title="查询接口："></a>查询接口：</h3><p>GET <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/get_current_selfmenu_info?access_token=ACCESS_TOKEN%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84json%E5%8D%B3%E4%B8%BA%E6%8E%A5%E5%8F%A3">https://api.weixin.qq.com/cgi-bin/get_current_selfmenu_info?access_token=ACCESS_TOKEN，返回结果的json即为接口</a></p>
<h3 id="删除接口："><a href="#删除接口：" class="headerlink" title="删除接口："></a>删除接口：</h3><p>GET <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN%EF%BC%8C%E8%BF%94%E5%9B%9E0%E5%8D%B3%E4%B8%BA%E5%88%A0%E9%99%A4%E6%88%90%E5%8A%9F">https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN，返回0即为删除成功</a></p>
<h3 id="事件推送："><a href="#事件推送：" class="headerlink" title="事件推送："></a>事件推送：</h3><p>用户点击自定义菜单后，微信会把点击事件推送给开发者，请注意，点击菜单弹出子菜单，不会产生上报</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[FromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[event]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Event</span>&gt;</span>&lt;![CDATA[CLICK]]&gt;<span class="tag">&lt;/<span class="name">Event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">EventKey</span>&gt;</span>&lt;![CDATA[EVENTKEY]]&gt;<span class="tag">&lt;/<span class="name">EventKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="个性化菜单接口"><a href="#个性化菜单接口" class="headerlink" title="个性化菜单接口"></a>个性化菜单接口</h3><p>可以通过该接口，让公众号的不同用户群体看到不一样的自定义菜单</p>
<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包发到开发者填写的URL上。</p>
<h3 id="1-接收文本消息"><a href="#1-接收文本消息" class="headerlink" title="1.接收文本消息"></a>1.接收文本消息</h3><p> 1.粉丝给公众号发送的文本消息</p>
<p>粉丝给公众号发送文本消息：“欢迎开启公众号开发者模式”，在开发者后台，收到公众平台发送的xml 如下：（下文均隐藏了ToUserName 及 FromUserName 信息）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[公众号]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[粉丝号]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1460537339<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[欢迎开启公众号开发者模式]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>6272960105994287618<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>createTime 是微信公众平台记录粉丝发送该消息的具体时间</p>
<p>text: 用于标记该xml 是文本消息，一般用于区别判断</p>
<p>欢迎开启公众号开发者模式: 说明该粉丝发给公众号的具体内容是欢迎开启公众号开发者模式</p>
<p>MsgId: 是公众平台为记录识别该消息的一个标记数值, 微信后台系统自动产生</p>
<ol start="2">
<li>被动回复文本消息</li>
</ol>
<p>即公众号给粉丝发送的文本消息，官方wiki链接: <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message">被动回复用户消息</a></p>
<p>特别强调：</p>
<p>1） 被动回复消息，即发送被动响应消息，不同于客服消息接口</p>
<p>2） 它其实并不是一种接口，而是对微信服务器发过来消息的一次回复</p>
<p>3） 收到粉丝消息后不想或者不能5秒内回复时，需回复“success”字符串</p>
<p>4） 客服接口在满足一定条件下随时调用</p>
<p>公众号想回复给粉丝一条文本消息，内容为“test”, 那么开发者发送给公众平台后台的xml 内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[粉丝号]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[公众号]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1460541339<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[test]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>特别备注：</p>
<p>1）ToUserName（接受者）、FromUserName(发送者) 字段请实际填写。</p>
<p>2）createtime 只用于标记开发者回复消息的时间，微信后台发送此消息都是不受这个字段约束。</p>
<p>3）text : 用于标记 此次行为是发送文本消息 （当然可以是image/voice等类型）。</p>
<p>4）文本换行 ‘\n’。</p>
<p> 3.回复success问题</p>
<p>查询官方wiki 开头强调： 假如服务器无法保证在五秒内处理回复，则必须回复“success”或者“”（空串），否则微信后台会发起三次重试。</p>
<p>解释一下为何有这么奇怪的规定。发起重试是微信后台为了尽可以保证粉丝发送的内容开发者均可以收到。如果开发者不进行回复，微信后台没办法确认开发者已收到消息，只好重试。</p>
<p>真的是这样子吗？尝试一下收到消息后，不做任何回复。在日志中查看到微信后台发起了三次重试操作，日志截图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xauONdVFJvic1Wfzxa0HnSEZ5libLcYibWWkb7gNDjt56DFs8kiaY3OtFtw/0?wx_fmt=png" alt="img"></p>
<p>三次重试后，依旧没有及时回复任何内容，系统自动在粉丝会话界面出现错误提示“该公众号暂时无法提供服务，请稍后再试”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xBp7Iiam8ydK0W4MOZa9bfHKgTesMkj3HXOnsYxttsodweib7mH9y5eQg/0?wx_fmt=png" alt="img"></p>
<p>如果回复success，微信后台可以确定开发者收到了粉丝消息，没有任何异常提示。因此请大家注意回复success的问题。</p>
<ol start="4">
<li>流程图</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xEVXiblIZm80UCBlia6vYiaXD7Od9Ev3nujHoNkNCubr9WPo8L7opJGhIA/0?wx_fmt=png" alt="img"></p>
<h3 id="2-接收图片消息"><a href="#2-接收图片消息" class="headerlink" title="2.接收图片消息"></a>2.接收图片消息</h3><p>MediaID</p>
<p>目的：</p>
<p>1）引入素材管理</p>
<p>2）以文本消息，图片消息为基础，可自行理解剩余的语音消息、视频消息、地理消息等</p>
<p>预实现功能：</p>
<p>接受粉丝发送的图片消息，并立马回复相同的图片给粉丝。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0x6zWAJ79NkGrlg34cGBjvqxtSxSVw5gPMsmlygTyhdDblrsNiaCX8GhQ/0?wx_fmt=png" alt="img"></p>
<p> 1.接收图片消息</p>
<p>即粉丝给公众号发送的图片消息。官方wiki链接：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html">消息管理/接收消息-接受普通消息/ 图片消息</a>从实例讲解，粉丝给公众号发送一张图片消息，在公众号开发者后台接收到的xml如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml&gt;</span><br><span class="line"> &lt;ToUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/ToUserName&gt;</span><br><span class="line"> &lt;FromUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/FromUserName&gt;</span><br><span class="line"> &lt;CreateTime&gt;1460536575&lt;/CreateTime&gt;</span><br><span class="line"> &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;</span><br><span class="line"> &lt;PicUrl&gt;&lt;![CDATA[http://mmbiz.qpic.cn/xxxxxx /0]]&gt;&lt;/PicUrl&gt;</span><br><span class="line"> &lt;MsgId&gt;6272956824639273066&lt;/MsgId&gt;</span><br><span class="line"> &lt;MediaId&gt;&lt;![CDATA[gyci5a-xxxxx-OL]]&gt;&lt;/MediaId&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure>

<p>特别说明：</p>
<p>PicUrl: 这个参数是微信系统把“粉丝“发送的图片消息自动转化成url。 这个url可用浏览器打开查看到图片。</p>
<p>MediaId: 是微信系统产生的id 用于标记该图片，详情可参考wiki<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1444738727&token=&lang=zh_CN">素材管理/获取临时素材</a>，</p>
<p> 2.被动回复图片消息</p>
<p>即公众号给粉丝发送的图片消息。官方wiki链接：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140543&token=&lang=zh_CN">消息管理/发送消息-被动回复用户消息/ 图片消息</a>)</p>
<p>特别说明：</p>
<p>1） 被动回复消息，即发送被动响应消息，不同于客服消息接口</p>
<p>2） 它其实并不是一种接口，而是对微信服务器发过来消息的一次回复</p>
<p>3） 收到粉丝消息后不想或者不能5秒内回复时，需回复“success”字符串</p>
<p>4） 客服接口在满足一定条件下随时调用</p>
<p>开发者发送给微信后台的xml 如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml&gt;</span><br><span class="line"> &lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt;</span><br><span class="line"> &lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt;</span><br><span class="line"> &lt;CreateTime&gt;1460536576&lt;/CreateTime&gt;</span><br><span class="line"> &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;</span><br><span class="line"> &lt;Image&gt;</span><br><span class="line"> &lt;MediaId&gt;&lt;![CDATA[gyci5oxxxxxxv3cOL]]&gt;&lt;/MediaId&gt;</span><br><span class="line"> &lt;/Image&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure>

<p>这里填写的MediaId的内容，其实就是粉丝的发送图片的原MediaId，所以粉丝收到了一张一模一样的原图。 如果想回复粉丝其它图片怎么呢？</p>
<p>1） 新增素材，请参考 新增临时素材 或者 新增永久素材</p>
<p>2） 获取其MediaId，请参考 获取临时素材MediaID 或者 获取永久素材MediaID</p>
<p>3.3 流程图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xDdfzVUuLvr3iaR3BvJnkkL9kATK0TgmFXsF2tPHTlpulfJ6eU930a1Q/0?wx_fmt=png" alt="img"></p>
<h3 id="3-语音消息"><a href="#3-语音消息" class="headerlink" title="3.语音消息"></a>3.语音消息</h3><h3 id="4-视频消息"><a href="#4-视频消息" class="headerlink" title="4.视频消息"></a>4.视频消息</h3><h3 id="5-小视频消息"><a href="#5-小视频消息" class="headerlink" title="5.小视频消息"></a>5.小视频消息</h3><h3 id="6-地理位置信息"><a href="#6-地理位置信息" class="headerlink" title="6.地理位置信息"></a>6.地理位置信息</h3><h3 id="7-链接消息"><a href="#7-链接消息" class="headerlink" title="7.链接消息"></a>7.链接消息</h3><h2 id="接收事件推送"><a href="#接收事件推送" class="headerlink" title="接收事件推送"></a>接收事件推送</h2><h3 id="1-关注-取消关注事件"><a href="#1-关注-取消关注事件" class="headerlink" title="1 关注/取消关注事件"></a>1 关注/取消关注事件</h3><p>用户在关注与取消关注公众号时，微信会把这个事件推送到开发者填写的URL。方便开发者给用户下发欢迎消息或者做帐号的解绑。为保护用户数据隐私，开发者收到用户取消关注事件时需要删除该用户的所有信息</p>
<h3 id="2-扫描带参数二维码事件"><a href="#2-扫描带参数二维码事件" class="headerlink" title="2 扫描带参数二维码事件"></a>2 扫描带参数二维码事件</h3><p>用户扫描带场景值二维码时，可能推送以下两种事件：</p>
<ol>
<li>如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。</li>
<li>如果用户已经关注公众号，则微信会将带场景值扫描事件推送给开发者</li>
</ol>
<h3 id="3-上报地理位置事件"><a href="#3-上报地理位置事件" class="headerlink" title="3 上报地理位置事件"></a>3 上报地理位置事件</h3><p>用户同意上报地理位置后，每次进入公众号会话时，都会在进入时上报地理位置，或在进入会话后每5秒上报一次地理位置，公众号可以在公众平台网站中修改以上设置。上报地理位置时，微信会将上报地理位置事件推送到开发者填写的URL。</p>
<h3 id="4-自定义菜单事件"><a href="#4-自定义菜单事件" class="headerlink" title="4 自定义菜单事件"></a>4 自定义菜单事件</h3><p>用户点击自定义菜单后，微信会把点击事件推送给开发者，请注意，点击菜单弹出子菜单，不会产生上报</p>
<h3 id="5-点击菜单拉取消息时的事件推送"><a href="#5-点击菜单拉取消息时的事件推送" class="headerlink" title="5 点击菜单拉取消息时的事件推送"></a>5 点击菜单拉取消息时的事件推送</h3><h3 id="6-点击菜单跳转链接时的事件推送"><a href="#6-点击菜单跳转链接时的事件推送" class="headerlink" title="6 点击菜单跳转链接时的事件推送"></a>6 点击菜单跳转链接时的事件推送</h3><h2 id="被动回复用户消息"><a href="#被动回复用户消息" class="headerlink" title="被动回复用户消息"></a>被动回复用户消息</h2><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。</p>
<p>严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。</p>
<p>1、直接回复success（推荐方式） 2、直接回复空串（指字节长度为0的空字符串，而不是XML结构体中content字段的内容为空）</p>
<p>1、开发者在5秒内未回复任何内容 2、开发者回复了异常数据，比如JSON数据等</p>
<p>就会出现<strong>“该公众号暂时无法提供服务，请稍后再试”</strong></p>
<h2 id="自动回复规则"><a href="#自动回复规则" class="headerlink" title="自动回复规则"></a>自动回复规则</h2><p>开发者可以通过该接口，获取公众号当前使用的自动回复规则，包括关注后自动回复、消息自动回复（60分钟内触发一次）、关键词自动回复</p>
<h2 id="模板消息"><a href="#模板消息" class="headerlink" title="模板消息"></a>模板消息</h2><ol>
<li>模板消息调用时主要需要模板ID和模板中各参数的赋值内容</li>
<li>模板中参数内容必须以”.DATA”结尾，否则视为保留字</li>
<li>模板保留符号””</li>
</ol>
<p>在模版消息发送任务完成后，微信服务器会将是否送达成功作为通知，发送到开发者中心中填写的服务器配置地址中</p>
<h2 id="微信网页开发"><a href="#微信网页开发" class="headerlink" title="微信网页开发"></a>微信网页开发</h2><h3 id="适配问题"><a href="#适配问题" class="headerlink" title="适配问题"></a>适配问题</h3><p>安卓版微信直接调用系统浏览器内核，它是用chrome改造做的一套WKwebView,概念上类似是一套组建, iOS则是调用safari，但</p>
<p>微信<strong>iOS客户端</strong>于2017年3月1日前逐步升级为WKWebview内核。ios也可以自己切换为UIWebview。微信内任意入口进入任意网页，在网页加载成功后向下拉动页面（或点击网页右上角菜单按钮），使之显示出地址栏，当地址栏以 “此网页由” 开头即为当前使用WKWebview，若以“网页由”则是使用的UIWebview</p>
<h3 id="网页授权"><a href="#网页授权" class="headerlink" title="网页授权"></a>网页授权</h3><p>如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。</p>
<p>OAuth2.0鉴权</p>
<h4 id="1、引导用户进入授权页面同意授权，获取code"><a href="#1、引导用户进入授权页面同意授权，获取code" class="headerlink" title="1、引导用户进入授权页面同意授权，获取code"></a>1、引导用户进入授权页面同意授权，获取code</h4><p>在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），引导关注者打开如下页面：<a target="_blank" rel="noopener" href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a> 若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。</p>
<p>尤其注意：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问。</p>
<p>如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE</p>
<p>跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。</p>
<p>code说明 ： code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期</p>
<p><strong>关于网页授权回调域名的说明</strong></p>
<p>1、在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；</p>
<p>2、授权回调域名配置规范为全域名，比如需要网页授权的域名为：<a target="_blank" rel="noopener" href="http://www.qq.com,配置以后此域名下面的页面http//www.qq.com/music.html">www.qq.com，配置以后此域名下面的页面http://www.qq.com/music.html</a> 、 <a target="_blank" rel="noopener" href="http://www.qq.com/login.html">http://www.qq.com/login.html</a> 都可以进行OAuth2.0鉴权。但<a target="_blank" rel="noopener" href="http://pay.qq.com/">http://pay.qq.com</a> 、 <a target="_blank" rel="noopener" href="http://music.qq.com/">http://music.qq.com</a> 、 <a target="_blank" rel="noopener" href="http://qq.com/">http://qq.com</a> 无法进行OAuth2.0鉴权</p>
<p>3、如果公众号登录授权给了第三方开发者来进行管理，则不必做任何设置，由第三方代替公众号实现网页授权即可</p>
<p><strong>关于网页授权的两种scope的区别说明</strong></p>
<p>1、以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p>
<p>2、以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</p>
<p>3、用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p>
<h4 id="2、通过code换取网页授权access-token（与基础支持中的access-token不同）"><a href="#2、通过code换取网页授权access-token（与基础支持中的access-token不同）" class="headerlink" title="2、通过code换取网页授权access_token（与基础支持中的access_token不同）"></a>2、通过code换取网页授权access_token（与基础支持中的access_token不同）</h4><p>这里通过code换取的是一个特殊的网页授权access_token,与基础支持中的access_token（该access_token用于调用其他接口）不同。公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。</p>
<p>尤其注意：由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起</p>
<p>获取code后，请求以下链接获取access_token： <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</a></p>
<p><strong>关于网页授权access_token和普通access_token的区别</strong></p>
<p>1、微信网页授权是通过OAuth2.0机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权access_token），通过网页授权access_token可以进行授权后接口调用，如获取用户基本信息；</p>
<p>2、其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用。</p>
<h4 id="3、如果需要，开发者可以刷新网页授权access-token，避免过期"><a href="#3、如果需要，开发者可以刷新网页授权access-token，避免过期" class="headerlink" title="3、如果需要，开发者可以刷新网页授权access_token，避免过期"></a>3、如果需要，开发者可以刷新网页授权access_token，避免过期</h4><p>由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token有效期为30天，当refresh_token失效之后，需要用户重新授权</p>
<p>获取第二步的access_token后，请求以下链接获取refresh_token： <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN">https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN</a></p>
<h4 id="4、通过网页授权access-token和openid获取用户基本信息（支持UnionID机制）"><a href="#4、通过网页授权access-token和openid获取用户基本信息（支持UnionID机制）" class="headerlink" title="4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）"></a>4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</h4><p>如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了</p>
<p>http：GET（请使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</a></p>
<p><strong>关于UnionID机制</strong></p>
<p>1、请注意，网页授权获取用户基本信息也遵循UnionID机制。即如果开发者有在多个公众号，或在公众号、移动应用之间统一用户帐号的需求，需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用UnionID机制来满足上述需求。</p>
<p>2、UnionID机制的作用说明：如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性，因为同一用户，对同一个微信开放平台下的不同应用（移动应用、网站应用和公众帐号），unionid是相同的。</p>
<p><strong>关于特殊场景下的静默授权</strong></p>
<p>1、上面已经提到，对于以snsapi_base为scope的网页授权，就静默授权的，用户无感知；</p>
<p>2、对于已关注公众号的用户，如果用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是scope为snsapi_userinfo，也是静默授权，用户无感知。</p>
<p><strong>检验授权凭证（access_token）是否有效</strong></p>
<p>http：GET（请使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID">https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID</a></p>
<p>返回0代表有效</p>
<h3 id="网页开发样式库：WEBUI"><a href="#网页开发样式库：WEBUI" class="headerlink" title="网页开发样式库：WEBUI"></a>网页开发样式库：WEBUI</h3><h3 id="微信JS-SDK"><a href="#微信JS-SDK" class="headerlink" title="微信JS-SDK"></a>微信JS-SDK</h3><p>是<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/cgi-bin/loginpage?t=wxm2-login&lang=zh_CN">微信公众平台</a> 面向网页开发者提供的基于微信内的网页开发工具包</p>
<h3 id="WEB开发者工具"><a href="#WEB开发者工具" class="headerlink" title="WEB开发者工具"></a>WEB开发者工具</h3><p>调试工具</p>
<h3 id="云开发"><a href="#云开发" class="headerlink" title="云开发"></a>云开发</h3><p>开发者可以使用云开发开发微信小程序、小游戏、公众号，无需搭建服务器，即可使用云端能力。</p>
<p>云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。</p>
<h2 id="Cookie和LocalStorage设置相关"><a href="#Cookie和LocalStorage设置相关" class="headerlink" title="Cookie和LocalStorage设置相关"></a>Cookie和LocalStorage设置相关</h2><p>一：退出微信账号后，将会清空所有Cookie和LocalStorage。</p>
<p>二：页面功能依赖Cookie，或有涉及到Cookie的相关逻辑 WKWebview内部实现变更，会影响目前页面Cookie相关的逻辑。</p>
<p>变化1：跨域存取Cookie 问题说明：在访问一个页面A时，如果页面A引用了另一个页面B的资源（页面A和B为不同的域名），这时页面B就被认为是第三方页面。若在页面B中设置Cookie，就会命中WKWebview下阻止第三方跨域设置Cookie的安全策略，导致问题出现。 适配建议： 在WKWebview中是默认阻止跨域的第三方设置Cookie。所有通过Cookie传递的信息，可通过业务后台存储需要传递的信息，然后给页面一个存储信息相对应的access_token加密码，再通过Url中加入自己业务的access_token进行页面间的信息传递。</p>
<p>变化2：微信原生层面的网络请求读取不到WKWebview中设置的cookie，即使域名是相同的。 问题说明：如果页面的资源或图片存储的服务器依赖校验Cookie来返回数据的情况，在切换到WKWebview后，在微信内长按保存，或者点击预览大图时，原生层面发起的网络请求将不会完整地带上所设置的Cookie，会导致图片保存失败或预览失败。 适配建议： 建议静态资源cookie free。如果确实有信息需要传递，可通过业务后台存储需要传递的信息，然后给页面一个存储信息相对应的access_token加密码，再通过Url中加入自己业务的access_token进行页面间信息传递。</p>
<p>除上述两种情况，开发者不用担心其他情况下Cookie丢失的问题，所有请求都会带上完整的Cookie</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.每个接口都有每日接口<strong>调用频次</strong>限制，可以在公众平台官网-开发者中心处查看具体频次。</p>
<p>2.公众平台以<strong>access_token</strong>为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储，详见获取接口调用凭据（access_token）文档</p>
<p>3.公众平台接口调用仅支持<strong>80端口</strong></p>
<p>微信公众号接口必须以http://或https://开头，分别支持80端口和443端口</p>
<p>4.涉及<strong>用户数据</strong>：</p>
<ul>
<li>您的服务需要收集用户任何数据的，必须事先获得用户的明确同意，且仅应当收集为运营及功能实现目的而必要的用户数据， 同时应当告知用户相关数据收集的目的、范围及使用方式等，保障用户知情权。</li>
<li>您收集用户的数据后，必须采取必要的保护措施，防止用户数据被盗、泄漏等。</li>
<li>您在特定微信公众号中收集的用户数据仅可以在该特定微信公众号中使用，不得将其使用在该特定微信公众号之外或为其他任何目的进行使用，也不得以任何方式将其提供给他人。</li>
<li>如果腾讯认为您收集、使用用户数据的方式，可能损害用户体验，腾讯有权要求您删除相关数据并不得再以该方式收集、使用用户数据。</li>
<li>一旦您停止使用本服务，或腾讯基于任何原因终止您使用本服务，您必须立即删除全部因使用本服务而获得的数据（包括各种备份）， 且不得再以任何方式进行使用。</li>
</ul>
<p>其他规范：</p>
<ul>
<li>请勿为任何用户自动登录到微信公众平台提供代理身份验证凭据。</li>
<li>请勿提供跟踪功能，包括但不限于识别其他用户在个人主页上查看、点击等操作行为。</li>
<li>请勿自动将浏览器窗口定向到其他网页。</li>
<li>请勿设置或发布任何违反相关法规、公序良俗、社会公德等的玩法、内容等。</li>
<li>请勿公开表达或暗示，您与腾讯之间存在合作关系，包括但不限于相互持股、商业往来或合作关系等，或声称腾讯对您的认可。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/" data-id="ckno8ff6f004yswwdazrahu2m" data-title="微信开发" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E8%BF%B0/" rel="tag">概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%88%E6%9C%AC/" rel="tag">版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%84%E8%8C%83/" rel="tag">规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">概述</a> <a href="/tags/%E7%89%88%E6%9C%AC/" style="font-size: 10px;">版本</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E8%A7%84%E8%8C%83/" style="font-size: 10px;">规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/19/19.4.SVN/">SVN</a>
          </li>
        
          <li>
            <a href="/2021/04/19/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/">WEB之上传和下载</a>
          </li>
        
          <li>
            <a href="/2021/04/19/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/">WEB之listener和filter</a>
          </li>
        
          <li>
            <a href="/2021/04/19/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/">WEB之cookie和session</a>
          </li>
        
          <li>
            <a href="/2021/04/19/9.6.WEB%E4%B9%8Bajax/">WEB之ajax</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>