<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/7/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-json" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/json/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T07:29:29.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/json/">json</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson">FastJson</a>: 阿里巴巴开发的 JSON 库，性能十分优秀</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在 Maven 构建的项目中，在 pom.xml 文件中加入以下依赖即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>从 Java 变量到 JSON 格式的编码过程如下：</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">	JSONObject object = <span class="keyword">new</span> JSONObject();    </span><br><span class="line">    <span class="comment">//string    </span></span><br><span class="line">	object.put(<span class="string">&quot;string&quot;</span>,<span class="string">&quot;string&quot;</span>);    </span><br><span class="line">    <span class="comment">//int    </span></span><br><span class="line">	object.put(<span class="string">&quot;int&quot;</span>,<span class="number">2</span>);    </span><br><span class="line">    <span class="comment">//boolean    </span></span><br><span class="line">	object.put(<span class="string">&quot;boolean&quot;</span>,<span class="keyword">true</span>);    </span><br><span class="line">    <span class="comment">//array    </span></span><br><span class="line">	List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);    </span><br><span class="line">	object.put(<span class="string">&quot;list&quot;</span>,integers);    </span><br><span class="line">    <span class="comment">//null    </span></span><br><span class="line">	object.put(<span class="string">&quot;null&quot;</span>,<span class="keyword">null</span>);     </span><br><span class="line">	System.out.println(object); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，首先建立一个 JSON 对象，然后依次添加字符串、整数、布尔值以及数组，最后将其打印为字符串。</p>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;boolean&quot;:true,&quot;string&quot;:&quot;string&quot;,&quot;list&quot;:[1,2,3],&quot;int&quot;:2&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>从 JSON 对象到 Java 变量的解码过程如下：</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    JSONObject object = JSONObject.parseObject(<span class="string">&quot;&#123;\&quot;boolean\&quot;:true,\&quot;string\&quot;:\&quot;string\&quot;,\&quot;list\&quot;:[1,2,3],\&quot;int\&quot;:2&#125;&quot;</span>);  </span><br><span class="line">    <span class="comment">//string  </span></span><br><span class="line">    String s = object.getString(<span class="string">&quot;string&quot;</span>);  System.out.println(s);  </span><br><span class="line">    <span class="comment">//int  </span></span><br><span class="line">    <span class="keyword">int</span> i = object.getIntValue(<span class="string">&quot;int&quot;</span>);  System.out.println(i);  </span><br><span class="line">    <span class="comment">//boolean  </span></span><br><span class="line">    <span class="keyword">boolean</span> b = object.getBooleanValue(<span class="string">&quot;boolean&quot;</span>);  System.out.println(b);  </span><br><span class="line">    <span class="comment">//list  </span></span><br><span class="line">    List&lt;Integer&gt; integers = JSON.parseArray(object.getJSONArray(<span class="string">&quot;list&quot;</span>).toJSONString(),Integer.class);  			              integers.forEach(System.out::println);  </span><br><span class="line">    <span class="comment">//null  </span></span><br><span class="line">    System.out.println(object.getString(<span class="string">&quot;null&quot;</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，首先从 JSON 格式的字符串中构造一个 JSON 对象，之后依次读取字符串、整数、布尔值以及数组，最后分别打印，打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string</span><br><span class="line">2</span><br><span class="line">true</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="JSON-对象与字符串的相互转化"><a href="#JSON-对象与字符串的相互转化" class="headerlink" title="JSON 对象与字符串的相互转化"></a>JSON 对象与字符串的相互转化</h2><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>JSON.parseObject()</code></td>
<td align="left">从字符串解析 JSON 对象</td>
</tr>
<tr>
<td align="left"><code>JSON.parseArray()</code></td>
<td align="left">从字符串解析 JSON 数组</td>
</tr>
<tr>
<td align="left"><code>JSON.toJSONString(obj/array)</code></td>
<td align="left">将 JSON 对象或 JSON 数组转化为字符串</td>
</tr>
</tbody></table>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从字符串解析JSON对象  String转JSONObject</span></span><br><span class="line">JSONObject obj = JSON.parseObject(<span class="string">&quot;&#123;\&quot;runoob\&quot;:\&quot;菜鸟教程\&quot;&#125;&quot;</span>); </span><br><span class="line">JSONObject jSONObject = JSONObject.parseObject(<span class="string">&quot;&#123;\&quot;runoob\&quot;:\&quot;菜鸟教程\&quot;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串解析JSON数组  String转JSONArray</span></span><br><span class="line">JSONArray arr = JSON.parseArray(<span class="string">&quot;[\&quot;菜鸟教程\&quot;,\&quot;RUNOOB\&quot;]\n&quot;</span>); </span><br><span class="line">JSONArray jsonArray= JSONArray.parseArray(<span class="string">&quot;[\&quot;菜鸟教程\&quot;,\&quot;RUNOOB\&quot;]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSONObject中的数组提取为JSONArray</span></span><br><span class="line">JSONArray jsonArray= jsonObject.getJSONArray(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSONArray提取为JSONObject</span></span><br><span class="line">JSONObject jsonObject = jsonArray.getJSONObject(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将JSON对象转化为字符串 </span></span><br><span class="line">String objStr = JSON.toJSONString(obj); </span><br><span class="line"><span class="comment">//将JSON数组转化为字符串 </span></span><br><span class="line">String arrStr = JSON.toJSONString(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map转为JSON格式的字符串</span></span><br><span class="line">Map&lt;String, Object&gt; paraMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">JSONObject.toJSONString(paraMap)</span><br><span class="line">自动过滤参数为<span class="keyword">null</span>的数值</span><br><span class="line">    </span><br><span class="line"><span class="comment">//javaBean转为JSONObject</span></span><br><span class="line">JSONObject.parseObject(JSONObject.toJSON(javaBean对象).toString())；</span><br><span class="line">    </span><br><span class="line"><span class="comment">//List&lt;实体类&gt;转String</span></span><br><span class="line">    List&lt;实体类&gt; value1 = 。。。。。。</span><br><span class="line">JSONObject.toJSONString(value1 )</span><br><span class="line">    </span><br><span class="line"><span class="comment">//JSONArray转List&lt;实体类&gt;</span></span><br><span class="line">JSONArray objects = JSONArray.parseArray(categoryConstantInfoFromRedis);</span><br><span class="line">List&lt;实体类&gt; categoryConstantInfos = objects.toJavaList(实体类名.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>找不到方法的时候，去看看JSONArray，JSONObject的源码，很多都有封装好的，你不会失望的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/16/json/" data-id="ckqk8k3dq00372wwd4nwg3pef" data-title="json" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/json/" rel="tag">json</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.11.java类型转换" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/4.11.java%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T07:17:42.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/4.11.java%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">java类型转换</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>类型列举</p>
<table>
<thead>
<tr>
<th>类型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>object</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>short</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>string</td>
<td></td>
</tr>
<tr>
<td>xml</td>
<td></td>
</tr>
<tr>
<td>json</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>bigDecimal</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> Map 与实体类相互转换：</p>
<p>1.引入fastjson依赖包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.54<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在类上引入包:<code>import com.alibaba.fastjson.JSON;</code></p>
<p>3.进行类型转换：<code>JSON.parseObject(JSON.toJSONString(源数据), 转换后数据类型.class);</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/16/4.11.java%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" data-id="ckqk8k3db001o2wwd26hr82ta" data-title="java类型转换" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.10.java扩展类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/4.10.java%E6%89%A9%E5%B1%95%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T07:17:29.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/4.10.java%E6%89%A9%E5%B1%95%E7%B1%BB/">java扩展类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>org.apache.commons.lang3包下的常用工具类</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>初学Java的时候，你应该用命令行编译过Java文件。Java代码通过javac编译成class文件，而类加载器的作用，就是把class文件装进虚拟机。</p>
<blockquote>
<p>面试请回答：将“通过类的全限定名获取描述类的二进制字节流”这件事放在虚拟机外部，由应用程序自己决定如何实现。</p>
</blockquote>
<p>宏观来看，只有两种类加载器：<strong>启动类加载器、其他类加载器。</strong></p>
<p><strong>启动类加载器</strong>属于虚拟机的一部分，它是用C++写的，看不到源码；<strong>其他类加载器</strong>是用Java写的，说白了就是一些Java类，一会儿就可以看到了，比如<strong>扩展类加载器、应用类加载器。</strong></p>
<ul>
<li>启动类加载器：BootstrapClassLoader</li>
<li>扩展类加载器：ExtentionClassLoader</li>
<li>应用类加载器：AppClassLoader （也叫做“系统类加载器”）</li>
</ul>
<p>既然只是把class文件装进虚拟机，为什么要用多种加载器呢？因为Java虚拟机启动的时候，并不会一次性加载所有的class文件（内存会爆），而是根据需要去动态加载。</p>
<h2 id="一、它们分别加载了什么？"><a href="#一、它们分别加载了什么？" class="headerlink" title="一、它们分别加载了什么？"></a>一、它们分别加载了什么？</h2><p>类加载器是通过类的<strong>全限定名</strong>（或者说<strong>绝对路径</strong>）来找到一个class文件的。可以直接打印启动类加载器BootstrapClassLoader的加载路径看看：</p>
<blockquote>
<p>这一小节里，你只关心输出结果就可以了，反正这些API我也是现查的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">    System.out.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果（%20是空格）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/resources.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/rt.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/sunrsasign.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/jsse.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/jce.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/charsets.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/jfr.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/classes</span><br></pre></td></tr></table></figure>

<p>可以看到，启动类加载器加载的是<strong>jre和jre/lib目录下的核心库，</strong>具体路径要看你的jre安装在哪里。再打印一下扩展类加载器ExtentionClassLoader的加载路径看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL[] urls = ((URLClassLoader) ClassLoader.getSystemClassLoader().getParent()).getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">    System.out.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/access-bridge-64.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/cldrdata.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/dnsns.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/dns_sd.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/jaccess.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/jfxrt.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/localedata.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/nashorn.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/sunec.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/sunjce_provider.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/sunmscapi.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/sunpkcs11.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jre1.8.0_131/lib/ext/zipfs.jar</span><br></pre></td></tr></table></figure>

<p>很明显，扩展类加载器加载的是<strong>jre/lib/ext目录下的扩展包。</strong>这些类库具体是什么不重要，只需要知道不同的类库可能是被不同的类加载器加载的。</p>
<blockquote>
<p>JVM是怎么知道我们把JRE安装到哪里了呢？因为你安装完JDK之后配置了环境变量啊！那些 JAVA_HOME、CLASSPATH 之类的就是干这个用的。</p>
</blockquote>
<p>最后是AppClassLoader：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL[] urls = ((URLClassLoader) ClassLoader.getSystemClassLoader()).getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">    System.out.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:/D:/JavaWorkSpace/PicklePee/bin/</span><br></pre></td></tr></table></figure>

<p>这是当前java工程的bin目录，也就是<strong>我们自己的Java代码编译成的class文件所在。</strong></p>
<h2 id="二、Java虚拟机的入口"><a href="#二、Java虚拟机的入口" class="headerlink" title="二、Java虚拟机的入口"></a><strong>二、Java虚拟机的入口</strong></h2><p>当我们运行一个Java程序时，首先是JDK安装目录下的jvm.dll启动虚拟机，而sun.misc.<strong>Launcher</strong>类就是虚拟机执行的第一段Java代码。之前提到，除BootstrapClassLoader以外，其他的类加载器都是用Java实现的——在Launcher里你就可以看到它们。</p>
<p>以下是sun.misc.Launcher的精简版源码，阅读起来应该毫无难度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> ClassLoader appClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动类加载器不是Java类，我们这里拿到的是其加载路径字符串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath = System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassLoader extentionClassLoader; <span class="comment">// 扩展类加载器在这里</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            extentionClassLoader = ExtClassLoader.getExtClassLoader(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="comment">// 应用类加载器在这里，get时把扩展类加载器作为参数，后面我们会回到这里。</span></span><br><span class="line">            appClassLoader = AppClassLoader.getAppClassLoader(extentionClassLoader); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">    &#125;	</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 静态内部类：扩展类加载器，父类是URLClassLoader</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类：应用类加载器，父类是URLClassLoader</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URLStreamHandlerFactory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">URLStreamHandlerFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> URLStreamHandler <span class="title">createURLStreamHandler</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/* 创建一个文件句柄（File Handler）</span></span><br><span class="line"><span class="comment">               我们硬盘上的class文件就是通过这个句柄进入内存 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，扩展类加载器和应用类加载器都是Launcher里的静态内部类。它们都是调用了自己的静态方法getExtClassLoader返回自己的实例，看一下发生了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 扩展类加载器是Launcher的静态内部类，这里只是把它单独拎出来了 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] dirs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 交给了父类URLClassLoader处理。中间的参数是null，它是什么呢？</span></span><br><span class="line">        <span class="keyword">super</span>(getExtURLs(dirs), <span class="keyword">null</span>, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File[] dirs = getExtDirs();</span><br><span class="line">        ExtClassLoader extentionClassLoader = <span class="keyword">new</span> ExtClassLoader(dirs);</span><br><span class="line">        <span class="keyword">return</span> extentionClassLoader</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">	<span class="comment">// 就这样拿到了扩展类加载器的加载路径，这跟第一小节我们打印的路径是一样的。</span></span><br><span class="line">	String s = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">	File[] dirs;</span><br><span class="line">	... 按照;分割字符串s，转化为一个File数组 ...</span><br><span class="line">	<span class="keyword">return</span> dirs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚传了三个参数给父类URLClassLoader的构造器，继续深入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLClassLoader</span> <span class="keyword">extends</span> <span class="title">SecureClassLoader</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;URL&gt; path = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent); <span class="comment">// 第二个参数null是这里的parent，然后又再次扔给了父类</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 保存这些类库的路径并创建一个获取jar文件的句柄，想干什么已经很明显了 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">            path.add(urls[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jarHandler = factory.createURLStreamHandler(<span class="string">&quot;jar&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>URLClassLoader继续把这个null扔给父类SecureClassLoader？看看它要做什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecureClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SecureClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么也没干，直接扔给了父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent; <span class="comment">// parent最终是ClassLoader里的全局变量</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们从子类到达这里</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 默认parent是系统(应用)类加载器！</span></span><br><span class="line">        <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 防止恶意代码对系统产生影响，有兴趣可以搜索Java安全管理器 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Void <span class="title">checkCreateClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkCreateClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于到头了，从扩展类加载器的getExtClassLoader()一路走来，发现参数null传给了最顶层ClassLoader的全局变量parent，看一下关系图：</p>
<p><img src="/4.10.java%E6%89%A9%E5%B1%95%E7%B1%BB/v2-da85d259f824126fd8e4c6f6e98e72bf_720w.jpg" alt="img"></p>
<p>你可能注意到，JDK总是通过一个类似System.getProperty(“xxx”)的方法来获取class文件路径。这个字符串参数到底是哪来的呢？其实它可以在虚拟机启动时手动赋值。比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -D java.ext.dirs=路径 MyClass  //这样自定义的路径将覆盖Java本身的拓展类路径</span><br><span class="line">还有一个命令是 -Xbootclasspath 可以改变核心类库的加载路径，知道有这回事儿就行了，最好别用。</span><br></pre></td></tr></table></figure>

<p>回到源码，还记得一开始Launcher类里，得到应用类加载器的这行代码吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appClassLoader = AppClassLoader.getAppClassLoader(extentionClassLoader); </span><br></pre></td></tr></table></figure>

<p>它把创建的扩展类加载器作为参数传给了应用类加载器，进去看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader extcl)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String s = System.getProperty(<span class="string">&quot;java.class.path&quot;</span>); <span class="comment">// 得到应用类加载器的加载路径</span></span><br><span class="line">	<span class="keyword">final</span> File[] path = getClassPath(s);</span><br><span class="line">        URL[] urls = pathToURLs(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传入的扩展类加载器extcl在这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppClassLoader(urls, extcl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AppClassLoader(URL[] urls, ClassLoader parent) &#123;</span><br><span class="line">        <span class="comment">// AppClassLoader的父类也是URLClassLoader，只不过第二个参数由null变为扩展类加载器</span></span><br><span class="line">	<span class="keyword">super</span>(urls, parent, factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此应该一切都清晰了，后面的过程与扩展类加载器一样！只不过最终的parent参数会被赋值为扩展类加载器（extcl）而不是null。扯了这么多，这个parent到底是干什么的？</p>
<h2 id="三、父加载器"><a href="#三、父加载器" class="headerlink" title="三、父加载器"></a><strong>三、父加载器</strong></h2><p>ClassLoader里的parent是<strong>父加载器</strong>。刚刚看了类加载器的继承关系图，但是<strong>父加载器不是父类，这是两个不同的概念。</strong>看一下前面ClassLoader的getParent()方法，任何一个类加载器调用此方法得到的对象就是它的父加载器。</p>
<p><img src="/4.10.java%E6%89%A9%E5%B1%95%E7%B1%BB/v2-8d95137175db949b1260607d087d6398_720w.jpg" alt="img">AppClassLoader的父类是URLClassLoader，但是它的父加载器是ExtentionClassLoader。</p>
<p>除了启动类加载器（BootstrapClassLoader），每个类加载器都有一个<strong>父加载器</strong>。比如刚才的应用类加载器，它的父加载器是扩展类加载器。你可能会说扩展类加载器的parent是null，所以它没有父加载器？</p>
<p>有，它的父加载器就是BootstrapClassLoader。<strong>任何parent为null的加载器，其父加载器为BootstrapClassLoader</strong>，先记住这个结论，很快你会看到原因。</p>
<p>最后一个问题，如果你直接继承ClassLoader自己实现一个类加载器，<strong>且不指定父加载器</strong>，那么这个自定义类加载器的父加载器是什么？</p>
<p>是应用类加载器AppClassLoader。可以拉回去看看ClassLoader的无参构造器。</p>
<p><img src="/4.10.java%E6%89%A9%E5%B1%95%E7%B1%BB/v2-ccaa3b0b08153ff02c3525567ca35005_720w.jpg" alt="img">父加载器关系</p>
<h2 id="四、双亲委派模型"><a href="#四、双亲委派模型" class="headerlink" title="四、双亲委派模型"></a>四、双亲委派模型</h2><p>有一个描述类加载器加载类过程的术语：<strong>双亲委派模型</strong>。然而这是一个很有误导性的术语，它应该叫做<strong>单亲委派模型</strong>（Parent-Delegation Model）。但是没有办法，大家都已经这样叫了。所谓双亲委派，这个<strong>亲</strong>就是指ClassLoader里的全局变量parent，也就是<strong>父加载器</strong>。</p>
<p>双亲委派的具体过程如下：</p>
<ol>
<li>当一个类加载器接收到类加载任务时，<strong>先查缓存</strong>里有没有，如果没有，将任务<strong>委托给它的父加载器</strong>去执行。</li>
<li>父加载器也做同样的事情，一层一层往上委托，直到<strong>最顶层的启动类加载器</strong>为止。</li>
<li>如果启动类加载器没有找到所需加载的类，便将此加载任务<strong>退回给下一级类加载器</strong>去执行，而下一级的类加载器也做同样的事情。</li>
<li>如果最底层类加载器仍然没有找到所需要的class文件，则抛出异常。</li>
</ol>
<p>所以是一条线传上再传下，并没有什么“双亲”。整个过程的Java实现也没有什么神秘的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// name: Class文件的绝对路径</span></span><br><span class="line">    <span class="comment">// resolve: 找到后是否立即解析（什么是解析？）</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 尝试从缓存获取，这也是为什么修改了Class后需重启JVM才能生效</span></span><br><span class="line">            Class&lt;?&gt; target = findLoadedClass(name); <span class="comment">// native方法</span></span><br><span class="line">            <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 委托给父加载器， 只查找不解析</span></span><br><span class="line">                        target = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 父加载器为null，则委托给启动类加载器BootstrapClassloader</span></span><br><span class="line">                        target = findBootstrapClassOrNull(name); <span class="comment">// native方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;...&#125;</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">                <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 父加载器没有找到，才调用自己的findClass()方法</span></span><br><span class="line">                    target = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(target); <span class="comment">// native方法</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// findClass是模板方法，需要重写</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么是解析？把符号引用变为直接引用。比如com.test.Car里面有一个com.test.Wheel类，在编译时Car类并不知道Wheel类的实际内存地址，此时com.test.Wheel只是一个符号。“解析”的意思就是把被引用的类加载入内存，然后将com.test.Wheel这个符号变成一个指针，能够定位到内存中目标。</p>
</blockquote>
<p>到现在就剩下findClass这个模板方法了，URLClassLoader继承了ClassLoader以后，重写了此方法，做了三件事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 1、安全检查</span></span><br><span class="line">    <span class="comment">// 2、根据绝对路径把硬盘上class文件读入内存</span></span><br><span class="line">    <span class="keyword">byte</span>[] raw = getBytes(name); </span><br><span class="line">    <span class="comment">// 3、将二进制数据转换成class对象</span></span><br><span class="line">    <span class="keyword">return</span> defineClass(raw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们自己去实现一个类加载器，基本上就是<strong>继承ClassLoader之后重写findClass方法，且在此方法的最后调包defineClass。</strong></p>
<h2 id="五、为什么要双亲委派？"><a href="#五、为什么要双亲委派？" class="headerlink" title="五、为什么要双亲委派？"></a>五、为什么要双亲委派？</h2><p><strong>确保类的全局唯一性</strong>。</p>
<p>如果你自己写的一个类与核心类库中的类重名，会发现这个类可以被正常编译，但永远无法被加载运行。因为你写的这个类<strong>不会被应用类加载器加载</strong>，而是被委托到顶层，被启动类加载器在核心类库中找到了。如果没有双亲委托机制来确保类的全局唯一性，谁都可以编写一个java.lang.Object类放在classpath下，那应用程序就乱套了。</p>
<p>从安全的角度讲，通过双亲委托机制，Java虚拟机总是先从最可信的Java核心API查找类型，可以防止不可信的类假扮被信任的类对系统造成危害。</p>
<h2 id="六、所以知道这些到底有什么用？"><a href="#六、所以知道这些到底有什么用？" class="headerlink" title="六、所以知道这些到底有什么用？"></a>六、所以知道这些到底有什么用？</h2><ol>
<li>面试。</li>
<li>研究Tomcat、JBoss等Servlet容器原理，可能得另开一篇了。</li>
<li>如果你不想自己的代码被反编译，可以将编译后的代码加密，用自己的类加载器解密。</li>
<li>我编不下去了。</li>
</ol>
<p><img src="/4.10.java%E6%89%A9%E5%B1%95%E7%B1%BB/v2-348b8099549c5407ffe9b99ef8ec88ac_r.jpg" alt="preview"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/16/4.10.java%E6%89%A9%E5%B1%95%E7%B1%BB/" data-id="ckqk8k3db001n2wwdab071d4f" data-title="java扩展类" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-19.1.git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/19.1.git/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T04:46:21.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/19.1.git/">git</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git是目前世界上最先进的分布式版本控制系统。<br>Linus在1991年创建了开源的Linux,从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux,但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，<strong>在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus,然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN,这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper,BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</strong>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个）,被BitMover公司发现了（监控工作做得不错！),于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后会严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：<br>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git!一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub,包括jQuery,PHP,Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>版本控制：可以解决多人同时开发的代码问题，也可以解决找回历史代码的问题。</p>
<p>分布式：Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。首先找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器“仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。可以自已搭建这台服务器，也可以使用GitHub网站。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>傻瓜式安装</p>
<h1 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h1><h2 id="在Windows的cmd-中使用linux的命令"><a href="#在Windows的cmd-中使用linux的命令" class="headerlink" title="在Windows的cmd 中使用linux的命令"></a>在Windows的cmd 中使用linux的命令</h2><p>cmd的命令功能肯定没有linux的命令功能好用，这点毋庸置疑。现在装好了Git，就可以在Windows的cmd中使用linux命令了。<br>关键词：环境变量 Git命令<br>怎么玩？如下2步操作：<br>假如你按照上述步骤将Git装在C盘，那么做如下操作：<br>操作1：找Git命令的【.exe文件】。</p>
<p>操作2：添加到环境变量，就可以在cmd里使用linux命令了。</p>
<p>最终效果：</p>
<p>PyCharm也可以使用linux命令。【环境变量–全局—使用】</p>
<p>备注：你可能需要关闭之前打开的cmd窗口/PyCharm窗口，重新打开新的cmd窗口//PyCharm窗口，使用命令才可能生效。<br>【效率会提高一点点】</p>
<h2 id="创建一个版本库"><a href="#创建一个版本库" class="headerlink" title="创建一个版本库"></a>创建一个版本库</h2><p>(1)新建一个目录git_test,在git_test目录下创建一个版本库，命令如下：</p>
<p>接着初始化仓库</p>
<p>说明：可以看到在git_test目录下创建了一个.git隐藏目录，这就是版本库目录。</p>
<p>4.版本的创建与回退<br>4.1 使用<br>(1)在git_test目录下创建一个文件code.txt,编辑内容如下：</p>
<p>(2)使用如下两条命令可以创建一个版本：<br>git add code.txt<br>git commit -m “版本1”</p>
<p>(3)使用如下命令可以查看版本记录：<br>git log</p>
<p>(4)继续编辑code.txt,在里面增加一行。</p>
<p>(5)使用如下命令再创建一个版本并查看版本记录：</p>
<p>(6)现在若想回到某一个版本，可以使用如下命令：</p>
<p>其中HEAD表示当前最新版本【请记死】，HEAD^表示当前版本的前一个版本，HEAD^^表示当前版本的前前个版本，也可以使用HEAD<del>1表示当前版本的前一个版本，HEAD</del>100表示当前版本的前100版本。</p>
<p>因为版本1的内容是1行：<br>this is the first line</p>
<p>因为版本2的内容是2行：<br>this is the first line<br>this is the second line</p>
<p>因为<br>$ git reset –hard HEAD^ HEAD is now at 51d36c7 版本1<br>使指针HEAD指向（倒退）到版本1，<br>因此打印的内容就是版本1的内容，即this is the first line</p>
<p>(7)假如我们现在又想回到版本2,这个时候怎么办？可以使用如下命令：<br>git reset –hard 版本号</p>
<p>（8）在终端执行如下命令：</p>
<p>版本2又回来了，内容也是原来的内容。</p>
<p>接着玩</p>
<p>退出终端，再重进：</p>
<p>这个重进终端的操作让我们看不到版本2的版本号，要回到版本2怎么办？<br>命令：git reflog来查看操作记录。</p>
<p>错误示例：<br>原因是按照当前版本1倒退的话，怎么也不会前进到版本2吧？逻辑错误。</p>
<p>正确实例：<br>要用到版本号。</p>
<p>查看版本2的内容：</p>
<p>不理解版本1，版本2有啥区别？<br>这个东西像游戏更新一样，版本2是在版本1的基础上添加新功能的，版本1内容不发生改变。例如王者荣耀版本更新，界面总会变化，但是英雄的属性（技能，名字）一般不会改变。</p>
<p>4.2 工作区和缓存区<br>4.2.1 工作区（WorkingDirectory)<br>工作区（WorkingDirectory) 电脑中的目录，比如我们的git_test,就是一个工作区。</p>
<p>4.2.2 版本库（Repository)<br>工作区有一个隐藏目录.git,这个不是工作区，而是git的版本库。git的版本库里存了很多东西，其中最重要的就是称为stage(或者叫index)的<br>暂存区，<br>还有git为我们自动创建的第一个分支master,以及指向master的一个指针叫HEAD。</p>
<p>因为我们创建git版本库时，git自动为我们创建了唯一一个master分 支，所以，现在，git commit就是往master分支上提交更改。<br>你可以简单理解为，需要提交的文件修改通通放到暂存区【计算机的缓存区】，然后，一次性提交暂存区的所有修改。</p>
<p>前面讲了我们把文件往版本库里添加的时候，是分两步执行的：<br>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区<br>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>(1)下面在git test目录下再创建一个文件code2.txt,然后编辑内容如下：</p>
<p>(2)然后编辑code.txt,操作如下：</p>
<p>注意的是创建文件和编辑文件都是在工作区里完成。<br>（3）使用如下命令查看当前工作树的状态：<br>git status</p>
<p>翻译一下：</p>
<p>上面提示我们code.txt被修改，而code2.txt没有被跟踪。</p>
<p>(4)我们使用如下命令把code.txt和code2.txt加入到暂存区，然后再执行git status命令，结果如下：</p>
<p>注意：所有的 git add 命令是把所有提交的修改存放到暂存区。</p>
<p>(5)然后，执行git commit就可以一次性把暂存区的所有修改提交到分支并创建一个版本。</p>
<p>注意：指针HEAD永远指向当前版本。此时当前版本是版本3。</p>
<p>(6)一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。执行如下命令可以发现：</p>
<p>现在我们的版本库变成了酱紫：</p>
<p>4.3 管理修改<br>git管理的文件的修改，它只会提交暂存区的修改来创建版本。<br>(1)编辑code.txt,并使用git add命令将其添加到暂存区中。</p>
<p>(2)继续编辑code.txt,并在其中添加一行。</p>
<p>(3)git commit创建一个版本，并使用git status查看，发现第二次修改code.txt内容之后，并没有将其添加的工作区，所以创建版本的时候并没有被提交。</p>
<p>注意：对于code.txt里的四行内容，每一个版本对应一行，例如版本1对应first line，以此类推。</p>
<p>4.4 撤销修改<br>(1)继续上面的操作，提示我们可使用git checkout – &lt;文件&gt;来丢弃工作区的改动。执行如下命令，发现工作区干净了，第二次的改动内容也没了。</p>
<p>(2)我们继续编辑code.txt,并在其中添加如下内容，并将其添加的暂存区。</p>
<p>(3)git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉，重新放回工作区。</p>
<p>(4)现在若想丢弃code.txt的修改，执行如下命令即可。</p>
<p>现在，如果你不但改错了东西，还从暂存区提交到了版本库，则需要进行版本回退。</p>
<p>小结：<br>场景1:当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用 命令git checkout – file<br>场景2:当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步：<br>第一步用命令git reset HEAD – file,就回到了场景1,<br>第二步按场景1操作。<br>场景3:已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节。</p>
<p>4.5 对比文件的不同<br>对比工作区和某个版本中文件的不同：</p>
<p>(1)继续编辑文件code.txt,在其中添加一行内容。</p>
<p>(2)现在要对比工作区中code.txt和HEAD版本中code.txt的不同。使用如下命令：</p>
<p>(3)使用如下命令丢弃工作区的改动。</p>
<p>对比两个版本间文件的不同：<br>(1)现在要对比HEAD和HEAD ^版本中code.txt的不同，使用如下命令：</p>
<p>反过来</p>
<p>4.6 删除文件<br>(1)我们把目录中的code2.txt删除。</p>
<p>这个时候，git知道删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻提示哪些文件被删除了。</p>
<p>(2)现在你有两个选择，一种情况是确实要从版本库中删除该文件，那就用命令 gitrm删掉【永久删除，无法撤消】，并且 git commit:</p>
<p>另一种情况是删错了，可以直接使用git checkout – code2.txt,这样文件code2.txt又回来了。<br>注意：两种情况有区别：<br>当执行第一种情况时【永久删除，无法撤消】，再执行第二种情况，会报错：</p>
<p>加长版：</p>
<p>简短版：</p>
<p>小结：<br>命令rm 删除是永久删除，要恢复数据的话可以恢复/扫描硬盘；<br>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<ol start="5">
<li>分支管理</li>
<li>1概念<br>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。<br>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了git又学会了SVN!</li>
</ol>
<p>分支在实际中有什么用呢？<br>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>5.2 创建与合并分支<br>git把我们之前每次提交的版本串成一条时间线，这条时间线就是一个分支。截止到目前只有一条时间线，在git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master,master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>(1)一开始的时候，master分支是一条线，git用master指向最新的提交，再用HEAD指向master,就能确定当前分支，以及当前分支的提交点：</p>
<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。<br>(2)当我们创建新的分支，例如dev时，git新建了一个指针叫dev,指向master相同的提交，再把HEAD指向dev,就表示当前分支在dev上：</p>
<p>git创建一个分支很快，因为除了增加一个dev指针，改变HEAD的指向，工作区的文件都没有任何变化。</p>
<p>(3)不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p>
<p>(4)假如我们在dev上的工作完成了，就可以把dev合并到master上。git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<p>git合并分支也很快，就改改指针，工作区内容也不变。<br>（5）合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<p>(1)执行如下命令可以查看当前有几个分支并且看到在哪个分支下工作。</p>
<p>(2)下面创建一个分支dev并切换到其上进行工作。</p>
<p>(3)下面我们修改code.txt内容，在里面添加一行，并进行提交。</p>
<p>(4)dev分支的工作完成，我们就可以切换回master分支：</p>
<p>查看code.txt,发现添加的内容没有了。因为那个提交是在dev分支上，而master分支此刻的提交点并没有变。【这里需要细细品味一下】</p>
<p>(5)现在，我们把dev分支的工作成果合并到master分支上：<br>git merge命令用于合并指定分支到当前分支。合并后，再查看code.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的rast-forward信息，Git告诉我们，这次合并是“快进模式“，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>(6)合并完成后，就可以放心地删除dev分支了，删除后，查看branch,就只剩下master分支了。</p>
<p>小结：<br>查看分支：git branch<br>创建分支：git branch <name><br>切换分支：git checkout <name><br>创建+切换分支：git checkout -b <name><br>合并某分支到当前分支：git merge <name><br>删除分支：git branch -d <name></p>
<p>5.3 解决冲突<br>合并分支往往也不是一帆风顺的。<br>(1)再创建一个新分支dev。</p>
<p>(2)修改code.txt内容，并进行提交。</p>
<p>(3)切换回master分支。</p>
<p>(4)在master的code.txt添加一行内容并进行提交。</p>
<p>这种情况下，git无法执行”快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。</p>
<p>(5)执行如下命令尝试将dev分支合并到master分支上来。</p>
<p>冲突原因：<br>现在，master分支和dev分支各自都分别有新的提交，并且编辑了同一个文件，变成了这样：</p>
<p>git告诉我们，code.txt文件存在冲突，必须手动解决冲突后再提交。</p>
<p>最重要的一步：</p>
<p>(6)git status也可以告诉我们冲突的文件：</p>
<p>(7)查看code.txt的内容。</p>
<p>(8)git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,========,&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记不同分支的内容，我们修改如下后保存：</p>
<p>(9)再提交。</p>
<p>(10)现在，master分支和dev分支变成了下图所示：</p>
<p>(11)用带参数的git log也可以看到分支的合并情况：</p>
<p>(12)最后工作完成，可以删除dev分支：</p>
<p>5.4 分支管理策略<br>通常，合并分支时，如果可能，git会用fast forward模式，但是有些快速合并不能成功而且合并时没有冲突，这个时候git会帮我们在合并之后做一次新的提交，但这种模式下，删除分支后，会丢掉分支信息。【弹窗说明信息】</p>
<p>(1)创建切换到dev分支下。</p>
<p>(2)新建一个文件code3.txt,编辑内容如下，并提交一个commit。</p>
<p>(3)切换回master分支，编辑code.txt并进行一个提交。</p>
<p>(4)合并dev分支的内容到master分支。</p>
<p>(5)出现如下提示时，这是因为这次不能进行快速合并，所以git提示输入合并说明信息，输入之后合并内容之后git会自动创建一次新的提交。</p>
<p>按 :x保存并退出。</p>
<p>(6)使用分支命令查看分支信息。</p>
<p>(7)删除dev分支。</p>
<p>如果要强制禁用fast forward模式，git就会在merge时生成一个新的commit,这样，从分支历史上就可以看出分支信息。<br>(1)创建并切换到dev分支。</p>
<p>(2)修改code.txt内容，并提交一个commit。</p>
<p>(3)切换回master分支。</p>
<p>（4）准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward:</p>
<p>因为本次合并要创建一个新的commit,所以加上-m参数，把commit描述写进去。</p>
<p>5.5 Bug分支<br>软件开发中，bug就像家常便饭一样，有了bug就需要修复，在git中，由于分支是如此的强大，所以，<br>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>(1)当你接到一个修复一个代号001的bug的任务时，很自然地，你想创建一个分支bug-001来修复它，但是，等等，当前正在dev上进行的工作还没有提交：<br>建议先敲clear清屏。</p>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug,怎么办？</p>
<p>(2)git还提供了一个stash功能，可以把当前工作现场“储藏“起来，等以后恢复现场后继续工作：【工作中可能会用到，在git pull之前先用这条命令。放入缓存是git stash，相对应的git stash pop从缓存中释放出来】</p>
<p>更多请参考：传送门<br>(3)首先确定要在哪个分支上修复bug,假定需要在master分支上修复，就从master创建临时分支：</p>
<p>(4)现在修复bug,这里假设把code.txt里的第9行删掉，然后提交。</p>
<p>(5)修复完成后，切换到master分支，并完成合并，最后删除bug-001分支。</p>
<p>(6)现在bug-001修复完成，是时候接着回到dev分支干活了！</p>
<p>(7)工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：【帮助我们列出保存的工作现场】</p>
<p>工作现场还在，git把stash内容存在某个地方了，需要恢复一下：</p>
<p>小结：<br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug,修复后，再git stash pop,恢复工作现场。</p>
<p>6.使用github<br>6.1 创建仓库<br>(1)注册github账户</p>
<p>登录后，点击”New respository”</p>
<p>(2)在新页面中，输入项目的名称【如2020】，勾选’readme.md’,点击’Create repository’</p>
<p>这里完成。</p>
<p>6.2 添加ssh账户<br>(1)点击账户头像后的下拉三角，选择’settings’如果某台机器需要与github上的仓库交互，那么就要把这台机器的ssh公钥添加到这个github账户上。</p>
<p>(2)在git的命令行中，回到用户的主目录下，编辑文件.gitconfig,修改某台机器的git配置。<br>修改为注册github时的邮箱，填写用户名。</p>
<p>完美：</p>
<p>6.3 克隆项目</p>
<p>接着：</p>
<p>6.4 上传分支/推送代码<br>(1)项目克隆到本地之后，执行如下命令创建分支：</p>
<p>(2)创建一个views.py并提交一个版本：</p>
<p>(3)推送前github上文件列表如下图:</p>
<p>(4)推送前github上分支列表如下图:</p>
<p>(5)推送分支，就是把该分支上的所有本地提交推送到远程库，推送时要指定本地分支，这样，git就会把该分支推送到远程库对应的远程分支上：<br>git push origin 分支名称<br>例：<br>git push origin smart</p>
<p>（6）再次查看github分支：<br>接下来操作重新加载页面：</p>
<p>点击smart,再点击views.py,如图所示：</p>
<p>6.5 将本地分支跟踪服务器分支<br> git branch –set-upstream-to=origin/远程分支名称 本地分支名称<br>1<br>例：</p>
<p>  git branch –set-upstream-to=origin/smart smart<br>1</p>
<p>我的社交网址：<a target="_blank" rel="noopener" href="https://github.com/Keegan-y">https://github.com/Keegan-y</a></p>
<p>6.6 从远程分支上拉取代码<br>git pull orgin 分支名称<br>例：<br>git pull orgin smart<br>使用上述命令会把远程分支smart上的代码下载并合并到本地所在分支。</p>
<p>7.工作使用git<br>不墨迹直接上代码：<br>loading…<br>项目经理：<br>(1)项目经理搭建项目的框架。<br>(2)搭建完项目框架之后，项目经理把项目框架代码放到服务器。</p>
<p>普通员工：<br>(1)在自己的电脑上，生成ssh公钥，然后把公钥给项目经理，项目经理把它添加的服务器上面。<br>(2)项目经理会给每个组员的项目代码的地址，组员把代码下载到自己的电脑上。<br>(3)创建本地的分支dev,在dev分支中进行每天的开发。<br>(4)每一个员工开发完自己的代码之后，都需要将代码发布远程的dev分支上。</p>
<p>项目里一般会有两个分支，如：<br>Master:用于保存发布的项目代码。<br>Dev:用于保存开发过程中的代码。所有的组员开发完自己的代码提交到该分支上。<br>补充小技巧：<br>首先，整体认知一下工作中git常用的就这么几个命令：<br>步骤1.创建项目目录，如git_test【强烈建议返回到2.安装配置一节，学一学在windows中用mkdir git_test。工作中点来点去，文件夹一多就不爽了，学会在windows上用linux命令，工作效率谁用谁知道<del>】<br>步骤2.git init【如果你考皮github上别人的代码，必须将别人的.git文件删掉。步骤：进入项目目录，如git_test，cd git_test，ls -al，rm -rf .git】【工作中linux必会的，赶快回到2.安装配置一节，学一学在windows使用linux命令，这样就不用装linux环境了，简单胜于复杂</del>】<br>步骤3.git add .<br>步骤4.git commit -m “整体提交”<br>步骤5.git remote add origin 【你的github/gitlab仓库地址】<br>步骤6.git checkout -b dev<br>步骤7.git push origin dev<br>当然不止于这7步，这些步骤会在你的实践中不断升华，壮大<del>。<br>先把git玩起来再说，否则很容易从入门到放弃。先玩起来</del><br>步骤操作如图所示：</p>
<p>可以看到，代码推到仓库了。<br>掌握了上面基本命令，记住使用步骤，强烈建议建议建议你在PyCharm/Goland上操作git，能可视化+带提示帮你提交代码，解决冲突【你在git bash里搞不定冲突，在PyCharm/Goland上操作一看就知道怎么做了，人家可视化+提示，你只需要手指点一点即可，很简单，节约你的时间】，工具是个好东西，前面的步骤都是为了这样一句话铺垫：【PyCharm/Goland上玩git】<br>【不会的可以在评论区留言，我看到后会继续在后文补充。既然是git使用教程，那就是成体系的，知识技能是结构化安放的，方便查，方便增，是不？】</p>
<p>到此，git使用教程就写完了，既是自己的实践记录【记不住哈哈】，也能帮助更多的道友管理控制代码，如果内容对读者有用，请关注我，为思考点赞！</p>
<p>最后奉上导图笔记：</p>
<p>8.思维导图笔记</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/16/19.1.git/" data-id="ckqk8k3e400452wwdd618by5h" data-title="git" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-5.5.MySQL工具之Navicat" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:39:28.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/">MySQL工具之Navicat</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>安装Navicat</strong></p>
<p>因为工作原因，需要经常连接不同的数据库，这里我安装的是Navicat Premium版本，在公众号后台回复 <strong>Navicat</strong> 即可获取。</p>
<p>安装过程很简单，只要你能看懂中文，不停的下一步，等待安装完成即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2xKluMyr9zsylJ1bbEy5kAicNwLkqjO2V3j6G3XFBLhiaozUuKYzLCVkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>连接不同数据库</strong></p>
<p>这里分别介绍Oracle，MySQL，SQL Server这三种数据库的连接方法</p>
<p><strong>连接Oracle</strong></p>
<p>在连接Oracle之前我们需要先配置一下OCI文件，具体如下：</p>
<p>点开主菜单里的【工具】——【选项…】,在弹出的对话框中找的OCI选项</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ayiavVhGWNUtCxzSv7nRAL32mTpAlsHmG6XrhvA5NfV7JIUia6FnBDWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里就要把你安装的oracle的安装目录下的bin文件夹里面的oci.dll文件导入</p>
<p>E:\software\oracle\Oracle_win64\product\11.2.0\dbhome_1\BIN\oci.dll</p>
<p>以上是我的安装目录下的文件，大家根据自己的安装目录不同来导进来</p>
<p>导进来之后就重启Navicat，重启后会自动生效。</p>
<p>重启Navicat后，点击菜单栏的连接，选择Oracle，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2v4ibO1bTE1sICWwbjoGlYjlPrbKGNmCazdqNG3U4SJDY4lNvydb8vGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中做如下配置，其中连接名可以随意起，然后输入你要连接的主机名或IP地址，最后输入账号密码。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO26DXvmnuAFhema70Vibkj2nhLc13TEpb2SwxMibrVuY9ECoP4BudbRf0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你是使用DBA角色登录的，还需要点开高级选项卡，将角色选为DBA</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO225C85ic0Bd8oYibzpBoHLKtmog0ZBdlib7Pd8grxHDIia7aNwEVdfw46uA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置完了以后，我们可以点击连接测试</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2pBzAsdJSbnWUI9La2k8icmAKIbnMWpOMicy9FsgFO1CdKCiaC2p3OqUOA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">这样Oracle的连接就配置好了。</p>
<p><strong>连接MySQL和SQL Server</strong></p>
<p>MySQL和SQL Server的连接相对比较简单，只需要输入主机名或IP地址，账号密码即可，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2HxIZHHUhGKML0TC1mgA7djpa5KZ2cqyJyrW5HUAtr9xIwxAJBWxobg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2UzsMibLp6NUbiaAE5dNa09XeOjh61qyCmUib1uRzpy8p1PnwZd3FMuUxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置好后，点击连接测试，在弹出连接成功窗口就表示我们配置好了。</p>
<p>数据库连接成功后，下面是各个功能的介绍，我们以SQL Server数据库作为案例来介绍各个功能的使用。</p>
<p><strong>创建数据库</strong></p>
<p>右键我们刚新建的数据库连接——选择【新建数据库…】即可开始创建数据库了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO25lWoNb7icSiaocd6c07JMQRVdvqrXHpnPpmOWMkEXk5lSUPhTxCvE3Fg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以根据你的要求来进行配置，配置完以后，还可以在【SQL预览】看到完整的SQL代码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2f6LfOqSt2tKhHUhxV089tAicnqGw6gQr1ic6JpNzic21UDxVbicm2pul5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>数据传输</strong></p>
<p>数据传输，顾名思义就是将数据从其他地方传输到当前数据库，例如我们将SQL_Road数据库中的数据传输到刚才新建的Test数据库中。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO29JIouv6OTsvv1tVHEARMD95v6JjKVnvJ2Cw07xzqUAOPp9ktxpNueQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>右键刚才创建好的Test数据库，在弹出的选项中选择【数据传输…】，在弹出的窗口中我们配置源数据库为【SQL_Road】,目标数据库配置为【Test】，这样就可以将SQL_Road中的对象传输到Test了，支持传输的对象包括：表，视图，函数和存储过程，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2a5ovyOCg7icHWslZj0ZH0icOZG0GG2zF5McQWlWxXhb0h7IH8ScszhyQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始即可开始进行数据传输，传输效率还是很快的，即使你的数据量很大，也可以使用该方法进行数据传输，这里使用了不到2秒钟就将整个数据库对象迁移到新的数据库中了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2gYlkicBOLCHXSicuics171YBiaBM06vu5TsoxFD1v8tMiatk27AFnl8icDBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>此外如果你想导出整个数据库中的对象到文件，也可以使用该方法，只需要将方式改为文件即可，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2dKibsOAkMktKzv4RcEnGCzF21WvhA8u23aO8mxQoXNGpbLRXkjrrasw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你想自定义导出的内容，可以点击该窗口的【高级】选项进行自定义配置，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ibkdpgmia7AP9ciadmUt0kIpKZHJWBicQibibicdibEtaZFkHcicEGtjG1OSUCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置完成后，点击开始，就会将你选择的数据库对象以脚本的形式导出到文件中。</p>
<p>但是数据传输到文件有个不足的地方，就是会将数据记录也会一并导出，而很多时候，我们其实只需要表结构，那么我们可以使用下面的这个功能。</p>
<p><strong>转储SQL文件</strong></p>
<p>双击打开数据库后，我们右键架构名dbo，在弹出的选项中选择【转储SQL文件…】，这里还有两个子选项：【结构和数据…】和【仅结构…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2klrr7KbWlHjd8oVYVaFhibky2ywFHxDfGbU0SNr80OElzF5bTVOor1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>他们的区别就是一个有数据记录，一个没有数据记录，如果你只要数据结构可以只选择【仅结构…】，这样就可以大大节省导出时间了。</p>
<p><strong>打印模式/数据字典*<em>生成*</em></strong></p>
<p>做数据库仓库往往面对的不是几张表，往往是成百上千张数据表，该怎么维护对DBA是个非常头疼的事，如果有个数据表结构或数据字典之类的就非常完美了。</p>
<p>打印模式可以<strong>完美的生成所有表的数据表结构</strong>的。这里我们选择表数量较多的数据库ReportServer。右键dbo后，选择【打印模式…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2NIZlTicjuVONVpYrhO0W1IqAeicswxic28stRoicXeJokqNTBNSQ3L0zWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以看到右侧窗口里面出现了所有数据表的表结构，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2TvxbdBAlYHmoILKSDia33M0MIm0IAghtK3LXibzq5icU19hqlFYkESx0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>足足有10页之多，我们点击左上方的【打印】，将表结构打印成PDF文件，就可以得到一份非常完成的数据字典了，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2aud0pqYSgMzwR3nXRMTNGibYQP3zXkCDrbTEU8UhTKDUhwZ2UDZxrSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>内容中主键和索引也有仔细的标注出来，其中<strong>P代表主键</strong>，下面的<strong>index表示索引</strong>。</p>
<p>这个功能绝对是一个神器！</p>
<p><strong>在模式中查找</strong></p>
<p>这个功能主要用来查找数据或结果，当你需要从当前数据库中查找数据记录或对象中包含某些字符时，可以使用该功能，具体如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO26F4rBdtKPq3pM6kk4v0iboN54ExFSJ6P0A8JrFI9x7Aj1zEICJeYw3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中，我们查找pre的结构，就可以将当前数据库符合要求的的所有对象都查找出来，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2zfWey0meibpxuwyU8ljtT6r0JIvHybx1e5rCDeAHwty4T2PIEKdQ1uw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>逆向模式到模型</strong></p>
<p>这又是一个神仙技能，谁用谁知道，右键dbo在弹出的选项中选择【逆向模式到模型..】,如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2gqmyJ95SwfRD1sZgybhd30aOiaV4LFDDSSKG7icQyHRGbTicMvBSqYjMQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>它可以<strong>将当前数据库中创建的所有表，以E-R图的模型清楚的告诉你每个表之间的关联关系</strong>，包括主外键，表结构，关联关系等，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2uQjNXTMRT6dVMkyT4tsO8Bb1CnibJgJfWDEePaGpVe8sicmkHdib245iaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>你以为就这？</p>
<p>还支持<strong>模型转换，模型导出</strong>，说白了就是你可以<strong>将该模型转换成其他数据库的模型</strong>，从SQL Server转换成MySQL，Oracle，Postgresql都可以。点击左上角的三短横，选择【文件】——【模型转换】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2cyYKRyxc5KAibxWfnU2zWdvUn7wAicn2lxZCBSP8mibaOaiaUbW9TzWn9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中选择你要转换的类型，比如我们想转换成MySQL 5.6的，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2x6TSHrBrmkymXceib25CkBfqVibGJlYibS0PL6VpSrOBPiacP71D1iciaBHw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击确定后，即可将当前的SQL Server模型立马转换成MySQL 5.6。给大家看下对比效果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2BUAibtGeIM6N5WXroknLPhTjT4k0r9EaZA8QRgCKzsnnUHsfqict08Tw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>SQL Server模型</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ImacDMUrYmibib6ZwhWa5hSwhtVXIhEUia6z4XxSz6chIVaeTzxmQcicuw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>MySQL模型</p>
<p>转换成功后可以直接将转换后的模型导出成对应的SQL。</p>
<p>点击【工具】——【导出SQL…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2SmPTTmH3LNPNNlmst71wAL7cpjlJuicBexVXBLh230wCzz2j3PGfvBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择导出位置，点确定即可，导出的SQL文件里面就是MySQL的建库代码了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2pvSqyJrD6aqeYmPh2lrIt56UXRL4RKyxzukKiaJ8GvaE2JGyjrKZx6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>能导出肯定就可以打印，同样如果需要将模型文件保存，也可以导出为PDF，PNG，SVG等格式，但是建议打印成PNG图片格式，因为PDF会分页，导致模型不完整。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2v0WVtdIJS4Qnj98H6rZwSic0mpKNvY4ML8OQEb4S5Y1cFk7icCmctdnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>打印出来的图片如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2VXiacibexrSpbeY1Y7kANuyIKGGobrsFNTiaolsaEMXRaDt8kXdeoibNLA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>新建表</strong></p>
<p>这个是比较常见的功能，相比其他管理工具，Navicat将建表过程中所涉及的各种常用功能都包含进去了，包含新字段，索引，主键，外键，唯一键等等与表有关的内容，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgQEuibfiaJMxTYlVaxYzphdW6VfpKYm6uLw3X8dyOIWryib4Aw8OYCicCbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>针对表的几个常用功能，我们再详细给大家介绍一下</p>
<p><strong>字段</strong></p>
<p>字段的功能很多，也是其他功能的前提，意思是你必须先创建了字段才能使用后面的一些功能。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgNIZBSp4nV53ZvBRxLqcpa9YunxHyn1qtDLf9lmialP9BQsZN1zELt6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其中第一排的添加字段，插入字段，删除字段，可以通过字面意思来理解。</p>
<p>主键：选中某个字段，点击主键即可设置为主键</p>
<p>标识：勾选后一般用作自增长列来使用</p>
<p>注释：对字段的备注，通常为中文</p>
<p>名：字段存在表里的字段名</p>
<p>类型：字段数据类型</p>
<p>长度：字段的长度，通常int和datetime可以不设置长度。</p>
<p>比例：小数位数</p>
<p>不是Null：该字段是否为空，勾选不为空，不勾选为空。</p>
<p><strong>索引</strong></p>
<p>用来创建索引，只需要选定指定的列，就可以在对应的列上创建索引了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgZQSnF3fd6xNaee5ibV4VXEQ1u7cibJfo2D0NvfGbcic9C1l056rOP9fcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>名：索引的名称，通常按命名规范以index或idx开头，当然你也可以自定义。</p>
<p>字段：选择在哪个字段上创建索引。还可以选择排序规则，默认是升序ASC。</p>
<p>索引类型：不同的数据库索引类型不同，SQL Server类型一般为聚集索引（Clustered）和非聚集索引（Non-Clustered）</p>
<p>唯一键：用来限制字段的记录是否可以重复，勾选就是不可重复。</p>
<p><strong>外键</strong></p>
<p>用来创建外键约束的功能，目前的数据库设计中，通常不设置外键约束了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgYfEockSvWia9MOegfNXLnFeSzJLnO0GgDqBTouNbAAnx2xP7SFVKU9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>名：外键名称，通常以fk开头</p>
<p>字段：用来设置外键的字段</p>
<p>参考表：与之相关联的表</p>
<p>参考字段：与之相关联表中的字段</p>
<p>删除时：是否级联删除</p>
<p>更新时：是否级联更新</p>
<p><strong>唯一键</strong></p>
<p>区别于主键，唯一键具有唯一性</p>
<p>与主键的区别有：</p>
<p>1.主键不允许空值，唯一索引允许空值</p>
<p>2.主键只允许一个，唯一索引允许多个</p>
<p>3.主键产生唯一的聚集索引，唯一索引产生唯一的非聚集索引</p>
<p><strong>检查</strong></p>
<p>用来约束数据插入的合法性，对应SQL中的CHECK或DEFAULT</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgxCROXWLcic26pQfMYHDX8K5Let2XYlibrAYzYtiaMwElzkX17mt1mFrvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>触发器</strong></p>
<p>用来创建与表相关的触发器，其中触发器的使用可以查看历史文章：</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA3MTg4NjY4Mw==&mid=2457301529&idx=2&sn=b3881753e41e401ac374057bce52e768&chksm=88a5602dbfd2e93bcae925b00130230e7e8f1b957f29ce2f3e7471c4076ebba3bf36ad2b4ab1&scene=21#wechat_redirect">SQL高级知识V2——触发器</a></p>
<p><strong>选项</strong></p>
<p>这里主要用来设置自增长的种子值（起始值）和增量</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgTr5rCyPoOtCZKcLA7ibtWLy8M1o4opjVATrsNBelsORc2SoBQ3elGjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>SQL预览</strong></p>
<p>这里可以看到我们刚才对表做的配置所对应的SQL语句</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgVe1icibSk4HTrcOZKR3hnXwUqL22Ofo1XfLtpfbibYTI0jMdBhUcn5kQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>查看对象模式</strong></p>
<p>创建好的表有三种查看方式：列表，详细信息和ER图，如下图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIovQPPbZyXibIAxiaY94ey9NUBALdy7jiaghl9WczAyTSFrLYB8dbNpJzibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>列表模式</strong></p>
<p>只显示表名，是表的默认显示方式</p>
<p><strong>详细信息模式</strong></p>
<p>会显示除了表名以为的其他信息，记录数，修改日期和表的注释等</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2vc7yZjic33zyty6PylhMMA9icpMGjtGb8croq8uo47TuF9RjtSyd3zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>ER图模式</strong></p>
<p>会以ER图的形式显示每个表之间的关联关系，如下图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoApicGEtFC7zxyYETTOrtKYs06TTTic2SNpsnEAKp99kTS3UvXYzXqFzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>导入向导</strong></p>
<p>用来引导用户导入数据到数据库对应的表</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgZSuMc6TCjM8JAytt1BYL0RvBNn7k1Lxafshibm5libYAUCzycBfmMc6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们打算将Customers.xlsx里的数据导入到表Customers中，具体操作如下：</p>
<p>在导入向导中选择要导入的文件类型，Navicat支持多种导入类型，这里我们选择导入Excel文档，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo4kDbmWv2gicpicrUlQtmq33Zua6RkT4sZQXhXr9ibCkPnp6lw50Y29a4g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>找的需要导入的文件，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo1oic8nEeeSjQic5fIqLcGETvcWeJAra33SRQ2dNJouJ9ePIpNZJyIVdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置字段名等内容，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIofmn6WiaXl270ic5y07kUErIXsYd4jy7a7YmbxyxfxguW716fRKJcnoDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择要导入的目标表，你也可以直接新建一张表，这里我们导入到目标表Orders，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoTQ7UYQWjlr4dC3iaqrVkqWKVPNmptZrjAU6u9ZlrnP1vPLqLUVuJckA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置源表和目标表之间的字段对应关系，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoAo5sT3zWIOWYGCVKeC2DSPW0E0tM6z7GBM2XHwbTjo7HibAgXtzPYsw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择一个导入模式，如果是直接添加，可以选择添加模式，如果是要先清空目标表再导入可以选择复制模式，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJzoC5vQ9mb05YrSUsAoTR6FRGpgGmrSZIgq2Hke2Q1ZgA7a5xP0alA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始就可以导入数据了</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoqhr3jY27uwVkalMIMw3VNtY2ZsZsrMgXQCKoJFDPDH66By1IxYCHnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>导出向导</strong></p>
<p>需要将数据库里的数据导出可以使用导出向导，具体如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIosDqVIic9Fyw1GIzhhynAp1gj2YfBHUgEE53B03vdPOgDARQUsqBicvBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中选择导出文件类型，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo5SsBEomUrzic3fvd4TJr8Ig4sFTGGdHxtjCJMPjXU63pVEbmNUicexzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择需要导出的表，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIocqzcibg1sEPdpbx0f0FqziaiahGak5Iz24y2kWFtzm3BfOcEkalwDCKIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择需要导出的列，默认全部字段，也可以选择指定字段，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJuTZ3MzwxnY7PAbyvQypMRE4X4266DicRFzccGgKDibib8bwzHjBJ0VkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>定义一些附加选项，导出包含标题，遇到导出错误继续等，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoDqcgLqHnEASje1LdH85fxzASTibKuiaPuItStfxzjXKsydBho1xUpfQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始执行导出操作</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIotFkCMS4qmA9ZaU9lQV72kd9yf3xQuXH8tNQYy0Trjc89OaPJVfbODw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>新建查询</strong></p>
<p>新建查询有两种方式，可以直接右键选择新建查询，也可以点击菜单栏的查询-新建查询，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoZge8TTPMzoYaMaichOUmddo9OkwHGwIoVHSb7TpiauRtIgCHtnzZcoXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>查询功能</strong></p>
<p>查询是我们用的比较频繁的一个功能，在查询窗口里面有许多好用的功能</p>
<p><strong>智能提醒</strong></p>
<p>根据我们输入的字符来自动提醒一些关键字，字段名，表名，视图名，函数名等，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIodFO8VeLldjRGdxUUCu7JqaVDcZhpzu3ET8A2urodtyUE674d2P9R8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>美化SQL</strong></p>
<p>当你看到一段代码写的很复杂且都堆在一起，可以使用美化SQL功能，一键帮你把堆在一起的SQL美化得整整齐齐。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2ws81EQbUEv6OwTZVUCVv0SkYeQ4ibU7Mia0oUqubE856t8QFTYTZnkg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>美化前</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIop5eiciaJ9kT4iaL8sxibNmWaRI68twNTKSAUsiaF8lmc2N9OkJnhBb5lNGg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>美化后</p>
<p><strong>其他功能</strong></p>
<p>此外查询窗口还有很多其他功能，都集中在左上角的三短横上面，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoZfZE8m5xAlAiaWyiaoaB5ib4FJPHB48teicrvpL1iaZUc3mtIQ4ImHnBpKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里将查询窗口的所有功能都汇集在一起，比如注释，查看执行计划，简化SQL等都在这里可以找到，小伙伴们可以一一尝试一下。</p>
<p><strong>创建视图</strong></p>
<p>Navicat提供一套创建视图的模板，主要是针对新手朋友。如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIotlErKxibGVngibLqbKfAmZmJgao6RMMOEOf1buYlRthMN4EMV1emOnRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里我们只需要写查询语句即可，在SQL预览里可以看到完整的SQL语句。如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo58Z7WQHwWh2LicjJAsBAAbEUictk2oYmex5u79n1C4SlHzmSsK6JA4MQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击预览，可以看到我们刚定义的视图结果，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoobd6t9vLPcZRnteqc9v8N0jeYhS5gtyCkicTPnh8ymjLHr5sKPjolgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>创建函数和存储过程</strong></p>
<p>函数和存储过程是类似的，区别是函数必须要有返回值，而存储过程可有可无。</p>
<p>他们也有一套模板，选择函数后点击新建函数，弹出如下对话框：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJibuYXzHaia6wiaN41LwF9BQoqtteicJj4sDF5lFibicE6vXkYbT6F3ypGww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>输入函数名或过程名，然后选择你想是想创建函数还是存储过程。然后输入参数名称和类型，也可以不带参数，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoMVGCWGLLdRfME5vtAb7GP7jiaSZJ4bgwsmcZHVM1Cn1aCaEFVTDF6vg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>函数必须要有返回值，这里需要定义返回值类型，点击下一步或完成。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoc3Jq9L01h8luBsFpIPcibrqXOs4A6ibXqK5GEHQsibB8cRW5kia1FdO90A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里会配置函数的一些附加信息，通常不用配置，直接点击完成即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoTFmlaHv2ZIP9t0icQd6pMjFOAOHTibicYRdNXGTo18gyP0MPzDJueXRBQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后我们就可以看到函数的编辑窗口了</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIog39HtbibClCyegtdt1zjN8nIvxbIYcvpeLuaMI6oL7Dw5ic0copYAN2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>写好函数里的语句后点击运行即可开始测试了。</p>
<p><strong>备份和还原</strong></p>
<p>通过Navicat，我们可以很方便的完成备份和还原操作，我们先来备份一个文件。</p>
<p><strong>备份</strong></p>
<p>点击菜单栏的SQL Server备份——新建备份，在弹出的窗口中配置备份内容，然后点击生成SQL即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIowFVnb9HfcicQHiagCnb3HLzyvpicUpF7Cf9S5qBB7CmfUfFtpckMdcRQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在这里我们可以看到备份的代码，然后点备份就会开始备份</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2N7mdeSiaMqEKbib8784hD9cYszwMFVrU2k1eqOdWqfF3Qib2UGvkiabhw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>还原</strong></p>
<p>在备份完成后，我们可以选择还原该备份包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoFbj8G9rvic4Pod7YeTzZDFm4hFEh6eibImpO9KF62UYuunZGOlC6qV7g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中可以配置相关信息</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoYkYWtRVp2H7l25ib5NPT6nQmdyx0v2eU6Rzmng4jvLFoQYnvWRYDn6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击生成SQL就会看到执行备份的SQL命令，点击还原即可开始执行</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoOXxlnPcECCGib8L7RGNOMze8FPzDmHiaib7BgGGlXQr0Yd6s0kLiaVzicqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>历史日志记录</strong></p>
<p>该功能可以很方便的查看到你在数据库中执行了哪些操作。点击菜单栏中的工具——历史日志，就可以看到我们的操作记录了，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoNM11YDOPrBnV7ibs8eQwJorWiaTRo1icrlFZu2rIjjjssomNk5dAZlIuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="利用Navicat客户端实现定时插入删除数据"><a href="#利用Navicat客户端实现定时插入删除数据" class="headerlink" title="利用Navicat客户端实现定时插入删除数据"></a>利用Navicat客户端实现定时插入删除数据</h2><h3 id="开启MySQL定时"><a href="#开启MySQL定时" class="headerlink" title="开启MySQL定时"></a>开启MySQL定时</h3><p>查询状态</p>
<p>新建查询&gt;运行：SHOW VARIABLES LIKE ‘event_scheduler’<br>查询看到默认为关闭</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507145245502.png" alt="在这里插入图片描述"></p>
<p>修改为开启<br>执行：SET GLOBAL event_scheduler = ON<br>开启，再次查询为ON，ok</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507145450634.png" alt="在这里插入图片描述"></p>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507150455218.png" alt="在这里插入图片描述"></p>
<h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>打开窗口<br>一次点击 函数&gt;新建函数&gt;完成</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507143906791.png" alt="在这里插入图片描述"></p>
<p>创建函数<br>在begin和end之间写一条要执行的sql<br>每分钟新增一条数据（定时删除可看最下方ps内容）</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507144555462.png" alt="在这里插入图片描述"></p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">	INSERT INTO hello (text,date) VALUES (&quot;每分钟增加一条&quot;,NOW());</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>点保存，填写一个名字，再点击函数可以看到刚才新建的函数</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507144312305.png" alt="在这里插入图片描述"></p>
<h3 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h3><p>一次点击 事件&gt;新建 输入call +刚才函数起的名字，我的是：CALL hello_min_ins</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507144717427.png" alt="在这里插入图片描述"></p>
<p>点击 计划，设置 时间间隔和开始时间</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507145730541.png" alt="在这里插入图片描述"></p>
<p>起一个名字保存，点击事件可以看到刚才创建的事件<br>此事件用来定时调用之前创建的函数</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507145816934.png" alt="在这里插入图片描述"></p>
<p>完成<br>实现了每分钟新增一条数据</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507150518156.png" alt="在这里插入图片描述"></p>
<p>ps：如果想每分钟删除一条id最小的数据，新建函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">	DELETE FROM hello ORDER BY id LIMIT 1;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>ps：如果想每天删除七天前的数据，新建函数</p>
<p>ps：如果想每天删除七天前的数据，新建函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    DELETE FROM hello WHERE date &lt; DATE_SUB(CURDATE(), INTERVAL 7 DAY);</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>事件里修改事件EVERY 1 DAY即可</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507151600764.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/" data-id="ckqk8k3ee004u2wwd5jnygcna" data-title="MySQL工具之Navicat" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-21.1.微信开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:36:09.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/">微信开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="微信公众平台开发"><a href="#微信公众平台开发" class="headerlink" title="微信公众平台开发"></a>微信公众平台开发</h1><h2 id="订阅号和服务号和企业号"><a href="#订阅号和服务号和企业号" class="headerlink" title="订阅号和服务号和企业号"></a>订阅号和服务号和企业号</h2><p>订阅号每天一条，收拢至订阅号文件夹，不强制推送；服务号每月一条，消息仍展示在聊天列表，但下发消息将即时提醒用户。</p>
<p>1、订阅号：主要偏于为用户传达资讯（类似报纸杂志），认证前后都是每天只可以群发一条消息。</p>
<p>2、服务号：主要偏于服务交互（类似银行，114，提供服务查询），认证前后都是每个月可群发4条消息；</p>
<p>3、企业号：主要用于公司内部通讯使用，需要先验证身份才可以关注成功企业号。</p>
<h2 id="验证登录和授权：AccessToken"><a href="#验证登录和授权：AccessToken" class="headerlink" title="验证登录和授权：AccessToken"></a>验证登录和授权：AccessToken</h2><h3 id="1-查看appid及appsecret"><a href="#1-查看appid及appsecret" class="headerlink" title="1.查看appid及appsecret"></a>1.查看appid及appsecret</h3><p>公众号后台界面查看</p>
<h3 id="2-获取accessToken"><a href="#2-获取accessToken" class="headerlink" title="2.获取accessToken"></a>2.获取accessToken</h3><p>1.临时方法获取</p>
<p>临时通过<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/debug/">在线测试</a> 或者 浏览器/postman等方式发送get请求获取返回结果里的accessToken</p>
<p>2.接口获取</p>
<p>第三方需要一个access_token获取和刷新的中控服务器（这个服务器会提前进行刷新，确保无缝连接）。</p>
<p>并发获取access_token会导致AccessToken互相覆盖，影响具体的业务功能，所以需要加并发锁</p>
<h2 id="用户标识：openid和UnionID"><a href="#用户标识：openid和UnionID" class="headerlink" title="用户标识：openid和UnionID"></a>用户标识：openid和UnionID</h2><p>为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID。如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下。绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID，可以在用户管理-获取用户基本信息（UnionID机制）文档了解详情。</p>
<p>​    <strong>一个用户对于一个公众号只会存在一个openid，即使取消关注了再关注，openid也不会改变。如果一个大公司下有多个公众号，会产生不同的openid，为了实现该公司下公众号间的数据互通，会有一个唯一的UnionID作为用户的唯一标识</strong></p>
<h2 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h2><p>公众号主要通过公众号消息会话和公众号内网页来为用户提供服务的：</p>
<h3 id="1、公众号消息会话"><a href="#1、公众号消息会话" class="headerlink" title="1、公众号消息会话"></a><strong>1、公众号消息会话</strong></h3><p>公众号是以微信用户的一个联系人形式存在的，消息会话是公众号与用户交互的基础。</p>
<p>目前公众号内主要有这样几类消息服务的类型，分别用于不同的场景。</p>
<p>1）群发消息：公众号可以以一定频次（订阅号为每天1次，服务号为每月4次），向用户群发消息，包括文字消息、图文消息、图片、视频、语音等。</p>
<p><strong>在公众号后台管理界面的创作管理可以编辑后选择群发</strong></p>
<p>2）被动回复消息：在用户给公众号发消息后，微信服务器会将消息发到开发者预先在开发者中心设置的服务器地址（开发者需要进行消息真实性验证），公众号可以在5秒内做出回复，可以回复一个消息，也可以回复命令告诉微信服务器这条消息暂不回复。被动回复消息可以设置加密（在公众平台官网的开发者中心处设置，设置后，按照消息加解密文档来进行处理。其他3种消息的调用因为是API调用而不是对请求的返回，所以不需要加解密）。</p>
<p>3）客服消息：在用户给公众号发消息后的48小时内，公众号可以给用户发送不限数量的消息，主要用于客服场景。用户的行为会触发事件推送，某些事件推送是支持公众号据此发送客服消息的，详见微信推送消息与事件说明文档。</p>
<p>4）模板消息：在需要对用户发送服务通知（如刷卡提醒、服务预约成功通知等）时，公众号可以用特定内容模板，主动向用户发送消息。</p>
<h3 id="2、公众号内网页"><a href="#2、公众号内网页" class="headerlink" title="2、公众号内网页"></a><strong>2、公众号内网页</strong></h3><p>许多复杂的业务场景，需要通过网页形式来提供服务，这时需要用到：</p>
<p>1）网页授权获取用户基本信息：通过该接口，可以获取用户的基本信息（获取用户的OpenID是无需用户同意的，获取用户的基本信息则需用户同意）</p>
<p>2）微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。</p>
<h2 id="全局返回码"><a href="#全局返回码" class="headerlink" title="全局返回码"></a>全局返回码</h2><p>公众号每次调用接口时，可能获得正确或错误的返回码，开发者可以根据返回码信息调试接口，排查错误</p>
<p>-1：系统繁忙，此时请开发者稍候再试</p>
<p>0：请求成功</p>
<p>4xxxx，6xxxx，9xxxx：各种问题的返回码</p>
<h2 id="开始开发"><a href="#开始开发" class="headerlink" title="开始开发"></a>开始开发</h2><h3 id="1-申请服务器"><a href="#1-申请服务器" class="headerlink" title="1.申请服务器"></a>1.申请服务器</h3><h3 id="2-搭建服务"><a href="#2-搭建服务" class="headerlink" title="2.搭建服务"></a>2.搭建服务</h3><p>后端程序配置微信的设置</p>
<h3 id="3-申请公众号"><a href="#3-申请公众号" class="headerlink" title="3.申请公众号"></a>3.申请公众号</h3><h3 id="4-开发者基本配置"><a href="#4-开发者基本配置" class="headerlink" title="4.开发者基本配置"></a>4.开发者基本配置</h3><h4 id="1-填写服务器配置"><a href="#1-填写服务器配置" class="headerlink" title="1.填写服务器配置"></a>1.填写服务器配置</h4><p>服务器地址（URL）、Token和EncodingAESKey</p>
<p>URL是开发者用来接收微信消息和事件的接口URL。</p>
<p>Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。</p>
<p>EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥</p>
<p>填写并提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求：signature（微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数），timestamp（时间戳），nonce（随机数），echostr（随机字符串）</p>
<p>通过检验signature对请求进行校验：</p>
<p>1）将token、timestamp、nonce三个参数进行字典序排序 </p>
<p>2）将三个参数字符串拼接成一个字符串进行sha1加密</p>
<p> 3）将加密后的字符串与signature对比，true表示是微信发来的，false表示不是微信。</p>
<p>若确认此次GET请求来自微信服务器，原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败</p>
<h4 id="2-后续可以在公众号后台的开发-基本配置里修改配置："><a href="#2-后续可以在公众号后台的开发-基本配置里修改配置：" class="headerlink" title="2.后续可以在公众号后台的开发/基本配置里修改配置："></a>2.后续可以在公众号后台的开发/基本配置里修改配置：</h4><p>开发者ID（AppID）：自动生成</p>
<p>开发者密码(AppSecret)：可以重置自动生成复制</p>
<p>IP白名单：配置自己的白名单以便调用测试接口获得access_token</p>
<p>服务器地址(URL)：http://外网IP/wx ，端口固定为80（http://外网IP/wx）</p>
<p>令牌(Token)：自主设置，这个token与前面的access_token不是一回事。这个token只用于验证开发者服务器</p>
<p>消息加解密密钥(EncodingAESKey)</p>
<h3 id="5-后端进行框架构思"><a href="#5-后端进行框架构思" class="headerlink" title="5.后端进行框架构思"></a>5.后端进行框架构思</h3><p>主要有三个部分：负责业务逻辑部分的服务器，负责对接微信API的API-Proxy服务器，以及唯一的AccessToken中控服务器</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xnC7SUbrIRwI8NhEGFeax6HoPcTMDqKGYxaSoNqBwocrj70Pt1EcKnQ/0?wx_fmt=png" alt="img"></p>
<p>1）AccessToken中控服务器：</p>
<p>负责： 提供主动刷新和被动刷新机制来刷新accessToken并存储（为了防止并发刷新，注意加并发锁），提供给业务逻辑有效的accessToken。</p>
<p>优点： 避免业务逻辑方并发获取access_token，避免AccessToken互相覆盖，提高业务功能的稳定性。</p>
<p>2）API-Proxy服务器：</p>
<p>负责：专一与微信API对接，不同的服务器可以负责对接不同的业务逻辑，更可进行调用频率、权限限制。</p>
<p>优点：某台API-proxy异常，还有其余服务器支持继续提供服务，提高稳定性，避免直接暴漏内部接口，有效防止恶意攻击，提高安全性</p>
<p>3）后端服务的服务器</p>
<h3 id="6-码代码"><a href="#6-码代码" class="headerlink" title="6.码代码"></a>6.码代码</h3><h3 id="7-在线测试"><a href="#7-在线测试" class="headerlink" title="7.在线测试"></a>7.在线测试</h3><p>在线测试接口可以输入access_token，进行接口测试，返回”请求失败”，说明代码有问题，检查代码逻辑。</p>
<p>“请求成功”，然后根据返回结果查看是否符合预期</p>
<h3 id="8-真实体验"><a href="#8-真实体验" class="headerlink" title="8.真实体验"></a>8.真实体验</h3><p>手机端微信关注测试</p>
<h2 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h2><ol>
<li>自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。</li>
<li>一级菜单最多4个汉字，二级菜单最多7个汉字，多出来的部分将会以“…”代替。</li>
<li>创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile（简介）页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果</li>
</ol>
<h3 id="设置类型："><a href="#设置类型：" class="headerlink" title="设置类型："></a>设置类型：</h3><ol>
<li><p>click：点击推事件。用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互；</p>
</li>
<li><p>view：跳转URL。用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。</p>
</li>
<li><p>scancode_push：扫码推事件用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。（这种是直接显示结果）</p>
</li>
<li><p>scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。（这种会直接返回公众号界面，并等待开发者下发消息）</p>
</li>
<li><p>pic_sysphoto：弹出系统拍照发图用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>pic_photo_or_album：弹出拍照或者相册发图用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。</p>
</li>
<li><p>pic_weixin：弹出微信相册发图器用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>location_select：弹出地理位置选择器用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>media_id：下发消息（除文本消息）用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频、图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</p>
</li>
<li><p>view_limited：跳转图文消息URL用户点击view_limited类型按钮后，微信客户端将打开开发者在按钮中填写的永久素材id对应的图文消息URL，永久素材类型只支持图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</p>
</li>
</ol>
<p>view类型：弹出网页（pc版本）</p>
<p>media_id类型：显示图文消息</p>
<p>click类型：发现公众号系统提示：“该公众号暂时无法提供服务“</p>
<p>点击click类型button，微信后台会推送一个event类型的xml 给开发者，需要开发者进一步完善后台代码逻辑，增加对自定义菜单事件推送的响应，必须设置key值</p>
<h3 id="创建-修改接口："><a href="#创建-修改接口：" class="headerlink" title="创建/修改接口："></a>创建/修改接口：</h3><p>这里的url应该是直接的url，nginx配置后需要前后端代码进行重定向</p>
<p>“sub_button”: [ ]里为空，代表不包含二级菜单</p>
<p>需要先获得access_token，然后POST（使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN%EF%BC%8C%E8%AF%B7%E6%B1%82%E4%BD%93%E4%B8%BA%EF%BC%9A">https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN，请求体为：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;button&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;安全帽绑定&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;http:&#x2F;&#x2F;elinktech.cn&#x2F;about.html&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;,</span><br><span class="line">        </span><br><span class="line">                    &#123;</span><br><span class="line">                &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;运营服务&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;http:&#x2F;&#x2F;elinktech.cn&#x2F;daohang.html&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;E联商城&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;http:&#x2F;&#x2F;elinktech.cn&#x2F;shop.html&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回0表示设置成功。</p>
<p>需要修改时，直接按流程发送，只是请求体里的东西作修改即可，不需要删除已有的菜单栏</p>
<h3 id="查询接口："><a href="#查询接口：" class="headerlink" title="查询接口："></a>查询接口：</h3><p>GET <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/get_current_selfmenu_info?access_token=ACCESS_TOKEN%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84json%E5%8D%B3%E4%B8%BA%E6%8E%A5%E5%8F%A3">https://api.weixin.qq.com/cgi-bin/get_current_selfmenu_info?access_token=ACCESS_TOKEN，返回结果的json即为接口</a></p>
<h3 id="删除接口："><a href="#删除接口：" class="headerlink" title="删除接口："></a>删除接口：</h3><p>GET <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN%EF%BC%8C%E8%BF%94%E5%9B%9E0%E5%8D%B3%E4%B8%BA%E5%88%A0%E9%99%A4%E6%88%90%E5%8A%9F">https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN，返回0即为删除成功</a></p>
<h3 id="事件推送："><a href="#事件推送：" class="headerlink" title="事件推送："></a>事件推送：</h3><p>用户点击自定义菜单后，微信会把事件推送给开发者，请注意，点击菜单弹出子菜单，不会产生上报</p>
<p>推送的事件有10种类型，对应接口的type：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[FromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[event]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Event</span>&gt;</span>&lt;![CDATA[CLICK]]&gt;<span class="tag">&lt;/<span class="name">Event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">EventKey</span>&gt;</span>&lt;![CDATA[EVENTKEY]]&gt;<span class="tag">&lt;/<span class="name">EventKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="个性化菜单接口"><a href="#个性化菜单接口" class="headerlink" title="个性化菜单接口"></a>个性化菜单接口</h3><p>可以通过该接口，让公众号的不同用户群体看到不一样的自定义菜单</p>
<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包发到开发者填写的URL上。</p>
<h3 id="1-接收文本消息"><a href="#1-接收文本消息" class="headerlink" title="1.接收文本消息"></a>1.接收文本消息</h3><p> 1.粉丝给公众号发送的文本消息</p>
<p>粉丝给公众号发送文本消息：“欢迎开启公众号开发者模式”，在开发者后台，收到公众平台发送的xml 如下：（下文均隐藏了ToUserName 及 FromUserName 信息）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[公众号]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[粉丝号]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1460537339<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[欢迎开启公众号开发者模式]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>6272960105994287618<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>createTime 是微信公众平台记录粉丝发送该消息的具体时间</p>
<p>text: 用于标记该xml 是文本消息，一般用于区别判断</p>
<p>欢迎开启公众号开发者模式: 说明该粉丝发给公众号的具体内容是欢迎开启公众号开发者模式</p>
<p>MsgId: 是公众平台为记录识别该消息的一个标记数值, 微信后台系统自动产生</p>
<ol start="2">
<li>被动回复文本消息</li>
</ol>
<p>即公众号给粉丝发送的文本消息，官方wiki链接: <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message">被动回复用户消息</a></p>
<p>特别强调：</p>
<p>1） 被动回复消息，即发送被动响应消息，不同于客服消息接口</p>
<p>2） 它其实并不是一种接口，而是对微信服务器发过来消息的一次回复</p>
<p>3） 收到粉丝消息后不想或者不能5秒内回复时，需回复“success”字符串</p>
<p>4） 客服接口在满足一定条件下随时调用</p>
<p>公众号想回复给粉丝一条文本消息，内容为“test”, 那么开发者发送给公众平台后台的xml 内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[粉丝号]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[公众号]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1460541339<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[test]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>特别备注：</p>
<p>1）ToUserName（接受者）、FromUserName(发送者) 字段请实际填写。</p>
<p>2）createtime 只用于标记开发者回复消息的时间，微信后台发送此消息都是不受这个字段约束。</p>
<p>3）text : 用于标记 此次行为是发送文本消息 （当然可以是image/voice等类型）。</p>
<p>4）文本换行 ‘\n’。</p>
<p> 3.回复success问题</p>
<p>查询官方wiki 开头强调： 假如服务器无法保证在五秒内处理回复，则必须回复“success”或者“”（空串），否则微信后台会发起三次重试。</p>
<p>解释一下为何有这么奇怪的规定。发起重试是微信后台为了尽可以保证粉丝发送的内容开发者均可以收到。如果开发者不进行回复，微信后台没办法确认开发者已收到消息，只好重试。</p>
<p>真的是这样子吗？尝试一下收到消息后，不做任何回复。在日志中查看到微信后台发起了三次重试操作，日志截图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xauONdVFJvic1Wfzxa0HnSEZ5libLcYibWWkb7gNDjt56DFs8kiaY3OtFtw/0?wx_fmt=png" alt="img"></p>
<p>三次重试后，依旧没有及时回复任何内容，系统自动在粉丝会话界面出现错误提示“该公众号暂时无法提供服务，请稍后再试”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xBp7Iiam8ydK0W4MOZa9bfHKgTesMkj3HXOnsYxttsodweib7mH9y5eQg/0?wx_fmt=png" alt="img"></p>
<p>如果回复success，微信后台可以确定开发者收到了粉丝消息，没有任何异常提示。因此请大家注意回复success的问题。</p>
<ol start="4">
<li>流程图</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xEVXiblIZm80UCBlia6vYiaXD7Od9Ev3nujHoNkNCubr9WPo8L7opJGhIA/0?wx_fmt=png" alt="img"></p>
<h3 id="2-接收图片消息"><a href="#2-接收图片消息" class="headerlink" title="2.接收图片消息"></a>2.接收图片消息</h3><p>MediaID</p>
<p>目的：</p>
<p>1）引入素材管理</p>
<p>2）以文本消息，图片消息为基础，可自行理解剩余的语音消息、视频消息、地理消息等</p>
<p>预实现功能：</p>
<p>接受粉丝发送的图片消息，并立马回复相同的图片给粉丝。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0x6zWAJ79NkGrlg34cGBjvqxtSxSVw5gPMsmlygTyhdDblrsNiaCX8GhQ/0?wx_fmt=png" alt="img"></p>
<p> 1.接收图片消息</p>
<p>即粉丝给公众号发送的图片消息。官方wiki链接：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html">消息管理/接收消息-接受普通消息/ 图片消息</a>从实例讲解，粉丝给公众号发送一张图片消息，在公众号开发者后台接收到的xml如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml&gt;</span><br><span class="line"> &lt;ToUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/ToUserName&gt;</span><br><span class="line"> &lt;FromUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/FromUserName&gt;</span><br><span class="line"> &lt;CreateTime&gt;1460536575&lt;/CreateTime&gt;</span><br><span class="line"> &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;</span><br><span class="line"> &lt;PicUrl&gt;&lt;![CDATA[http://mmbiz.qpic.cn/xxxxxx /0]]&gt;&lt;/PicUrl&gt;</span><br><span class="line"> &lt;MsgId&gt;6272956824639273066&lt;/MsgId&gt;</span><br><span class="line"> &lt;MediaId&gt;&lt;![CDATA[gyci5a-xxxxx-OL]]&gt;&lt;/MediaId&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure>

<p>特别说明：</p>
<p>PicUrl: 这个参数是微信系统把“粉丝“发送的图片消息自动转化成url。 这个url可用浏览器打开查看到图片。</p>
<p>MediaId: 是微信系统产生的id 用于标记该图片，详情可参考wiki<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1444738727&token=&lang=zh_CN">素材管理/获取临时素材</a>，</p>
<p> 2.被动回复图片消息</p>
<p>即公众号给粉丝发送的图片消息。官方wiki链接：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140543&token=&lang=zh_CN">消息管理/发送消息-被动回复用户消息/ 图片消息</a>)</p>
<p>特别说明：</p>
<p>1） 被动回复消息，即发送被动响应消息，不同于客服消息接口</p>
<p>2） 它其实并不是一种接口，而是对微信服务器发过来消息的一次回复</p>
<p>3） 收到粉丝消息后不想或者不能5秒内回复时，需回复“success”字符串</p>
<p>4） 客服接口在满足一定条件下随时调用</p>
<p>开发者发送给微信后台的xml 如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml&gt;</span><br><span class="line"> &lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt;</span><br><span class="line"> &lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt;</span><br><span class="line"> &lt;CreateTime&gt;1460536576&lt;/CreateTime&gt;</span><br><span class="line"> &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;</span><br><span class="line"> &lt;Image&gt;</span><br><span class="line"> &lt;MediaId&gt;&lt;![CDATA[gyci5oxxxxxxv3cOL]]&gt;&lt;/MediaId&gt;</span><br><span class="line"> &lt;/Image&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure>

<p>这里填写的MediaId的内容，其实就是粉丝的发送图片的原MediaId，所以粉丝收到了一张一模一样的原图。 如果想回复粉丝其它图片怎么呢？</p>
<p>1） 新增素材，请参考 新增临时素材 或者 新增永久素材</p>
<p>2） 获取其MediaId，请参考 获取临时素材MediaID 或者 获取永久素材MediaID</p>
<p>3.3 流程图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xDdfzVUuLvr3iaR3BvJnkkL9kATK0TgmFXsF2tPHTlpulfJ6eU930a1Q/0?wx_fmt=png" alt="img"></p>
<h3 id="3-语音消息"><a href="#3-语音消息" class="headerlink" title="3.语音消息"></a>3.语音消息</h3><h3 id="4-视频消息"><a href="#4-视频消息" class="headerlink" title="4.视频消息"></a>4.视频消息</h3><h3 id="5-小视频消息"><a href="#5-小视频消息" class="headerlink" title="5.小视频消息"></a>5.小视频消息</h3><h3 id="6-地理位置信息"><a href="#6-地理位置信息" class="headerlink" title="6.地理位置信息"></a>6.地理位置信息</h3><h3 id="7-链接消息"><a href="#7-链接消息" class="headerlink" title="7.链接消息"></a>7.链接消息</h3><h2 id="接收事件推送"><a href="#接收事件推送" class="headerlink" title="接收事件推送"></a>接收事件推送</h2><p>只有点击了微信的自定义菜单，才会被认定为是一个事件，向指定的url发送事件推送的xml</p>
<h3 id="1-关注-取消关注事件"><a href="#1-关注-取消关注事件" class="headerlink" title="1 关注/取消关注事件"></a>1 关注/取消关注事件</h3><p>用户在关注与取消关注公众号时，微信会把这个事件推送到开发者填写的URL。方便开发者给用户下发欢迎消息或者做帐号的解绑。为保护用户数据隐私，开发者收到用户取消关注事件时需要删除该用户的所有信息</p>
<h3 id="2-扫描带参数二维码事件"><a href="#2-扫描带参数二维码事件" class="headerlink" title="2 扫描带参数二维码事件"></a>2 扫描带参数二维码事件</h3><p>用户扫描带场景值二维码时，可能推送以下两种事件：</p>
<ol>
<li>如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。</li>
<li>如果用户已经关注公众号，则微信会将带场景值扫描事件推送给开发者</li>
</ol>
<h3 id="3-上报地理位置事件"><a href="#3-上报地理位置事件" class="headerlink" title="3 上报地理位置事件"></a>3 上报地理位置事件</h3><p>用户同意上报地理位置后，每次进入公众号会话时，都会在进入时上报地理位置，或在进入会话后每5秒上报一次地理位置，公众号可以在公众平台网站中修改以上设置。上报地理位置时，微信会将上报地理位置事件推送到开发者填写的URL。</p>
<h3 id="4-自定义菜单事件"><a href="#4-自定义菜单事件" class="headerlink" title="4 自定义菜单事件"></a>4 自定义菜单事件</h3><p>用户点击自定义菜单后，微信会把点击事件推送给开发者，请注意，点击菜单弹出子菜单，不会产生上报</p>
<h3 id="5-点击菜单拉取消息时的事件推送"><a href="#5-点击菜单拉取消息时的事件推送" class="headerlink" title="5 点击菜单拉取消息时的事件推送"></a>5 点击菜单拉取消息时的事件推送</h3><h3 id="6-点击菜单跳转链接时的事件推送"><a href="#6-点击菜单跳转链接时的事件推送" class="headerlink" title="6 点击菜单跳转链接时的事件推送"></a>6 点击菜单跳转链接时的事件推送</h3><h2 id="被动回复用户消息"><a href="#被动回复用户消息" class="headerlink" title="被动回复用户消息"></a>被动回复用户消息</h2><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。</p>
<p>严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。</p>
<p>1、直接回复success（推荐方式） 2、直接回复空串（指字节长度为0的空字符串，而不是XML结构体中content字段的内容为空）</p>
<p>1、开发者在5秒内未回复任何内容 2、开发者回复了异常数据，比如JSON数据等</p>
<p>就会出现<strong>“该公众号暂时无法提供服务，请稍后再试”</strong></p>
<p>回复文本消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toXML</span><span class="params">(String toUserName,String fromUserName,String text)</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;xml&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;ToUserName&gt;&lt;![CDATA[&quot;</span>+toUserName+<span class="string">&quot;]]&gt;&lt;/ToUserName&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;FromUserName&gt;&lt;![CDATA[&quot;</span>+fromUserName+<span class="string">&quot;]]&gt;&lt;/FromUserName&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;CreateTime&gt;&quot;</span>+System.currentTimeMillis()/<span class="number">1000</span>+<span class="string">&quot;&lt;/CreateTime&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;Content&gt;&lt;![CDATA[&quot;</span>+text+<span class="string">&quot;]]&gt;&lt;/Content&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;/xml&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回复图片消息</p>
<p>这里的media_id需要先调用接口上传图片。图片格式为jpg才能成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toImageXML</span><span class="params">(String toUserName,String fromUserName,String media_id)</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;xml&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;ToUserName&gt;&lt;![CDATA[&quot;</span>+toUserName+<span class="string">&quot;]]&gt;&lt;/ToUserName&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;FromUserName&gt;&lt;![CDATA[&quot;</span>+fromUserName+<span class="string">&quot;]]&gt;&lt;/FromUserName&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;CreateTime&gt;&quot;</span>+System.currentTimeMillis()/<span class="number">1000</span>+<span class="string">&quot;&lt;/CreateTime&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;Image&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;MediaId&gt;&lt;![CDATA[&quot;</span>+media_id+<span class="string">&quot;]]&gt;&lt;/MediaId&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;/Image&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;/xml&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些回复用户消息都是一般只能回复一条，如果两条的话，还需要调用客服回复消息接口。</p>
<h2 id="自动回复规则"><a href="#自动回复规则" class="headerlink" title="自动回复规则"></a>自动回复规则</h2><p>开发者可以通过该接口，获取公众号当前使用的自动回复规则，包括关注后自动回复、消息自动回复（60分钟内触发一次）、关键词自动回复</p>
<h2 id="模板消息"><a href="#模板消息" class="headerlink" title="模板消息"></a>模板消息</h2><ol>
<li>模板消息调用时主要需要模板ID和模板中各参数的赋值内容</li>
<li>模板中参数内容必须以”.DATA”结尾，否则视为保留字</li>
<li>模板保留符号””</li>
</ol>
<p>在模版消息发送任务完成后，微信服务器会将是否送达成功作为通知，发送到开发者中心中填写的服务器配置地址中</p>
<h2 id="微信网页开发"><a href="#微信网页开发" class="headerlink" title="微信网页开发"></a>微信网页开发</h2><h3 id="适配问题"><a href="#适配问题" class="headerlink" title="适配问题"></a>适配问题</h3><p>安卓版微信直接调用系统浏览器内核，它是用chrome改造做的一套WKwebView,概念上类似是一套组建, iOS则是调用safari，但</p>
<p>微信<strong>iOS客户端</strong>于2017年3月1日前逐步升级为WKWebview内核。ios也可以自己切换为UIWebview。微信内任意入口进入任意网页，在网页加载成功后向下拉动页面（或点击网页右上角菜单按钮），使之显示出地址栏，当地址栏以 “此网页由” 开头即为当前使用WKWebview，若以“网页由”则是使用的UIWebview</p>
<h3 id="网页授权"><a href="#网页授权" class="headerlink" title="网页授权"></a>网页授权</h3><p>如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。</p>
<p>OAuth2.0鉴权</p>
<h4 id="1、引导用户进入授权页面同意授权，获取code"><a href="#1、引导用户进入授权页面同意授权，获取code" class="headerlink" title="1、引导用户进入授权页面同意授权，获取code"></a>1、引导用户进入授权页面同意授权，获取code</h4><p>在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），引导关注者打开如下页面：<a target="_blank" rel="noopener" href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a> 若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。</p>
<p>尤其注意：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问。</p>
<p>如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE</p>
<p>跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。</p>
<p>code说明 ： code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期</p>
<p><strong>关于网页授权回调域名的说明</strong></p>
<p>1、在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；</p>
<p>2、授权回调域名配置规范为全域名，比如需要网页授权的域名为：<a target="_blank" rel="noopener" href="http://www.qq.com,配置以后此域名下面的页面http//www.qq.com/music.html">www.qq.com，配置以后此域名下面的页面http://www.qq.com/music.html</a> 、 <a target="_blank" rel="noopener" href="http://www.qq.com/login.html">http://www.qq.com/login.html</a> 都可以进行OAuth2.0鉴权。但<a target="_blank" rel="noopener" href="http://pay.qq.com/">http://pay.qq.com</a> 、 <a target="_blank" rel="noopener" href="http://music.qq.com/">http://music.qq.com</a> 、 <a target="_blank" rel="noopener" href="http://qq.com/">http://qq.com</a> 无法进行OAuth2.0鉴权</p>
<p>3、如果公众号登录授权给了第三方开发者来进行管理，则不必做任何设置，由第三方代替公众号实现网页授权即可</p>
<p><strong>关于网页授权的两种scope的区别说明</strong></p>
<p>1、以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p>
<p>2、以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</p>
<p>3、用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p>
<h4 id="2、通过code换取网页授权access-token（与基础支持中的access-token不同）"><a href="#2、通过code换取网页授权access-token（与基础支持中的access-token不同）" class="headerlink" title="2、通过code换取网页授权access_token（与基础支持中的access_token不同）"></a>2、通过code换取网页授权access_token（与基础支持中的access_token不同）</h4><p>这里通过code换取的是一个特殊的网页授权access_token,与基础支持中的access_token（该access_token用于调用其他接口）不同。公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。</p>
<p>尤其注意：由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起</p>
<p>获取code后，请求以下链接获取access_token： <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</a></p>
<p><strong>关于网页授权access_token和普通access_token的区别</strong></p>
<p>1、微信网页授权是通过OAuth2.0机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权access_token），通过网页授权access_token可以进行授权后接口调用，如获取用户基本信息；</p>
<p>2、其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用。</p>
<h4 id="3、如果需要，开发者可以刷新网页授权access-token，避免过期"><a href="#3、如果需要，开发者可以刷新网页授权access-token，避免过期" class="headerlink" title="3、如果需要，开发者可以刷新网页授权access_token，避免过期"></a>3、如果需要，开发者可以刷新网页授权access_token，避免过期</h4><p>由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token有效期为30天，当refresh_token失效之后，需要用户重新授权</p>
<p>获取第二步的access_token后，请求以下链接获取refresh_token： <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN">https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN</a></p>
<h4 id="4、通过网页授权access-token和openid获取用户基本信息（支持UnionID机制）"><a href="#4、通过网页授权access-token和openid获取用户基本信息（支持UnionID机制）" class="headerlink" title="4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）"></a>4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</h4><p>如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了</p>
<p>http：GET（请使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</a></p>
<p><strong>关于UnionID机制</strong></p>
<p>1、请注意，网页授权获取用户基本信息也遵循UnionID机制。即如果开发者有在多个公众号，或在公众号、移动应用之间统一用户帐号的需求，需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用UnionID机制来满足上述需求。</p>
<p>2、UnionID机制的作用说明：如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性，因为同一用户，对同一个微信开放平台下的不同应用（移动应用、网站应用和公众帐号），unionid是相同的。</p>
<p><strong>关于特殊场景下的静默授权</strong></p>
<p>1、上面已经提到，对于以snsapi_base为scope的网页授权，就静默授权的，用户无感知；</p>
<p>2、对于已关注公众号的用户，如果用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是scope为snsapi_userinfo，也是静默授权，用户无感知。</p>
<p><strong>检验授权凭证（access_token）是否有效</strong></p>
<p>http：GET（请使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID">https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID</a></p>
<p>返回0代表有效</p>
<h3 id="网页开发样式库：WEBUI"><a href="#网页开发样式库：WEBUI" class="headerlink" title="网页开发样式库：WEBUI"></a>网页开发样式库：WEBUI</h3><h3 id="微信JS-SDK"><a href="#微信JS-SDK" class="headerlink" title="微信JS-SDK"></a>微信JS-SDK</h3><p>是<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/cgi-bin/loginpage?t=wxm2-login&lang=zh_CN">微信公众平台</a> 面向网页开发者提供的基于微信内的网页开发工具包</p>
<p>通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验</p>
<h4 id="1-绑定域名"><a href="#1-绑定域名" class="headerlink" title="1.绑定域名"></a>1.<strong>绑定域名</strong></h4><p>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。</p>
<p>备注：登录后可在“开发者中心”查看对应的接口权限</p>
<h4 id="2-引入JS文件"><a href="#2-引入JS文件" class="headerlink" title="2.引入JS文件"></a>2.<strong>引入JS文件</strong></h4><p>在需要调用JS接口的页面引入JS文件，（支持https）：<a target="_blank" rel="noopener" href="http://res.wx.qq.com/open/js/jweixin-1.6.0.js">http://res.wx.qq.com/open/js/jweixin-1.6.0.js</a></p>
<p>如需进一步提升服务稳定性，当上述资源不可访问时，可改访问：<a target="_blank" rel="noopener" href="http://res2.wx.qq.com/open/js/jweixin-1.6.0.js">http://res2.wx.qq.com/open/js/jweixin-1.6.0.js</a> （支持https）。</p>
<p>备注：支持使用 AMD/CMD 标准模块加载方法加载</p>
<h4 id="3-通过config接口注入权限验证配置"><a href="#3-通过config接口注入权限验证配置" class="headerlink" title="3.通过config接口注入权限验证配置"></a>3.<strong>通过config接口注入权限验证配置</strong></h4><p>所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用（同一个url仅需调用一次，对于变化url的SPA的web app可在每次url变化时进行调用,目前Android微信客户端不支持pushState的H5新特性，所以使用pushState来实现web app的页面会导致签名失败，此问题会在Android6.2中修复）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">  debug: <span class="literal">true</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">  appId: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">  timestamp: , <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">  nonceStr: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">  signature: <span class="string">&#x27;&#x27;</span>,<span class="comment">// 必填，签名</span></span><br><span class="line">  jsApiList: [] <span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="签名算法：JS-SDK使用权限签名算法"><a href="#签名算法：JS-SDK使用权限签名算法" class="headerlink" title="签名算法：JS-SDK使用权限签名算法"></a>签名算法：JS-SDK使用权限签名算法</h4><p><strong>jsapi_ticket</strong></p>
<p>生成签名之前必须先了解一下jsapi_ticket，jsapi_ticket是公众号用于调用微信JS接口的临时票据。正常情况下，jsapi_ticket的有效期为7200秒，通过access_token来获取。由于获取jsapi_ticket的api调用次数非常有限，频繁刷新jsapi_ticket会导致api调用受限，影响自身业务，开发者必须在自己的服务全局缓存jsapi_ticket 。</p>
<ol>
<li>参考以下文档获取access_token（有效期7200秒，开发者必须在自己的服务全局缓存access_token）：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html">https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html</a></li>
<li>用第一步拿到的access_token 采用http GET方式请求获得jsapi_ticket（有效期7200秒，开发者必须在自己的服务全局缓存jsapi_ticket）：<a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi</a></li>
</ol>
<p>成功返回如下JSON：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;errcode&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;errmsg&quot;</span>:<span class="string">&quot;ok&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;ticket&quot;</span>:<span class="string">&quot;bxLdikRXVbTPdHSM05e5u5sUoXNKd8-41ZO3MhKoyN5OfkWITDGgnr2fwJ0m9E8NYzWKVZvdVtaUgWvsdshFKA&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span>:<span class="number">7200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得jsapi_ticket之后，就可以生成JS-SDK权限验证的签名了。</p>
<p><strong>签名算法</strong></p>
<p>签名生成规则如下：参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分） 。对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。</p>
<p>即signature=sha1(string1)。 示例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">noncestr=Wm3WZYTPz0wzccnW</span><br><span class="line">jsapi_ticket=sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg</span><br><span class="line">timestamp=1414587457</span><br><span class="line">url=http://mp.weixin.qq.com?params=value</span><br></pre></td></tr></table></figure>

<p>步骤1. 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsapi_ticket=sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg&amp;noncestr=Wm3WZYTPz0wzccnW&amp;timestamp=1414587457&amp;url=http://mp.weixin.qq.com?params=value</span><br></pre></td></tr></table></figure>

<p>步骤2. 对string1进行sha1签名，得到signature：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0f9de62fce790f9a083d5c99e95740ceb90c27ed</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ol>
<li>签名用的noncestr和timestamp必须与wx.config中的nonceStr和timestamp相同。</li>
<li>签名用的url必须是调用JS接口页面的完整URL。</li>
<li>出于安全考虑，开发者必须在服务器端实现签名的逻辑。</li>
</ol>
<h4 id="4-通过ready接口处理成功验证"><a href="#4-通过ready接口处理成功验证" class="headerlink" title="4.通过ready接口处理成功验证"></a>4.<strong>通过ready接口处理成功验证</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-通过error接口处理失败验证"><a href="#5-通过error接口处理失败验证" class="headerlink" title="5.通过error接口处理失败验证"></a>5.<strong>通过error接口处理失败验证</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.error(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="接口调用说明"><a href="#接口调用说明" class="headerlink" title="接口调用说明"></a><strong>接口调用说明</strong></h4><p>所有接口通过wx对象(也可使用jWeixin对象)来调用，参数是一个对象，除了每个接口本身需要传的参数之外，还有以下通用参数：</p>
<ol>
<li>success：接口调用成功时执行的回调函数。</li>
<li>fail：接口调用失败时执行的回调函数。</li>
<li>complete：接口调用完成时执行的回调函数，无论成功或失败都会执行。</li>
<li>cancel：用户点击取消时的回调函数，仅部分有用户取消操作的api才会用到。</li>
<li>trigger: 监听Menu中的按钮点击时触发的方法，该方法仅支持Menu中的相关接口。</li>
</ol>
<p>备注：不要尝试在trigger中使用ajax异步请求修改本次分享的内容，因为客户端分享操作是一个同步操作，这时候使用ajax的回包会还没有返回。</p>
<p>以上几个函数都带有一个参数，类型为对象，其中除了每个接口本身返回的数据之外，还有一个通用属性errMsg，其值格式如下：</p>
<p>调用成功时：”xxx:ok” ，其中xxx为调用的接口名</p>
<p>用户取消时：”xxx:cancel”，其中xxx为调用的接口名</p>
<p>调用失败时：其值为具体错误信息</p>
<h4 id="基础接口"><a href="#基础接口" class="headerlink" title="基础接口"></a><strong>基础接口</strong></h4><h5 id="判断当前客户端版本是否支持指定JS接口"><a href="#判断当前客户端版本是否支持指定JS接口" class="headerlink" title="判断当前客户端版本是否支持指定JS接口"></a><strong>判断当前客户端版本是否支持指定JS接口</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wx.checkJsApi(&#123;</span><br><span class="line">  jsApiList: [<span class="string">&#x27;chooseImage&#x27;</span>], <span class="comment">// 需要检测的JS接口列表，所有JS接口列表见附录2,</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以键值对的形式返回，可用的api值true，不可用为false</span></span><br><span class="line">  <span class="comment">// 如：&#123;&quot;checkResult&quot;:&#123;&quot;chooseImage&quot;:true&#125;,&quot;errMsg&quot;:&quot;checkJsApi:ok&quot;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>备注：checkJsApi接口是客户端6.0.2新引入的一个预留接口，第一期开放的接口均可不使用checkJsApi来检测</p>
<h3 id="WEB开发者工具"><a href="#WEB开发者工具" class="headerlink" title="WEB开发者工具"></a>WEB开发者工具</h3><p>调试工具</p>
<h3 id="云开发"><a href="#云开发" class="headerlink" title="云开发"></a>云开发</h3><p>开发者可以使用云开发开发微信小程序、小游戏、公众号，无需搭建服务器，即可使用云端能力。</p>
<p>云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。</p>
<h2 id="Cookie和LocalStorage设置相关"><a href="#Cookie和LocalStorage设置相关" class="headerlink" title="Cookie和LocalStorage设置相关"></a>Cookie和LocalStorage设置相关</h2><p>一：退出微信账号后，将会清空所有Cookie和LocalStorage。</p>
<p>二：页面功能依赖Cookie，或有涉及到Cookie的相关逻辑 WKWebview内部实现变更，会影响目前页面Cookie相关的逻辑。</p>
<p>变化1：跨域存取Cookie 问题说明：在访问一个页面A时，如果页面A引用了另一个页面B的资源（页面A和B为不同的域名），这时页面B就被认为是第三方页面。若在页面B中设置Cookie，就会命中WKWebview下阻止第三方跨域设置Cookie的安全策略，导致问题出现。 适配建议： 在WKWebview中是默认阻止跨域的第三方设置Cookie。所有通过Cookie传递的信息，可通过业务后台存储需要传递的信息，然后给页面一个存储信息相对应的access_token加密码，再通过Url中加入自己业务的access_token进行页面间的信息传递。</p>
<p>变化2：微信原生层面的网络请求读取不到WKWebview中设置的cookie，即使域名是相同的。 问题说明：如果页面的资源或图片存储的服务器依赖校验Cookie来返回数据的情况，在切换到WKWebview后，在微信内长按保存，或者点击预览大图时，原生层面发起的网络请求将不会完整地带上所设置的Cookie，会导致图片保存失败或预览失败。 适配建议： 建议静态资源cookie free。如果确实有信息需要传递，可通过业务后台存储需要传递的信息，然后给页面一个存储信息相对应的access_token加密码，再通过Url中加入自己业务的access_token进行页面间信息传递。</p>
<p>除上述两种情况，开发者不用担心其他情况下Cookie丢失的问题，所有请求都会带上完整的Cookie</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.每个接口都有每日接口<strong>调用频次</strong>限制，可以在公众平台官网-开发者中心处查看具体频次。</p>
<p>2.公众平台以<strong>access_token</strong>为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储，详见获取接口调用凭据（access_token）文档</p>
<p>3.公众平台接口调用仅支持<strong>80端口</strong></p>
<p>微信公众号接口必须以http://或https://开头，分别支持80端口和443端口</p>
<p>4.涉及<strong>用户数据</strong>：</p>
<ul>
<li>您的服务需要收集用户任何数据的，必须事先获得用户的明确同意，且仅应当收集为运营及功能实现目的而必要的用户数据， 同时应当告知用户相关数据收集的目的、范围及使用方式等，保障用户知情权。</li>
<li>您收集用户的数据后，必须采取必要的保护措施，防止用户数据被盗、泄漏等。</li>
<li>您在特定微信公众号中收集的用户数据仅可以在该特定微信公众号中使用，不得将其使用在该特定微信公众号之外或为其他任何目的进行使用，也不得以任何方式将其提供给他人。</li>
<li>如果腾讯认为您收集、使用用户数据的方式，可能损害用户体验，腾讯有权要求您删除相关数据并不得再以该方式收集、使用用户数据。</li>
<li>一旦您停止使用本服务，或腾讯基于任何原因终止您使用本服务，您必须立即删除全部因使用本服务而获得的数据（包括各种备份）， 且不得再以任何方式进行使用。</li>
</ul>
<p>其他规范：</p>
<ul>
<li>请勿为任何用户自动登录到微信公众平台提供代理身份验证凭据。</li>
<li>请勿提供跟踪功能，包括但不限于识别其他用户在个人主页上查看、点击等操作行为。</li>
<li>请勿自动将浏览器窗口定向到其他网页。</li>
<li>请勿设置或发布任何违反相关法规、公序良俗、社会公德等的玩法、内容等。</li>
<li>请勿公开表达或暗示，您与腾讯之间存在合作关系，包括但不限于相互持股、商业往来或合作关系等，或声称腾讯对您的认可。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/" data-id="ckqk8k3eq00662wwd122xb8x9" data-title="微信开发" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-22.1.计算机基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:30:15.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。"><a href="#计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。" class="headerlink" title="*计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。*"></a><em><strong>*计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。*</strong></em></h3><p>存储器分为内存和磁盘。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="一、CPU"><a href="#一、CPU" class="headerlink" title="*一、CPU*"></a><em><strong>*一、CPU*</strong></em></h3><p>1.计算机核心组件，在单个计算机芯片上放置数十亿个微型晶体管来构建成CPU。</p>
<p>2.CPU的核心是从程序或应用程序获取指令并执行计算。提取，解码，执行。从系统的RAM（随机存取存储器，也叫主存）中提取指令然后解码该指令的实际内容，然后再由CPU相关部分执行。</p>
<p>3.主要由两部分组成：控制单元和算术逻辑单元（ALU）。</p>
<p>控制单元：从内存中提取指令并解码执行。</p>
<p>算术逻辑单元：处理算术和逻辑运算。</p>
<p>从功能看，由四部分:****寄存器n个****和控制器、运算器、时钟。由电信号连通。</p>
<p>CPU是一系列寄存器的集合体。</p>
<p>****累加寄存器*<em><strong>、</strong></em>*标志寄存器*<em><strong>、</strong></em>*程序计数器*<em><strong>、基址寄存器、变址寄存器、通用寄存器、</strong></em>*指令寄存器*<em><strong>、</strong></em>*栈寄存器****。（基址变址通用有多个，其余都是只有一个）</p>
<p>（1）程序计数器：用来存储下一条指令所在单元的地址。程序计数器控制着程序的流程。</p>
<p>（2）标志寄存器：保存累加寄存器的运算结果，也负责溢出（指运算的指令超过了寄存器的长度范围）和奇偶校验。标志寄存器的第一个字节为1则为正，第二个字节为1则为0，第三个字节为1则为负数。</p>
<p>（CPU执行机制有个比较运算，实际上是减法运算，其结果记录在标志寄存器上）</p>
<p>函数调用机制：call指令调用和return指令返回，中间是栈</p>
<p>（3）基址寄存器和变址寄存器：用过这两个寄存器可以实现对主存上的特定区域进行划分，来实现类似****数组****的操作。</p>
<p>实际地址=基址寄存器的值+变址寄存器的值</p>
<table>
<thead>
<tr>
<th>寄存器名</th>
<th>名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td>eax</td>
<td>累加寄存器</td>
<td>运算</td>
</tr>
<tr>
<td>ebc</td>
<td>基址存储器</td>
<td>存储内存地址</td>
</tr>
<tr>
<td>ecx</td>
<td>计数存储器</td>
<td>计算循环次数</td>
</tr>
<tr>
<td>edx</td>
<td>数据寄存器</td>
<td>存储数据</td>
</tr>
<tr>
<td>esi</td>
<td>源基址寄存器</td>
<td>存储数据发送源的内存地址</td>
</tr>
<tr>
<td>edi</td>
<td>目的基址寄存器</td>
<td>存储数据发送目标的内存地址</td>
</tr>
<tr>
<td>ebp</td>
<td>扩展基址寄存器</td>
<td>存储数据存储领域基点的内存地址</td>
</tr>
<tr>
<td>esp</td>
<td>扩展栈指针寄存器</td>
<td>存储栈中最高位数据的内存地址</td>
</tr>
</tbody></table>
<p>数据的销毁：栈中存在两个参数，可通过两次pop指令可以将栈内的数据销毁；也可采用esp寄存器+8的方式更有效率（只需处理一次）：数值的单位是4字节，esp寄存器+8相当于pop2次，虽然内存中的数据实际上还残留着，但只要把esp寄存器的值更新为数据存储地址前面的数据位置，该数据就相当于销毁了。</p>
<p>函数的参数是通过栈来传递，返回值是通过寄存器返回的。</p>
<p>∷CPU指令执行过程:取指令，指令译码，执行指令，访存取数，结果写回。</p>
<h3 id="二、-内存（内部存储设备）"><a href="#二、-内存（内部存储设备）" class="headerlink" title="二、****内存（内部存储设备）****"></a><strong>二、***</strong>*内存（内部存储设备）****</h3><p>\1. 也叫主存。是与CPU进行沟通的桥梁。通过控制芯片相连，由可读写的元素构成，每个字节（1byte=8bits）都有一个地址编号。CPU通过地址从内存中读取数据和指令，也可以根据地址写入数据。计算机所有程序的运行都是在主存中运行的。当计算机关闭时，内存中的指令和数据就会被清除。</p>
<p>\2. 作用：存放CPU中的运算数据，与硬盘等外部存储设备交换的数据。其运行决定了计算机的稳定运行。</p>
<p>\3. 内存的内部由各种IC电路组成，可分为三种：</p>
<p>（1）随机存储器（RAM）：最重要的一种，可读可写，机器关闭时，信息会丢失。</p>
<p>（2）只读存储器（ROM）：只可读，机器关闭时，信息不会丢失。</p>
<p>程序的运行环境，存在着名为BIOS（Basic Input/Output System）的系统。BIOS存储在ROM中，是预先内置在计算机主机内部的程序，记录了用来控制外围设备的程序和数据。BIOS除了键盘、磁盘、显卡等基本控制外，还有引导程序的功能。****引导程序****是存储在启动驱动器启示区域的小程序。操作系统的启动驱动器一般是硬盘，也有CD-ROM和软盘。</p>
<p>（3）高速缓存（Cache）：分为一级缓存（L1 Cache）、二级缓存、三级缓存。位于内存和CPU之间，是一个读写速度比内存更快的存储器。</p>
<p>内存IC：一个完整的结构，内部有电源，地址信号，控制信号和用于寻址的IC****引脚（Pin）****来进行数据的读写。IC就是集成电器（integrated circuit）</p>
<p>存储方式有两种:低字节序列（将数据低位存储在内存低位地址）和高字节序列（将数据的高位存储在内存的低位）。</p>
<p>数组是内存的实现。</p>
<p>\4. 虚拟内存是内存和磁盘交互的第二个媒介，是把磁盘的一部分作为假想内存来使用。虚拟内存在硬盘上的存在形式就是PAGEFILE.SYS这个页面文件。</p>
<p>当内存不足时可借助虚拟内存运行程序，通过置换（swap）。分为分页式和分段式。</p>
<p>Windows操作系统：</p>
<p>1.Windows是以图形界面为基础的操作系统，前身是MS-DOC（16位操作系统）。</p>
<p>2.有两个版本32和64位。（指的是处理效率最高的数据大小）</p>
<p>3.通过API（Application Programming Interface，应用程序接口）函数集成来提供系统调用。API通过多个DLL文件来提供。</p>
<p>4.通过WYSIWYG（what you see is what you get）实现打印输出。</p>
<p>5.提供多任务功能：通过时钟分割技术来实现，底层是cpu时间切片，这也是多线程多任务的核心。</p>
<p>6.提供网络功能和数据库功能。它们和操作系统很接近，所以被称为中间件而不是应用。操作系统+中间件=系统软件。</p>
<p>7.即插即用实现设备驱动的自动设定。</p>
<p>节约内存有两种方式：增加内存的容量，加内存条；优化应用程序，使其尽可能变小。</p>
<p>怎样优化应用程序呢？</p>
<p>1.可以通过DLL文件实现函数共有。</p>
<p>DLL（Dynamic Link Library）文件是一种动态链接库文件，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。多个应用可以共有一个DLL文件从而达到节约内存的效果。</p>
<p>\2. 通过调用_stdcall来减少程序文件的大小。</p>
<p>_stdcall是standard call（标准调用）。Windows提供的DLL函数都是通过_stdcall调用。</p>
<p>三、磁盘（外部存储设备）</p>
<p>内存通过电流实现存储，磁盘通过磁记录技术来实现存储。</p>
<p>早期磁盘：软盘。如今用的是硬磁盘。磁盘中存储的程序必须加载到内存中才能运行。</p>
<p>磁盘的缓存叫做磁盘缓存，指的是把从磁盘中读出的数据存储到内存的方式，磁盘缓存大大改善了磁盘访问的速度。磁盘缓存是内存的一部分。</p>
<p>磁盘的物理结构指的是磁盘存储数据的形式。通过其物理表面划分成多个空间来使用，划分方式：可变长方式和扇区方式（一般是这种）。</p>
<p>扇区是对磁盘进行物理读写的最小单位。</p>
<p>四、操作系统环境</p>
<p>程序要运行需要运行环境。运行环境=操作系统+硬件。</p>
<p>操作系统又可以被称为软件，是由一系列的指令组成的。分为：Windows、Linux、Unix、FreeBSD(Unix系统的一种)。监控程序（加载程序、运行程序）可以说是操作系统的原型。后来又加上了基本的输入输出程序，再后来加上了硬件控制程序、编程语言处理器（汇编、编译、解析）、各种应用程序。操作系统其实就是多个程序的集合体。</p>
<p>Windows操作的是硬件而不是软件，软件通过操作windows系统可以达到控制硬件的目的。程序员没法直接控制硬件，且windows屏蔽了控制硬件的细节，但是windows却开放了系统调用功能来实现对硬件的控制，系统调用称为API，API就是应用调用的函数，这些函数的实体被存放在DLL文件中。</p>
<p>CPU的类型不同，所对应的机器的语言也不同。操作系统的类型不同，应用程序向操作系统传递指令的途径（称为API，Application Programming Interface）也不同。</p>
<p>五、显卡</p>
<p>承担图形的输出任务。又被称为图形处理器（Graphic Processing Unit,GPU）。</p>
<p>显示器中显示的信息一直存储在某内存中，该内存称为VRAM（Video RAM），在程序中，只要往VRAM中写入数据，该数据就会在显示器中显示出来。实现该功能的程序，是由操作系统或者BIOS提供，并借助中断来处理。</p>
<p>集成显卡：集成显卡是一种特殊的显卡，它一般不带有显存，而是使用系统的一部分主内存作为显存，具体的数量是系统根据需要自动动态调整的。</p>
<p>独立显卡：独立显卡简称独显，是指成独立的板卡，需要插在主板的相应接口上的显卡。独立显卡又分为内置独立显卡和外置显卡。独立显卡具备单独的显存，不占用系统内存，而且技术上领先于集成显卡，能够提供更好的显示效果和运行性能。</p>
<p>六、外围设备</p>
<p>1.IO端口</p>
<p>计算机主机中，附带了用来连接显示器以及键盘等外围设备的连接器，连接器内部都连接有用来交换计算机主机内外围设备之间电流特性的IC，这些IC统称为IO控制器。IO控制器中有用于临时保存输入输出数据的内存，被称为寄存器（与CPU的寄存器不同），这些内存就是端口。一个io控制器可以控制多个设备，各端口之间通过端口号来区分。端口号也被称为IO地址。</p>
<p>2.IRQ实现中断</p>
<p>外围设备的中断请求：IRQ（Interrupt Request）代表的就是中断请求。IRQ用来暂停当前正在运行的程序，并跳转到其他程序运行的必要机制，该机制被称为处理中断。实施中断请求的是连接外围设备的io控制器，负责实施中断处理的是CPU，外围设备的中断请求会使用不同于IO端口的其他编号，这个编号叫中断编号。操作系统以及BIOS则会提供响应中断编号的中断处理程序。</p>
<p>假如有多个外围设备请求中断的话，可以在IO控制器和CPU之间加入名为中断控制器的IC进行缓冲。</p>
<p>3.DMA实现短时间内大量数据传输</p>
<p>DMA（Direct Memory Access）：指在不通过CPU的情况下，外围设备直接和主存进行数据传输。磁盘等外围设备都用到了DMA机制</p>
<p>假如多个设备设定成相同的端口号、IRQ和DMA通道的话，计算机就无法正常工作，会提示设备冲突。</p>
<p>网址后缀名：</p>
<p>.org  非盈利性组织</p>
<p>.com  商业机构</p>
<p>.cn  政府</p>
<p>.edu  教育</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ckqk8k3d3000x2wwd4zwjaa4q" data-title="计算机基础知识" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库和SQL语句" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:29:35.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/">数据库和SQL语句</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数据库就是一个文件系统，通过标准的SQL语句获取数据</p>
<p>关系型数据库：存放的是实体之间的关系</p>
<p>ER模型图：E：Entity  R：Relational  （实体用矩形，属性用椭圆，关系用菱形）</p>
<p>表：对应一个实体类</p>
<p>对数据库的添加，修改，删除，查询操作</p>
<p>对数据库表的添加，修改，删除，查询操作</p>
<p>对数据库表记录的添加，修改，删除，查询操作</p>
<p>常见的关系型数据库：</p>
<p><strong>MySQL</strong></p>
<p><strong>Oracle</strong></p>
<p>SQLServer</p>
<p>DB2</p>
<p>SyBase</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps18.jpg" alt="img"> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/" data-id="ckqk8k3e0003q2wwdb7w63bng" data-title="数据库和SQL语句" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-15.1.Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/15.1.Redis/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:28:54.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/15.1.Redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个开源的使用ANSI <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1219.htm">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1088.htm">数据库</a>，并提供多种语言的APIRedis是一个开源的使用ANSI <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1219.htm">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1088.htm">数据库</a>，并提供多种语言的API</p>
<p>从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助</p>
<p>Redis是 NoSQL（not only SQL）技术阵营中的一员，它通过多种键值数据类型来适应不同场景下的存储需求，借助一些高层级的接口使用其可以胜任，如缓存、队列系统的不同角色</p>
<p>Redis可以保存在内存中（性能非常好），也可以持久化在文件中</p>
<p>Redis的官网: <a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<p>经常用的数据成缓存，所以用redis</p>
<p>特性：</p>
<p>1.Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</p>
<p>2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</p>
<p>3.Redis支持数据的备份，即master-slave模式的数据备份</p>
<p>优势：</p>
<p>1.性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s</p>
<p>2.丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作</p>
<p>3.原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行</p>
<p>4.丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性</p>
<h1 id="Redis下载及安装"><a href="#Redis下载及安装" class="headerlink" title="Redis下载及安装"></a>Redis下载及安装</h1><p>Redis版本说明</p>
<p>Redis原生只支持linux系统。Redis官方是不支持windows平台，windows版本是微软自己建立的分支，基于官方的redis源码上进行编译、发布、维护的，所以window平台上的redis版本都略低于官方版本</p>
<p>当前redis最新版本是6.0</p>
<p>可以直接在windows上下载，通过上传工具上传到linux系统，也可以在linux下直接复制最新稳定版本下载链接的网址，然后wget+网址（这种方式必须要求可以上网）</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps1.jpg" alt="img"> </p>
<p>Redis安装：</p>
<p>1.将redis.tar.gz解压：tar -zxvf redis-3.2.8.tar.gz</p>
<p>mkdir redis  建一个目录</p>
<p>2.进入redis-3.2.8目录：cd redis-3.2.8</p>
<p>3.对redis进行编译:make  </p>
<p>4.安装到指定的目录：make PREFIX=/usr/local/redis install</p>
<p>如果安装redis是报下面的错误，是因为系统没有安装gcc环境，缺少依赖</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps2.jpg" alt="img"> </p>
<p>解决方案：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps3.jpg" alt="img"> </p>
<p>安装完成后，对redis进行重新编译安装</p>
<p>redis安装完成后，我们进入目录bin中查看</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps4.jpg" alt="img"> </p>
<p>redis-server          redis服务器</p>
<p>redis-cli           redis命令行客户端</p>
<p>redis-benchmark          redis性能测试工具</p>
<p>redis-check-aof         AOF文件修复工具</p>
<p>redis-check-rdb          RDB文件检索工具</p>
<p>redis客户端测试：</p>
<p>1.启动redis服务</p>
<p>./redis-server是可以启动的，但是有风险，只在测试环境下可以。正常启动需要加载配置文件</p>
<p>注意：我们需要将redis编译后的目录中的redis.conf文件copy到我们自己的redis目录中。 cp redis.conf /usr/local/redis </p>
<p>这个redis.conf文件是redis的配置文件</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps5.jpg" alt="img"> </p>
<p>在输入</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps6.jpg" alt="img">就可以启动</p>
<p>注意:前面是redis-server服务，后面redis.conf配置文件</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps7.jpg" alt="img"> </p>
<p>Redis占用的端口是6379</p>
<p>可以通过redis-cli命令行客户端来测试redis是否启动成功</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps8.jpg" alt="img"> </p>
<p>其他ip地址不能连接是因为配置文件中只允许回环地址127.0.0.1连接</p>
<p>windows版redis</p>
<p>github下载或者百度网盘找到.msi的安装包，按步骤安装。</p>
<p>验证：</p>
<p>1、打开cmd窗口，输入redis-cli.exe -h 127.0.0.1 -p 6379后回车，出现127.0.0.1：6379说明redis安装且连接成功</p>
<p>2.试下是否能够存储成功：set key1 value1       get key1</p>
<p>3.设置redis密码：</p>
<p>​    查看密码：config get requirepass</p>
<p>​    设置密码：config set requirepass 123456</p>
<p>​    除去密码：config set requirepass ‘’</p>
<p>4.带密码登录，不然提示没有权限</p>
<p>redis-cli.exe -h 127.0.0.1 -p 6379 -a 密码</p>
<p>redis-cli.exe -h 127.0.0.1 -p 6379后进行操作提示没有权限时，  auth 密码</p>
<h1 id="Redis数据类型与常见操作"><a href="#Redis数据类型与常见操作" class="headerlink" title="Redis数据类型与常见操作"></a>Redis数据类型与常见操作</h1><p>redis是一个key-value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/51839.htm">存储系统</a>。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/549479.htm">链表</a>)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）</p>
<h2 id="string类型常见操作"><a href="#string类型常见操作" class="headerlink" title="string类型常见操作"></a>string类型常见操作</h2><p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。</p>
<p>在Redis中字符串类型的Value最多可以容纳的数据长度是512M</p>
<p>常见操作（小写也可）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">SET key value 	 </span><br><span class="line">设定该Key持有指定的字符串Value，如果该Key已经存在，则覆盖其原有值。返回值：总是返回&quot;OK&quot;</span><br><span class="line"></span><br><span class="line">GET key 	 </span><br><span class="line">获取指定Key的Value。如果与该Key关联的Value不是string类型，Redis将返回错误信息，因为GET命令只能用于获取string Value</span><br><span class="line">返回值：与该Key相关的Value，如果该Key不存在，则返回nil。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MSET key value [key value ...] 	 </span><br><span class="line">该命令原子性的完成参数中所有key&#x2F;value的设置操作，其具体行为可以看成是多次迭代执行SET命令。 </span><br><span class="line">返回值：该命令不会失败，始终返回OK。 </span><br><span class="line"></span><br><span class="line">MGET key [key ...]  </span><br><span class="line">返回所有指定Keys的Values，如果其中某个Key不存在，或者其值不为string类型，该Key的Value将返回nil。	</span><br><span class="line">返回值：返回一组指定Keys的Values的列表。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">SETNX key value  </span><br><span class="line">如果指定的Key不存在，则设定该Key持有指定字符串Value，此时其效果等价于SET命令。相反，如果该Key已经存在，该命令将不做任何操作并返回。</span><br><span class="line">返回值：1表示设置成功，否则0。（not exists）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MSETNX key value [key value ...] 	 </span><br><span class="line">该命令原子性的完成参数中所有key&#x2F;value的设置操作，其具体行为可以看成是多次迭代执行SETNX命令。然而这里需要明确说明的是，如果在这一批Keys中有任意一个Key已经存在了，那么该操作将全部回滚，即所有的修改都不会生效。</span><br><span class="line">返回值：1表示所有Keys都设置成功，0则表示没有任何Key被修改。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">APPEND key value  </span><br><span class="line">如果该Key已经存在，APPEND命令将参数Value的数据追加到已存在Value的末尾。如果该Key不存在，APPEND命令将会创建一个新的Key&#x2F;Value。</span><br><span class="line">返回值：追加后Value的长度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DECR key	 </span><br><span class="line">将指定Key的Value原子性的递减1。如果该Key不存在，其初始值为0，在decr之后其值为-1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。（error）</span><br><span class="line">返回值：递减后的Value值。</span><br><span class="line"></span><br><span class="line">INCR key	 </span><br><span class="line">将指定Key的Value原子性的递增1。如果该Key不存在，其初始值为0，在incr之后其值为1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。</span><br><span class="line">返回值：递增后的Value值。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">DECRBY key decrement  </span><br><span class="line">将指定Key的Value原子性的减少decrement。如果该Key不存在，其初始值为0，在decrby之后其值为-decrement。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</span><br><span class="line">返回值：减少后的Value值。</span><br><span class="line"></span><br><span class="line">INCRBY key increment   </span><br><span class="line">将指定Key的Value原子性的增加increment。如果该Key不存在，其初始值为0，在incrby之后其值为increment。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</span><br><span class="line">返回值：增加后的Value值。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">GETSET key value	 </span><br><span class="line">原子性的设置该Key为指定的Value，同时返回该Key的原有值。和GET命令一样，该命令也只能处理string Value，否则Redis将给出相关的错误信息。</span><br><span class="line">返回值：返回该Key的原有值，如果该Key之前并不存在，则返回nil。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">l STRLEN key	 </span><br><span class="line"></span><br><span class="line">返回指定Key的字符值长度，如果Value不是string类型，Redis将执行失败并给出相关的错误信息。</span><br><span class="line"></span><br><span class="line">返回值：指定Key的Value字符长度，如果该Key不存在，返回0。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">l SETEX key seconds value	 </span><br><span class="line"></span><br><span class="line">原子性完成两个操作，一是设置该Key的值为指定字符串，同时设置该Key在Redis服务器中的存活时间(秒数)。该命令主要应用于Redis被当做Cache服务器使用时。	 （expire，到期）</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">l SETRANGE key offset value  </span><br><span class="line"></span><br><span class="line">替换指定Key的部分字符串值。从offset开始，替换的长度为该命令第三个参数value的字符串长度，其中如果offset的值大于该Key的原有值Value的字符串长度，Redis将会在Value的后面补齐(offset - strlen(value))数量的0x00，之后再追加新值。如果该键不存在，该命令会将其原值的长度假设为0，并在其后添补offset个0x00后再追加新值。鉴于字符串Value的最大长度为512M，因此offset的最大值为536870911。最后需要注意的是，如果该命令在执行时致使指定Key的原有值长度增加，这将会导致Redis重新分配足够的内存以容纳替换后的全部字符串，因此就会带来一定的性能折损。</span><br><span class="line"></span><br><span class="line">返回值：修改后的字符串Value长度。</span><br><span class="line"></span><br><span class="line">l GETRANGE key start end	 </span><br><span class="line"></span><br><span class="line">截取字符串。该命令在截取子字符串时，将以闭区间的方式同时包含start(0表示第一个字符)和end所在的字符，如果end值超过Value的字符长度，该命令将只是截取从start开始之后所有的字符数据。当end为-1时表示是最后一位，-4 -1表示从后数4位</span><br><span class="line"></span><br><span class="line">返回值：子字符串；</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">l SETBIT key offset value 	 </span><br><span class="line"></span><br><span class="line">设置在指定Offset上BIT的值，该值只能为1或0，在设定后该命令返回该Offset上原有的BIT值。如果指定Key不存在，该命令将创建一个新值，并在指定的Offset上设定参数中的BIT值。如果Offset大于Value的字符长度，Redis将拉长Value值并在指定Offset上设置参数中的BIT值，中间添加的BIT值为0。最后需要说明的是Offset值必须大于0。</span><br><span class="line"></span><br><span class="line">返回值：在指定Offset上的BIT原有值。</span><br><span class="line"></span><br><span class="line">l GETBIT key offset 	 </span><br><span class="line"></span><br><span class="line">返回在指定Offset上BIT的值，0或1。如果Offset超过string value的长度，该命令将返回0，所以对于空字符串始终返回0。</span><br><span class="line"></span><br><span class="line">返回值：在指定Offset上的BIT值。 </span><br><span class="line"></span><br><span class="line">(布隆过滤器)</span><br><span class="line"></span><br><span class="line">a  97  0110 0001	</span><br><span class="line"></span><br><span class="line">A  65  0100 0001  其实只用 setbit key 2 0  就将a改为了A（从0开始计数）</span><br></pre></td></tr></table></figure>

<p>2.list类型常见操作</p>
<p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的****普通链表****一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。</p>
<p>从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。</p>
<p>常见操作</p>
<p>l LPUSH key value [value …]      </p>
<p>在指定Key所关联的List Value的头部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的头部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。</p>
<p>返回值：插入后链表中元素的数量。</p>
<p>l LPUSHX key value       （x相当于判断）</p>
<p>仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的头部插入参数中给出的Value，否则将不会有任何操作发生。    </p>
<p>返回值：插入后链表中元素的数量。 </p>
<p>l LRANGE key start stop      </p>
<p>该命令的参数start和end都是0-based。即0表示链表头部(leftmost)的第一个元素。其中start的值也可以为负值，-1将表示链表中的最后一个元素，即尾部元素，-2表示倒数第二个并以此类推。该命令在获取元素时，start和end位置上的元素也会被取出。如果start的值大于链表中元素的数量，空链表将会被返回。如果end的值大于元素的数量，该命令则获取从start(包括start)开始，链表中剩余的所有元素。</p>
<p>返回值：返回指定范围内元素的列表。</p>
<p>这里的链表插入的头部插入相当于是栈：插入12345，输出时就会是54321</p>
<p>lrange key 0 -1 表示返回这个链表的所有元素</p>
<p>l LPOP key      （相当于把头部的那个元素移除）</p>
<p>返回并弹出指定Key关联的链表中的第一个元素，即头部元素。如果该Key不存，返回nil。</p>
<p>返回值：链表头部的元素。</p>
<p>l LLEN key     </p>
<p>返回指定Key关联的链表中元素的数量，如果该Key不存在，则返回0。如果与该Key关联的Value的类型不是链表，则返回相关的错误信息。</p>
<p>返回值：链表中元素的数量。</p>
<p>l LREM key count value  </p>
<p>在指定Key关联的链表中，删除前count个值等于value的元素。如果count大于0，从头向尾遍历并删除，如果count小于0，则从尾向头遍历并删除。</p>
<p>如果count等于0，则删除链表中所有等于value的元素。如果指定的Key不存在，则直接返回0。    </p>
<p>返回值：返回被删除的元素数量。</p>
<p>l LSET key index value </p>
<p>设定链表中指定位置的值为新值，其中0表示第一个元素，即头部元素，-1表示尾部元素。如果索引值Index超出了链表中元素的数量范围，该命令将返回相关的错误信息。     </p>
<p>(对指定脚标的值进行设置)</p>
<p>返回值：OK</p>
<p>l LINDEX key index      </p>
<p>该命令将返回链表中指定位置(index)的元素，index是0-based，表示头部元素，如果index为-1，表示尾部元素。如果与该Key关联的不是链表，该命令将返回相关的错误信息。    </p>
<p>返回值：返回请求的元素，如果index超出范围，则返回nil。</p>
<p>(读出指定脚标的值)</p>
<p>l LTRIM key start stop      </p>
<p>该命令将仅保留指定范围内的元素，从而保证链接中的元素数量相对恒定。start和stop参数都是0-based，0表示头部元素。和其他命令一样，start和stop也可以为负值，-1表示尾部元素。如果start大于链表的尾部，或start大于stop，该命令不会报错，而是返回一个空的链表，与此同时该Key也将被删除。如果stop大于元素的数量，则保留从start开始剩余的所有元素。     </p>
<p>l LINSERT key BEFORE|AFTER pivot value  </p>
<p>该命令的功能是在pivot元素的前面或后面插入参数中的元素value。如果Key不存在，该命令将不执行任何操作。如果与Key关联的Value类型不是链表，相关的错误信息将被返回。    </p>
<p>返回值：成功插入后链表中元素的数量，如果没有找到pivot，返回-1，如果key不存在，返回0。</p>
<p>(在指定的某个value前或后插入一个新的value)</p>
<p>l RPUSH key value [value …]      </p>
<p>在指定Key所关联的List Value的尾部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的尾部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。 </p>
<p>返回值：插入后链表中元素的数量。 </p>
<p>l RPUSHX key value </p>
<p>仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的尾部插入参数中给出的Value，否则将不会有任何操作发生。</p>
<p>返回值：插入后链表中元素的数量。 </p>
<p>l RPOP key      </p>
<p>返回并弹出指定Key关联的链表中的最后一个元素，即尾部元素，。如果该Key不存，返回nil。 </p>
<p>返回值：链表尾部的元素。 </p>
<p>l RPOPLPUSH source destination      </p>
<p>原子性的从与source键关联的链表尾部弹出一个元素，同时再将弹出的元素插入到与destination键关联的链表的头部。如果source键不存在，该命令将返回nil，同时不再做任何其它的操作了。如果source和destination是同一个键，则相当于原子性的将其关联链表中的尾部元素移到该链表的头部。    </p>
<p>返回值：返回弹出和插入的元素</p>
<p>3.hash类型常见操作</p>
<p>Redis中的Hashes类型可以看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如用户信息：Username、Password和Age等。每一个Hash可以存储4294967295个键值对。</p>
<p>常见操作</p>
<p>l HSET key field value     </p>
<p>为指定的Key设定Field/Value对，如果Key不存在，该命令将创建新Key以参数中的Field/Value对，如果参数中的Field在该Key中已经存在，则用新值覆盖其原有值。</p>
<p>返回值：1表示新的Field被设置了新值，0表示Field已经存在，用新值覆盖原有值。 </p>
<p>l HGET key field      </p>
<p>返回指定Key中指定Field的关联值。    </p>
<p>返回值：返回参数中Field的关联值，如果参数中的Key或Field不存，返回nil。</p>
<p>l HSETNX key field value     </p>
<p>只有当参数中的Key或Field不存在的情况下，为指定的Key设定Field/Value对，否则该命令不会进行任何操作。 </p>
<p>返回值：1表示新的Field被设置了新值，0表示Key或Field已经存在，该命令没有进行任何操作。</p>
<p>l HEXISTS key field      </p>
<p>判断指定Key中的指定Field是否存在。    </p>
<p>返回值：1表示存在，0表示参数中的Field或Key不存在。</p>
<p>l HLEN key      </p>
<p>获取该Key所包含的Field的数量。    返回Key包含的Field数量，如果Key不存在，返回0。</p>
<p>l HDEL key field [field …]      </p>
<p>从指定Key的Hashes Value中删除参数中指定的多个字段，如果不存在的字段将被忽略。</p>
<p>返回值：如果Key不存在，则将其视为空Hashes，并返回0，否则返回实际删除的Field数量。</p>
<p>l HINCRBY key field increment      </p>
<p>增加指定Key中指定Field关联的Value的值。如果Key或Field不存在，该命令将会创建一个新Key或新Field，并将其关联的Value初始化为0，之后再指定数字增加的操作。该命令支持的数字是64位有符号整型，即increment可以负数。返回值：运算后的值。</p>
<p>l HGETALL key     </p>
<p>获取该键包含的所有Field/Value。其返回格式为一个Field、一个Value，并以此类推。    </p>
<p>返回值：Field/Value的列表。</p>
<p>l HKEYS key      </p>
<p>返回指定Key的所有Fields名。    </p>
<p>返回值：Field的列表。</p>
<p>l HVALS key      </p>
<p>返回指定Key的所有Values名。 </p>
<p>返回值：Value的列表。 </p>
<p>l HMGET key field [field …]      </p>
<p>获取和参数中指定Fields关联的一组Values。如果请求的Field不存在，其值返回nil。如果Key不存在，该命令将其视为空Hash，因此返回一组nil。    </p>
<p>返回值：返回和请求Fields关联的一组Values，其返回顺序等同于Fields的请求顺序。</p>
<p>l HMSET key field value [field value …]     </p>
<p>逐对依次设置参数中给出的Field/Value对。如果其中某个Field已经存在，则用新值覆盖原有值。如果Key不存在，则创建新Key，同时设定参数中的Field/Value</p>
<p>4.set类型常见操作（不重复，可以完成交并差操作）</p>
<p>在Redis中，我们可以将Set类型看作为没有排序的字符串集合。Set可包含的最大元素数量是4294967295。</p>
<p>Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。</p>
<p>常见操作</p>
<p>l SADD key member [member …]     </p>
<p>如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。</p>
<p>返回值：本次操作实际插入的成员数量。</p>
<p>l SCARD key     </p>
<p>获取Set中成员的数量。    </p>
<p>返回值：返回Set中成员的数量，如果该Key并不存在，返回0。</p>
<p>l SISMEMBER key member     </p>
<p>判断参数中指定成员是否已经存在于与Key相关联的Set集合中。    </p>
<p>返回值：1表示已经存在，0表示不存在，或该Key本身并不存在。</p>
<p>l SMEMBERS key     </p>
<p>获取与该Key关联的Set中所有的成员。</p>
<p>返回值：返回Set中所有的成员。</p>
<p>l SPOP  key      </p>
<p>随机的移除并返回Set中的某一成员。 由于Set中元素的布局不受外部控制，因此无法像List那样确定哪个元素位于Set的头部或者尾部。    </p>
<p>返回值：返回移除的成员，如果该Key并不存在，则返回nil。</p>
<p>l SRANDMEMBER key      </p>
<p>和SPOP一样，随机的返回Set中的一个成员，不同的是该命令并不会删除返回的成员。    </p>
<p>返回值：返回随机位置的成员，如果Key不存在则返回nil。</p>
<p>l SREM key member [member …]     </p>
<p>从与Key关联的Set中删除参数中指定的成员，不存在的参数成员将被忽略，如果该Key并不存在，将视为空Set处理。    </p>
<p>返回值：从Set中实际移除的成员数量，如果没有则返回0。</p>
<p>l SMOVE source destination member     </p>
<p>原子性的将参数中的成员从source键移入到destination键所关联的Set中。如果该成员在source中并不存在，该命令将不会再执行任何操作并返回0，否则，该成员将从source移入到destination。如果此时该成员已经在destination中存在，那么该命令仅是将该成员从source中移出。</p>
<p>返回值：1表示正常移动，0表示source中并不包含参数成员。</p>
<p>l SDIFF key [key …]     </p>
<p>返回参数中第一个Key所关联的Set和其后所有Keys所关联的Sets中成员的差异。如果Key不存在，则视为空Set。    </p>
<p>返回值：差异结果成员的集合。</p>
<p>l SDIFFSTORE destination key [key …]      </p>
<p>该命令和SDIFF命令在功能上完全相同，两者之间唯一的差别是SDIFF返回差异的结果成员，而该命令将差异成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。    </p>
<p>返回值：返回差异成员的数量。</p>
<p>l SINTER key [key …]      </p>
<p>该命令将返回参数中所有Keys关联的Sets中成员的交集。因此如果参数中任何一个Key关联的Set为空，或某一Key不存在，那么该命令的结果将为空集。</p>
<p>返回值：交集结果成员的集合。</p>
<p>l SINTERSTORE destination key [key …]     </p>
<p>该命令和SINTER命令在功能上完全相同，两者之间唯一的差别是SINTER返回交集的结果成员，而该命令将交集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。    </p>
<p>返回值：返回交集成员的数量。 </p>
<p>l SUNION key [key …]      </p>
<p>该命令将返回参数中所有Keys关联的Sets中成员的并集。    </p>
<p>返回值：并集结果成员的集合。</p>
<p>l SUNIONSTORE destination key [key …]      </p>
<p>该命令和SUNION命令在功能上完全相同，两者之间唯一的差别是SUNION返回并集的结果成员，而该命令将并集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。 </p>
<p>返回值：返回并集成员的数量</p>
<p>5.sortedSet类型常见操作</p>
<p>Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的<em><strong>*成员必须是唯一*<em><strong>的，但是</strong></em>*分数*</strong>***</em>*(score)********却是可以重复****的。</p>
<p>在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。</p>
<p>常见操作</p>
<p>l ZADD key score member [score] [member]      </p>
<p>添加参数中指定的所有成员及其分数到指定key的Sorted-Set中，在该命令中我们可以指定多组score/member作为参数。如果在添加时参数中的某一成员已经存在，该命令将更新此成员的分数为新值，同时再将该成员基于新值重新排序。如果键不存在，该命令将为该键创建一个新的Sorted-Sets Value，并将score/member对插入其中。</p>
<p>返回值：本次操作实际插入的成员数量。</p>
<p>l ZINCRBY key increment member      </p>
<p>该命令将为指定Key中的指定成员增加指定的分数。如果成员不存在，该命令将添加该成员并假设其初始分数为0，此后再将其分数加上increment。如果Key不存，该命令将创建该Key及其关联的Sorted-Sets，并包含参数指定的成员，其分数为increment参数。</p>
<p>返回值：以字符串形式表示的新分数。</p>
<p>l ZCARD key      </p>
<p>获取与该Key相关联的Sorted-Sets中包含的成员总数量。</p>
<p>返回值：返回Sorted-Sets中的成员数量，如果该Key不存在，返回0。</p>
<p>l ZCOUNT key min max     </p>
<p>该命令用于获取<em><strong>*分数*</strong>***</em>*(score)****在min和max之间的成员数量。缺省情况下，min和max表示的范围是闭区间范围，即min &lt;= score &lt;= max内的成员将被返回。然而我们可以通过在min和max的前面添加”(“字符来表示开区间，如(min max表示min &lt; score &lt;= max，而(min (max表示min &lt; score &lt; max。</p>
<p>返回值：分数指定范围内成员的数量。</p>
<p>l ZRANGE key start stop [WITHSCORES]      </p>
<p>该命令返回****排名****在参数start和stop指定范围内的成员，这里start和stop参数都是0-based，即0表示第一个成员，-1表示最后一个成员。如果start大于该Sorted-Set中的最大索引值，或start &gt; stop，此时一个空集合将被返回。如果stop大于最大索引值，该命令将返回从start到集合的最后一个成员。如果命令中带有可选参数WITHSCORES选项，该命令在返回的结果中将包含每个成员的分数值，如value1,score1,value2,score2…。　　    </p>
<p>返回值：返回索引在start和stop之间的成员列表。</p>
<p>l ZREVRANGE key start stop [WITHSCORES]   </p>
<p>该命令的功能和ZRANGE基本相同，唯一的差别在于顺序相反。    </p>
<p>返回值：返回指定的成员列表。</p>
<p>l ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]      </p>
<p>该命令将返回****分数****在min和max范围内的成员，即满足表达式min &lt;= score &lt;= max的成员，其中返回的成员是按照其分数从低到高的顺序返回，如果成员具有相同的分数，则按成员的字典顺序返回。可选参数LIMIT用于限制返回成员的数量范围。可选参数offset表示从符合条件的第offset个成员开始返回，同时返回count个成员。</p>
<p>返回值：返回分数在指定范围内的成员列表。</p>
<p>l ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]      </p>
<p>该命令除了排序方式是基于从高到低的分数排序之外，其它功能和参数含义均与ZRANGEBYSCORE相同。    </p>
<p>返回值：返回分数在指定范围内的成员列表。 </p>
<p>l ZRANK key member      </p>
<p>该命令将返回参数中指定****成员的位置值****（按分数由低到高的顺序），其中0表示第一个成员，它是Sorted-Set中分数最低的成员。</p>
<p>返回值：如果该成员存在，则返回它的位置索引值。否则返回nil。</p>
<p>l ZREVRANK key member      </p>
<p>该命令的功能和ZRANK基本相同，唯一的差别在于顺序相反    </p>
<p>返回值：如果该成员存在，则返回它的位置索引值。否则返回nil。 </p>
<p>l ZSCORE key member     </p>
<p>获取指定成员的分数。    </p>
<p>返回值：如果该成员存在，以字符串的形式返回其分数，否则返回nil。</p>
<p>l ZREM key member [member …]     </p>
<p>该命令将移除参数中指定的成员，其中不存在的成员将被忽略。如果与该Key关联的Value不是Sorted-Set，相应的错误信息将被返回。</p>
<p>返回值：实际被删除的成员数量。</p>
<p>l ZREMRANGEBYRANK key start stop      </p>
<p>删除索引位置位于start和stop之间的成员，start和stop都是0-based，即0表示分数最低的成员，-1表示最后一个成员，即分数最高的成员。     </p>
<p>返回值：被删除的成员数量。</p>
<p>l ZREMRANGEBYSCORE key min max      </p>
<p>删除分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的所有成员。对于min和max参数，可以采用开区间的方式表示，具体规则参照ZCOUNT。 </p>
<p>返回值：被删除的成员数量</p>
<p>6.Key通用操作</p>
<p>l KEYS pattern     </p>
<p>获取所有匹配pattern参数（正则）的Keys。需要说明的是，在我们的正常操作中应该尽量避免对该命令的调用，因为对于大型数据库而言，该命令是非常耗时的，对Redis服务器的性能打击也是比较大的。pattern支持glob-style的通配符格式，如*表示任意一个或多个字符，?表示任意字符，[abc]表示方括号中任意一个字母。    匹配模式的键列表。</p>
<p>l DEL key [key …]     </p>
<p>从数据库删除中参数中指定的keys，如果指定键不存在，则直接忽略。还需要另行指出的是，如果指定的Key关联的数据类型不是String类型，而是List、Set、Hashes和Sorted Set等容器类型，该命令删除每个键的时间复杂度为O(M)，其中M表示容器中元素的数量。而对于String类型的Key，其时间复杂度为O(1)。</p>
<p>返回值：实际被删除的Key数量。</p>
<p>l EXISTS key      </p>
<p>判断指定键是否存在。    </p>
<p>返回值：1表示存在，0表示不存在。</p>
<p>l MOVE key db      </p>
<p>将当前数据库中指定的键Key移动到参数中指定的数据库中。如果该Key在目标数据库中已经存在，或者在当前数据库中并不存在，该命令将不做任何操作并返回0。     </p>
<p>返回值：移动成功返回1，否则0。</p>
<p>在redis.conf文件中定义了redis的默认库的数量</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps9.jpg" alt="img"> </p>
<p>我们可以使用select 数值 来进行库的切换: select  10.</p>
<p>l RENAME key newkey      </p>
<p>为指定的键重新命名，如果参数中的两个Keys的名字相同，或者是源Key不存在，该命令都会返回相关的错误信息。如果newKey已经存在，则直接覆盖。  </p>
<p>l RENAMENX key newkey     </p>
<p>如果新值不存在，则将参数中的原值修改为新值。其它条件和RENAME一致。</p>
<p>返回值：1表示修改成功，否则0。</p>
<p>l PERSIST key     </p>
<p>如果Key存在过期时间，该命令会将其过期时间消除，使该Key不再有超时，而是可以持久化存储。    </p>
<p>返回值：1表示Key的过期时间被移除，0表示该Key不存在或没有过期时间。</p>
<p>l EXPIRE key seconds      </p>
<p>该命令为参数中指定的Key设定超时的秒数，在超过该时间后，Key被自动的删除。如果该Key在超时之前被修改，与该键关联的超时将被移除。 </p>
<p>返回值：1表示超时被设置，0则表示Key不存在，或不能被设置。</p>
<p>l EXPIREAT key timestamp  </p>
<p>该命令的逻辑功能和EXPIRE完全相同，唯一的差别是该命令指定的超时时间是绝对时间，而不是相对时间。该时间参数是Unix timestamp格式的，即从1970年1月1日开始所流经的秒数。    </p>
<p>返回值：1表示超时被设置，0则表示Key不存在，或不能被设置。 </p>
<p>l TTL key      </p>
<p>获取该键所剩的超时描述。 </p>
<p>返回值：返回所剩描述，如果该键不存在或没有超时设置，则返回-1。</p>
<p>l RANDOMKEY     </p>
<p>从当前打开的数据库中随机的返回一个Key。    </p>
<p>返回值：返回的随机键，如果该数据库是空的则返回nil。</p>
<p>l TYPE key      </p>
<p>获取与参数中指定键关联值的类型，该命令将以字符串的格式返回。    </p>
<p>返回值：返回的字符串为string、list、set、hash和zset，如果key不存在返回none</p>
<p>7.事务</p>
<p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<p>l 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>l 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<p>开始事务。<em><strong>*MULTI*</strong></em> </p>
<p>命令入队。执行的redis的操作</p>
<p>执行事务。<em><strong>*EXEC*</strong></em> </p>
<p>事务常用命令</p>
<p>l MULTI</p>
<p>Redis Multi 命令用于标记一个事务块的开始。</p>
<p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p>
<p>返回值:总是返回OK</p>
<p>l EXEC</p>
<p>Redis Exec 命令用于执行所有事务块内的命令</p>
<p>返回值: 事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</p>
<p>l DISCARD</p>
<p>Redis Discard 命令用于取消事务，放弃执行事务块内的所有命令。</p>
<p>返回值: 总是返回 OK 。</p>
<p>l WATCH</p>
<p>Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</p>
<p>l UNWATCH</p>
<p>Redis Unwatch 命令用于取消 WATCH 命令对所有 key 的监视</p>
<h1 id="Redis-java-客户端-jedis"><a href="#Redis-java-客户端-jedis" class="headerlink" title="*Redis java*****客户端*****jedis*"></a><em><strong>*Redis java*</strong>***</em>*客户端****<em><strong>*jedis*</strong></em></h1><p>Jedis介绍与快速入门</p>
<p>通过java来操作redis：使用jedis</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps10.jpg" alt="img"> </p>
<p>搭建jedis环境：</p>
<p>新建一个javaproject，复制jar包到lib下，右键addpath构建路径</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps11.jpg" alt="img"> </p>
<p>编写代码</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps12.jpg" alt="img"> </p>
<p>程序执行报错：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps13.jpg" alt="img"> </p>
<p>原因:</p>
<p>1.redis服务器是否开启：linux上加载redis-server和redis.conf查看开启</p>
<p>2.linux的防火墙是否关闭：service iptables stop  关了之后在重启redis服务器</p>
<p>3.在redis.conf配置文件中 bind 127.0.0.1 代表的是外部不可以访问redis（可以把它注释掉，前面加#）</p>
<p>通过以上操作，错误信息不一样了：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps14.jpg" alt="img"> </p>
<p>原因：是我们没有设置密码</p>
<p>我们需要在redis.conf文件中设置密码admin：查找到requirepass，将前面的#删掉，然后将后面的改为admin，：wq保存退出</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps15.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps16.jpg" alt="img"> </p>
<p>有密码的情况下，在命令行下连接redis需加上-a：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps17.jpg" alt="img"> </p>
<p>string类型常见操作</p>
<p>//string操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo2 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示 set get</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.set(“username”, “tom”);        </p>
<p>​        String value = jedis.get(“username”);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示mset mget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        jedis.mset(“password”,”123”,”age”,”20”);</p>
<p>​        </p>
<p>​        List<String> values = jedis.mget(“username”,”password”,”age”);</p>
<p>​        </p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示 append  setrange getrange</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        //jedis.append(“username”,” is boy”);</p>
<p>​        </p>
<p>​        //jedis.setrange(“username”, 7,”girl”);</p>
<p>​        System.****<em>out*</em>***.println(jedis.get(“username”));</p>
<p>​        </p>
<p>​        </p>
<p>​        System.****<em>out*</em>***.println(jedis.getrange(“username”, 7, -1));</p>
<p>​    }</p>
<p>}</p>
<p>list类型常见操作：</p>
<p>//list操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo3 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示lpush lrange</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.lpush(“names”, “tom”, “james”, “张三”, “李四”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>​    // lset</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        // jedis.lset(“names”, 1, “王五”);</p>
<p>​        // List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        // System.out.println(names);</p>
<p>​        String value = jedis.lindex(“names”, 1);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    // linsert</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3() {</p>
<p>​        jedis.linsert(“names”, LIST_POSITION.****<em>BEFORE*</em>***, “james”, “fox”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>​    </p>
<p>​    // lrem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.lrem(“names”, 1, “tom”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>}</p>
<p>hash类型常见操作</p>
<p>//hash操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo4 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示hset hget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.hset(“user”, “username”, “tom”);</p>
<p>​        String value = jedis.hget(“user”, “username”);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    // 演示hmset hmget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        Map&lt;String, String&gt; hash = <em><strong>*new*</strong></em> HashMap&lt;String, String&gt;();</p>
<p>​        hash.put(“password”, “123”);</p>
<p>​        hash.put(“sex”, “male”);</p>
<p>​        jedis.hmset(“user”, hash);</p>
<p>​        List<String> values = jedis.hmget(“user”, “username”, “password”, “sex”);</p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示 hgetall hkeys kvals</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        Map&lt;String, String&gt; map = jedis.hgetAll(“user”);</p>
<p>​        <em><strong>*for*</strong></em>(String key:map.keySet()){</p>
<p>​            System.****<em>out*</em>***.println(key+”  “+map.get(key));</p>
<p>​        }</p>
<p>​        </p>
<p>​        Set<String> keys = jedis.hkeys(“user”);</p>
<p>​        System.****<em>out*</em>***.println(keys);</p>
<p>​        </p>
<p>​        List<String> values = jedis.hvals(“user”);</p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>//    演示hdel</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.hdel(“user”, “username”,”password”);</p>
<p>​        Map&lt;String, String&gt; map = jedis.hgetAll(“user”);</p>
<p>​        <em><strong>*for*</strong></em>(String key:map.keySet()){</p>
<p>​            System.****<em>out*</em>***.println(key+”  “+map.get(key));</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>set类型常见操作</p>
<p>//set操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo5 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);        </p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示sadd smembers</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        </p>
<p>​        Set<String> smembers = jedis.smembers(“language1”);</p>
<p>​        System.****<em>out*</em>***.println(smembers);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示srem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        jedis.srem(“language1”, “java”);</p>
<p>​        Set<String> smembers = jedis.smembers(“language1”);</p>
<p>​        System.****<em>out*</em>***.println(smembers);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //差集 sdiff</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        </p>
<p>​        Set<String> sdiff = jedis.sdiff(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sdiff);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //交集</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        Set<String> sinter = jedis.sinter(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sinter);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //并集</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test5(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        Set<String> sunion = jedis.sunion(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sunion);</p>
<p>​    }</p>
<p>​    </p>
<p>}</p>
<p>sortedSet类型常见操作</p>
<p>//sortedset操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo6 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示zadd zrange zrangeByScore</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Set<String> set = jedis.zrange(“zkey”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(set);</p>
<p>​        // 根据分数获取</p>
<p>​        Set<String> set1 = jedis.zrangeByScore(“zkey”, 70.0, 90.0);</p>
<p>​        System.****<em>out*</em>***.println(set1);</p>
<p>​    }</p>
<p>​    // 获取分数元素 zrangeWithScores</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Set<Tuple> zws = jedis.zrangeWithScores(“zkey”, 0, -1);</p>
<p>​        <em><strong>*for*</strong></em> (Tuple t : zws) {</p>
<p>​            System.****<em>out*</em>***.println(t.getScore() + “  “ + t.getElement());</p>
<p>​        }</p>
<p>​    }</p>
<p>​    // zrank</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Long num = jedis.zrank(“zkey”, “赵六”);</p>
<p>​        System.****<em>out*</em>***.println(num);</p>
<p>​    }</p>
<p>​    // zscore</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Double zscore = jedis.zscore(“zkey”, “张三”);</p>
<p>​        System.****<em>out*</em>***.println(zscore);</p>
<p>​    }</p>
<p>​    // zrem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test5() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        jedis.zrem(“zkey”, “李四”);</p>
<p>​        </p>
<p>​        Set<Tuple> zws = jedis.zrangeWithScores(“zkey”, 0, -1);</p>
<p>​        <em><strong>*for*</strong></em> (Tuple t : zws) {</p>
<p>​            System.****<em>out*</em>***.println(t.getScore() + “  “ + t.getElement());</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>key的常见操作</p>
<p>//key的通用操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo7 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // keys patten</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1(){</p>
<p>​        Set<String> keys = jedis.keys(“*”);</p>
<p>​        System.****<em>out*</em>***.println(keys);</p>
<p>​    }</p>
<p>​    </p>
<p>​    // del key</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        Long del = jedis.del(“user”);</p>
<p>​        System.****<em>out*</em>***.println(del);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //关于key时间设置</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        //jedis.expire(“username”, 200); //设置生命周期为200秒</p>
<p>​        jedis.persist(“username”);</p>
<p>​        Long ttl = jedis.ttl(“username”); //获取生命周期值</p>
<p>​        System.****<em>out*</em>***.println(ttl);</p>
<p>​        </p>
<p>​    }</p>
<p>}</p>
<h1 id="Redis-数据持久化"><a href="#Redis-数据持久化" class="headerlink" title="*Redis*****数据持久化****"></a><em><strong>*Redis*</strong>***</em>*数据持久化****</h1><p>Redis将内存存储和持久化存储相结合，既可提供数据访问的高效性，又可保证数据存储的安全性</p>
<p>1.Redis数据持久化机制介绍</p>
<p>1). RDB持久化：该机制是指在指定的时间间隔内将****内存中的数据集快照****写入磁盘。  </p>
<p>2). AOF(append only file)持久化:该机制将以****日志的形式记录服务器所处理的每一个写操作****，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</p>
<p>3). 同时应用AOF和RDB。 </p>
<p>4). 无持久化：可通过配置的方式禁用Redis服务器的持久化功能，这样我们就可以将Redis视为一个功能加强版的memcached了</p>
<p>2.Redis数据持久化配置与测试</p>
<p>l RDB快照方式:缺省情况下，Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开redis.conf文件之后，我们搜索save，可以看到下面的配置信息：</p>
<p>Ø save 900 1        </p>
<p>#在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。</p>
<p>Ø save 300 10       </p>
<p>#在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。</p>
<p>Ø save 60 10000     </p>
<p>#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</p>
<p>注意:关于dump.rdb文件存储的位置：它是设置是在redis.conf文件中dir ./</p>
<p>dir ./这段配置指的是服务器启动时的当前路径（在哪启动服务器时，这个rdb文件就在哪创建）。</p>
<p>l AOF日志文件方式：</p>
<p>Ø AOF日志持久化机制的开启：需要手动设置，在redis.conf文件中</p>
<p>将appendonly  no  改为 appendonly  yes</p>
<p>Ø AOF同步方式的配置：</p>
<p>在Redis的配置文件中存在三种同步方式，它们分别是：</p>
<p>appendfsync  always   #每次有数据修改发生时都会写入AOF文件。</p>
<p>appendfsync  everysec  #每秒钟同步一次，该策略为AOF的缺省策略。</p>
<p>appendfsync  no      #从不同步。高效但是数据不会被持久化。</p>
<p>3.RDB与AOF对比总结</p>
<p>l RDB存在哪些优势呢？</p>
<p>1). 数据的备份和恢复非常方便，因为一个数据库只有一个持久化文件</p>
<p>2). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p>
<p>3). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
<p>l RDB又存在哪些劣势呢？</p>
<p>1).系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
<p>2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p>l AOF的优势有哪些呢？</p>
<p>1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3种同步策略，即每秒同步、每修改同步和不同步。</p>
<p>2).对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。</p>
<p>3). 如果日志过大，Redis可以自动启用rewrite机制迅速“瘦身”(也可手动触发aof的rewrite操作，命令： bgrewriteaof)</p>
<p>4). AOF日志格式清晰、易于理解，很容易用AOF日志文件完成数据的重建。  </p>
<p>l AOF的劣势有哪些呢？</p>
<p>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。</p>
<p>2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/15.1.Redis/" data-id="ckqk8k3eo00632wwdb0e17us3" data-title="Redis" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.7.内部类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:50:38.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/">内部类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>内部类：把类定义在其他类的内部，这个类就被称为内部类。</p>
<p>内部类访问特点：</p>
<p>内部类可以直接访问外部类的成员，包括私有。</p>
<p>外部类要访问内部类的成员，必须创建对象。</p>
<p>内部类的位置：</p>
<p>成员位置：成员内部类</p>
<p>成员内部类是非静态的访问方式：</p>
<p>外部类名.内部类名  对象名 = new  外部类名.new 内部类名()；</p>
<p>eg：Outer.Inner  oi = new Outer().new Inner();</p>
<p>常见修饰符：</p>
<p>1.一般内部类是不让外界直接访问的，所以用private，保证了数据的安全性。</p>
<p>2.static为了让数据访问更方便。内部类用静态修饰是因为内部类可以看作是外部类的成员。（所以static可以修饰内部类，不能修饰类）</p>
<p>被静态修饰的成员内部类只能访问外部类的静态成员（静态只能访问静态）</p>
<p>成员内部类被静态修饰后，是不能被对象访问的，只能被类访问。它下面的方法可以是静态可以是非静态。</p>
<p>成员内部类是静态的访问方式：</p>
<p> 外部类名.内部类名  对象名=new 外部类名.内部类名();</p>
<p>eg：Outer.Inner oi = new Outer.Inner();</p>
<p>oi.静态方法();   oi.非静态方法();</p>
<p>静态内部类的静态方法还可以用：Outer.Inner.静态方法名();</p>
<p>局部位置：局部内部类</p>
<p>可以直接访问外部类的成员</p>
<p>在局部位置可以创建内部类对象，通过对象调用内部类方法来使用局部内部类的功能</p>
<p>局部内部类访问局部变量的注意事项：</p>
<p>局部内部类访问的局部变量必须用final修饰。（因为局部变量是随着方法的调用而调用，随着调用完毕而消失，而堆内存的内容不会立即消失（如果不是final修饰的话，就会矛盾报错），所以加final修饰，使变为常量，即使消失了，也有数据在使用）</p>
<p>匿名内部类:就是内部类的简化写法。</p>
<p>前提：存在一个类或者接口。（这里的类可以是具体类也可以是抽象类）</p>
<p>格式： new  类名或者接口名(){</p>
<p>重写方法；</p>
<p>}</p>
<p>本质：就是具体类的子类或者抽象类的具体实现类或者接口的实现类的匿名****对象****。</p>
<p>因为本质是一个对象，所以后面可以跟调用方法。</p>
<p>new  类名或者接口名(){</p>
<p>重写方法；</p>
<p>}.方法名();</p>
<p>当有多个方法要重写时，只能调一次方法，因为这是个匿名对象。所以改进：在前面赋值给父接口或者父类、父抽象类，这就是多态。（实际上就是在{}中补了很多代码，其他格式不变），最后再通过多态的对象调用方法。</p>
<p>匿名内部类在开发中的使用：在android中常见，在ee中不常见。因为匿名内部类用完就会被回收不占内存。匿名内部类只能用一次。</p>
<p>类名调用方法，该方法就必须是静态类方法，否则应该是对象调用方法。</p>
<p>注意：内部类和外部类没有继承关系。</p>
<p>可以通过外部类名来限定this对象：new Outer().num  等价于  Outer.this.num（Outer.this其实是一个对象）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/" data-id="ckqk8k3dk002f2wwd4mx34pdg" data-title="内部类" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/8/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/30/4.27.%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">序列化与反序列化</a>
          </li>
        
          <li>
            <a href="/2021/06/28/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/">电商项目</a>
          </li>
        
          <li>
            <a href="/2021/06/24/4.26.JSR/">JSR</a>
          </li>
        
          <li>
            <a href="/2021/06/24/31.3.%E8%85%BE%E8%AE%AF%E4%BA%91%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9A%84%E5%BC%80%E5%8F%91/">腾讯云音视频的开发</a>
          </li>
        
          <li>
            <a href="/2021/06/23/%E7%94%B3%E8%AF%B7%E8%BD%AF%E8%91%97/">申请软著</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>