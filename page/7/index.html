<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/7/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-22.1.计算机基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:30:15.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。"><a href="#计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。" class="headerlink" title="*计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。*"></a><em><strong>*计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。*</strong></em></h3><p>存储器分为内存和磁盘。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="一、CPU"><a href="#一、CPU" class="headerlink" title="*一、CPU*"></a><em><strong>*一、CPU*</strong></em></h3><p>1.计算机核心组件，在单个计算机芯片上放置数十亿个微型晶体管来构建成CPU。</p>
<p>2.CPU的核心是从程序或应用程序获取指令并执行计算。提取，解码，执行。从系统的RAM（随机存取存储器，也叫主存）中提取指令然后解码该指令的实际内容，然后再由CPU相关部分执行。</p>
<p>3.主要由两部分组成：控制单元和算术逻辑单元（ALU）。</p>
<p>控制单元：从内存中提取指令并解码执行。</p>
<p>算术逻辑单元：处理算术和逻辑运算。</p>
<p>从功能看，由四部分:****寄存器n个****和控制器、运算器、时钟。由电信号连通。</p>
<p>CPU是一系列寄存器的集合体。</p>
<p>****累加寄存器*<em><strong>、</strong></em>*标志寄存器*<em><strong>、</strong></em>*程序计数器*<em><strong>、基址寄存器、变址寄存器、通用寄存器、</strong></em>*指令寄存器*<em><strong>、</strong></em>*栈寄存器****。（基址变址通用有多个，其余都是只有一个）</p>
<p>（1）程序计数器：用来存储下一条指令所在单元的地址。程序计数器控制着程序的流程。</p>
<p>（2）标志寄存器：保存累加寄存器的运算结果，也负责溢出（指运算的指令超过了寄存器的长度范围）和奇偶校验。标志寄存器的第一个字节为1则为正，第二个字节为1则为0，第三个字节为1则为负数。</p>
<p>（CPU执行机制有个比较运算，实际上是减法运算，其结果记录在标志寄存器上）</p>
<p>函数调用机制：call指令调用和return指令返回，中间是栈</p>
<p>（3）基址寄存器和变址寄存器：用过这两个寄存器可以实现对主存上的特定区域进行划分，来实现类似****数组****的操作。</p>
<p>实际地址=基址寄存器的值+变址寄存器的值</p>
<table>
<thead>
<tr>
<th>寄存器名</th>
<th>名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td>eax</td>
<td>累加寄存器</td>
<td>运算</td>
</tr>
<tr>
<td>ebc</td>
<td>基址存储器</td>
<td>存储内存地址</td>
</tr>
<tr>
<td>ecx</td>
<td>计数存储器</td>
<td>计算循环次数</td>
</tr>
<tr>
<td>edx</td>
<td>数据寄存器</td>
<td>存储数据</td>
</tr>
<tr>
<td>esi</td>
<td>源基址寄存器</td>
<td>存储数据发送源的内存地址</td>
</tr>
<tr>
<td>edi</td>
<td>目的基址寄存器</td>
<td>存储数据发送目标的内存地址</td>
</tr>
<tr>
<td>ebp</td>
<td>扩展基址寄存器</td>
<td>存储数据存储领域基点的内存地址</td>
</tr>
<tr>
<td>esp</td>
<td>扩展栈指针寄存器</td>
<td>存储栈中最高位数据的内存地址</td>
</tr>
</tbody></table>
<p>数据的销毁：栈中存在两个参数，可通过两次pop指令可以将栈内的数据销毁；也可采用esp寄存器+8的方式更有效率（只需处理一次）：数值的单位是4字节，esp寄存器+8相当于pop2次，虽然内存中的数据实际上还残留着，但只要把esp寄存器的值更新为数据存储地址前面的数据位置，该数据就相当于销毁了。</p>
<p>函数的参数是通过栈来传递，返回值是通过寄存器返回的。</p>
<p>∷CPU指令执行过程:取指令，指令译码，执行指令，访存取数，结果写回。</p>
<h3 id="二、-内存（内部存储设备）"><a href="#二、-内存（内部存储设备）" class="headerlink" title="二、****内存（内部存储设备）****"></a><strong>二、***</strong>*内存（内部存储设备）****</h3><p>\1. 也叫主存。是与CPU进行沟通的桥梁。通过控制芯片相连，由可读写的元素构成，每个字节（1byte=8bits）都有一个地址编号。CPU通过地址从内存中读取数据和指令，也可以根据地址写入数据。计算机所有程序的运行都是在主存中运行的。当计算机关闭时，内存中的指令和数据就会被清除。</p>
<p>\2. 作用：存放CPU中的运算数据，与硬盘等外部存储设备交换的数据。其运行决定了计算机的稳定运行。</p>
<p>\3. 内存的内部由各种IC电路组成，可分为三种：</p>
<p>（1）随机存储器（RAM）：最重要的一种，可读可写，机器关闭时，信息会丢失。</p>
<p>（2）只读存储器（ROM）：只可读，机器关闭时，信息不会丢失。</p>
<p>程序的运行环境，存在着名为BIOS（Basic Input/Output System）的系统。BIOS存储在ROM中，是预先内置在计算机主机内部的程序，记录了用来控制外围设备的程序和数据。BIOS除了键盘、磁盘、显卡等基本控制外，还有引导程序的功能。****引导程序****是存储在启动驱动器启示区域的小程序。操作系统的启动驱动器一般是硬盘，也有CD-ROM和软盘。</p>
<p>（3）高速缓存（Cache）：分为一级缓存（L1 Cache）、二级缓存、三级缓存。位于内存和CPU之间，是一个读写速度比内存更快的存储器。</p>
<p>内存IC：一个完整的结构，内部有电源，地址信号，控制信号和用于寻址的IC****引脚（Pin）****来进行数据的读写。IC就是集成电器（integrated circuit）</p>
<p>存储方式有两种:低字节序列（将数据低位存储在内存低位地址）和高字节序列（将数据的高位存储在内存的低位）。</p>
<p>数组是内存的实现。</p>
<p>\4. 虚拟内存是内存和磁盘交互的第二个媒介，是把磁盘的一部分作为假想内存来使用。虚拟内存在硬盘上的存在形式就是PAGEFILE.SYS这个页面文件。</p>
<p>当内存不足时可借助虚拟内存运行程序，通过置换（swap）。分为分页式和分段式。</p>
<p>Windows操作系统：</p>
<p>1.Windows是以图形界面为基础的操作系统，前身是MS-DOC（16位操作系统）。</p>
<p>2.有两个版本32和64位。（指的是处理效率最高的数据大小）</p>
<p>3.通过API（Application Programming Interface，应用程序接口）函数集成来提供系统调用。API通过多个DLL文件来提供。</p>
<p>4.通过WYSIWYG（what you see is what you get）实现打印输出。</p>
<p>5.提供多任务功能：通过时钟分割技术来实现，底层是cpu时间切片，这也是多线程多任务的核心。</p>
<p>6.提供网络功能和数据库功能。它们和操作系统很接近，所以被称为中间件而不是应用。操作系统+中间件=系统软件。</p>
<p>7.即插即用实现设备驱动的自动设定。</p>
<p>节约内存有两种方式：增加内存的容量，加内存条；优化应用程序，使其尽可能变小。</p>
<p>怎样优化应用程序呢？</p>
<p>1.可以通过DLL文件实现函数共有。</p>
<p>DLL（Dynamic Link Library）文件是一种动态链接库文件，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。多个应用可以共有一个DLL文件从而达到节约内存的效果。</p>
<p>\2. 通过调用_stdcall来减少程序文件的大小。</p>
<p>_stdcall是standard call（标准调用）。Windows提供的DLL函数都是通过_stdcall调用。</p>
<p>三、磁盘（外部存储设备）</p>
<p>内存通过电流实现存储，磁盘通过磁记录技术来实现存储。</p>
<p>早期磁盘：软盘。如今用的是硬磁盘。磁盘中存储的程序必须加载到内存中才能运行。</p>
<p>磁盘的缓存叫做磁盘缓存，指的是把从磁盘中读出的数据存储到内存的方式，磁盘缓存大大改善了磁盘访问的速度。磁盘缓存是内存的一部分。</p>
<p>磁盘的物理结构指的是磁盘存储数据的形式。通过其物理表面划分成多个空间来使用，划分方式：可变长方式和扇区方式（一般是这种）。</p>
<p>扇区是对磁盘进行物理读写的最小单位。</p>
<p>四、操作系统环境</p>
<p>程序要运行需要运行环境。运行环境=操作系统+硬件。</p>
<p>操作系统又可以被称为软件，是由一系列的指令组成的。分为：Windows、Linux、Unix、FreeBSD(Unix系统的一种)。监控程序（加载程序、运行程序）可以说是操作系统的原型。后来又加上了基本的输入输出程序，再后来加上了硬件控制程序、编程语言处理器（汇编、编译、解析）、各种应用程序。操作系统其实就是多个程序的集合体。</p>
<p>Windows操作的是硬件而不是软件，软件通过操作windows系统可以达到控制硬件的目的。程序员没法直接控制硬件，且windows屏蔽了控制硬件的细节，但是windows却开放了系统调用功能来实现对硬件的控制，系统调用称为API，API就是应用调用的函数，这些函数的实体被存放在DLL文件中。</p>
<p>CPU的类型不同，所对应的机器的语言也不同。操作系统的类型不同，应用程序向操作系统传递指令的途径（称为API，Application Programming Interface）也不同。</p>
<p>五、显卡</p>
<p>承担图形的输出任务。又被称为图形处理器（Graphic Processing Unit,GPU）。</p>
<p>显示器中显示的信息一直存储在某内存中，该内存称为VRAM（Video RAM），在程序中，只要往VRAM中写入数据，该数据就会在显示器中显示出来。实现该功能的程序，是由操作系统或者BIOS提供，并借助中断来处理。</p>
<p>集成显卡：集成显卡是一种特殊的显卡，它一般不带有显存，而是使用系统的一部分主内存作为显存，具体的数量是系统根据需要自动动态调整的。</p>
<p>独立显卡：独立显卡简称独显，是指成独立的板卡，需要插在主板的相应接口上的显卡。独立显卡又分为内置独立显卡和外置显卡。独立显卡具备单独的显存，不占用系统内存，而且技术上领先于集成显卡，能够提供更好的显示效果和运行性能。</p>
<p>六、外围设备</p>
<p>1.IO端口</p>
<p>计算机主机中，附带了用来连接显示器以及键盘等外围设备的连接器，连接器内部都连接有用来交换计算机主机内外围设备之间电流特性的IC，这些IC统称为IO控制器。IO控制器中有用于临时保存输入输出数据的内存，被称为寄存器（与CPU的寄存器不同），这些内存就是端口。一个io控制器可以控制多个设备，各端口之间通过端口号来区分。端口号也被称为IO地址。</p>
<p>2.IRQ实现中断</p>
<p>外围设备的中断请求：IRQ（Interrupt Request）代表的就是中断请求。IRQ用来暂停当前正在运行的程序，并跳转到其他程序运行的必要机制，该机制被称为处理中断。实施中断请求的是连接外围设备的io控制器，负责实施中断处理的是CPU，外围设备的中断请求会使用不同于IO端口的其他编号，这个编号叫中断编号。操作系统以及BIOS则会提供响应中断编号的中断处理程序。</p>
<p>假如有多个外围设备请求中断的话，可以在IO控制器和CPU之间加入名为中断控制器的IC进行缓冲。</p>
<p>3.DMA实现短时间内大量数据传输</p>
<p>DMA（Direct Memory Access）：指在不通过CPU的情况下，外围设备直接和主存进行数据传输。磁盘等外围设备都用到了DMA机制</p>
<p>假如多个设备设定成相同的端口号、IRQ和DMA通道的话，计算机就无法正常工作，会提示设备冲突。</p>
<p>网址后缀名：</p>
<p>.org  非盈利性组织</p>
<p>.com  商业机构</p>
<p>.cn  政府</p>
<p>.edu  教育</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ckq1xbdri0013pwwd77vu14bl" data-title="计算机基础知识" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库和SQL语句" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:29:35.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/">数据库和SQL语句</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数据库就是一个文件系统，通过标准的SQL语句获取数据</p>
<p>关系型数据库：存放的是实体之间的关系</p>
<p>ER模型图：E：Entity  R：Relational  （实体用矩形，属性用椭圆，关系用菱形）</p>
<p>表：对应一个实体类</p>
<p>对数据库的添加，修改，删除，查询操作</p>
<p>对数据库表的添加，修改，删除，查询操作</p>
<p>对数据库表记录的添加，修改，删除，查询操作</p>
<p>常见的关系型数据库：</p>
<p><strong>MySQL</strong></p>
<p><strong>Oracle</strong></p>
<p>SQLServer</p>
<p>DB2</p>
<p>SyBase</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps18.jpg" alt="img"> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/" data-id="ckq1xbdsh003vpwwd9dweffb3" data-title="数据库和SQL语句" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-15.1.Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/15.1.Redis/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:28:54.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/15.1.Redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个开源的使用ANSI <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1219.htm">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1088.htm">数据库</a>，并提供多种语言的APIRedis是一个开源的使用ANSI <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1219.htm">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1088.htm">数据库</a>，并提供多种语言的API</p>
<p>从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助</p>
<p>Redis是 NoSQL（not only SQL）技术阵营中的一员，它通过多种键值数据类型来适应不同场景下的存储需求，借助一些高层级的接口使用其可以胜任，如缓存、队列系统的不同角色</p>
<p>Redis可以保存在内存中（性能非常好），也可以持久化在文件中</p>
<p>Redis的官网: <a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<p>经常用的数据成缓存，所以用redis</p>
<p>特性：</p>
<p>1.Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</p>
<p>2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</p>
<p>3.Redis支持数据的备份，即master-slave模式的数据备份</p>
<p>优势：</p>
<p>1.性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s</p>
<p>2.丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作</p>
<p>3.原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行</p>
<p>4.丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性</p>
<h1 id="Redis下载及安装"><a href="#Redis下载及安装" class="headerlink" title="Redis下载及安装"></a>Redis下载及安装</h1><p>Redis版本说明</p>
<p>Redis原生只支持linux系统。Redis官方是不支持windows平台，windows版本是微软自己建立的分支，基于官方的redis源码上进行编译、发布、维护的，所以window平台上的redis版本都略低于官方版本</p>
<p>当前redis最新版本是6.0</p>
<p>可以直接在windows上下载，通过上传工具上传到linux系统，也可以在linux下直接复制最新稳定版本下载链接的网址，然后wget+网址（这种方式必须要求可以上网）</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps1.jpg" alt="img"> </p>
<p>Redis安装：</p>
<p>1.将redis.tar.gz解压：tar -zxvf redis-3.2.8.tar.gz</p>
<p>mkdir redis  建一个目录</p>
<p>2.进入redis-3.2.8目录：cd redis-3.2.8</p>
<p>3.对redis进行编译:make  </p>
<p>4.安装到指定的目录：make PREFIX=/usr/local/redis install</p>
<p>如果安装redis是报下面的错误，是因为系统没有安装gcc环境，缺少依赖</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps2.jpg" alt="img"> </p>
<p>解决方案：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps3.jpg" alt="img"> </p>
<p>安装完成后，对redis进行重新编译安装</p>
<p>redis安装完成后，我们进入目录bin中查看</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps4.jpg" alt="img"> </p>
<p>redis-server          redis服务器</p>
<p>redis-cli           redis命令行客户端</p>
<p>redis-benchmark          redis性能测试工具</p>
<p>redis-check-aof         AOF文件修复工具</p>
<p>redis-check-rdb          RDB文件检索工具</p>
<p>redis客户端测试：</p>
<p>1.启动redis服务</p>
<p>./redis-server是可以启动的，但是有风险，只在测试环境下可以。正常启动需要加载配置文件</p>
<p>注意：我们需要将redis编译后的目录中的redis.conf文件copy到我们自己的redis目录中。 cp redis.conf /usr/local/redis </p>
<p>这个redis.conf文件是redis的配置文件</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps5.jpg" alt="img"> </p>
<p>在输入</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps6.jpg" alt="img">就可以启动</p>
<p>注意:前面是redis-server服务，后面redis.conf配置文件</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps7.jpg" alt="img"> </p>
<p>Redis占用的端口是6379</p>
<p>可以通过redis-cli命令行客户端来测试redis是否启动成功</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps8.jpg" alt="img"> </p>
<p>其他ip地址不能连接是因为配置文件中只允许回环地址127.0.0.1连接</p>
<h1 id="Redis数据类型与常见操作"><a href="#Redis数据类型与常见操作" class="headerlink" title="Redis数据类型与常见操作"></a>Redis数据类型与常见操作</h1><p>redis是一个key-value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/51839.htm">存储系统</a>。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/549479.htm">链表</a>)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）</p>
<h2 id="string类型常见操作"><a href="#string类型常见操作" class="headerlink" title="string类型常见操作"></a>string类型常见操作</h2><p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。</p>
<p>在Redis中字符串类型的Value最多可以容纳的数据长度是512M</p>
<p>常见操作（小写也可）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">SET key value 	 </span><br><span class="line">设定该Key持有指定的字符串Value，如果该Key已经存在，则覆盖其原有值。返回值：总是返回&quot;OK&quot;</span><br><span class="line"></span><br><span class="line">GET key 	 </span><br><span class="line">获取指定Key的Value。如果与该Key关联的Value不是string类型，Redis将返回错误信息，因为GET命令只能用于获取string Value</span><br><span class="line">返回值：与该Key相关的Value，如果该Key不存在，则返回nil。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MSET key value [key value ...] 	 </span><br><span class="line">该命令原子性的完成参数中所有key&#x2F;value的设置操作，其具体行为可以看成是多次迭代执行SET命令。 </span><br><span class="line">返回值：该命令不会失败，始终返回OK。 </span><br><span class="line"></span><br><span class="line">MGET key [key ...]  </span><br><span class="line">返回所有指定Keys的Values，如果其中某个Key不存在，或者其值不为string类型，该Key的Value将返回nil。	</span><br><span class="line">返回值：返回一组指定Keys的Values的列表。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">SETNX key value  </span><br><span class="line">如果指定的Key不存在，则设定该Key持有指定字符串Value，此时其效果等价于SET命令。相反，如果该Key已经存在，该命令将不做任何操作并返回。</span><br><span class="line">返回值：1表示设置成功，否则0。（not exists）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MSETNX key value [key value ...] 	 </span><br><span class="line">该命令原子性的完成参数中所有key&#x2F;value的设置操作，其具体行为可以看成是多次迭代执行SETNX命令。然而这里需要明确说明的是，如果在这一批Keys中有任意一个Key已经存在了，那么该操作将全部回滚，即所有的修改都不会生效。</span><br><span class="line">返回值：1表示所有Keys都设置成功，0则表示没有任何Key被修改。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">APPEND key value  </span><br><span class="line">如果该Key已经存在，APPEND命令将参数Value的数据追加到已存在Value的末尾。如果该Key不存在，APPEND命令将会创建一个新的Key&#x2F;Value。</span><br><span class="line">返回值：追加后Value的长度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DECR key	 </span><br><span class="line">将指定Key的Value原子性的递减1。如果该Key不存在，其初始值为0，在decr之后其值为-1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。（error）</span><br><span class="line">返回值：递减后的Value值。</span><br><span class="line"></span><br><span class="line">INCR key	 </span><br><span class="line">将指定Key的Value原子性的递增1。如果该Key不存在，其初始值为0，在incr之后其值为1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。</span><br><span class="line">返回值：递增后的Value值。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">DECRBY key decrement  </span><br><span class="line">将指定Key的Value原子性的减少decrement。如果该Key不存在，其初始值为0，在decrby之后其值为-decrement。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</span><br><span class="line">返回值：减少后的Value值。</span><br><span class="line"></span><br><span class="line">INCRBY key increment   </span><br><span class="line">将指定Key的Value原子性的增加increment。如果该Key不存在，其初始值为0，在incrby之后其值为increment。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</span><br><span class="line">返回值：增加后的Value值。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">GETSET key value	 </span><br><span class="line">原子性的设置该Key为指定的Value，同时返回该Key的原有值。和GET命令一样，该命令也只能处理string Value，否则Redis将给出相关的错误信息。</span><br><span class="line">返回值：返回该Key的原有值，如果该Key之前并不存在，则返回nil。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">l STRLEN key	 </span><br><span class="line"></span><br><span class="line">返回指定Key的字符值长度，如果Value不是string类型，Redis将执行失败并给出相关的错误信息。</span><br><span class="line"></span><br><span class="line">返回值：指定Key的Value字符长度，如果该Key不存在，返回0。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">l SETEX key seconds value	 </span><br><span class="line"></span><br><span class="line">原子性完成两个操作，一是设置该Key的值为指定字符串，同时设置该Key在Redis服务器中的存活时间(秒数)。该命令主要应用于Redis被当做Cache服务器使用时。	 （expire，到期）</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">l SETRANGE key offset value  </span><br><span class="line"></span><br><span class="line">替换指定Key的部分字符串值。从offset开始，替换的长度为该命令第三个参数value的字符串长度，其中如果offset的值大于该Key的原有值Value的字符串长度，Redis将会在Value的后面补齐(offset - strlen(value))数量的0x00，之后再追加新值。如果该键不存在，该命令会将其原值的长度假设为0，并在其后添补offset个0x00后再追加新值。鉴于字符串Value的最大长度为512M，因此offset的最大值为536870911。最后需要注意的是，如果该命令在执行时致使指定Key的原有值长度增加，这将会导致Redis重新分配足够的内存以容纳替换后的全部字符串，因此就会带来一定的性能折损。</span><br><span class="line"></span><br><span class="line">返回值：修改后的字符串Value长度。</span><br><span class="line"></span><br><span class="line">l GETRANGE key start end	 </span><br><span class="line"></span><br><span class="line">截取字符串。该命令在截取子字符串时，将以闭区间的方式同时包含start(0表示第一个字符)和end所在的字符，如果end值超过Value的字符长度，该命令将只是截取从start开始之后所有的字符数据。当end为-1时表示是最后一位，-4 -1表示从后数4位</span><br><span class="line"></span><br><span class="line">返回值：子字符串；</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">l SETBIT key offset value 	 </span><br><span class="line"></span><br><span class="line">设置在指定Offset上BIT的值，该值只能为1或0，在设定后该命令返回该Offset上原有的BIT值。如果指定Key不存在，该命令将创建一个新值，并在指定的Offset上设定参数中的BIT值。如果Offset大于Value的字符长度，Redis将拉长Value值并在指定Offset上设置参数中的BIT值，中间添加的BIT值为0。最后需要说明的是Offset值必须大于0。</span><br><span class="line"></span><br><span class="line">返回值：在指定Offset上的BIT原有值。</span><br><span class="line"></span><br><span class="line">l GETBIT key offset 	 </span><br><span class="line"></span><br><span class="line">返回在指定Offset上BIT的值，0或1。如果Offset超过string value的长度，该命令将返回0，所以对于空字符串始终返回0。</span><br><span class="line"></span><br><span class="line">返回值：在指定Offset上的BIT值。 </span><br><span class="line"></span><br><span class="line">(布隆过滤器)</span><br><span class="line"></span><br><span class="line">a  97  0110 0001	</span><br><span class="line"></span><br><span class="line">A  65  0100 0001  其实只用 setbit key 2 0  就将a改为了A（从0开始计数）</span><br></pre></td></tr></table></figure>

<p>2.list类型常见操作</p>
<p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的****普通链表****一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。</p>
<p>从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。</p>
<p>常见操作</p>
<p>l LPUSH key value [value …]      </p>
<p>在指定Key所关联的List Value的头部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的头部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。</p>
<p>返回值：插入后链表中元素的数量。</p>
<p>l LPUSHX key value       （x相当于判断）</p>
<p>仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的头部插入参数中给出的Value，否则将不会有任何操作发生。    </p>
<p>返回值：插入后链表中元素的数量。 </p>
<p>l LRANGE key start stop      </p>
<p>该命令的参数start和end都是0-based。即0表示链表头部(leftmost)的第一个元素。其中start的值也可以为负值，-1将表示链表中的最后一个元素，即尾部元素，-2表示倒数第二个并以此类推。该命令在获取元素时，start和end位置上的元素也会被取出。如果start的值大于链表中元素的数量，空链表将会被返回。如果end的值大于元素的数量，该命令则获取从start(包括start)开始，链表中剩余的所有元素。</p>
<p>返回值：返回指定范围内元素的列表。</p>
<p>这里的链表插入的头部插入相当于是栈：插入12345，输出时就会是54321</p>
<p>lrange key 0 -1 表示返回这个链表的所有元素</p>
<p>l LPOP key      （相当于把头部的那个元素移除）</p>
<p>返回并弹出指定Key关联的链表中的第一个元素，即头部元素。如果该Key不存，返回nil。</p>
<p>返回值：链表头部的元素。</p>
<p>l LLEN key     </p>
<p>返回指定Key关联的链表中元素的数量，如果该Key不存在，则返回0。如果与该Key关联的Value的类型不是链表，则返回相关的错误信息。</p>
<p>返回值：链表中元素的数量。</p>
<p>l LREM key count value  </p>
<p>在指定Key关联的链表中，删除前count个值等于value的元素。如果count大于0，从头向尾遍历并删除，如果count小于0，则从尾向头遍历并删除。</p>
<p>如果count等于0，则删除链表中所有等于value的元素。如果指定的Key不存在，则直接返回0。    </p>
<p>返回值：返回被删除的元素数量。</p>
<p>l LSET key index value </p>
<p>设定链表中指定位置的值为新值，其中0表示第一个元素，即头部元素，-1表示尾部元素。如果索引值Index超出了链表中元素的数量范围，该命令将返回相关的错误信息。     </p>
<p>(对指定脚标的值进行设置)</p>
<p>返回值：OK</p>
<p>l LINDEX key index      </p>
<p>该命令将返回链表中指定位置(index)的元素，index是0-based，表示头部元素，如果index为-1，表示尾部元素。如果与该Key关联的不是链表，该命令将返回相关的错误信息。    </p>
<p>返回值：返回请求的元素，如果index超出范围，则返回nil。</p>
<p>(读出指定脚标的值)</p>
<p>l LTRIM key start stop      </p>
<p>该命令将仅保留指定范围内的元素，从而保证链接中的元素数量相对恒定。start和stop参数都是0-based，0表示头部元素。和其他命令一样，start和stop也可以为负值，-1表示尾部元素。如果start大于链表的尾部，或start大于stop，该命令不会报错，而是返回一个空的链表，与此同时该Key也将被删除。如果stop大于元素的数量，则保留从start开始剩余的所有元素。     </p>
<p>l LINSERT key BEFORE|AFTER pivot value  </p>
<p>该命令的功能是在pivot元素的前面或后面插入参数中的元素value。如果Key不存在，该命令将不执行任何操作。如果与Key关联的Value类型不是链表，相关的错误信息将被返回。    </p>
<p>返回值：成功插入后链表中元素的数量，如果没有找到pivot，返回-1，如果key不存在，返回0。</p>
<p>(在指定的某个value前或后插入一个新的value)</p>
<p>l RPUSH key value [value …]      </p>
<p>在指定Key所关联的List Value的尾部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的尾部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。 </p>
<p>返回值：插入后链表中元素的数量。 </p>
<p>l RPUSHX key value </p>
<p>仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的尾部插入参数中给出的Value，否则将不会有任何操作发生。</p>
<p>返回值：插入后链表中元素的数量。 </p>
<p>l RPOP key      </p>
<p>返回并弹出指定Key关联的链表中的最后一个元素，即尾部元素，。如果该Key不存，返回nil。 </p>
<p>返回值：链表尾部的元素。 </p>
<p>l RPOPLPUSH source destination      </p>
<p>原子性的从与source键关联的链表尾部弹出一个元素，同时再将弹出的元素插入到与destination键关联的链表的头部。如果source键不存在，该命令将返回nil，同时不再做任何其它的操作了。如果source和destination是同一个键，则相当于原子性的将其关联链表中的尾部元素移到该链表的头部。    </p>
<p>返回值：返回弹出和插入的元素</p>
<p>3.hash类型常见操作</p>
<p>Redis中的Hashes类型可以看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如用户信息：Username、Password和Age等。每一个Hash可以存储4294967295个键值对。</p>
<p>常见操作</p>
<p>l HSET key field value     </p>
<p>为指定的Key设定Field/Value对，如果Key不存在，该命令将创建新Key以参数中的Field/Value对，如果参数中的Field在该Key中已经存在，则用新值覆盖其原有值。</p>
<p>返回值：1表示新的Field被设置了新值，0表示Field已经存在，用新值覆盖原有值。 </p>
<p>l HGET key field      </p>
<p>返回指定Key中指定Field的关联值。    </p>
<p>返回值：返回参数中Field的关联值，如果参数中的Key或Field不存，返回nil。</p>
<p>l HSETNX key field value     </p>
<p>只有当参数中的Key或Field不存在的情况下，为指定的Key设定Field/Value对，否则该命令不会进行任何操作。 </p>
<p>返回值：1表示新的Field被设置了新值，0表示Key或Field已经存在，该命令没有进行任何操作。</p>
<p>l HEXISTS key field      </p>
<p>判断指定Key中的指定Field是否存在。    </p>
<p>返回值：1表示存在，0表示参数中的Field或Key不存在。</p>
<p>l HLEN key      </p>
<p>获取该Key所包含的Field的数量。    返回Key包含的Field数量，如果Key不存在，返回0。</p>
<p>l HDEL key field [field …]      </p>
<p>从指定Key的Hashes Value中删除参数中指定的多个字段，如果不存在的字段将被忽略。</p>
<p>返回值：如果Key不存在，则将其视为空Hashes，并返回0，否则返回实际删除的Field数量。</p>
<p>l HINCRBY key field increment      </p>
<p>增加指定Key中指定Field关联的Value的值。如果Key或Field不存在，该命令将会创建一个新Key或新Field，并将其关联的Value初始化为0，之后再指定数字增加的操作。该命令支持的数字是64位有符号整型，即increment可以负数。返回值：运算后的值。</p>
<p>l HGETALL key     </p>
<p>获取该键包含的所有Field/Value。其返回格式为一个Field、一个Value，并以此类推。    </p>
<p>返回值：Field/Value的列表。</p>
<p>l HKEYS key      </p>
<p>返回指定Key的所有Fields名。    </p>
<p>返回值：Field的列表。</p>
<p>l HVALS key      </p>
<p>返回指定Key的所有Values名。 </p>
<p>返回值：Value的列表。 </p>
<p>l HMGET key field [field …]      </p>
<p>获取和参数中指定Fields关联的一组Values。如果请求的Field不存在，其值返回nil。如果Key不存在，该命令将其视为空Hash，因此返回一组nil。    </p>
<p>返回值：返回和请求Fields关联的一组Values，其返回顺序等同于Fields的请求顺序。</p>
<p>l HMSET key field value [field value …]     </p>
<p>逐对依次设置参数中给出的Field/Value对。如果其中某个Field已经存在，则用新值覆盖原有值。如果Key不存在，则创建新Key，同时设定参数中的Field/Value</p>
<p>4.set类型常见操作（不重复，可以完成交并差操作）</p>
<p>在Redis中，我们可以将Set类型看作为没有排序的字符串集合。Set可包含的最大元素数量是4294967295。</p>
<p>Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。</p>
<p>常见操作</p>
<p>l SADD key member [member …]     </p>
<p>如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。</p>
<p>返回值：本次操作实际插入的成员数量。</p>
<p>l SCARD key     </p>
<p>获取Set中成员的数量。    </p>
<p>返回值：返回Set中成员的数量，如果该Key并不存在，返回0。</p>
<p>l SISMEMBER key member     </p>
<p>判断参数中指定成员是否已经存在于与Key相关联的Set集合中。    </p>
<p>返回值：1表示已经存在，0表示不存在，或该Key本身并不存在。</p>
<p>l SMEMBERS key     </p>
<p>获取与该Key关联的Set中所有的成员。</p>
<p>返回值：返回Set中所有的成员。</p>
<p>l SPOP  key      </p>
<p>随机的移除并返回Set中的某一成员。 由于Set中元素的布局不受外部控制，因此无法像List那样确定哪个元素位于Set的头部或者尾部。    </p>
<p>返回值：返回移除的成员，如果该Key并不存在，则返回nil。</p>
<p>l SRANDMEMBER key      </p>
<p>和SPOP一样，随机的返回Set中的一个成员，不同的是该命令并不会删除返回的成员。    </p>
<p>返回值：返回随机位置的成员，如果Key不存在则返回nil。</p>
<p>l SREM key member [member …]     </p>
<p>从与Key关联的Set中删除参数中指定的成员，不存在的参数成员将被忽略，如果该Key并不存在，将视为空Set处理。    </p>
<p>返回值：从Set中实际移除的成员数量，如果没有则返回0。</p>
<p>l SMOVE source destination member     </p>
<p>原子性的将参数中的成员从source键移入到destination键所关联的Set中。如果该成员在source中并不存在，该命令将不会再执行任何操作并返回0，否则，该成员将从source移入到destination。如果此时该成员已经在destination中存在，那么该命令仅是将该成员从source中移出。</p>
<p>返回值：1表示正常移动，0表示source中并不包含参数成员。</p>
<p>l SDIFF key [key …]     </p>
<p>返回参数中第一个Key所关联的Set和其后所有Keys所关联的Sets中成员的差异。如果Key不存在，则视为空Set。    </p>
<p>返回值：差异结果成员的集合。</p>
<p>l SDIFFSTORE destination key [key …]      </p>
<p>该命令和SDIFF命令在功能上完全相同，两者之间唯一的差别是SDIFF返回差异的结果成员，而该命令将差异成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。    </p>
<p>返回值：返回差异成员的数量。</p>
<p>l SINTER key [key …]      </p>
<p>该命令将返回参数中所有Keys关联的Sets中成员的交集。因此如果参数中任何一个Key关联的Set为空，或某一Key不存在，那么该命令的结果将为空集。</p>
<p>返回值：交集结果成员的集合。</p>
<p>l SINTERSTORE destination key [key …]     </p>
<p>该命令和SINTER命令在功能上完全相同，两者之间唯一的差别是SINTER返回交集的结果成员，而该命令将交集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。    </p>
<p>返回值：返回交集成员的数量。 </p>
<p>l SUNION key [key …]      </p>
<p>该命令将返回参数中所有Keys关联的Sets中成员的并集。    </p>
<p>返回值：并集结果成员的集合。</p>
<p>l SUNIONSTORE destination key [key …]      </p>
<p>该命令和SUNION命令在功能上完全相同，两者之间唯一的差别是SUNION返回并集的结果成员，而该命令将并集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。 </p>
<p>返回值：返回并集成员的数量</p>
<p>5.sortedSet类型常见操作</p>
<p>Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的<em><strong>*成员必须是唯一*<em><strong>的，但是</strong></em>*分数*</strong>***</em>*(score)********却是可以重复****的。</p>
<p>在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。</p>
<p>常见操作</p>
<p>l ZADD key score member [score] [member]      </p>
<p>添加参数中指定的所有成员及其分数到指定key的Sorted-Set中，在该命令中我们可以指定多组score/member作为参数。如果在添加时参数中的某一成员已经存在，该命令将更新此成员的分数为新值，同时再将该成员基于新值重新排序。如果键不存在，该命令将为该键创建一个新的Sorted-Sets Value，并将score/member对插入其中。</p>
<p>返回值：本次操作实际插入的成员数量。</p>
<p>l ZINCRBY key increment member      </p>
<p>该命令将为指定Key中的指定成员增加指定的分数。如果成员不存在，该命令将添加该成员并假设其初始分数为0，此后再将其分数加上increment。如果Key不存，该命令将创建该Key及其关联的Sorted-Sets，并包含参数指定的成员，其分数为increment参数。</p>
<p>返回值：以字符串形式表示的新分数。</p>
<p>l ZCARD key      </p>
<p>获取与该Key相关联的Sorted-Sets中包含的成员总数量。</p>
<p>返回值：返回Sorted-Sets中的成员数量，如果该Key不存在，返回0。</p>
<p>l ZCOUNT key min max     </p>
<p>该命令用于获取<em><strong>*分数*</strong>***</em>*(score)****在min和max之间的成员数量。缺省情况下，min和max表示的范围是闭区间范围，即min &lt;= score &lt;= max内的成员将被返回。然而我们可以通过在min和max的前面添加”(“字符来表示开区间，如(min max表示min &lt; score &lt;= max，而(min (max表示min &lt; score &lt; max。</p>
<p>返回值：分数指定范围内成员的数量。</p>
<p>l ZRANGE key start stop [WITHSCORES]      </p>
<p>该命令返回****排名****在参数start和stop指定范围内的成员，这里start和stop参数都是0-based，即0表示第一个成员，-1表示最后一个成员。如果start大于该Sorted-Set中的最大索引值，或start &gt; stop，此时一个空集合将被返回。如果stop大于最大索引值，该命令将返回从start到集合的最后一个成员。如果命令中带有可选参数WITHSCORES选项，该命令在返回的结果中将包含每个成员的分数值，如value1,score1,value2,score2…。　　    </p>
<p>返回值：返回索引在start和stop之间的成员列表。</p>
<p>l ZREVRANGE key start stop [WITHSCORES]   </p>
<p>该命令的功能和ZRANGE基本相同，唯一的差别在于顺序相反。    </p>
<p>返回值：返回指定的成员列表。</p>
<p>l ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]      </p>
<p>该命令将返回****分数****在min和max范围内的成员，即满足表达式min &lt;= score &lt;= max的成员，其中返回的成员是按照其分数从低到高的顺序返回，如果成员具有相同的分数，则按成员的字典顺序返回。可选参数LIMIT用于限制返回成员的数量范围。可选参数offset表示从符合条件的第offset个成员开始返回，同时返回count个成员。</p>
<p>返回值：返回分数在指定范围内的成员列表。</p>
<p>l ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]      </p>
<p>该命令除了排序方式是基于从高到低的分数排序之外，其它功能和参数含义均与ZRANGEBYSCORE相同。    </p>
<p>返回值：返回分数在指定范围内的成员列表。 </p>
<p>l ZRANK key member      </p>
<p>该命令将返回参数中指定****成员的位置值****（按分数由低到高的顺序），其中0表示第一个成员，它是Sorted-Set中分数最低的成员。</p>
<p>返回值：如果该成员存在，则返回它的位置索引值。否则返回nil。</p>
<p>l ZREVRANK key member      </p>
<p>该命令的功能和ZRANK基本相同，唯一的差别在于顺序相反    </p>
<p>返回值：如果该成员存在，则返回它的位置索引值。否则返回nil。 </p>
<p>l ZSCORE key member     </p>
<p>获取指定成员的分数。    </p>
<p>返回值：如果该成员存在，以字符串的形式返回其分数，否则返回nil。</p>
<p>l ZREM key member [member …]     </p>
<p>该命令将移除参数中指定的成员，其中不存在的成员将被忽略。如果与该Key关联的Value不是Sorted-Set，相应的错误信息将被返回。</p>
<p>返回值：实际被删除的成员数量。</p>
<p>l ZREMRANGEBYRANK key start stop      </p>
<p>删除索引位置位于start和stop之间的成员，start和stop都是0-based，即0表示分数最低的成员，-1表示最后一个成员，即分数最高的成员。     </p>
<p>返回值：被删除的成员数量。</p>
<p>l ZREMRANGEBYSCORE key min max      </p>
<p>删除分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的所有成员。对于min和max参数，可以采用开区间的方式表示，具体规则参照ZCOUNT。 </p>
<p>返回值：被删除的成员数量</p>
<p>6.Key通用操作</p>
<p>l KEYS pattern     </p>
<p>获取所有匹配pattern参数（正则）的Keys。需要说明的是，在我们的正常操作中应该尽量避免对该命令的调用，因为对于大型数据库而言，该命令是非常耗时的，对Redis服务器的性能打击也是比较大的。pattern支持glob-style的通配符格式，如*表示任意一个或多个字符，?表示任意字符，[abc]表示方括号中任意一个字母。    匹配模式的键列表。</p>
<p>l DEL key [key …]     </p>
<p>从数据库删除中参数中指定的keys，如果指定键不存在，则直接忽略。还需要另行指出的是，如果指定的Key关联的数据类型不是String类型，而是List、Set、Hashes和Sorted Set等容器类型，该命令删除每个键的时间复杂度为O(M)，其中M表示容器中元素的数量。而对于String类型的Key，其时间复杂度为O(1)。</p>
<p>返回值：实际被删除的Key数量。</p>
<p>l EXISTS key      </p>
<p>判断指定键是否存在。    </p>
<p>返回值：1表示存在，0表示不存在。</p>
<p>l MOVE key db      </p>
<p>将当前数据库中指定的键Key移动到参数中指定的数据库中。如果该Key在目标数据库中已经存在，或者在当前数据库中并不存在，该命令将不做任何操作并返回0。     </p>
<p>返回值：移动成功返回1，否则0。</p>
<p>在redis.conf文件中定义了redis的默认库的数量</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps9.jpg" alt="img"> </p>
<p>我们可以使用select 数值 来进行库的切换: select  10.</p>
<p>l RENAME key newkey      </p>
<p>为指定的键重新命名，如果参数中的两个Keys的名字相同，或者是源Key不存在，该命令都会返回相关的错误信息。如果newKey已经存在，则直接覆盖。  </p>
<p>l RENAMENX key newkey     </p>
<p>如果新值不存在，则将参数中的原值修改为新值。其它条件和RENAME一致。</p>
<p>返回值：1表示修改成功，否则0。</p>
<p>l PERSIST key     </p>
<p>如果Key存在过期时间，该命令会将其过期时间消除，使该Key不再有超时，而是可以持久化存储。    </p>
<p>返回值：1表示Key的过期时间被移除，0表示该Key不存在或没有过期时间。</p>
<p>l EXPIRE key seconds      </p>
<p>该命令为参数中指定的Key设定超时的秒数，在超过该时间后，Key被自动的删除。如果该Key在超时之前被修改，与该键关联的超时将被移除。 </p>
<p>返回值：1表示超时被设置，0则表示Key不存在，或不能被设置。</p>
<p>l EXPIREAT key timestamp  </p>
<p>该命令的逻辑功能和EXPIRE完全相同，唯一的差别是该命令指定的超时时间是绝对时间，而不是相对时间。该时间参数是Unix timestamp格式的，即从1970年1月1日开始所流经的秒数。    </p>
<p>返回值：1表示超时被设置，0则表示Key不存在，或不能被设置。 </p>
<p>l TTL key      </p>
<p>获取该键所剩的超时描述。 </p>
<p>返回值：返回所剩描述，如果该键不存在或没有超时设置，则返回-1。</p>
<p>l RANDOMKEY     </p>
<p>从当前打开的数据库中随机的返回一个Key。    </p>
<p>返回值：返回的随机键，如果该数据库是空的则返回nil。</p>
<p>l TYPE key      </p>
<p>获取与参数中指定键关联值的类型，该命令将以字符串的格式返回。    </p>
<p>返回值：返回的字符串为string、list、set、hash和zset，如果key不存在返回none</p>
<p>7.事务</p>
<p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<p>l 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>l 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<p>开始事务。<em><strong>*MULTI*</strong></em> </p>
<p>命令入队。执行的redis的操作</p>
<p>执行事务。<em><strong>*EXEC*</strong></em> </p>
<p>事务常用命令</p>
<p>l MULTI</p>
<p>Redis Multi 命令用于标记一个事务块的开始。</p>
<p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p>
<p>返回值:总是返回OK</p>
<p>l EXEC</p>
<p>Redis Exec 命令用于执行所有事务块内的命令</p>
<p>返回值: 事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</p>
<p>l DISCARD</p>
<p>Redis Discard 命令用于取消事务，放弃执行事务块内的所有命令。</p>
<p>返回值: 总是返回 OK 。</p>
<p>l WATCH</p>
<p>Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</p>
<p>l UNWATCH</p>
<p>Redis Unwatch 命令用于取消 WATCH 命令对所有 key 的监视</p>
<h1 id="Redis-java-客户端-jedis"><a href="#Redis-java-客户端-jedis" class="headerlink" title="*Redis java*****客户端*****jedis*"></a><em><strong>*Redis java*</strong>***</em>*客户端****<em><strong>*jedis*</strong></em></h1><p>Jedis介绍与快速入门</p>
<p>通过java来操作redis：使用jedis</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps10.jpg" alt="img"> </p>
<p>搭建jedis环境：</p>
<p>新建一个javaproject，复制jar包到lib下，右键addpath构建路径</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps11.jpg" alt="img"> </p>
<p>编写代码</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps12.jpg" alt="img"> </p>
<p>程序执行报错：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps13.jpg" alt="img"> </p>
<p>原因:</p>
<p>1.redis服务器是否开启：linux上加载redis-server和redis.conf查看开启</p>
<p>2.linux的防火墙是否关闭：service iptables stop  关了之后在重启redis服务器</p>
<p>3.在redis.conf配置文件中 bind 127.0.0.1 代表的是外部不可以访问redis（可以把它注释掉，前面加#）</p>
<p>通过以上操作，错误信息不一样了：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps14.jpg" alt="img"> </p>
<p>原因：是我们没有设置密码</p>
<p>我们需要在redis.conf文件中设置密码admin：查找到requirepass，将前面的#删掉，然后将后面的改为admin，：wq保存退出</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps15.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps16.jpg" alt="img"> </p>
<p>有密码的情况下，在命令行下连接redis需加上-a：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps17.jpg" alt="img"> </p>
<p>string类型常见操作</p>
<p>//string操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo2 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示 set get</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.set(“username”, “tom”);        </p>
<p>​        String value = jedis.get(“username”);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示mset mget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        jedis.mset(“password”,”123”,”age”,”20”);</p>
<p>​        </p>
<p>​        List<String> values = jedis.mget(“username”,”password”,”age”);</p>
<p>​        </p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示 append  setrange getrange</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        //jedis.append(“username”,” is boy”);</p>
<p>​        </p>
<p>​        //jedis.setrange(“username”, 7,”girl”);</p>
<p>​        System.****<em>out*</em>***.println(jedis.get(“username”));</p>
<p>​        </p>
<p>​        </p>
<p>​        System.****<em>out*</em>***.println(jedis.getrange(“username”, 7, -1));</p>
<p>​    }</p>
<p>}</p>
<p>list类型常见操作：</p>
<p>//list操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo3 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示lpush lrange</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.lpush(“names”, “tom”, “james”, “张三”, “李四”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>​    // lset</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        // jedis.lset(“names”, 1, “王五”);</p>
<p>​        // List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        // System.out.println(names);</p>
<p>​        String value = jedis.lindex(“names”, 1);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    // linsert</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3() {</p>
<p>​        jedis.linsert(“names”, LIST_POSITION.****<em>BEFORE*</em>***, “james”, “fox”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>​    </p>
<p>​    // lrem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.lrem(“names”, 1, “tom”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>}</p>
<p>hash类型常见操作</p>
<p>//hash操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo4 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示hset hget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.hset(“user”, “username”, “tom”);</p>
<p>​        String value = jedis.hget(“user”, “username”);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    // 演示hmset hmget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        Map&lt;String, String&gt; hash = <em><strong>*new*</strong></em> HashMap&lt;String, String&gt;();</p>
<p>​        hash.put(“password”, “123”);</p>
<p>​        hash.put(“sex”, “male”);</p>
<p>​        jedis.hmset(“user”, hash);</p>
<p>​        List<String> values = jedis.hmget(“user”, “username”, “password”, “sex”);</p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示 hgetall hkeys kvals</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        Map&lt;String, String&gt; map = jedis.hgetAll(“user”);</p>
<p>​        <em><strong>*for*</strong></em>(String key:map.keySet()){</p>
<p>​            System.****<em>out*</em>***.println(key+”  “+map.get(key));</p>
<p>​        }</p>
<p>​        </p>
<p>​        Set<String> keys = jedis.hkeys(“user”);</p>
<p>​        System.****<em>out*</em>***.println(keys);</p>
<p>​        </p>
<p>​        List<String> values = jedis.hvals(“user”);</p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>//    演示hdel</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.hdel(“user”, “username”,”password”);</p>
<p>​        Map&lt;String, String&gt; map = jedis.hgetAll(“user”);</p>
<p>​        <em><strong>*for*</strong></em>(String key:map.keySet()){</p>
<p>​            System.****<em>out*</em>***.println(key+”  “+map.get(key));</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>set类型常见操作</p>
<p>//set操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo5 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);        </p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示sadd smembers</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        </p>
<p>​        Set<String> smembers = jedis.smembers(“language1”);</p>
<p>​        System.****<em>out*</em>***.println(smembers);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示srem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        jedis.srem(“language1”, “java”);</p>
<p>​        Set<String> smembers = jedis.smembers(“language1”);</p>
<p>​        System.****<em>out*</em>***.println(smembers);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //差集 sdiff</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        </p>
<p>​        Set<String> sdiff = jedis.sdiff(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sdiff);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //交集</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        Set<String> sinter = jedis.sinter(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sinter);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //并集</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test5(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        Set<String> sunion = jedis.sunion(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sunion);</p>
<p>​    }</p>
<p>​    </p>
<p>}</p>
<p>sortedSet类型常见操作</p>
<p>//sortedset操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo6 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示zadd zrange zrangeByScore</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Set<String> set = jedis.zrange(“zkey”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(set);</p>
<p>​        // 根据分数获取</p>
<p>​        Set<String> set1 = jedis.zrangeByScore(“zkey”, 70.0, 90.0);</p>
<p>​        System.****<em>out*</em>***.println(set1);</p>
<p>​    }</p>
<p>​    // 获取分数元素 zrangeWithScores</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Set<Tuple> zws = jedis.zrangeWithScores(“zkey”, 0, -1);</p>
<p>​        <em><strong>*for*</strong></em> (Tuple t : zws) {</p>
<p>​            System.****<em>out*</em>***.println(t.getScore() + “  “ + t.getElement());</p>
<p>​        }</p>
<p>​    }</p>
<p>​    // zrank</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Long num = jedis.zrank(“zkey”, “赵六”);</p>
<p>​        System.****<em>out*</em>***.println(num);</p>
<p>​    }</p>
<p>​    // zscore</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Double zscore = jedis.zscore(“zkey”, “张三”);</p>
<p>​        System.****<em>out*</em>***.println(zscore);</p>
<p>​    }</p>
<p>​    // zrem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test5() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        jedis.zrem(“zkey”, “李四”);</p>
<p>​        </p>
<p>​        Set<Tuple> zws = jedis.zrangeWithScores(“zkey”, 0, -1);</p>
<p>​        <em><strong>*for*</strong></em> (Tuple t : zws) {</p>
<p>​            System.****<em>out*</em>***.println(t.getScore() + “  “ + t.getElement());</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>key的常见操作</p>
<p>//key的通用操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo7 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // keys patten</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1(){</p>
<p>​        Set<String> keys = jedis.keys(“*”);</p>
<p>​        System.****<em>out*</em>***.println(keys);</p>
<p>​    }</p>
<p>​    </p>
<p>​    // del key</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        Long del = jedis.del(“user”);</p>
<p>​        System.****<em>out*</em>***.println(del);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //关于key时间设置</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        //jedis.expire(“username”, 200); //设置生命周期为200秒</p>
<p>​        jedis.persist(“username”);</p>
<p>​        Long ttl = jedis.ttl(“username”); //获取生命周期值</p>
<p>​        System.****<em>out*</em>***.println(ttl);</p>
<p>​        </p>
<p>​    }</p>
<p>}</p>
<h1 id="Redis-数据持久化"><a href="#Redis-数据持久化" class="headerlink" title="*Redis*****数据持久化****"></a><em><strong>*Redis*</strong>***</em>*数据持久化****</h1><p>Redis将内存存储和持久化存储相结合，既可提供数据访问的高效性，又可保证数据存储的安全性</p>
<p>1.Redis数据持久化机制介绍</p>
<p>1). RDB持久化：该机制是指在指定的时间间隔内将****内存中的数据集快照****写入磁盘。  </p>
<p>2). AOF(append only file)持久化:该机制将以****日志的形式记录服务器所处理的每一个写操作****，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</p>
<p>3). 同时应用AOF和RDB。 </p>
<p>4). 无持久化：可通过配置的方式禁用Redis服务器的持久化功能，这样我们就可以将Redis视为一个功能加强版的memcached了</p>
<p>2.Redis数据持久化配置与测试</p>
<p>l RDB快照方式:缺省情况下，Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开redis.conf文件之后，我们搜索save，可以看到下面的配置信息：</p>
<p>Ø save 900 1        </p>
<p>#在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。</p>
<p>Ø save 300 10       </p>
<p>#在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。</p>
<p>Ø save 60 10000     </p>
<p>#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</p>
<p>注意:关于dump.rdb文件存储的位置：它是设置是在redis.conf文件中dir ./</p>
<p>dir ./这段配置指的是服务器启动时的当前路径（在哪启动服务器时，这个rdb文件就在哪创建）。</p>
<p>l AOF日志文件方式：</p>
<p>Ø AOF日志持久化机制的开启：需要手动设置，在redis.conf文件中</p>
<p>将appendonly  no  改为 appendonly  yes</p>
<p>Ø AOF同步方式的配置：</p>
<p>在Redis的配置文件中存在三种同步方式，它们分别是：</p>
<p>appendfsync  always   #每次有数据修改发生时都会写入AOF文件。</p>
<p>appendfsync  everysec  #每秒钟同步一次，该策略为AOF的缺省策略。</p>
<p>appendfsync  no      #从不同步。高效但是数据不会被持久化。</p>
<p>3.RDB与AOF对比总结</p>
<p>l RDB存在哪些优势呢？</p>
<p>1). 数据的备份和恢复非常方便，因为一个数据库只有一个持久化文件</p>
<p>2). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p>
<p>3). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
<p>l RDB又存在哪些劣势呢？</p>
<p>1).系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
<p>2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p>l AOF的优势有哪些呢？</p>
<p>1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3种同步策略，即每秒同步、每修改同步和不同步。</p>
<p>2).对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。</p>
<p>3). 如果日志过大，Redis可以自动启用rewrite机制迅速“瘦身”(也可手动触发aof的rewrite操作，命令： bgrewriteaof)</p>
<p>4). AOF日志格式清晰、易于理解，很容易用AOF日志文件完成数据的重建。  </p>
<p>l AOF的劣势有哪些呢？</p>
<p>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。</p>
<p>2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/15.1.Redis/" data-id="ckq1xbdt2005ypwwdety2bbxy" data-title="Redis" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.7.内部类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:50:38.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/">内部类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>内部类：把类定义在其他类的内部，这个类就被称为内部类。</p>
<p>内部类访问特点：</p>
<p>内部类可以直接访问外部类的成员，包括私有。</p>
<p>外部类要访问内部类的成员，必须创建对象。</p>
<p>内部类的位置：</p>
<p>成员位置：成员内部类</p>
<p>成员内部类是非静态的访问方式：</p>
<p>外部类名.内部类名  对象名 = new  外部类名.new 内部类名()；</p>
<p>eg：Outer.Inner  oi = new Outer().new Inner();</p>
<p>常见修饰符：</p>
<p>1.一般内部类是不让外界直接访问的，所以用private，保证了数据的安全性。</p>
<p>2.static为了让数据访问更方便。内部类用静态修饰是因为内部类可以看作是外部类的成员。（所以static可以修饰内部类，不能修饰类）</p>
<p>被静态修饰的成员内部类只能访问外部类的静态成员（静态只能访问静态）</p>
<p>成员内部类被静态修饰后，是不能被对象访问的，只能被类访问。它下面的方法可以是静态可以是非静态。</p>
<p>成员内部类是静态的访问方式：</p>
<p> 外部类名.内部类名  对象名=new 外部类名.内部类名();</p>
<p>eg：Outer.Inner oi = new Outer.Inner();</p>
<p>oi.静态方法();   oi.非静态方法();</p>
<p>静态内部类的静态方法还可以用：Outer.Inner.静态方法名();</p>
<p>局部位置：局部内部类</p>
<p>可以直接访问外部类的成员</p>
<p>在局部位置可以创建内部类对象，通过对象调用内部类方法来使用局部内部类的功能</p>
<p>局部内部类访问局部变量的注意事项：</p>
<p>局部内部类访问的局部变量必须用final修饰。（因为局部变量是随着方法的调用而调用，随着调用完毕而消失，而堆内存的内容不会立即消失（如果不是final修饰的话，就会矛盾报错），所以加final修饰，使变为常量，即使消失了，也有数据在使用）</p>
<p>匿名内部类:就是内部类的简化写法。</p>
<p>前提：存在一个类或者接口。（这里的类可以是具体类也可以是抽象类）</p>
<p>格式： new  类名或者接口名(){</p>
<p>重写方法；</p>
<p>}</p>
<p>本质：就是具体类的子类或者抽象类的具体实现类或者接口的实现类的匿名****对象****。</p>
<p>因为本质是一个对象，所以后面可以跟调用方法。</p>
<p>new  类名或者接口名(){</p>
<p>重写方法；</p>
<p>}.方法名();</p>
<p>当有多个方法要重写时，只能调一次方法，因为这是个匿名对象。所以改进：在前面赋值给父接口或者父类、父抽象类，这就是多态。（实际上就是在{}中补了很多代码，其他格式不变），最后再通过多态的对象调用方法。</p>
<p>匿名内部类在开发中的使用：在android中常见，在ee中不常见。因为匿名内部类用完就会被回收不占内存。匿名内部类只能用一次。</p>
<p>类名调用方法，该方法就必须是静态类方法，否则应该是对象调用方法。</p>
<p>注意：内部类和外部类没有继承关系。</p>
<p>可以通过外部类名来限定this对象：new Outer().num  等价于  Outer.this.num（Outer.this其实是一个对象）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/" data-id="ckq1xbdrt0028pwwde1cs16r4" data-title="内部类" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.6.接口和抽象类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:50:31.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/">接口和抽象类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>为了体现事物功能的扩展性，java中提供了接口来定义这些额外功能，但不给出具体实现，将来有要实现的地方在添加实现。</p>
<p>特点：接口用interface关键字表示</p>
<p>格式：  interface  接口名{}</p>
<p>类实现接口用implements表示：</p>
<p>class  类名  implements  接口名{}</p>
<p>接口不能实例化。按照多态的方式，接口可以由具体的子类实例化。这也是多态的一种，接口多态。</p>
<p>所以多态有3种：</p>
<p>A. 具体类多态（几乎不用）</p>
<p>B. 抽象类多态（常用）</p>
<p>C. 接口多态（最常用）</p>
<p>接口的子类：要么是抽象类，要么重写接口中的所有抽象方法（推荐）。</p>
<p>接口成员特点：</p>
<p>成员变量：接口中的变量默认是常量，并且是静态的。默认修饰符public static final （所以建议自己手动给出）</p>
<p>构造方法：接口没有构造方法，因为接口主要是扩展功能的，没有具体存在</p>
<p>成员方法：只能是抽象方法。默认修饰符  public abstract（建议自己手动给出）</p>
<p>接口名+Impl这种格式是接口的实现类格式。</p>
<p>所有的类都默认继承自Object类。类 Object是类层次结构的根类，每个类都使用Object作为超类。因为Objec类只有无参构造，所以默认每个子类都会调用其父类的无参构造super();</p>
<p>类与类关系：继承关系，可以单继承，也可以多层继承</p>
<p>类与接口关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
<p>接口与接口的关系：继承关系，可以单继承，也可以多继承（java中有多继承，只有接口有）</p>
<p>抽象类和接口的区别：</p>
<p>A. 成员区别：抽象类有变量、常量，有构造方法，有抽象方法和非抽象方法</p>
<p>接口中只有常量，抽象方法</p>
<p>B. 关系区别：类与类关系、类与接口关系、接口与接口的关系</p>
<p>C. 设计理念区别：</p>
<p>抽象类被继承体现的是“is  a”的关系。共性功能</p>
<p>接口被实现体现的是“hava a”的关系。扩展功能（也有说like a的关系 谁像啥）</p>
<p>形式参数是引用类型：</p>
<p>类：类作为形参，其实需要的是该类的对象（匿名对象可以作为对象，只使用一次）</p>
<p>抽象类：需要的是该抽象类的子类对象。（因为它本身不能实例化，只有子类的对象）</p>
<p>接口：需要的是该接口的实现类对象。</p>
<p>返回值是引用类型：</p>
<p>类：返回的是该类的对象。</p>
<p>抽象类：返回的是该抽象类的子类对象。</p>
<p>接口：返回的是该接口的实现类对象。</p>
<p>链式编程：每次调用完毕方法后，返回的是一个对象。（适用于中间调用的返回值是类、接口、抽象类）</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在java中，一个没有方法体的方法应该定义为抽象方法。而类中如果有抽象方法，该类必须定义为抽象类。</p>
<p>抽象类和抽象方法必须使用abstract关键字修饰。</p>
<p>格式：抽象类：  abstract class 类名{…}</p>
<p> 抽象方法：    public abstract void eat（）；</p>
<p>空方法体用  ｛｝   没有方法体用  ;  </p>
<p>抽象类不一定有抽象方法（没有抽象方法的抽象类的意义就是不让外界创建对象，只能通过子类访问），但是有抽象方法的类一定是抽象类。</p>
<p>抽象类有构造方法（这个构造方法的作用是用于子类访问父类数据的初始化），但是不能实例化。按照多态的方式，抽象类可以由具体的子类实例化，和多态的声明一样: 父 f=new 子();  抽象类多态</p>
<p>抽象类的子类要么是抽象类，要么重写抽象类中的所有抽象方法成为一个具体的类。</p>
<p>抽象类的成员特点：</p>
<p>成员变量：既可以是变量，也可以是常量。</p>
<p>构造方法：有。用于子类访问父类数据的初始化。</p>
<p>成员方法：既可以是抽象的（强制要求子类做的事情），也可以是非抽象的（子类继承的事情，提高代码的复用性）。</p>
<p>如果测试的东西父类中都包含，可以使用多态。但如果要测试子类中特有的内容，我们无法用多态继续测试，所以要创建子类的对象来测试。</p>
<p>abstract不能共存的关键字：</p>
<p>private：冲突。加了就不让重写了。</p>
<p>final：冲突。不能被重写。</p>
<p>static：无意义。因为静态可以直接通过类名访问，而abstract没有方法体，访问一个没有方法体的方法是无意义的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/" data-id="ckq1xbdrs0027pwwd43sh594b" data-title="接口和抽象类" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.8.程序控制流程if" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:49:57.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/">程序控制流程if</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>想了想还是单独给程序控制流程部分开了一个文章。因为业务逻辑部分，最主要的用的还是if语句。通过对不同情形的判断，来进行情况分类，可以帮助我们实现功能，学会if是写逻辑层代码重要的一环。</p>
<p>流程控制语句：可以控制程序的执行流程。</p>
<h1 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h1><p>是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p>
<p>从上往下，依次执行。</p>
<h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><p>也被称为分支结构。有特定的语法规则，代码要执行具体的逻辑运算进行判断，逻辑运算的结果有两个，所以产生选择，按照不同的选择执行不同的代码。</p>
<p>两种：</p>
<p>if语句的使用场景：</p>
<p>a.针对表达式是一个boolean类型的判断</p>
<p>b.针对一个范围的判断</p>
<p>c.针对几个常量值的判断</p>
<p>switch语句使用场景：针对几个常量值的判断</p>
<p>1.if语句</p>
<p>if语句的使用格式：</p>
<p>a. 适合做单个判断</p>
<p> if(关系表达式){</p>
<p>语句体</p>
<p>}</p>
<p>if语句控制的语句体如果是一条语句，大括号可以省略，如果是多条语句，就不能省略。建议永远不要省略。</p>
<p>一般来说，有左大括号就没有分号，有分号就没有左大括号。if();或if(){}</p>
<p>b.适合做两个判断</p>
<p>if(关系表达式){</p>
<p>语句体1；</p>
<p>}else{</p>
<p>语句体2；</p>
<p>}</p>
<p>else后面是没有表达式的，只有if后面有。</p>
<p>三元运算符实现的都可以用if语句实现。反之不成立（因为当if语句控制的操作是一个输出语句时候就不能，三元运算符是一个运算符，操作完毕是会有一个结果而不是一个输出语句）</p>
<p>c.适合做多个判断</p>
<p>if(比较表达式1){</p>
<p>语句体1；</p>
<p>}else if(比较表达式2){</p>
<p>语句体2；</p>
<p>}else if(比较表达式3){</p>
<p>语句体3；</p>
<p>}</p>
<p>…</p>
<p>else{</p>
<p>语句体n+1；</p>
<p>}</p>
<p>注意事项：比较表达式无论简单还是复杂，结果必须是boolean类型。</p>
<p>if语句是可以任意嵌套使用的，把语句体n改为if语句即可实现（无论使用if三种格式那种都行）。</p>
<p>\2. switch语句</p>
<p>switch(表达式){</p>
<p>case  值1:</p>
<p>语句体1；</p>
<p>break；</p>
<p>case  值2:</p>
<p>语句体2；</p>
<p>break；</p>
<p>…</p>
<p>default：</p>
<p>语句体n+1；</p>
<p>break；</p>
<p>}</p>
<p>switch:表示这是switch选择结构。</p>
<p>表达式：表达式取值有限定，byte，short，char，int。JDK5以后可以是枚举，JDK7以后可以是字符串。</p>
<p>case后面跟的是要和表达式比较的值。</p>
<p>语句体部分可以是一条或者多条语句</p>
<p>break表示中断，结束的意思，可以结束switch语句。</p>
<p>注意事项：</p>
<p>\1. case后面只能是常量，不能是变量，而且多个case后面的值不能出现相同的。</p>
<p>\2. default可以省略。一般不建议，除非判断的case值是固定的（可以穷举完）。他的作用是对不正确的情况给出提示。</p>
<p>\3. break可以省略。一般不建议，会出现case穿透(可以利用case穿透来实现多个输出结果相同时整合到一起)。最后一个break可以省略。</p>
<p>\4. default位置可以出现在switch语句的任意位置。建议在最后。</p>
<p>\5. switch语句的结束条件：遇到break或者执行到程序的末尾。</p>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>循环语句的组成：</p>
<p>初始化语句：一条或者多条语句，这些语句完成一些初始化操作</p>
<p>判断条件语句：这是一个boolean表达式，这个表达式决定是否执行循环体</p>
<p>循环体语句：要多次循环的语句</p>
<p>控制条件语句：在一次循环结束后，下次循环判断条件执行前执行，通过用于控制循环条件中的变量，使得循环再合适的时候结束</p>
<h2 id="for循环："><a href="#for循环：" class="headerlink" title="for循环："></a>for循环：</h2><p>for(初始化语句；判断条件语句；控制条件语句)｛</p>
<p>循环体语句；</p>
<p>｝</p>
<p>注意事项：判断条件语句的结果是一个boolean类型</p>
<p>循环语句如果是一条语句，大括号可以省略，如果是多条语句，大括号不能省略，建议永远不要省略。</p>
<p>一般来说，有左大括号就没有分号，有分号就没有左大括号。</p>
<p>for循环：求和思想：初始化值为0。</p>
<p>求阶乘思想：初始化值为1。</p>
<p>水仙花数：就是指一个三位数，其各位数字的立方和等于该数本身。eg：153</p>
<h2 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h2><p>基本格式：</p>
<p>while(判断条件语句){</p>
<p>循环体语句；</p>
<p>}</p>
<p>扩展格式：</p>
<p>初始化语句；</p>
<p>while（判断条件语句）｛</p>
<p>循环体语句；</p>
<p>控制条件语句；</p>
<p>｝</p>
<p> for循环和while循环语句可以等价转换，但也存在区别：</p>
<p>使用区别：控制条件语句所控制的那个变量，在for循环结束后，就不能在被访问到了，而while循环结束还可以继续使用。若不使用推荐使用for循环，因为这个变量会从内存中消失，能够提高内存的使用效率。</p>
<p>场景区别：for循环适合针对一个范围判断进行操作，while循环适合判断次数不明确的操作。</p>
<h2 id="do-…-while-循环语句："><a href="#do-…-while-循环语句：" class="headerlink" title="do … while 循环语句："></a>do … while 循环语句：</h2><p>至少执行一次</p>
<p>基本格式：</p>
<p>do{</p>
<p>循环体语句；</p>
<p>}while（判断条件语句）;</p>
<p>扩展格式：</p>
<p>初始化语句；</p>
<p>do｛</p>
<p>循环体语句；</p>
<p>控制条件语句；</p>
<p>｝while（判断条件语句）;</p>
<p>优先考虑for循环，其次是while循环，最后考虑do… while循环。</p>
<p>注意死循环：ctrl+c中断循环</p>
<p>A：注意控制条件语句控制的那个变量的问题，不要丢了，否则会死循环。</p>
<p>B：两种最简单的死循环格式</p>
<p>while（true）｛</p>
<p>｝</p>
<p>for（；；）｛</p>
<p>｝</p>
<p>循环嵌套：循环语句的循环体本身是一个循环语句。</p>
<p>外循环控制行数，内循环控制列数。</p>
<h1 id="控制跳转语句"><a href="#控制跳转语句" class="headerlink" title="控制跳转语句"></a>控制跳转语句</h1><p>****break****：中断</p>
<p>使用场景：离开下面2个场景使用，无意义。</p>
<p>A：switch语句中</p>
<p>B：循环语句中（加入了if判断的情况）</p>
<p>使用：A：跳出单层循环</p>
<p>B：跳出多层循环，必须借助标签。</p>
<p>格式：</p>
<p>标签名： 语句</p>
<p>****continue****：继续</p>
<p>使用场景：循环语句中。（离开此场景无意义）</p>
<p>break和continue的区别：break是跳出单层循环。continue是跳出一次循环，进行下一次的判断执行。</p>
<p>****return****：返回</p>
<p>renturn关键字不是为了跳转出循环体，更常用的功能是结束一个方法，也就是推出一个方法，跳转到上层调用的方法。</p>
<p>一旦遇到return，程序就不会在继续往后执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/" data-id="ckq1xbdrt002apwwdga4z8hge" data-title="程序控制流程if" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-1.5.编程规范" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T02:57:13.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/">编程规范</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><p>遇到左大括号缩进一个tab的位置。</p>
<p>关联不是很大的语句间空行。</p>
<p>很多细节规范参考《阿里开发手册华山版》</p>
<h1 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h1><p>前后端接口规范：解耦接口，尽量不要用大接口。可以用公共的接口，但是尽量是前端需要什么信息，传递什么信息，不要查到所有信息再返回给前端。因为尽量避免暴露数据库表结构，避免传递不必要的信息。</p>
<h2 id="RESTful-架构"><a href="#RESTful-架构" class="headerlink" title="RESTful 架构"></a>RESTful 架构</h2><p>RESTful 只是一种指导风格，就像我们 Java 要用驼峰命名法。</p>
<p>REST 不是一个单词，是 Representational State Transfer 的缩写。直译过来就是表述性状态转移。其实它还有个主语 Resource ，所以是资源的表述性状态转移。</p>
<p><strong>核心</strong>就是资源，用 URL 定位资源，用 HTTP 动词来描述所要做的操作。</p>
<p>HTTP的提供了很多动词：GET、PUT、POST、DELETE……这些动词都是有含义的。</p>
<p>比如：</p>
<p>GET 就是获取资源，是查询请求。</p>
<p>PUT 指的是修改资源，是幂等的。</p>
<p>POST 也是修改(新增也是一种修改)，指的是不幂等的操作。</p>
<p>所以根据这些规范我们都能得知这次交互的一些动作，所以 RESTful 风格正确的使用姿势如下：</p>
<p>比如获取一个 user：</p>
<p>​    错误姿势：<code>GET /getUserById?userId=1</code>。</p>
<p>​    正确姿势：<code>GET /users/1</code>。</p>
<p>再比如新增 user：</p>
<p>​    错误姿势：<code>POST /addUser</code> （省略body）。</p>
<p>​    正确姿势：<code>POST /users</code> （省略body）。</p>
<p>可以看到 HTTP 的动词其实就能指代你要对资源做的操作，所以不需要在 URL 上做一些东西，就把 URL 表明的东西看作一个资源即可。</p>
<p>这里注意要用对 HTTP 动词，比如一个获取资源的请求用 PUT，用了也能获取资源但是这不合适。</p>
<p>其实更深一步的理解是  HTTP 是一个协议。</p>
<p>协议其实就是约定好的一个东西，协议就规定 GET 是获取资源，那你非得在 URL 上再重复一遍或者所有请求不论增删改都用 GET 这个动作，这其实就是没有完全遵循这个协议。</p>
<p>可以说只是把 HTTP 当成一个传输管道，而不是约定好的协议。</p>
<p>这其实是对 HTTP 更深一层的认识，我认为也是 RESTful 被推出的原因。</p>
<p>当然理想很丰满，现实很骨感，还是有很多人就 <code>getUserById</code>。</p>
<p>不过我个人觉得问题不大，公司统一就行。</p>
<h2 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h2><p>即 Hypermedia as the Engine of Application State 的缩写，翻译过来就是作为应用状态引擎的超媒体。</p>
<p>这也是 REST 提出的设计。</p>
<p>比如你请求获取用户列表：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /users</span><br><span class="line">Accept: application/json+userdb</span><br></pre></td></tr></table></figure>

<p>此时的返回应该是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Content-Type: application/json+userdb</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;users&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 1,</span><br><span class="line">            &quot;name&quot;: &quot;Emil&quot;,</span><br><span class="line">            &quot;country: &quot;Sweden&quot;,</span><br><span class="line">            &quot;links&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/user/1&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;self&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;GET&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/user/1&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;PUT&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/user/1&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;delete&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 2,</span><br><span class="line">           ....省略.....</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;links&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;/user&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;create&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;POST&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点就是这个 links，结果会返回你能对这个资源所做的操作。</p>
<p>比如对于 userId 是 1 的，你调用<code>PUT /user/1</code>就是做修改这个用户，<code>DELETE /user/1</code>就是删除这个用户。</p>
<p>最外层的 links 告诉你用 <code>POST /user</code> 就能再创建一个用户。</p>
<p>这里还有个隐藏信息，可以看到外层的 links 没有返回 DELETE 的信息，说明此时客户端无法删除用户！</p>
<p>所以说 RESTful API 还需要再返回此时能对资源做的操作，这样客户端就知道它能做什么。</p>
<p>它也不需要管具体怎么做，反正返回里面会告诉它 DELETE 就这样这样，POST 就这样这样。</p>
<p>没告诉它的就是不能做的。</p>
<p>然后这个时候再去理解下资源的表述性状态转移，是不是感觉来了？</p>
<p>如果说上一 part 提到用 HTTP 的动词来指代动作， URL 仅表示资源的现实是骨感的。</p>
<p>那么 HATEOAS 的现实就是骨灰。</p>
<p>基本上没几家公司会这么做。</p>
<p>就我个人而言这玩意没啥用。</p>
<p>它的出发点是让客户端从响应就能得知对资源操作的入口，并且通过响应得知哪些动作能执行。</p>
<p>听起来好像有点用，但是就我目前的功力，我只能看到响应变得十分冗余。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章关于 RESTful API 具体的写法我就提到一些，还有挺多的就自己查资料吧。</p>
<p>文章的目的是为了让你理解 RESTful API，我再总结一下重点。</p>
<p>HTTP 是协议，不是传输通道。（对协议不理解的看我之前的 HTTP 分析）</p>
<p>所以协议约定了很多东西，推荐我们按照协议的用法进行客户端和服务端的交互。</p>
<p>也就是 RESTful 表明的面向资源，通过 HTTP 动作 + URL 上的资源。</p>
<p>RESTful 还提到了 HATEOAS，虽说基本上没什么公司会这样使用，但是它能让你更好的理解 REST 这个名字的含义。</p>
<p>RESTful 是一种风格，你是否采用这种风格对你的程序运行没有影响，类比驼峰命名来思考。</p>
<p>简而言之，RESTful 就是不要在 URL 上表现出动作，用 HTTP 动词代表动作，URL 上只做资源。</p>
<p>仅此而已。</p>
<p>至于要不要严格遵循 RESTful 风格，我个人的看法是公司内部保持一致就行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" data-id="ckq1xbdr10001pwwdd79walfy" data-title="编程规范" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-5.3.MySQL踩坑" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/13/5.3.MySQL%E8%B8%A9%E5%9D%91/" class="article-date">
  <time class="dt-published" datetime="2021-04-12T16:40:08.000Z" itemprop="datePublished">2021-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/13/5.3.MySQL%E8%B8%A9%E5%9D%91/">MySQL踩坑</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="关于数据库时区说明"><a href="#关于数据库时区说明" class="headerlink" title="关于数据库时区说明"></a>关于数据库时区说明</h2><p>2016-12-07T03:13:25.808Z:T是代表后面跟着“时间”。Z代表0时区，<br>这是UTC统一时间</p>
<p>时间的描述：</p>
<p>mysql数据库拥有时区设置，默认使用系统时区</p>
<p>可通过如下语句查询当前时区</p>
<p><code>show variables like &#39;%time_zone%&#39;;</code></p>
<p>数据库使用系统时间CST——China Standard Time UTC+8:00 中国沿海时间(北京时间)</p>
<p>​     UTC:国际时间</p>
<p>​    UTC-8:伦敦时间</p>
<p>​    UTC+8就是国际时加八小时,是东八区时间,也就是北京时间</p>
<p>GMT，即格林尼治标准时间，也就是世界时。GMT的正午是指当太阳横穿格林尼治子午线（本初子午线）时的时间。但由于地球自转不均匀不规则，导致GMT不精确，现在已经不再作为世界标准时间使用。</p>
<p>UTC，即协调世界时。UTC是以原子时秒长为基础，在时刻上尽量接近于GMT的一种时间计量系统。为确保UTC与GMT相差不会超过0.9秒，在有需要的情况下会在UTC内加上正或负闰秒。UTC现在作为世界标准时间使用。</p>
<p>所以，UTC与GMT基本上等同，误差不超过0.9秒</p>
<p>RTC，硬件时间，主板上面bios的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String dateTime = <span class="string">&quot;2019-06-27T16:00:00.000Z&quot;</span>;</span><br><span class="line"></span><br><span class="line">dateTime = dateTime .replace(<span class="string">&quot;Z&quot;</span>, <span class="string">&quot; UTC&quot;</span>); <span class="comment">//2019-06-27T16:00:00.000 UTC</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat format1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS Z&quot;</span>);<span class="comment">//转换时区格式</span></span><br><span class="line">SimpleDateFormat format2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"></span><br><span class="line">Date date = format1.parse(dateTime ) || <span class="keyword">long</span> ldate = format1.parse(dateTime ).getTime();<span class="comment">//将Z时间格式转换成Date类型格式或换成毫秒</span></span><br><span class="line">String time= format2.format(date);<span class="comment">//2019-06-28</span></span><br><span class="line"></span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2019</span>-<span class="number">06</span>-<span class="number">28</span></span><br></pre></td></tr></table></figure>

<p>时间类型说明</p>
<p>datetime</p>
<p>实际格式储存（Just stores what you have stored and retrieves the same thing which you have stored.）</p>
<p>与时区无关（It has nothing to deal with the TIMEZONE and Conversion.）</p>
<p>timestamp</p>
<p>值以UTC毫秒数保存（ it stores the number of milliseconds）</p>
<p>存储及检索时根据当前时区设置，对时间数值做转换</p>
<p>由于timestamp与时区相关，且线上数据库时区设置为北京时间（即UTC+8:00）。因此，当数据库中使用了timestamp列，若使用不当，统一UTC格式时间改造将很可能会引入错误！</p>
<h2 id="关于时间查询的sql语句"><a href="#关于时间查询的sql语句" class="headerlink" title="关于时间查询的sql语句"></a>关于时间查询的sql语句</h2><p>在项目开发过程中，自己需要查询出一定时间段内的交易。故需要在sql查询语句中加入日期时间要素，sql语句如何实现?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM lmapp.lm_bill where tx_time Between &#39;2015-12-20&#39; And &#39;2015-12-31&#39;;</span><br></pre></td></tr></table></figure>

<p>查询每一天某个时间段的所有记录(例:9:00:00到21:00:00)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 </span><br><span class="line">WHERE DATE_FORMAT(create_time,&#39;%H:%i:%S&#39;)&gt;&#x3D;&#39;09:00:00&#39;</span><br><span class="line">and DATE_FORMAT(create_time,&#39;%H:%i:%S&#39;)&lt;&#x3D;&#39;21:00:00&#39; </span><br><span class="line">ORDER BY 排序字段 ASC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mysql 查询当天、最近一天、最近一周，本月，上一个月的数据</p>
<p>今天<br><code>select * from 表名 where to_days(时间字段名) = to_days(now());</code></p>
<p>昨天</p>
<p><code>SELECT * FROM 表名 WHERE TO_DAYS( NOW( ) ) - TO_DAYS( 时间字段名) &lt;= 1</code><br>7天</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;&#x3D; date(时间字段名)</span><br></pre></td></tr></table></figure>

<p>近30天</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;&#x3D; date(时间字段名)</span><br></pre></td></tr></table></figure>

<p>本月</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE DATE_FORMAT( 时间字段名, &#39;%Y%m&#39; ) &#x3D; DATE_FORMAT( CURDATE( ) , &#39;%Y%m&#39; )</span><br></pre></td></tr></table></figure>

<p>上一月</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE PERIOD_DIFF( date_format( now( ) , &#39;%Y%m&#39; ) , date_format( 时间字段名, &#39;%Y%m&#39; ) ) &#x3D;1</span><br></pre></td></tr></table></figure>



<p>SELECT id FROM m_question WHERE cratedate BETWEEN<br>‘2018-05-31 12:00:00’ and ‘2018-06-26 14:59:59’ ORDER BY id DESC<br>或者<br>SELECT id FROM m_question WHERE cratedate &gt;<br>‘2018-05-31 12:00:00’ and cratedate &lt; ‘2018-06-26 14:59:59’ ORDER BY id DESC<br>但是between and 包含时间界限，也相当于&gt;= &lt;=，而&gt; &lt;不包含</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Select  *  from mytable where  DateField1&lt;&#x3D;&#39;2010-1-31&#39;</span><br><span class="line"></span><br><span class="line">Select  *  from mytable where  DateField1&lt;&#x3D;&#39;2010-1-31 0:0:0&#39;</span><br><span class="line"></span><br><span class="line">Select  *  from mytable where  DateField1&lt; &#39;2010-2-1&#39;</span><br><span class="line"></span><br><span class="line">Select  *  from mytable where  DateField1&lt;&#39;2010-2-1 0:0:0&#39;</span><br></pre></td></tr></table></figure>

<p>如果DateField1 里面有 值为 2010-1-31 ，我们不建议用 语句1 或者 语句 2，因为由于数据库的数据精度和编程语言的数据精度不一致，</p>
<p>使用&lt;= 会导致无法取得 2010-1-31 的数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/13/5.3.MySQL%E8%B8%A9%E5%9D%91/" data-id="ckq1xbdru002fpwwd0y2sbd5v" data-title="MySQL踩坑" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-5.1.MySQL初级" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/13/5.1.MySQL%E5%88%9D%E7%BA%A7/" class="article-date">
  <time class="dt-published" datetime="2021-04-12T16:39:03.000Z" itemprop="datePublished">2021-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/13/5.1.MySQL%E5%88%9D%E7%BA%A7/">MySQL初级</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>关系型数据库</p>
<p>服务器：</p>
<p>​    硬件：指的就是一台计算机</p>
<p>​    软件：指的是需要在这台电脑上安装数据库服务器</p>
<p>一台电脑如果安装了MySQL，这台电脑称为是MySQL数据库服务器</p>
<p>MySQL数据库服务器存储的方式：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml5948\wps1.jpg" alt="img"> </p>
<p>一台数据库服务器中会创建很多数据库（一个项目，会创建一个数据库）。在数据库中会创建很多张表（一个实体会创建一个表）。在表中会有很多记录（一个对象的实例会添加一条新的记录）。</p>
<p>SQL：结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=51720422&ss_c=ssc.citiao.link">数据库查询和程序设计语言</a>，用于存取数据以及查询、更新和管理关系数据库系统；同时也是<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=71639443&ss_c=ssc.citiao.link">数据库脚本文件</a>的<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=190718&ss_c=ssc.citiao.link">扩展名</a>。</p>
<p>分类：</p>
<p>​    DDL：数据定义语言：create，drop，alter..</p>
<p>​    DCL：数据控制语言：grant，if…</p>
<p>​    DML：数据操纵语言：insert，update，delete…</p>
<p>​    DQL：数据查询语言：select   （不区分大小写）</p>
<h1 id="对数据库进行CRUD的操作"><a href="#对数据库进行CRUD的操作" class="headerlink" title="对数据库进行CRUD的操作"></a>对数据库进行CRUD的操作</h1><h2 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h2><p>语法：</p>
<p><code>create database 数据库名称 [character set 字符集 collate 字符集校对规则]; </code>  </p>
<p>utf-8的字符集写的时候是utf8</p>
<p>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode，比如emoji表情</p>
<p>为了获取更好的兼容性，应该总是使用 utf8mb4 而非 utf8.  对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，根据 Mysql 官方建议，使用 VARCHAR  替代 CHAR</p>
<p>字符集校对规则可以在查询手册中查到，用来数据库排序展示</p>
<h2 id="查看数据库："><a href="#查看数据库：" class="headerlink" title="查看数据库："></a>查看数据库：</h2><p>语法：</p>
<p>查看数据库服务器中所有的数据库：<code>show databases;</code></p>
<p>查看某个数据库的定义信息： <code>show create database 数据库名称;</code></p>
<h2 id="修改数据库："><a href="#修改数据库：" class="headerlink" title="修改数据库："></a>修改数据库：</h2><p>语法：</p>
<p><code>alter database 数据库名称 character set 字符集 collate 校对规则;</code></p>
<h2 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h2><p>语法:</p>
<p><code>drop database 数据库名称;</code></p>
<h2 id="其他数据库操作："><a href="#其他数据库操作：" class="headerlink" title="其他数据库操作："></a>其他数据库操作：</h2><p>切换数据库：<code>use 数据库名称;</code></p>
<p>查看当前正在使用的数据库：<code>select database();</code></p>
<h1 id="对数据库表进行操作"><a href="#对数据库表进行操作" class="headerlink" title="对数据库表进行操作"></a>对数据库表进行操作</h1><table>
<thead>
<tr>
<th>Java中的类型</th>
<th>MySQL中的类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte/short/int/long</td>
<td>tinyint/smallint/int/bigint</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>double</td>
<td>double</td>
</tr>
<tr>
<td>boolean</td>
<td>bit</td>
</tr>
<tr>
<td>char/String</td>
<td>char和varchar类型</td>
</tr>
<tr>
<td>Date</td>
<td>date/time/datetime/timestamp</td>
</tr>
<tr>
<td>File</td>
<td>BLOB/TEXT</td>
</tr>
</tbody></table>
<p>char和varchar的区别：</p>
<p>​    char代表是固定长度的字符或字符串。定义类型char(8),向这个字段存入字符串hello，那么数据库使用三个空格将其补全。</p>
<p>​    varchar代表的是可变长度的字符串。定义类型varchar(8), 向这个字段存入字符串hello,那么存入到数据库的就是hello。</p>
<p>datetime和timestamp区别：</p>
<p>​    datetime就是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库使用null存入到数据库中。</p>
<p>​    timestamp也是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库使用当前的系统时间存入到数据库中。</p>
<p>BLOB是二进制的文件，TEXT是文本类型的文件（都很少使用）</p>
<h2 id="约束："><a href="#约束：" class="headerlink" title="约束："></a>约束：</h2><p>约束作用：保证数据的完整性</p>
<p>单表约束分类：</p>
<p>​    主键约束：primary key 主键约束默认就是唯一 非空的</p>
<p>​    唯一约束：unique</p>
<p>​    非空约束：not null</p>
<h2 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a>创建表：</h2><p>语法：<code>create table 表名称(字段名称 字段类型(长度) 约束,字段名称 字段类型(长度) 约束…);</code></p>
<p>字段类型：一个实体对应一个表，一个实体属性对应表的一个字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database web_test1;</span><br><span class="line"></span><br><span class="line">use web_test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line"></span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line"></span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span>,</span><br><span class="line"></span><br><span class="line">	password <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"></span><br><span class="line">	age <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line">	birthday <span class="type">date</span></span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="查看表："><a href="#查看表：" class="headerlink" title="查看表："></a>查看表：</h2><p>查看某个数据库下的所有的表： （必须先切换到这个数据库）</p>
<p>语法：<code>show tables;</code></p>
<p>查看某个表的结构信息：</p>
<p>语法：<code>desc 表名; </code>（只是结构信息）</p>
<h2 id="删除表："><a href="#删除表：" class="headerlink" title="删除表："></a>删除表：</h2><p>语法：<code>drop table 表名;</code></p>
<h2 id="修改表："><a href="#修改表：" class="headerlink" title="修改表："></a>修改表：</h2><p>​    添加列：<code>alter table 表名 add 列名 类型(长度) 约束;</code></p>
<p>​    修改列类型，长度和约束：<code>alter table 表名 modify 列名 类型(长度) 约束;</code></p>
<p>​    删除列：<code>alter table 表名 drop 列名;</code></p>
<p>​    修改列名称：<code>alter table 表名 change 旧列名 新列名 类型(长度) 约束;</code></p>
<p>​    修改表名：<code>rename table 表名 to 新的表名;</code></p>
<p>​    修改表的字符集：<code>alter table 表名 character set 字符集;</code></p>
<h1 id="对数据库表的记录进行操作"><a href="#对数据库表的记录进行操作" class="headerlink" title="对数据库表的记录进行操作"></a>对数据库表的记录进行操作</h1><h2 id="添加表的记录："><a href="#添加表的记录：" class="headerlink" title="添加表的记录："></a>添加表的记录：</h2><p>语法：</p>
<p>​    向表中插入某些列：<code>insert into 表名 (列名1,列名2,列名3…) values (值1,值2,值3…)</code></p>
<p>​    向表中插入所有列：<code>insert into 表名 values (值1,值2,值3…);</code></p>
<p>//id一般是自动增长的，所以可以把值写为null</p>
<p>注意事项</p>
<p>1.值的类型与数据库中表列的类型一致。</p>
<p>2.值的顺序与数据库中表列的顺序一致。</p>
<p>3.值的最大长度不能超过列设置最大长度。</p>
<p>4.值的类型是字符串或者是日期类型，使用单引号引起来。</p>
<p>直接向数据库中插入中文记录会出现错误！ </p>
<p>解决方法：</p>
<ol>
<li><code>show variables like &#39;%character%&#39;; </code> –查看数据库中与字符集相关参数（数据库中都是utf8，而命令行中的是gbk）所以需要将MySQL数据库服务器中的客户端部分的字符集改为gbk。MySQL数据库服务器中的服务端还是utf8，但是MySQL数据库服务器已经可以识别了。</li>
</ol>
<p>​    2.找到MySQL的安装路径：my.ini文件，修改文件中[client]下的字符集，重新启动MySQL数据库服务器（在搜索程序和文件中输入 services.msc 打开服务 界面，找到MySQL停止，再启动），再<code>show variables like &#39;%character%&#39;; </code> 就可以看到改成功了。</p>
<h2 id="修改表的记录："><a href="#修改表的记录：" class="headerlink" title="修改表的记录："></a>修改表的记录：</h2><p>语法:<code>update 表名 set 列名=值,列名=值 [where 条件];</code></p>
<p>注意事项</p>
<p>1.值的类型与列的类型一致。</p>
<p>2.值的最大长度不能超过列设置的最大长度。</p>
<p>3.字符串类型和日期类型添加单引号。</p>
<h2 id="删除表的记录："><a href="#删除表的记录：" class="headerlink" title="删除表的记录："></a>删除表的记录：</h2><p>语法：<code>delete from 表名 [where 条件];</code></p>
<p>注意事项</p>
<p>1.删除表的记录，指的是删除表中的一行记录。</p>
<p>2.删除如果没有条件，默认是删除表中的所有记录。</p>
<p>删除表中的记录有两种做法:</p>
<p><code>delete from user;</code> 删除所有记录，属于DML语句，一条记录一条记录删除。事务可以作用在DML语句上的（可以回滚）</p>
<p><code>truncate table user;</code>删除所有记录，属于DDL语句，将表删除，然后重新创建一个结构一样的表。事务不能控制DDL的（真的删除掉了）</p>
<h2 id="查看表的记录："><a href="#查看表的记录：" class="headerlink" title="查看表的记录："></a>查看表的记录：</h2><p>基本查询：</p>
<p>语法:</p>
<p><code>select  [distinct]  *|列名 from 表 [条件];</code></p>
<p>[]代表可选，就是可加可不加。distinct表示不重复的</p>
<p>*|列名 中的列名可以进行运算的。select name,english+chinese+math from exam;</p>
<p>也可以取个别名进行查询：</p>
<p>select name,english+chinese+math as sum from exam; （as有没有都可以）</p>
<p>条件查询：使用where子句：</p>
<p>&gt; , &lt; , &gt;= , &lt;= , &lt;&gt;（不等于） ,=</p>
<p>like:模糊查询（like可以进行模糊查询,在like子句中可以使用_或者%作为占位符。_只能代表一个字符，而%可以代表任意个字符。）</p>
<p>in:范围查询  （in后面跟的是范围）</p>
<p>条件关联:and , or ,not  （多个条件时可以使用）</p>
<p>排序查询：</p>
<p>使用order by 字段名称 asc/desc;</p>
<p>asc 升序   desc  降序  （不写的话，默认是asc升序）</p>
<p>查询学生信息，先按照语文成绩进行倒序排序，如果成绩相同再按照英语成绩升序排序：select * from exam order by chinese desc,english asc;</p>
<p>分组统计查询：</p>
<p>聚合函数使用：（）括号中加对象</p>
<p>sum();</p>
<p>select sum(english)+sum(chinese)+sum(math) from exam;和select sum(english+chinese+math) from exam;的区别：</p>
<p>第一个语句是按照列的方式统计，英语成绩总和+语文成绩总和+数学成绩总和。</p>
<p>第二个语句先计算英语+数学+语文然后再求和。</p>
<p>//如果其中有一个值为null时，select sum(english+chinese+math) from exam;语句不会把那一行数据加上（null加上任意数还是null），select sum(english)+sum(chinese)+sum(math) from exam;语句就会正确相加。</p>
<p>如果某一列有null值，可以使用ifnull的函数：</p>
<p><code>select sum(ifnull(english,0)+chinese+math) from exam;</code>如果english是null，赋值为0</p>
<p>count();  统计个数 select count(*) from exam where name like ‘李%’;</p>
<p>max();</p>
<p>min();</p>
<p>avg();</p>
<p>分组查询：</p>
<p>语法：使用group by 字段名称;</p>
<p>where的子句后面不能跟着聚合函数。如果现在使用带有聚合函数的条件过滤（分组后条件过滤）需要使用一个关键字having</p>
<p>select product,sum(price) from orderitem  group by product having sum(price) &gt; 5000;</p>
<p>总结</p>
<p>S(select)… F(from)…W(where)…G(group by)…H(having)…O(order by);</p>
<p>顺序不能颠倒，可以省略</p>
<h1 id="MySQL的密码重置-不成功"><a href="#MySQL的密码重置-不成功" class="headerlink" title="MySQL的密码重置(不成功)"></a>MySQL的密码重置(不成功)</h1><p>\1. 停止MySQL的服务：在搜索程序和文件中输入 services.msc 打开服务 界面，找到MySQL停止</p>
<p>\2. 在cmd下启动服务：mysqld –skip-grant-tables</p>
<p>\3. 重新开启cmd的命令行（前面那个不要关掉）：mysql -u root -p 直接登入，不需要密码</p>
<p>\4. 修改root密码：use mysql；  update user set password = password (‘xinmima’) where user =’root’;</p>
<p>update user set password =password(‘sunweixuan’) where user =’root’;</p>
<p>\5. 结束mysqld的进程:在任务管理器中的进程结束mysqld.exe</p>
<p>\6. 重新启动mysql的服务：在搜索程序和文件中输入 services.msc 打开服务 界面，找到MySQL启动</p>
<h1 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h1><p>数据库的备份：</p>
<p>1.打开cmd的命令行窗口（以管理员身份运行）</p>
<p>2.输入mysqldump -u root -p web_test1 &gt;C:/web_test1.sql （这样c盘中就有了web_test1.sql ）  （&gt;和&lt;是数据流向）</p>
<p>数据库的还原：</p>
<p>第一种：</p>
<p>1.在数据库服务器内部创建数据库：creat</p>
<p>2.在命令行窗口输入：mysql -u root -p web_test1 &lt; C:/web_test1.sql</p>
<p>第二种：</p>
<p>1.在数据库服务器内部创建数据库：creat</p>
<p>2.切换到该数据库：use</p>
<p>3.使用source命令还原：source C:/web_test1.sql</p>
<h1 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h1><p>SQLyog、navicat等</p>
<p>MySQL的可视化工具有很多，基本上功能和内容都一样。</p>
<p>可以增删查改，可以执行SQL语句。</p>
<h1 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h1><p>约束是用来保证数据的完整性。</p>
<p>单表：主键约束、非空约束、唯一约束。</p>
<p>多表：外键约束：用来保证数据完整性（多表之间）</p>
<p>让两个表之间产生联系：</p>
<p>在员工表上添加外键：alter table employee add foreign key (dno) references dept(did);  （添加外键dno指向dept表中的did列）</p>
<p>对外键进行操作类似于对表进行修改：设置外键为非空：alter table employee modify dno int not null;</p>
<p>表与表之间的关系：</p>
<p>\1. 一对多的关系（员工和部门）：</p>
<p>建表原则：在多的一方创建外键指向一的一方的主键</p>
<p>\2. 多对多的关系（学生和课程）：</p>
<p>建表原则：需要创建中间表，中间表中至少两个字段，分别作为外键指向多对多双方的主键</p>
<p>\3. 一对一的关系（公司和注册地址）：（很少见）</p>
<p>两种方式：</p>
<p>（1）唯一外键对应：假设是一对多，在多的一方创建外键指向一的一方的主键，将外键设置为unique。</p>
<p>（2）主键对应：将两个表的主键建立对应关系即可。</p>
<p>多表设计：</p>
<p>\1. 多表分析： 分析每个类之间的关系</p>
<p>\2. 多表创建：创建各个表，添加外键使其建立关系，对于多对多的关系，需要再建立中间表。</p>
<p>\3. 多表查询：2类</p>
<p>（1）连接查询</p>
<p>l 交叉连接（了解）：查询到的是两个表的笛卡尔积（表1*表2=总记录条数）</p>
<p>语法：<code>select * from 表1 cross join 表2;</code></p>
<p><code>select * from 表1,表2;</code></p>
<p>l 内连接：inner join （inner可以省略）</p>
<p>显示内连接：在SQL中显示的调用inner join关键字</p>
<p>语法：<code>select * from 表1 inner join 表2 on 关联条件;</code></p>
<p>（select * from classes c inner join student s on c.cid = s.cno;）</p>
<p>隐式内连接：在SQL中没有调用inner join关键字</p>
<p>语法：<code>select * from 表1,表2 where 关联条件;</code></p>
<p>（SELECT * FROM classes c,student s WHERE c.cid = s.cno;）</p>
<p>l 外连接：outer join  （outer可以省略）</p>
<p>左外连接：语法：select * from 表1 left outer join 表2 on 关联条件; </p>
<p>左边表的全部和左右边共有的部分（左边表为基准）</p>
<p>右外连接：语法：select * from 表1 right outer join 表2 on 关联条件;</p>
<p>左边表的全部和左右边共有的部分（右边表为基准）</p>
<p>（2）子查询：一个查询语句条件需要依赖另一个查询语句的结果。（查询可以嵌套）</p>
<p>带in的子查询：select * from classes where cid in (SELECT cno FROM student WHERE birthday &gt; ‘1991-01-01’); （先查询出后面的范围，再在后面的范围中查找前面的信息并输出）</p>
<p>带exists的子查询：select * from classes where exists (SELECT cno FROM student WHERE birthday &gt; ‘1991-01-01’); （先查询后面的范围，如果存在，就对前面的语句进行查询；如果不存在，不执行前面的查询语句）</p>
<p>带any的子查询：SELECT * FROM classes WHERE cid &gt; ANY (SELECT cno FROM student )； （大于后面中最小值的）</p>
<p>带all的子查询：SELECT * FROM classes WHERE cid &gt; ALL (SELECT cno FROM student)； （大于后面中最大值的）</p>
<p>内连接与外连接的区别：左外连接和右外连接的交集就是内连接。</p>
<p>IFNULL() 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值</p>
<p>Case具有两种格式。</p>
<p>简单Case函数</p>
<p>​    格式说明   </p>
<p>　　　　case 列名</p>
<p>　　　　when  条件值1  then  选项1</p>
<p>　　　　when  条件值2   then  选项2…….</p>
<p>　　　　else   默认值    end</p>
<p>Case搜索函数</p>
<p>​    格式说明   </p>
<p>　　　　case  </p>
<p>　　　　when  列名= 条件值1  then  选项1</p>
<p>　　　　when  列名=条件值2   then  选项2…….</p>
<p>　　　　else   默认值 end</p>
<p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同</p>
<p>not in</p>
<p>对于第二个表中的某个字段不想要，只想取第一个表中这个字段值时，可以在查询时利用where条件限定id字段not in 第一个表的id字段。这样第二个表的查询结果会自动把第一个表中已经存在的id字段自动去除。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/13/5.1.MySQL%E5%88%9D%E7%BA%A7/" data-id="ckq1xbdru002cpwwdb5m8gcs1" data-title="MySQL初级" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-19.2.Gitee" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/12/19.2.Gitee/" class="article-date">
  <time class="dt-published" datetime="2021-04-12T02:59:11.000Z" itemprop="datePublished">2021-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/12/19.2.Gitee/">Gitee</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="码云教程"><a href="#码云教程" class="headerlink" title="码云教程"></a>码云教程</h2><p>gitee是开源中国（<a target="_blank" rel="noopener" href="https://www.oschina.net/%EF%BC%89%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8Egit%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%EF%BC%8C%E8%83%BD%E5%A4%9F%E7%94%A8%E7%A0%81%E4%BA%91%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E3%80%81%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E3%80%81%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%98%AF%E5%9B%BD%E5%86%85%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BB%A3%E7%A0%81%E7%B3%BB%E7%BB%9F%EF%BC%8Cgitee%E5%92%8Cgithub%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E6%80%A7%E8%B4%A8%E6%98%AF%E7%B1%BB%E4%BC%BC%E7%9A%84%EF%BC%8C%E7%A0%81%E4%BA%91%E6%98%AF%E5%9F%BA%E4%BA%8Egitlab%EF%BC%8C%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E4%B8%8Egithub%E7%B1%BB%E4%BC%BC%EF%BC%8C%E4%BD%86%E6%98%AF%E7%9B%B8%E6%AF%94%E4%BA%8Egithub%E8%80%8C%E8%A8%80%EF%BC%8Cgitee%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%98%BE%E8%91%97%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A%E4%B8%80%E6%98%AF%E9%80%9F%E5%BA%A6%E5%BF%AB%EF%BC%8C%E4%BA%8C%E6%98%AF%E6%94%AF%E6%8C%81%E5%85%8D%E8%B4%B9%E7%9A%84%E7%A7%81%E5%AF%86%E9%A1%B9%E7%9B%AE%E3%80%82">https://www.oschina.net/）开发的一款基于git的代码托管平台，能够用码云实现代码托管、项目管理、协作开发，目前是国内最大的代码系统，gitee和github的作用和性质是类似的，码云是基于gitlab，操作方式与github类似，但是相比于github而言，gitee有两个显著的优势：一是速度快，二是支持免费的私密项目。</a></p>
<h3 id="对于网上的项目"><a href="#对于网上的项目" class="headerlink" title="对于网上的项目"></a>对于网上的项目</h3><h4 id="一、fork源项目"><a href="#一、fork源项目" class="headerlink" title="一、fork源项目"></a>一、fork源项目</h4><p>码云的协作是基于fork（分支）源项目的基础上，才能进行pull request。对要进行协作开发或者学习的项目，fork一份到自己的远程仓库。</p>
<p>这样我们自己的远程仓库就会有一份源工程的副本。熟悉git版本工具开发的朋友，可以把一份fork下来的副本当成一个开发分支。</p>
<p>只有fork下来的副本你才拥有修改的权限，等同于一个拥有开发权限的分支。在这个开发分支中，你可以进行代码学习或者开发，提交修改到远程仓库的副本工程。</p>
<h4 id="二、协同修改操作pull-request"><a href="#二、协同修改操作pull-request" class="headerlink" title="二、协同修改操作pull request"></a>二、协同修改操作pull request</h4><p>这样可以将自己仓库的修改过的分支，提交合并请求到源项目，完成远程协作。</p>
<h4 id="三、拉取源项目最新内容"><a href="#三、拉取源项目最新内容" class="headerlink" title="三、拉取源项目最新内容"></a>三、拉取源项目最新内容</h4><p>点击项目标题下源项目旁边的 刷新按钮，便可以拉取最新的源项目数据。</p>
<p>便于及时获取原作者最新的项目更新。</p>
<p>也可以通过给fork下来的副本添加上游仓库地址<br>使用git 命令更新</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://gitee.com/xxxxxxxx.git</span><br><span class="line">git pull upstream develop</span><br></pre></td></tr></table></figure>

<p>注意： 更新上游仓库 会覆盖本地修改，所以请pr项目评审(Project Review) 接受之后 在更新</p>
<h3 id="对于工作的项目"><a href="#对于工作的项目" class="headerlink" title="对于工作的项目"></a>对于工作的项目</h3><h4 id="创建本地代码仓库"><a href="#创建本地代码仓库" class="headerlink" title="创建本地代码仓库"></a>创建本地代码仓库</h4><ol>
<li><p>在本地一个盘下新建一个文件夹，当作本地代码仓库，也就是说希望之后这个文件夹里的文件的改动都能被git进行管理。<br>例如在F盘内新建一个名为XXX的文件夹</p>
</li>
<li><p>在该文件内： 点击鼠标右键，选择执行git命令，执行代码：<code>git init</code></p>
</li>
</ol>
<p>这句话的意思是初始一个本地仓库，之后可以看到在该文件夹下多了一个.git文件夹，用于记录所有与管理本仓库相关的文件，<br>所以请小心改动。</p>
<p>也可以：<code>git clone 项目的url</code></p>
<p>然后就会发现在该盘下面就有了一个同名文件夹，并且.git目录和README.md文件都有，这两个代码仓库都已经同步好了</p>
<h4 id="进行代码托管"><a href="#进行代码托管" class="headerlink" title="进行代码托管"></a>进行代码托管</h4><p>本地代码仓库和远程代码仓库都创建好之后，需要把它们进行同步才能在gitee上进行代码托管。</p>
<p>1.本地代码仓库与远程代码仓库进行同步，执行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;xxxxxxx.git</span><br></pre></td></tr></table></figure>

<p>其中远程库的名字就是origin，这是git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>origin可以改为项目名，或者和项目名不同也都是可以的，因为重要的是后面的url，每个远程代码库都有一个自己的url，所以本地仓库本质上是和这个url所指代的远程仓库进行关联的。</p>
<p>2.拉取远程代码库<br>由于在创建远程仓库时会初始化一个README.md文件，而本地仓库里没有，所以需要先执行pull操作将远程仓库拉取合并到本地仓库，否则会出错。执行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p>【注1：由于在本地创建了代码仓库，git默认关联的库在本地，所以直接执行git pull命令是无效的，需要执行<code>git pull origin master</code>命令才行，这句话的意思是推送到远程库master分支，此外，也可以根据提示执行一下<code>git branch --set-upstream origin master</code>命令，以后就可以直接使用git pull了】</p>
<p>此时可以看到在本地代码仓库中多了一个README.md文件。</p>
<p>【注2：如果遇到错误提示“fatal: refusing to merge unrelated histories”，出现这种错误是因为git会以为这两个仓库不同所以进行无法合并，在执行pull操作时添加–allow-unrelated-histories，即执行<code>git pull origin master --allow-unrelated-histories</code>就可以了】</p>
<p>3.向远程代码仓库推送文件（例如在本地代码仓库中新建了test1.txt和test2.txt文件，现把它们同步到远程代码仓库），执行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;对该操作的相关描述&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到，git追踪到了仓库中文件的变化，所以说git起到了作用。现在执行push操作将它推送到远程代码库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure>

<p>【注3：这里使用git push命令会和上面使用git pull时出现同样的问题，根据提示<code>git push --set-upstream origin master</code>，以后就可以直接使用git push命令了】<br>刷新远程代码仓库，可以看到文件被成功的同步到了远程仓库：</p>
<p>当然，同步一个文件夹到远程仓库与同步单个文件相同，只不过无法同步空文件夹到远程仓库，因为git会认为没有改动</p>
<p>【注4：这以直接使用git push命令，因为远程创建了代码仓库，git默认关联的库在远程，git push是默认推送到远程库master分支】</p>
<h3 id="关于删除"><a href="#关于删除" class="headerlink" title="关于删除"></a>关于删除</h3><h4 id="一、删除文件、文件夹"><a href="#一、删除文件、文件夹" class="headerlink" title="一、删除文件、文件夹"></a>一、删除文件、文件夹</h4><p>1.删除文件，执行命令：<code>git rm 想要删除的文件的名字及其后缀</code></p>
<p>如果在本地代码仓库testGit1中有三个文件，README.md、test1.txt和test2.txt，删除文件test1.txt，<br>但是如果不加文件后缀的话，会发现提示匹配不到文件，所以必须给全名。<br>之后可以发现本地仓库已经没有这个文件了，但是刷新远程仓库会发现，这个文件依然存在，<br>这是因为在本地仓库改动过后，没有将现在的状态同步到远程仓库，所以需要执行一下commit和push命令：</p>
<p><code>git commit -m &quot;对本次提交的描述信息&quot;</code><br><code>git push</code></p>
<p>现在刷新远程代码仓库，可以看到文件test1.txt被成功的删除了。</p>
<p>2.删除文件夹，执行命令：<code>git rm 想要删除的文件夹的名字 -r</code></p>
<p>如果在本地代码仓库testGit1中有一个名为test的文件夹，直接使用删除文件的命令无法删除文件夹，会提示错误“not removing ‘test’ recursively without -r”，可以先执行一下git rm -help命令查看rm命令的使用详情，其中添加-r表示允许迭代移除，所以git rm test -r可以删除test文件夹，之后执行commit和push操作即可。</p>
<h4 id="二、找回误删文件、文件夹"><a href="#二、找回误删文件、文件夹" class="headerlink" title="二、找回误删文件、文件夹"></a>二、找回误删文件、文件夹</h4><p>git对于版本的管理本质是对提交的管理，所以在每个操作后最好提交一下，便于之后需要回退，例如要找回上面操作中误删的文件test1.txt。</p>
<p>1.如果你现在正在进行某些更改，需要先推送远程仓库，否则回退之后，最新状态的内容就没有了。</p>
<p>2.执行命令：<code>git log</code></p>
<p>这个命令会显示出提交日志，可以看到有一个增加了2个文件（test1.txt和test2.txt）的提交和删除test1.txt的提交：</p>
<p>每个提交都有自己的唯一标识，所以想要找回文件test1.txt，需要回退到提交删除操作的前一个状态，所以这里是回退到添加文件状态，执行命令：</p>
<p><code>git reset --hard 需要回退到的状态的commit标识号</code></p>
<p>该命令的原理：git有个指向当前版本的HEAD指针，执行回退操作本质上是git把HEAD指针从当前状态指向想要回退到的状态，所以回退的速度很快，需要回退到哪里，就让HEAD指向哪里就行。</p>
<p>如果看到提示说HEAD已经处于添加文件的状态了，此时查看文件也可以看到test1.txt文件。</p>
<p>3.如果在这个状态和最新状态之间又提交过很多文件，需要手动把这个找回的test1.txt文件拷贝出去一份，再执行reset命令回到最新的状态：</p>
<p><code>git reset --hard 最新状态的commit标识号</code><br>4.最新状态是没有刚刚找回的这个文件的，把test1.txt文件拷贝进本地仓库中，然后推送到远程仓库即可，执行命令：</p>
<p>git add .<br>git commit -m “对本次提交的描述”<br>git push</p>
<p>这样就可以既找回了之前误删的文件，又没有丢掉中间状态的很多文件。<br>找回误删的文件夹和找回误删的文件操作完全相同，因为git不会识别你找回的是什么，只是回退到相应的状态而已。</p>
<p>过程示意图：</p>
<p>commit:1——&gt;commit:2——&gt;commit:3——&gt;commit:4——&gt;commit：5<br>                           误删                    最新状态</p>
<p>当你想要找回删除的文件的时候，先保存现在的状态即最新状态commit：5，然后回退到误删的前一个状态也就是commit：2，<br>这时候可以获取到已经删除的文件，把它拷贝出去保存一份，然后回到最新状态commit：5，<br>该状态下是没有已经删除的文件的，但是刚刚我们找到了它并拷贝了一份，现在把这个文件再拷贝进来到本地仓库中，<br>然后执行提交推送操作，会产生一个新的commit状态，这个就是在commit：5的基础上找回已删除文件后产生的最最新的状态。</p>
<h2 id="常见名词"><a href="#常见名词" class="headerlink" title="常见名词"></a>常见名词</h2><ol>
<li>分支（git branch命令）</li>
</ol>
<p>git默认分支一般是master，当然，这是可以修改的，我们在master完成一次开发，生成了一个稳定版本，那么当需要添加新功能或者做修改时，只需要新建一个分支，然后在该分支上开发，完成后合并到主分支即可，分支功能解决了正在开发的版本与上线版本稳定性冲突的问题。</p>
<ol start="2">
<li>提交（git commit命令）</li>
</ol>
<p>git对于版本的管理其实是对提交的管理，git使用40个字节长度的16进制字符串来标识每一个提交，每一个提交具有唯一的标识，根据这个标识可以任意回退。</p>
<ol start="3">
<li>拉取（git pull命令）</li>
</ol>
<p>用于取回远程仓库某个分支的更新，再与本地仓库合并。</p>
<ol start="4">
<li>推送（git push命令）</li>
</ol>
<p>用于把本地的代码更新到远程仓库。</p>
<h2 id="常见操作指令"><a href="#常见操作指令" class="headerlink" title="常见操作指令"></a>常见操作指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git init  &#x2F;&#x2F;初始化一个Git仓库，Git的很多命令都需要在Git的仓库中运行，所以 git init 是使用Git的第一个命令</span><br><span class="line">git clone  &#x2F;&#x2F;拷贝一份远程仓库，也就是下载一个项目</span><br><span class="line">git config --list &#x2F;&#x2F;查看配置信息</span><br><span class="line">git config --global user.name &quot;runoob&quot;  &#x2F;&#x2F;配置个人的用户名称</span><br><span class="line">git config --global user.email test@runoob.com  &#x2F;&#x2F;配置个人的电子邮件地址    去掉 --global 参数只对当前仓库有效</span><br><span class="line"></span><br><span class="line">git status  &#x2F;&#x2F;查看仓库当前的状态，显示有变更的文件</span><br><span class="line">git diff  &#x2F;&#x2F;比较文件的不同，即暂存区和工作区的差异</span><br><span class="line">git reset &#x2F;&#x2F;回退版本</span><br><span class="line">git rm  &#x2F;&#x2F;删除工作区文件</span><br><span class="line">git mv  &#x2F;&#x2F;移动或重命名工作区文件</span><br><span class="line"></span><br><span class="line">git remote  &#x2F;&#x2F;远程仓库操作    （remote 远程）</span><br><span class="line">git fetch  &#x2F;&#x2F;从远程获取代码库   （fetch 取来）</span><br><span class="line"></span><br><span class="line">分支管理</span><br><span class="line">git branch (branchname)  &#x2F;&#x2F;创建分支  git branch -分支名</span><br><span class="line">git checkout (branchname) &#x2F;&#x2F;切换分支  git checkout -   分支名</span><br><span class="line">git merge  &#x2F;&#x2F;合并分支   git merg --no-ff 分支名</span><br><span class="line">git log  &#x2F;&#x2F;查看历史提交记录   git log --graph</span><br><span class="line">git blame &lt;file&gt;  &#x2F;&#x2F;以列表形式查看指定文件的历史修改记录  （blame 责备）</span><br><span class="line"></span><br><span class="line"> git tag -a v1.0 &#x2F;&#x2F;git标签</span><br></pre></td></tr></table></figure>



<h2 id="IDEA集成gitee"><a href="#IDEA集成gitee" class="headerlink" title="IDEA集成gitee"></a>IDEA集成gitee</h2><h3 id="1、安装gitee插件"><a href="#1、安装gitee插件" class="headerlink" title="1、安装gitee插件"></a>1、安装gitee插件</h3><p>【File】-【Settings】-【Plugins】，查看gitee插件并安装</p>
<p>IDEA 码云插件已由 gitosc 更名为 gitee。</p>
<p>安装完成后，重启IDEA</p>
<h3 id="2、使用码云托管项目"><a href="#2、使用码云托管项目" class="headerlink" title="2、使用码云托管项目"></a>2、使用码云托管项目</h3><h5 id="添加Gitee账户"><a href="#添加Gitee账户" class="headerlink" title="添加Gitee账户"></a>添加Gitee账户</h5><p>【File】-【Settings】-【Version Control】-【Gitee】，点击【Add account】添加账户</p>
<p>输入账号和密码，点击【Log In】</p>
<p>登录成功后会显示账户信息。</p>
<h5 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h5><p><strong>将IDEA项目分享至Gitee（这个会推送到个人的项目里，不是多人合作的项目）（用于个人练习的项目存到码云上）</strong></p>
<p>选中要同步的项目，点击菜单【VCS】-【Import into Version Control】-【Share Project on Gitee】</p>
<p>点击【Share】按钮</p>
<p>（如果文件有很多更改）将不必要的文件去除对勾，点击【Add】</p>
<p>提示项目成功分享至Gitee</p>
<p>登录Gitee可看到项目</p>
<p><strong>Gitee项目克隆至IDEA（用于将码云上的项目下载到本地）</strong></p>
<p>【VCS】-【Git】</p>
<p>输入Gitee项目的URL，点击【Clone】，开始克隆</p>
<p>点击【Yes】</p>
<p>点击【This Window】</p>
<p>克隆成功，可看到项目代码</p>
<p><strong>Gitee团队协作（用于正式项目的开发合作）</strong></p>
<p>拉取代码<br>【VCS】-【Update Project】</p>
<p>点击【OK】</p>
<p>提示更新多少个文件，可以点击【View】查看更新的文件列表</p>
<p>更新文件列表</p>
<h6 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h6><p>注：提交代码前，应先拉取。若拉取时出现代码冲突，应先解决冲突后再提交</p>
<p>【VCS】-【Commit】</p>
<p>可选择哪些代码提交，默认全选，输入提交信息，点击【Commit and Push】。或者先点击【Commit】，再从菜单中点击【Push】</p>
<p>选择默认分支，点击【Push】</p>
<p>提交成功</p>
<h2 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h2><h3 id="发生的场景"><a href="#发生的场景" class="headerlink" title="发生的场景"></a>发生的场景</h3><ul>
<li>情景一：多个分支代码合并到一个分支时</li>
<li>情景二：多个分支向同一个远端分支推送代码时</li>
</ul>
<p>实际上，push操作即是将本地代码merge到远端库分支上。</p>
<p>关于push和pull其实就分别是用本地分支合并到远程分支 和 将远程分支合并到本地分支</p>
<p>所以这两个过程中也可能存在冲突。git的合并中产生冲突的具体情况：<br>　　&lt;1&gt;两个分支中修改了同一个文件（不管什么地方）<br>　　&lt;2&gt;两个分支中修改了同一个文件的名称<br>两个分支中分别修改了不同文件中的部分，不会产生冲突，可以直接将两部分合并。</p>
<h3 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h3><ul>
<li>情景一：在当前分支上，直接修改冲突代码—&gt;add—&gt;commit</li>
<li>情景二：在本地当前分支上，修改冲突代码—&gt;add—&gt;commit—&gt;push</li>
</ul>
<p>注：借用vim或者IDE或者直接找到冲突文件，修改</p>
<h4 id="idea里："><a href="#idea里：" class="headerlink" title="idea里："></a>idea里：</h4><p>当在提交或拉取代码时，出现冲突会弹出对话框，选中冲突的文件，点击【Merge】</p>
<p>对话框中出现三个框，分别为：</p>
<p>左边框为本地待提交的代码<br>右边框为Gitee中代码<br>中间框为解决冲突后的结果代码<br>解决代码冲突：我们修改中间的代码，可根据情况选择【Accept Left】或【Accept Right】；亦或者手动修改冲突代码后点击【Apply】</p>
<p>点击【Yes】</p>
<p>当所有冲突文件解决后，重新提交即可</p>
<p>还有一种解决冲突的方式：</p>
<p>1.将本地代码进行stash 即保存到git栈中，并命名”333 conflict” （<code>git - repository - stash changes</code>） 此后所有的修改已经不存在了，恢复到上一次的代码内容</p>
<p>2.<code>pull master</code>  代码内容变为远程仓库master分支的内容</p>
<p>3.将本地修改取出 （<code>git - repository - unstash changes</code>）选中之前创建的”333 conflict” 恢复</p>
<p>4.此时会提示有冲突 点击解决冲突 中间的result为解决结果 可以直接选择左或右或修改结果</p>
<p>5.冲突修改完成，commit and push</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>本地新建立一个文件夹，然后git命令拉取到本地：</p>
<p><code>git clone url地址</code></p>
<p>提交代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;提交的备注信息&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h3 id="分支："><a href="#分支：" class="headerlink" title="分支："></a>分支：</h3><p>gitee是国内的代码托管平台，相比较于github拉取仓库和推送的速度更快，这里主要讲述一下通过git bash将代码推送到gitee的某个branch的流程。</p>
<h5 id="推送流程简述："><a href="#推送流程简述：" class="headerlink" title="推送流程简述："></a>推送流程简述：</h5><p>推送的流程其实归纳起来可以总结出四步：</p>
<ol>
<li>将Gitee的仓库/某个具体的分支拉取到本地</li>
<li>将自己写好的代码放到本地仓库中</li>
<li>将代码提交到本地仓库</li>
<li>将代码推送到Gitee远端仓库</li>
</ol>
<h5 id="具体过程详解："><a href="#具体过程详解：" class="headerlink" title="具体过程详解："></a>具体过程详解：</h5><p>首先是将Gitee的仓库/分支拉取到本地：</p>
<p>首先进入任意文件夹，选择git bash（在这里运行的前提是本地已经安装并配置好git，安装配置的过程在这里不多赘述），然后输入命令：</p>
<p><code>git clone -b【分支名】SSH（这里的ssh是码云仓库的SSH）</code></p>
<p>这里强调一下，如果是要拉取master分支就可以直接使用git clone，如果要拉取子分支需要加 -b 【分支名】，否则默认拉取的是master分支！</p>
<p>拉取成功之后会看到本地多了一个文件夹，这就是我们远端拉取到的git仓库</p>
<p>将代码提交到本地git仓库<br>在成功拉取之后我们进入到拉取来的文件夹，可以看到里面的结构与我们码云上的结构是完全相同的</p>
<p>然后直接从本地将我们的代码拷贝到该文件夹中，打开git bash，执行</p>
<p><code>git add 【文件】</code></p>
<p>的操作（！！这里要重点强调，一定要在远端仓库中打开git bash，会在路径中看到有我们的分支名称）</p>
<p>当 git add完成之后我们需要执行</p>
<p><code>git commit -m &quot;&quot;</code> </p>
<p>操作，来表明我们对这个事务进行提交（可以类比数据库的事务）<br>在这里使用 <code>-m</code>  目的是对提交的项目进行描述（message）</p>
<p>当commit成功后我们就成功将我们的项目添加到了本地的git仓库中，使用</p>
<p><code>git push origin 【分支名】</code></p>
<p>就可以成功把本地git仓库的代码推送到码云远端仓库中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/12/19.2.Gitee/" data-id="ckq1xbdsk0045pwwd6u3qg647" data-title="Gitee" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/18/WebRTC%E7%9A%84%E5%AD%A6%E4%B9%A0/">WebRTC的学习</a>
          </li>
        
          <li>
            <a href="/2021/06/18/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/">流媒体协议</a>
          </li>
        
          <li>
            <a href="/2021/06/17/1.7.%E7%AE%80%E5%8E%86%E5%AE%8C%E5%96%84/">简历完善</a>
          </li>
        
          <li>
            <a href="/2021/06/08/%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/">搭建网站</a>
          </li>
        
          <li>
            <a href="/2021/06/03/%E6%94%BB%E7%A0%B4%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99/">攻破一个网站</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>