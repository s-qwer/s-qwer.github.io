<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/8/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-10.5.项目提交" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/11/10.5.%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4/" class="article-date">
  <time class="dt-published" datetime="2021-04-11T06:03:11.000Z" itemprop="datePublished">2021-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/11/10.5.%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4/">项目提交</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>后端项目打包：</p>
<p>maven的lifecycle提供了一个package，点击后打的jar包会出现在target文件下。</p>
<p>或者控制台输入命令：</p>
<p><code>mvn clean package -Dmaven.test.skip=true</code></p>
<p>前端项目打包：</p>
<p>1.先运行依赖包：<code>npm install</code></p>
<p>2.控制台输入打包命令：</p>
<p><code>cnpm run build</code>   </p>
<p>3.将生成的dist文件，直接放到服务器上</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/11/10.5.%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4/" data-id="ckq1xbdr8000fpwwd1icle96h" data-title="项目提交" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-10.6.项目外包" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/10.6.%E9%A1%B9%E7%9B%AE%E5%A4%96%E5%8C%85/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T12:03:47.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/10.6.%E9%A1%B9%E7%9B%AE%E5%A4%96%E5%8C%85/">项目外包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>项目外包一般包括：项目文档、项目外包合同</p>
<p><em><strong>*分为*</strong>***</em>*项目立项*<em><strong>、</strong></em>*项目规划*<em><strong>、</strong></em>*需求分析*<em><strong>、</strong></em>*项目验收****<em><strong>*阶段*</strong></em></p>
<p><em><strong>*1.明确项目干系人*</strong>***</em>*<br>****    在项目规划阶段明确干系人的人员组成、优先级、期望点，是保障项目定位、需求来源的准确性的必要途径，是进入项目需求阶段的基础</p>
<p><em><strong>*2.合理的项目团队组织*</strong></em></p>
<p>包括人员安排、任务划分、沟通协作项目确认</p>
<p>· 安排专业人员作为项目对接人</p>
<p>· 建立项目进度跟踪机制</p>
<p>3.不可忽视项目的非功能需求：包括性能需求、安全需求、集成需求、可靠性需求、兼容性需求、易用性需求等</p>
<p><strong>l</strong> <em><strong>*性能需求*</strong></em></p>
<p>对于前台的系统而言，通常以“响应时间”上进行定义，并具体到的某个业务场景。需求描述举例如下：</p>
<p>定位系统从点击到第一个界面显示出来所需要的时间不得超过300毫秒。</p>
<p>在非高峰时间根据编号和名称特定条件进行搜索，可以在3秒内得到搜索结果。</p>
<p>对于后台的业务管理系统来说，通常以“整体能力上来定义”，并具体到某个业务场景。常见的业务指标包括“并发量、资源使用率、业务量、系统容量”等等。需求描述举例如下：</p>
<p>系统可以同时满足10,000个用户请求，并为25,000个并发用户提供浏览功能。</p>
<p>CPU占用率&lt;=50%，内存占用率&lt;=50%。</p>
<p>数据库表行数不超过100万行，数据库最大容量不超过1000GB，磁盘空间至少需要40G以上。</p>
<p><strong>l</strong> <em><strong>*可扩展需求*</strong></em></p>
<p>系统可扩展可以从系统性能、系统功能两个方面进行考虑，其基本要求是功能扩展时不需要对系统的基础架构进行改动，性能扩展不通过任何代码的更改。在描述系统性能的可扩展需求时应结合性能需求，举例如下：</p>
<p>系统可以在未来需要的情况下，不通过任何代码的更改，对系统性能进行提升，使之中心系统每秒钟能记录25个以上的考勤记录。</p>
<p>从业务设计的角度来说，模块化、可复用、较少依赖或耦合是可扩展的原则。</p>
<p>l 集成需求</p>
<p>集成需求主要包括数据对接（系统之间的数据交换和信息传递）、单点登录（多个独立系统统一账号和登录认证）、系统融合（ 将多个系统融合在一个系统中，统一账号、权限、应用的管理，最终以一个独立的软件系统存在）。需求描述举例如下：</p>
<p>某某图书管理系统采集##库存管理系统的数据包括库存数据、订单数据。</p>
<p>某某课程管理系统通过与EHR系统实施集成，实现相关基础数据（组织机构、用户数据等）的共享，实施统一身份认证和统一登录界面。</p>
<p>内训管理后台融合到社区管理后台中，统一账号、权限、功能的管理。</p>
<p>l 兼容性需求<br>一般对于前台系统而言，都需要考虑其兼容性。目前最为广泛的前台系统是手机客户端、web端，在考虑系统的兼容性时主要前台的适用平台有哪些，需求描述举例如下。</p>
<p>· 系统仅支持chrome浏览器，不考虑移动端适配。</p>
<p>· 移动端需要兼容的操作系统IOS6以上、Andriod6.0以上</p>
<p>l 易用性需求</p>
<p>易用性和产品的用户体验相关，是一组规定或者潜在的用户为使用其软件所需做的努力和对这样的使用所作的评价有关的一组属性。衡量易用性的标准是用户对于系统功能是否容易理解、是否容易学习、是否容易操作，需求描述举例如下：</p>
<p>80%的用户经过培训后，可在5分钟内完成课程创建。</p>
<p>90％的用户完成建课后，需要在5s内知道下一步需要进行什么操作，如课程上线、编辑、查看详情等。</p>
<p>接口测试也是属于****功能测试*<em><strong>，所以跟我们以往的功能测试流程并没有太大区别，测试流程依旧是：1.测试接口文档（需求文档） 2.根据接口文档编写</strong></em>*测试用例****（用例编写完全可以按照以往规则来编写，例如等价类划分，边界值等设计方法） 3. 执行测试，查看不同的参数请求，接口的返回的数据是否达到预期</p>
<p>HTTP抓包工具：Fiddler、Charles、Firebug、开发者工具等等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/10.6.%E9%A1%B9%E7%9B%AE%E5%A4%96%E5%8C%85/" data-id="ckq1xbdr9000gpwwd1fc2b0cb" data-title="项目外包" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-7.Tomcat" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/7.Tomcat/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:47:13.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/7.Tomcat/">Tomcat</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Apache/6265">Apache</a>、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>
<p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTML">HTML</a>（<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073">标准通用标记语言</a>下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。</p>
<p>诀窍是，当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。另外，Tomcat和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/IIS">IIS</a>等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTML">HTML</a>的能力不如Apache服务器。</p>
<p>Tomcat就是一个web的服务器，用来发布web项目。</p>
<p>下载：<a target="_blank" rel="noopener" href="http://tomcat.apache.org/download-70.cgi">http://tomcat.apache.org/download-70.cgi</a></p>
<p>解压文件之后，bin目录下的startup.bat，会出现一个dos命令界面，不要关闭的情况下，在浏览器中输入localhost:8080/会跳转到一个页面,这样就表示安装成功了。</p>
<p>安装注意事项：</p>
<p>Tomcat运行需要依赖Java环境，也就是说需要在电脑上安装了JDK之后才可以安装和启动Tomcat。因为Tomcat启动的时候需要使用JRE的环境。必须要配置JAVA_HOME环境变量（这个必须要在系统变量中才行），如果没有配置JAVA_HOME环境变量，那么服务器在启动的时候就会一闪然后关闭。（可以将startup.bat用记事本打开，在最后的end后面的最后一行写上pause，令它停止一下，再打开就会显示错误信息）</p>
<p>如果电脑上安装了一个应用之后，有可能会占用Tomcat的端口，如果将Tomcat端口占用了，同样这个Tomcat启动不了的。Tomcat默认的端口号是8080（很少会有程序占用，除非你启动了两个Tomcat，但是一般80端口容易被其他程序所占用）。因为80端口是HTTP协议的默认端口（一般在http协议下的输入网址字母后面都可以跟：80，无影响，所以可以省略）。</p>
<p>解决端口号冲突导致Tomcat的startup.bat打开不了的方法：</p>
<p>1.将占用端口的程序结束掉。</p>
<p>在cmd命令符中输入命令查看端口号：netstat -ano</p>
<p>假如出现了这个：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps1.jpg" alt="img"> </p>
<p>8080的端口是PID为9428的占用了，可以在任务管理器中结束这个9428的进程</p>
<p>\2. 改变自身程序的端口。</p>
<p>修改Tomcat的端口号：进入tomcat/conf/server.xml</p>
<p>将配置文件中的</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps2.jpg" alt="img"> </p>
<p>改为其他的即可。</p>
<p>查看日志：</p>
<p>C:\Users\vcc\Desktop\apache-tomcat-9.0.41-windows-x64\apache-tomcat-9.0.41\logs</p>
<p>Tomcat的目录结构：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps3.jpg" alt="img"> </p>
<p>bin        :二进制文件（命令文件：开启和关闭）</p>
<p>conf    :配置文件</p>
<p>lib        :tomcat所需要的jar包</p>
<p>logs        :tomcat服务器日志文件</p>
<p>temp    :tomcat运行产生临时文件</p>
<p>webapps    :需要发布的项目需要放在webapps下，这样就相当于发布出去了（ROOT中的index.jsp就是发布项目的首页）</p>
<p>work    :JSP翻译（编译）成Servlet产生的代码</p>
<p>发布一个Tomcat项目：</p>
<p>可以发布静态，动态项目</p>
<p>如果是静态的项目，只需要有静态页面就够了</p>
<p>动态WEB资源目录结构：</p>
<p>website</p>
<p>​    |——静态页面（HTML、CSS、JS、图片）</p>
<p>​    |——JSP页面</p>
<p>​    |——<em><strong>*WEB-INF*</strong></em></p>
<p>​            |—–<em><strong>*web.xml*</strong></em>    （必须的，有配置、servlet）</p>
<p>​            |—–classes    （可选的，java类，servlet被编译）</p>
<p>​            |—–lib        （可选的，第三方的jar包）</p>
<p>项目的发布方式：</p>
<p>\1. 直接将项目复制到tomcat/webapps下</p>
<p>将项目复制到tomcat/webapps中，启动服务器：bin/startup.bat</p>
<p>访问项目（本机访问）：<a target="_blank" rel="noopener" href="http://localhost:8080/aaa/index.html%EF%BC%88index.html%E6%98%AF%E4%B8%BB%E9%A1%B5%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%86%99%EF%BC%89%EF%BC%88%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%B0%86localhost%E6%94%B9%E4%B8%BAip%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BE%9B%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91%E8%AE%BF%E9%97%AE%EF%BC%89">http://localhost:8080/aaa/index.html（index.html是主页，也可以不写）（也可以将localhost改为ip地址，供其他电脑访问）</a></p>
<p>\2. 在tomcat/conf/server.xml配置tomcat的虚拟路径</p>
<p>虚拟路径：配置一个名称与一个真实的路径进行绑定，然后访问这个名称从而找到真实路径。</p>
<p>在tomcat/conf/server.xml中进行配置（配置的相关变量属性可以在tomcat的文档中找到，tomcat的文档可以在localhost:8080/下找到）。</p>
<p>要添加<Context></Context>表示配置虚拟路径</p>
<p>docBase：项目路径（文档的根路径）</p>
<p>path：虚拟路径</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps4.jpg" alt="img"> </p>
<p>启动服务器访问：<a target="_blank" rel="noopener" href="http://localhost:8080/itheima/index.html">http://localhost:8080/虚拟路径/index.html</a></p>
<p>3.在tomcat/conf/Catalina/localhost/下配置tomcat的虚拟路径</p>
<p>第三种方式也需要配置虚拟路径，第二种需要修改server.xml。server.xml是tomcat的核心配置文件，一旦修改错了，那么tomcat服务器就会出现问题。推荐使用第三种配置方式。</p>
<p>在tomcat/conf/Catalina/localhost下创建一个xml文件：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps5.jpg" alt="img"> </p>
<p>文件的名称就是虚拟路径，只需要访问虚拟路径就可以访问C:\ccc这个路径</p>
<p>启动服务器访问：<a target="_blank" rel="noopener" href="http://localhost:8080/itheima/index.html">http://localhost:8080/虚拟路径/index.html</a></p>
<p>在Eclipse中集成Tomcat</p>
<p>1.选择Eclipse的服务的配置：</p>
<p>打开Eclipse–选择window下的preferences–选择Server下的runtimeenvironment–add添加服务选择ApacheTomcat你的版本，选择安装路径，finish</p>
<p>2.配置服务</p>
<p>切换到javaee视图–在控制台位置找到servers，点击下面的添加–选择ApacheTomcat你的版本，finish–添加好的服务右击open，修改其中的两步</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps6.jpg" alt="img"> </p>
<p>\3. 在eclipse中发布项目</p>
<p>空白处new一个DynamicWebProject，设置项目名称名字，设置模块版本为2.5，finish</p>
<p>（java的代码写到JavaResources的src下，静态页面、jsp写到WebContent下）</p>
<p>创建一个html页面（在WebContent下new），写完之后在下面的Servers右击AddAndRemove，将项目add到右边，finish</p>
<p>在Servers右击start表示开启服务器（现在可以在Tomcat的WebApps下看到项目已经配置了）</p>
<p>\4. 访问项目</p>
<p>浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8080/web_test/">http://localhost:8080/项目名字/</a>就可以访问了。</p>
<p>网站访问的过程：BS模式下</p>
<p><a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a></p>
<p>http是协议</p>
<p>www是万维网的主机名</p>
<p>baidu.com是域名</p>
<p>访问域名的时候，会先去本地的host文件中查找这个域名是否有匹配的ip地址，如果有，会直接返回，如果没有就会去网络上的DNS服务器查找域名所匹配的ip地址，如果找到了就会直接返回这个ip地址，然后根据80端口去访问相应的ip服务器，如果没有就会出错（404）</p>
<p>DNS服务器：DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。</p>
<p>Tomcat虚拟主机的配置：</p>
<p>虚拟主机：在电脑上设置一个目录，使用一个名称与该目录进行绑定。这个路径称为是虚拟主机。主机是可以发布web项目的。</p>
<p>1.抓取一个页面（以百度为例）</p>
<p>2.创建一个路径（虚拟主机的目录）：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps7.jpg" alt="img"> </p>
<p>baidu是虚拟主机的目录，website是项目名称，将抓取的页面放入到项目中</p>
<p>3.配置tomcat的虚拟主机：conf下的server.xml配置。appBase是虚拟主机的目录，name是虚拟主机的名称</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps8.jpg" alt="img"> </p>
<p>4.修改本地的hosts文件：找到C:\Windows\System32\drivers\etc\hosts，修改hosts文件</p>
<p>首先需要知道本机的ip地址：cmd中输入ipconfig /all 找到ip地址</p>
<p>在最下面添加：<img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps9.jpg" alt="img"></p>
<p>5.启动服务器访问项目：在bin下启动服务器：startup.bat</p>
<p>在浏览器输入：<a target="_blank" rel="noopener" href="http://www.baidu.com:8080/website/baidu.htm">http://www.baidu.com:8080/website/baidu.htm</a></p>
<p>但是一般输入的时候不用输入这么多，所以需要修改一些配置，在conf下的server.xml配置</p>
<p>修改端口号：8080改为80</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps10.jpg" alt="img"> </p>
<p>将路径中的website去掉：在自己的虚拟主机中再配置一个虚拟路径</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps11.jpg" alt="img"> </p>
<p>（只要输入一个/就会去website下查找）上述因为添加了注释的汉字，所以格式需要另存一下，改为utf-8（不然会报错）</p>
<p>配置默认的首页（将baidu.htm去掉）：在conf/web.xml下添加baidu.htm为默认页面</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps12.jpg" alt="img"> </p>
<p>注意：修改conf的配置文件后，需要重启服务器</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/7.Tomcat/" data-id="ckq1xbdrv002hpwwd8zvqe42i" data-title="Tomcat" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-14.1.linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/14.1.linux/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:42:46.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/14.1.linux/">linux</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>学习Linux目标:掌握linux常用命令，会安装开发中使用软件，例如mysql,jdk…</p>
<p>开发人员掌握就好，更多的是运维人员需要掌握</p>
<h1 id="Linux介绍"><a href="#Linux介绍" class="headerlink" title="Linux介绍"></a>Linux介绍</h1><p>Linux是基于Unix开发的，Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核</p>
<p>Unix是一个强大的多用户、多任务操作系统。    于1969年在AT&amp;T的贝尔实验室开发。    UNIX的商标权由国际开放标准组织（The Open Group）所拥有。    UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些</p>
<p>Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机</p>
<p>Linux系统的应用</p>
<p>服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； </p>
<p>嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，</p>
<p>高性能运算、计算密集型应用Linux有强大的运算能力。</p>
<p>桌面应用系统 ubuntu</p>
<p>移动手持系统</p>
<p>Linux版本：<em><strong>*内核版本和发行版本*</strong></em></p>
<p>内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号，非常小，只有几M</p>
<p>​    常用的ubuntu  centos  fedora  redhat</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps1.jpg" alt="img"> </p>
<h1 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="*Linux*****安装****"></a><em><strong>*Linux*</strong>***</em>*安装****</h1><p>我们在虚拟机上来安装Linux</p>
<p>虚拟机：一台虚拟的电脑</p>
<p>虚拟机软件：</p>
<p>VMWare它是一个收费虚拟软件，密钥</p>
<p>VirtualBox    :免费的</p>
<p>怎样安装linux系统(centos6.5)：</p>
<p>参考《虚拟软件vmware安装.doc》，安装VmWare</p>
<p>参考《CentOS6详细安装文档.doc》，安装CentOS</p>
<p>前提需要一个.iso的镜像文件</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps2.jpg" alt="img"> </p>
<p>典型安装就可以</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps3.jpg" alt="img"><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps4.jpg" alt="img"><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps5.jpg" alt="img"><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps6.jpg" alt="img"> </p>
<p>需要指定iso文件的位置</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps7.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps8.jpg" alt="img"> </p>
<p>进入安装，选择skip（ctrl+alt可以将鼠标的光标跳出虚拟机）</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps9.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps10.jpg" alt="img"> </p>
<p>时区，亚洲上海</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps11.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps12.jpg" alt="img"> </p>
<p>选择basic server是安装为服务，只有dos命令，便于远程连接访问。如果是desktop桌面版的话不灵活且安装的内容会很多</p>
<p>慢慢等待安装完成，重新引导（重启）</p>
<p>登录时，使用的用户是root,录入密码时不会显示（其实已经输入了），显示第三行的内容为登录成功</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps13.jpg" alt="img"> </p>
<p>很少会直接登录，一般都是远程访问</p>
<h1 id="Linux远程访问"><a href="#Linux远程访问" class="headerlink" title="*Linux远程访问*"></a><em><strong>*Linux远程访问*</strong></em></h1><p>使用CRT软件打开</p>
<p>新建一个连接，快速连接</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps14.jpg" alt="img"> </p>
<p>需要录入linux的ip地址及用户名密码，连接成功后可以在选项中设置窗口颜色方案，变为黑白的这种经典窗口</p>
<p>在虚拟机中查看ip地址 ，输入命令 ifconfig</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps15.jpg" alt="img"> </p>
<p>注意事项:</p>
<p>1.关于linux安装时失败问题，有可能是硬件虚拟化没有打开，需要在bios中开启虚拟化。通过 <img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps16.jpg" alt="img">可以查看</p>
<p>2.关于CRT安装与破解(参考图片)</p>
<h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="*Linux目录结构*"></a><em><strong>*Linux目录结构*</strong></em></h1><p>Linux系统它是文件系统</p>
<p>它的根目录 是”/”,是以树型结构来管理</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps17.jpg" alt="img"> </p>
<p>Root用户登录后，显示时有一个~,它其实代表的就是root目录</p>
<p>通过命令cd..  就会放回上层的根目录 /]#</p>
<p>通过命令ls  可以查看所有的文件名 </p>
<p>bin  boot  cgroup  dev  etc  home  lib  lost  found  media  misc  mnt  net  opt  proc  root  sbin  selinux  srv  sys  tmp  usr  var</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps18.jpg" alt="img"> </p>
<p>root管理员的home目录root</p>
<p>其他用户的home目录home目录中</p>
<p>我们可以将我们自己的文件安装在任意位置</p>
<h1 id="Linux常用命令-重点"><a href="#Linux常用命令-重点" class="headerlink" title="*Linux常用命令(重点)*"></a><em><strong>*Linux常用命令(重点)*</strong></em></h1><p>1.切换目录命令 <em><strong>*cd*</strong></em> （这个命令非常重要）</p>
<p>cd app    切换到app目录    cd ..      切换到上一层目录    cd /        切换到系统根目录    cd ~        切换到用户主目录 root    cd -        切换到上一次执行时所在的目录</p>
<p>2.列出文件列表 <em><strong>*ls ll*</strong></em> （这个命令非常重要）</p>
<p>ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。</p>
<p>dir命令很少用</p>
<p> 格式：ls [参数]  [路径或文件名]        ls –help 可以帮助我们查看帮助信息，都有哪些命令可以执行</p>
<p>可能会出现中文乱码的问题，可以在选项中选择编码为UTF-8</p>
<p>ls -a  显示所有文件或目录（包含隐藏的文件）</p>
<p>ls -l  使用较长格式列出信息（详细信息），缩写成ll</p>
<p>TIPS:在linux中以 . 开头的文件都是隐藏的文件</p>
<p>3.创建与删除目录（注意权限）</p>
<p>可以mkdir –help查看可用命令</p>
<p>mkdir(make directory)命令可用来创建子目录：mkdir app  è  在当前目录下创建app目录mkdir –p app2/test  è 级联创建aap2以及test目录</p>
<p>rmdir(remove directory)命令可用来删除“空”的子目录：    rmdir app  è  删除app目录</p>
<p>当用rmdir 删除非空目录时会显示失败</p>
<p>4.浏览文件</p>
<p>cat操作：cat用于显示文件的内容。</p>
<p>格式：cat [参数] &lt;文件名&gt;</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps19.jpg" alt="img"> </p>
<p>more操作：more一般用于要显示的内容会超过一个画面长度的情况。</p>
<p>按空格键显示下一个画面，按回车键显示下一行内容，按 q 键退出查看</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps20.jpg" alt="img"> </p>
<p>less操作：用法和more类似，不同的是less可以通过PgUp、PgDn键来控制</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps21.jpg" alt="img"> </p>
<p>tail操作：tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容</p>
<p>用法:</p>
<p>tail -10 /etc/passwd  è 查看后10行数据</p>
<p>tail -f catalina.log  è <em><strong>*动态查看日志*</strong></em>(非常重要)</p>
<p>ctrl+c 结束查看</p>
<p>5.文件操作</p>
<p>cp操作：是copy操作</p>
<p>cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</p>
<p>cp a.txt b.txt  è 将a.txt复制为b.txt文件</p>
<p>cp  a.txt  ../  è 将a.txt文件复制到上一层目录中</p>
<p>cp  a.txt  /a/b.txt  将a.txt文件复制到a目录下的b.txt文件中（如果没有这个文件会创建）</p>
<p>mv操作：是move相当于剪切</p>
<p>mv 移动或者重命名</p>
<p>mv a.txt ../  è 将a.txt文件移动到上一层目录中</p>
<p>mv a.txt b.txt  è 将a.txt文件重命名为b.txt</p>
<p>rm操作：它可以帮助我们删除文件与目录</p>
<p>rm  删除文件</p>
<p>用法：rm  [选项]  文件</p>
<p>rm a.txt  è 删除a.txt文件 （删除需要用户确认，y/n）</p>
<p>rm 删除不需要询问</p>
<p>rm -f a.txt  è 不询问，直接删除</p>
<p>rm 删除目录</p>
<p>rm -r a  è 递归删除 （删除需要用户递归确认，y/n）</p>
<p>不询问递归删除（慎用）</p>
<p>rm -rf  a  è 不询问递归删除</p>
<p>rm -rf *  è  删除所有文件</p>
<p>rm -rf /*  è  自杀</p>
<p>****tar操作****：打包压缩与解压（打包或解压操作时常用）</p>
<p>ls或者ll命令下查看：d开头的一般是一个目录，r开头的是一个文件</p>
<p>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件（所以一般.gz或者.tgz文件就是linux系统的文件，.zip就是windows系统的文件）</p>
<p>常用参数：</p>
<p>-c：创建一个新tar文件</p>
<p>-v：显示运行过程的信息</p>
<p>-f：指定文件名</p>
<p>-z：调用gzip压缩命令进行压缩</p>
<p>-t：查看压缩文件的内容</p>
<p>-x：解开tar文件</p>
<p>打包：</p>
<p>tar –cvf xxx.tar ./*  将./*（./*可以是多个文件）的文件打包成xxx.tar文件</p>
<p>打包并且压缩：</p>
<p>tar –zcvf xxx.tar.gz ./* </p>
<p>解压 </p>
<p> tar –xvf xxx.tar   就会解压到当前路径</p>
<p>tar -xvf xxx.tar.gz -C /usr/aaa 注意：C要大写，必须在xxx.tar.gz的目录下执行这个命令</p>
<p>find操作：文件查找，用于查找符合条件的文件</p>
<p>示例：</p>
<p>find / -name “ins*” 查找文件名称是以ins开头的文件</p>
<p>find / -name “ins*” –ls  查找文件名称是以ins开头的文件并列出来详细信息</p>
<p>find / –user itcast –ls 查找用户itcast的文件并列出详细信息（user是权限符）</p>
<p>find / –user itcast –type d –ls 查找用户itcast的目录</p>
<p>find /-perm -777 –type d-ls 查找权限是777的文件</p>
<p>grep操作：字符串查找，用于查找文件中符合条件的字符串</p>
<p>用法: grep  [选项]   PATTERN [FILE]</p>
<p>示例：</p>
<p>grep lang anaconda-ks.cfg  在文件中查找lang</p>
<p>grep lang anaconda-ks.cfg –color 高亮显示</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps22.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps23.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps24.jpg" alt="img"> </p>
<p>A是after，B是before的意思，A5 B5就是前五行和后五行</p>
<p>6.其它常用命令</p>
<p>clear：清屏命令</p>
<p>pwd：显示当前所在目录</p>
<p>touch：创建一个空文件  touch a.txt</p>
<p>ll -h：友好显示文件大小，k表示</p>
<p>wget：下载资料   wget <a target="_blank" rel="noopener" href="http://nginx.org/download/nginx-1.9.12.tar.gz">http://nginx.org/download/nginx-1.9.12.tar.gz</a></p>
<p>LSB是Linux Standard Base的缩写，lsb_release命令用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。</p>
<p>-v, –version<br>显示版本信息<br>-i, –id<br>显示发行版的ID<br>-d, –description<br>显示该发行版的描述信息<br>-r, –release<br>显示当前系统是发行版的具体版本号<br>-c, –codename<br>发行版代号<br>-a, –all<br>显示上面的所有信息<br>-h, –help<br>显示帮助信息</p>
<p> netstat -anp  查看当前进程</p>
<p>netstat -lnp|grep 80 查看80端口</p>
<p>kill -9 进程名字  杀死进程</p>
<h1 id="VI与VIM编辑器"><a href="#VI与VIM编辑器" class="headerlink" title="*VI与VIM编辑器*"></a><em><strong>*VI与VIM编辑器*</strong></em></h1><p>vim是vi的升级。</p>
<p>在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。有三种模式： 命令行、 插入  、底行 模式</p>
<p>通过vi（vim）文件名，就可以对文件进行操作。 </p>
<p>当操作时，开始是命令行模式，按i o  a 切换到插入模式</p>
<p>i 在当前位置前插入</p>
<p>  I 在当前行首插入</p>
<p>  a 在当前位置后插入</p>
<p>  A 在当前行尾插入</p>
<p>  o 在当前行之后插入一行</p>
<p>  O 在当前行之前插入一行</p>
<p>再按esc 可以重新切换到命令行模式 </p>
<p>在命令行模式下按 “:” 就可以切换到底行模式，更多详细用法，可以查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》</p>
<p>在命令行模式下可以使用一些快捷键：</p>
<p>打开文件：vim file</p>
<p>退出：esc à :q （切换到底行模式，再按q就是退出）</p>
<p>修改文件：输入i进入插入模式</p>
<p>保存并退出：escà:wq</p>
<p>不保存退出：escà:q!</p>
<p>三种进入插入模式：</p>
<p>i:在当前的光标所在处插入</p>
<p>o:在当前光标所在的行的下一行插入</p>
<p>a:在光标所在的下一个字符插入</p>
<p>快捷键：</p>
<p>dd – 快速删除一行</p>
<p>yy - 复制当前行</p>
<p>nyy - 从当前行向后复制几行</p>
<p>p - 粘贴</p>
<p>R – 替换</p>
<p>重定向</p>
<p>echo  “sdahufha”  命令就是直接打印出“”内容</p>
<p>&gt;  重定向输出，覆盖原有内容；    &gt;&gt; 重定向输出，换行+追加功能；    示例：</p>
<p>cat /etc/passwd &gt; a.txt  将输出定向到a.txt中</p>
<p>cat /etc/passwd &gt;&gt; a.txt  输出并且追加</p>
<p>ifconfig &gt; ifconfig.txt</p>
<p>管道</p>
<p>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例</p>
<p>ls –help | more  分页查询帮助信息</p>
<p>ps –ef | grep java  查询名称中包含java的进程 （ps -ef 查看当前的进程）</p>
<p>ifconfig | more</p>
<p>cat index.html | more</p>
<p>ps –ef | grep aio</p>
<p>&amp;&amp;命令执行控制</p>
<p>命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。  </p>
<p>只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 </p>
<p>只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。</p>
<p>mkdir test &amp;&amp; cd test</p>
<p>系统管理常用命令</p>
<p>date 可以显示或设置系统时间</p>
<p>date  显示当前系统时间</p>
<p>date -s “2014-01-01 10:10:10“  设置系统时间df 显示磁盘信息</p>
<p>df –h  友好显示大小free 显示内存状态</p>
<p>free –m 以mb单位显示内存组昂头top 显示，管理执行中的程序</p>
<p>clear 清屏幕 </p>
<p>ps 正在运行的某个进程的状态</p>
<p>ps –ef  查看所有进程</p>
<p>ps –ef | grep ssh 查找某一进程kill 杀掉某一进程kill + pid</p>
<p>kill 2868  杀掉2868编号的进程</p>
<p>kill -9 2868  强制杀死进程</p>
<p>du 显示目录或文件的大小。</p>
<p>du –h 显示当前目录的大小</p>
<p> who 显示目前登入系统的用户信息。 </p>
<p>uname 显示系统信息。</p>
<p>uname -a 显示本机详细信息。依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称</p>
<h1 id="Linux下用户与组管理"><a href="#Linux下用户与组管理" class="headerlink" title="*Linux下用户与组管理*"></a><em><strong>*Linux下用户与组管理*</strong></em></h1><p>用户管理</p>
<p>useradd 添加一个用户</p>
<p>useradd test 添加test用户 （会出现在home目录下）</p>
<p>useradd test -d /home/t1  指定用户home目录 </p>
<p>passwd  设置、修改密码</p>
<p>passwd test  为test用户设置密码</p>
<p>切换登录：</p>
<p>ssh -l test -p 22 192.168.19.128  （ssh协议默认22端口）</p>
<p>su – 用户名 切换到这个用户</p>
<p> userdel 删除一个用户</p>
<p>userdel test 删除test用户(不会删除home目录)</p>
<p>userdel –r test  删除用户以及home目录</p>
<p>组管理</p>
<p>当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组 </p>
<p>创建用户时也可以指定所在组 </p>
<p>groupadd  创建组</p>
<p>groupadd public  创建一个名为public的组</p>
<p>useradd u1 –g public  创建用户指定组groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。</p>
<p>groupdel public</p>
<p>id命令：查看一个用户的UID和GID用法：id  [选项] [用户名]</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps25.jpg" alt="img"> </p>
<p>直接使用id，直接使用id 用户名</p>
<p>su命令：切换用户。用法：su   [选项]  [-] [用户   [参数]  ]示例：</p>
<p>su u1  切换到u1用户</p>
<p>su - u1 切换到u1用户，并且将环境也切换到u1用户的环境（推荐使用）</p>
<p>账户文件</p>
<p>/etc/passwd  用户文件    /etc/shadow  密码文件    /etc/group  组信息文件</p>
<p>【用户文件】</p>
<p>root:x:0:0:root:/root:/bin/bash账号名称：        在系统中是唯一的用户密码：        此字段存放加密口令用户标识码(User ID)：  系统内部用它来标示用户组标识码(Group ID)：  系统内部用它来标识用户属性用户相关信息：        例如用户全名等用户目录：        用户登录系统后所进入的目录用户环境:        用户工作的环境</p>
<p>【密码文件】</p>
<p>shadow文件中每条记录用冒号间隔的9个字段组成.用户名：用户登录到系统时使用的名字，而且是惟一的口令：  存放加密的口令最后一次修改时间:  标识从某一时刻起到用户最后一次修改时间最大时间间隔:  口令保持有效的最大天数，即多少天后必须修改口令最小时间间隔：    再次修改口令之间的最小天数警告时间：从系统开始警告到口令正式失效的天数不活动时间：    口令过期少天后，该账号被禁用失效时间：指示口令失效的绝对天数(从1970年1月1日开始计算)标志：未使用 </p>
<p>【组文件】</p>
<p>root:x:0:组名：用户所属组组口令：一般不用GID：组ID用户列表：属于该组的所有用户</p>
<h1 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="*文件权限管理*"></a><em><strong>*文件权限管理*</strong></em></h1><p>文件权限</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps26.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps27.jpg" alt="img"> </p>
<p>r:对文件是指可读取内容 对目录是可以ls</p>
<p>w:对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件)</p>
<p>x:对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录</p>
<p>Linux三种文件类型：</p>
<p>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 </p>
<p> 目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。  </p>
<p>设备文件： Linux系统把每一个设备都看成是一个文件</p>
<p>文件类型标识：</p>
<p>普通文件（-）目录（d）符号链接（l） 进入etc可以查看，相当于快捷方式字符设备文件（c）块设备文件（s）套接字（s）命名管道（p）</p>
<p>文件权限管理：</p>
<p>chmod 变更文件或目录的权限。</p>
<p>chmod 755 a.txt </p>
<p>chmod u=rwx,g=rx,o=rx a.txt</p>
<p>chmod 000 a.txt  / chmod 777 a.txt</p>
<p>chmod u-r a.txt  /  chmod g+x a.txtchown 变更文件或目录改文件所属用户和组</p>
<p>chown u1:public a.txt：变更当前的目录或文件的所属用户和组(用户为u1，组为public)</p>
<p>chown -R u1:public dir：变更目录中的所有的子目录及子文件的所属用户和组</p>
<h1 id="常用网络操作"><a href="#常用网络操作" class="headerlink" title="*常用网络操作*"></a><em><strong>*常用网络操作*</strong></em></h1><p>主机名配置</p>
<p>hostname 查看主机名</p>
<p>hostname xxx 修改主机名，临时性修改 重启后无效</p>
<p>如果想要永久生效，可以修改/etc/sysconfig/network文件（vi 进入文件后编辑）</p>
<p>IP地址配置</p>
<p>Setup设置ip地址</p>
<p>ifconfig 查看(修改)ip地址(重启后无效)</p>
<p>ifconfig eth0 192.168.12.22 修改ip地址</p>
<p>如果想要永久生效</p>
<p>修改 /etc/sysconfig/network-scripts/ifcfg-eth0文件</p>
<p>可以直接输入setup进入网络配置设置（DHCP是自动分配，自己设置的话就是静态ip，空格，tab键）</p>
<p>域名映射</p>
<p>在windows中，System下的drivers下的etc下的hosts文件是域名映射文件</p>
<p>/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps28.jpg" alt="img"> </p>
<p>网络服务管理</p>
<p>service network status 查看指定服务的状态</p>
<p>service network stop 停止指定服务</p>
<p>service network start 启动指定服务</p>
<p>service network restart 重启指定服务</p>
<p>service —status–all 查看系统中所有后台服务</p>
<p>netstat –nltp 查看系统中网络进程的端口监听情况</p>
<p>防火墙设置</p>
<p>防火墙根据配置文件/etc/sysconfig/iptables来控制本机的”出”、”入”网络访问行为。</p>
<p>service iptables status 查看防火墙状态</p>
<p><em><strong>*service iptables stop 关闭防火墙*</strong></em> （需要关闭以访问一些服务和下载）</p>
<p>service iptables start 启动防火墙</p>
<p>chkconfig  iptables off 禁止防火墙自启</p>
<h1 id="Linux上软件安装介绍"><a href="#Linux上软件安装介绍" class="headerlink" title="*Linux上软件安装介绍*"></a><em><strong>*Linux上软件安装介绍*</strong></em></h1><p>Linux上的软件安装有以下几种常见方式介绍</p>
<p>1.二进制发布包</p>
<p>软件已经针对具体平台编译打包发布，只要解压，修改配置即可（可能对linux的某个版本可以，其他版本不可用）</p>
<p>2.RPM包</p>
<p>软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装（可能依赖其他包，需要下载其他包，但是可能没有打包依赖包）</p>
<p>3.Yum在线安装</p>
<p>软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题</p>
<p>4.源码编译安装</p>
<p>软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署。</p>
<p>上传与下载工具介绍：就是windows和linux的文件交互</p>
<p>1.FileZilla：在windows上下载好</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps29.jpg" alt="img"> </p>
<p>解压后，运行exe文件：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps30.jpg" alt="img"> </p>
<p>左边是windows的文件，右边是linux的文件，可以直接把左边的安装包拖拽到右边进行上传</p>
<p>2.lrzsz</p>
<p>我们可以在linux上使用yum安装方式安装 yum install lrzsz</p>
<p>注意：必须有网络</p>
<p>直接输入命令：yum install lrzsz 就会提示下载成功</p>
<p>可以在crt中设置上传与下载目录：在crt上面有个选项，会话选择</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps31.jpg" alt="img"> </p>
<p>上传：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps32.jpg" alt="img"> </p>
<p>下载：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps33.jpg" alt="img"> </p>
<p>在Linux上安装JDK:</p>
<p>1.上传JDK到Linux的服务器</p>
<p>通过rz命令上传JDK，然后java –version发现可以查到版本号，所以卸载自带的open-JDK</p>
<p>rpm -qa | grep java 查找自带的java版本。然后复制，再通过rpm -e –nodeps 复制的内容卸载</p>
<p>rpm -e –nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686</p>
<p>rpm -e –nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.i686</p>
<p>2.在Linux服务器上安装JDK</p>
<p>通常将软件安装到/usr/local</p>
<p>直接解压就可以： tar –xvf  jdk.tar.gz  -C 目标路径  </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps34.jpg" alt="img">./就是当前</p>
<p>3.配置JDK的环境变量</p>
<p>ll查看jdk下的文件获得版本号</p>
<p>配置环境变量：</p>
<p>① vi /etc/profile</p>
<p>② 在末尾行添加</p>
<p>​    #set java environment</p>
<p>​    JAVA_HOME=/usr/local/jdk/jdk1.7.0_71</p>
<p>​    CLASSPATH=.:$JAVA_HOME/lib.tools.jar</p>
<p>​    PATH=$JAVA_HOME/bin:$PATH</p>
<p>​    export JAVA_HOME CLASSPATH PATH</p>
<p>保存退出 ：wq</p>
<p>③source /etc/profile  使更改的配置立即生效</p>
<p>在Linux上安装Mysql:</p>
<p>1.将mysql的安装文件上传到Linux的服务器.（也可以通过wget 网址下载Mysql的安装包）</p>
<p>rz上传</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps35.jpg" alt="img"> </p>
<p>将mysql的tar解压：创建一个新的mysql目录</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps36.jpg" alt="img"> </p>
<p>将系统自带的mysql卸载</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps37.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps38.jpg" alt="img"> </p>
<p>–nodeps是忽略相关依赖包</p>
<p>2.安装MYSQL服务端</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps39.jpg" alt="img"> </p>
<p>如果安装显示出错，需要导入相关的依赖包</p>
<p>下面的提示是告诉我们root用户的密码第一次是随机生成的，它保存在/root/.mysql_secret中，第一次登录需要修改root密码</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps40.jpg" alt="img"> </p>
<p>3.安装MYSQL客户端</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps41.jpg" alt="img"> </p>
<p>查看生成的root密码</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps42.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps43.jpg" alt="img"> </p>
<p>报错:原因是没有启动mysql服务</p>
<p>需要开启mysql服务</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps44.jpg" alt="img"> </p>
<p>可以通过netstat -nltp 查看现在的服务，找到3306的端口证明启动了mysql</p>
<p>然后进行登录，操作mysql时会报错，原因是第一次操作mysql必须修改root用户的密码</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps45.jpg" alt="img"> </p>
<p>设置root用户的密码为root</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps46.jpg" alt="img"> </p>
<p><em><strong>*M*</strong>***</em>*ysql服务加入到系统服务并自动启动操作********：****chkconfig –add mysql</p>
<p>自动启动：chkconfig mysql on</p>
<p>查询列表：chkconfig</p>
<p>关于mysql远程访问设置：</p>
<p>先登录到mysql，然后输入下面命令进行设置</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps47.jpg" alt="img"> </p>
<p>在linux中很多软件的端口都被”防火墙”限止，我们需要将防火墙关闭，也可以将防火墙打开3306端口</p>
<p>/sbin/iptables -I INPUT -p tcp –dport 3306 -j ACCEPT</p>
<p>/etc/rc.d/init.d/iptables save</p>
<p>/etc/init.d/iptables status</p>
<p>学习阶段我们也可以直接将防火墙关闭（不推荐，因为服务器需要防火墙）：service iptables stop</p>
<p>在Linux上安装tomcat:</p>
<p>1.Tomcat上传到linux上：rz，上传文件。ll查看是否上传成功</p>
<p>2.将上传的tomcat解压：建目录mkdir tomcat7  ，然后tar -xvf 安装包名字 -C ./tomacat7</p>
<p>3.在tomcat/bin目录下执行 startup.sh（注意防火墙需要关闭）： ./startup.sh </p>
<p>4.查看日志 tomcat/logs/catalina.out：cat ./catalina.out</p>
<p>也可以查看cat ./catalina.日期.log</p>
<p>以后的文件工程可以放到webapp下进行发布</p>
<p><strong>Linux系统一般有4个主要部分：</strong></p>
<p>内核、shell、文件系统和应用程序。内核、shell和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统。部分层次结构如图1-1所示。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lEDBbOe0FuicSPxypcgPoeL9uibcHTFXGQibX74k5ffhwscOY6zyhhZgH1w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iblTYUnF9yPPAFqPibv6Siadtw5kYIvianGuggAAZcL0nicTqibicKG1MUJG8Nvic9BVDaXuJSlRZquoQJjNkNgglBRAxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>一、linux内核</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OKdYEbfJSc6gicBpKXLM0OehXMoaLEVciciaZtGq2EVOCnYxayTAq4iat0n7tpp67RLQyAwnJ704cic8UPyaYhQicRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。</p>
<p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。如图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lETUWYmjOW4badfSmqjQhYuGiaxO1ZmiaiayfKJslK7oJBD2qZN4t5IHicuA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">图1</p>
<p> 系统调用接口：SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。</p>
<h3 id="1、内存管理"><a href="#1、内存管理" class="headerlink" title="1、内存管理"></a><strong>1、内存管理</strong></h3><p>对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux  采用了称为“虚拟内存”的内存管理方式。Linux  将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。</p>
<p>不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。</p>
<p>为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。</p>
<h3 id="2、进程管理"><a href="#2、进程管理" class="headerlink" title="2、进程管理"></a><strong>2、进程管理</strong></h3><p>进程实际是某特定应用程序的一个运行实体。在 Linux  系统中，能够同时运行多个进程，Linux  通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。</p>
<p>进程调度控制进程对CPU的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待CPU资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux使用了比较简单的基于优先级的进程调度算法选择新的进程。</p>
<p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。</p>
<p>内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSⅨ] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSⅨ 机制）。</p>
<h3 id="3、-文件系统"><a href="#3、-文件系统" class="headerlink" title="3、 文件系统"></a><strong>3、 文件系统</strong></h3><p>和 DOS 等操作系统不同，Linux 操作系统中单独的文件系统并不是由驱动器号或驱动器名称（如 A:  或 C:  等）来标识的。相反，和 UNIX  操作系统一样，Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux  将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。Linux  操作系统的一个重要特点是它支持许多不同类型的文件系统。Linux 中最普遍使用的文件系统是 Ext2，它也是 Linux  土生土长的文件系统。但 Linux  也能够支持 FAT、VFAT、FAT32、MINIX 等不同类型的文件系统，从而可以方便地和其它操作系统交换数据。由于 Linux  支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统.</p>
<p>虚拟文件系统（VirtualFileSystem,VFS）:隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。虚拟文件系统可以分为逻辑文件系统和设备驱动程序。逻辑文件系统指Linux所支持的文件系统，如ext2,fat等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。</p>
<p>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层。即VFS 在用户和文件系统之间提供了一个交换层。</p>
<h5 id="VFS在用户和文件系统之间提供了一个交换层"><a href="#VFS在用户和文件系统之间提供了一个交换层" class="headerlink" title="VFS在用户和文件系统之间提供了一个交换层:"></a>VFS在用户和文件系统之间提供了一个交换层:</h5><p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lEQqkMREF3lmAGBkIon8Nm1VNjPdYz1KxFnV2oEVdLjNU9AnJzPRDVuw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。</p>
<p>文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p>
<p>因此，用户和进程不需要知道文件所在的文件系统类型，而只需要象使用 Ext2  文件系统中的文件一样使用它们。</p>
<h3 id="4、设备驱动程序"><a href="#4、设备驱动程序" class="headerlink" title="4、设备驱动程序"></a><strong>4、设备驱动程序</strong></h3><p>设备驱动程序是 Linux  内核的主要部分。和操作系统的其它部分类似，设备驱动程序运行在高特权级的处理器环境中，从而可以直接对硬件进行操作，但正因为如此，任何一个设备驱动程序的错误都可能导致操作系统的崩溃。设备驱动程序实际控制操作系统和硬件设备之间的交互。</p>
<p>设备驱动程序提供一组操作系统可理解的抽象接口完成和操作系统之间的交互，而与硬件相关的具体操作细节由设备驱动程序完成。一般而言，设备驱动程序和设备的控制芯片有关，例如，如果计算机硬盘是 SCSI  硬盘，则需要使用 SCSI  驱动程序，而不是 IDE 驱动程序。</p>
<h3 id="5、网络接口（NET）"><a href="#5、网络接口（NET）" class="headerlink" title="5、网络接口（NET）"></a><strong>5、网络接口（NET）</strong></h3><p>提供了对各种网络标准的存取和各种网络硬件的支持。网络接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。众所周知，TCP/IP  协议是 Internet  的标准协议，同时也是事实上的工业标准。</p>
<p>Linux  的网络实现支持 BSD 套接字，支持全部的TCP/IP协议。Linux内核的网络部分由BSD套接字、网络协议层和网络设备驱动程序组成。网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iblTYUnF9yPPAFqPibv6Siadtw5kYIvianGuggAAZcL0nicTqibicKG1MUJG8Nvic9BVDaXuJSlRZquoQJjNkNgglBRAxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>二、linux shell</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OKdYEbfJSc6gicBpKXLM0OehXMoaLEVciciaZtGq2EVOCnYxayTAq4iat0n7tpp67RLQyAwnJ704cic8UPyaYhQicRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。</p>
<p><strong>目前主要有下列版本的shell。</strong></p>
<p>1、Bourne Shell：是贝尔实验室开发的。<br>2、BASH：是GNU的Bourne Again Shell，是GNU操作系统上默认的shell,大部分linux的发行套件使用的都是这种shell。<br>3、Korn Shell：是对Bourne SHell的发展，在大部分内容上与Bourne Shell兼容。<br>4、C Shell：是SUN公司Shell的BSD版本。</p>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iblTYUnF9yPPAFqPibv6Siadtw5kYIvianGuggAAZcL0nicTqibicKG1MUJG8Nvic9BVDaXuJSlRZquoQJjNkNgglBRAxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>三、****linux 文件系统</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OKdYEbfJSc6gicBpKXLM0OehXMoaLEVciciaZtGq2EVOCnYxayTAq4iat0n7tpp67RLQyAwnJ704cic8UPyaYhQicRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、 EXT3、 FAT、 FAT32、 VFAT和ISO9660。</p>
<h3 id="3-1-文件类型"><a href="#3-1-文件类型" class="headerlink" title="3.1 文件类型"></a><strong>3.1 文件类型</strong></h3><p>Linux下面的文件类型主要有：</p>
<p><strong>1) 普通文件：</strong>C语言元代码、SHELL脚本、二进制的可执行文件等。分为纯文本和二进制。<br><strong>2) 目录文件：</strong>目录，存储文件的唯一地方。<br><strong>3) 链接文件：</strong>指向同一个文件或目录的的文件。<br><strong>4) 设备文件：</strong>与系统外设相关的，通常在/dev下面。分为块设备和字符设备。</p>
<p><strong>5）管道(FIFO)文件 :</strong> 提供进程建通信的一种方式<br><strong>6）套接字(socket) 文件：</strong> 该文件类型与网络通信有关</p>
<p>可以通过ls –l, file, stat几个命令来查看文件的类型等相关信息。</p>
<h3 id="3-2-Linux目录"><a href="#3-2-Linux目录" class="headerlink" title="3.2  Linux目录"></a><strong>3.2  Linux目录</strong></h3><p>文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上。</p>
<p>目录提供了管理文件的一个方便而有效的途径。</p>
<p>Linux使用标准的目录结构，在安装的时候，安装程序就已经为用户创建了文件系统和完整而固定的目录组成形式，并指定了每个目录的作用和其中的文件类型。</p>
<p>完整的目录树可划分为小的部分，这些小部分又可以单独存放在自己的磁盘或分区上。这样，相对稳定的部分和经常变化的部分可单独存放在不同的分区中，从而方便备份或系统管理。目录树的主要部分有 root、/usr、/var、/home  等（图2） 。这样的布局可方便在 Linux 计算机之间共享文件系统的某些部分。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lEs5lJ5fZtO0ibWSopT8HNxrGISkXhdWxKwicwodAHXdLluic9ibuQszIGOA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图2</p>
<p>Linux采用的是树型结构。最上层是根目录，其他的所有目录都是从根目录出发而生成的。</p>
<p>微软的DOS和windows也是采用树型结构，但是在DOS和 windows中这样的树型结构的根是磁盘分区的盘符，有几个分区就有几个树型结构，他们之间的关系是并列的。最顶部的是不同的磁盘（分区），如：C，D，E，F等。</p>
<p>但是在linux中，无论操作系统管理几个磁盘分区，这样的目录树只有一个。从结构上讲，各个磁盘分区上的树型目录不一定是并列的。</p>
<h3 id="3-3-Linux磁盘分区"><a href="#3-3-Linux磁盘分区" class="headerlink" title="3.3 Linux磁盘分区"></a><strong>3.3 Linux磁盘分区</strong></h3><h4 id="一、主分区，扩展分区和逻辑分区："><a href="#一、主分区，扩展分区和逻辑分区：" class="headerlink" title="一、主分区，扩展分区和逻辑分区："></a><strong>一、主分区，扩展分区和逻辑分区：</strong></h4><p>linux分区不同于windows,硬盘和硬盘分区在Linux都表示为设备.</p>
<p><strong>硬盘分区一共有三种：</strong>主分区，扩展分区和逻辑分区。</p>
<p>硬盘的分区主要分为主分区(Primary Partion)和扩展分区(Extension Partion)两种，主分区和扩展分区的数目之和不能大于四个。</p>
<blockquote>
<p><strong>主分区(Primary Partion)：</strong>可以马上被使用但不能再分区。</p>
<p><strong>扩展分区(Extension Partion)：</strong>必须再进行分区后才能使用，也就是说它必须还要进行二次分区。</p>
<p><strong>逻辑分区（(Logical Partion)）：</strong>由扩展分区建立起来的分区。逻辑分区没有数量上限制。</p>
</blockquote>
<p>扩展分区只不过是逻辑分区的“容器”，实际上只有主分区和逻辑分区进行数据存储。</p>
<h4 id="二、Linux下硬盘分区的标识"><a href="#二、Linux下硬盘分区的标识" class="headerlink" title="二、Linux下硬盘分区的标识"></a><strong>二、Linux下硬盘分区的标识</strong></h4><p>硬盘分区的标识一般使用/dev/hd[a-z]X或者/dev/sd[a-z]X来标识，其中[a-z]代表硬盘号，X代表硬盘内的分区号。</p>
<p>整块硬盘分区的块号标识:Linux下用hda、hdb、sda、sdb 等来标识不同的硬盘;</p>
<p><strong>其中：</strong></p>
<p><strong>IDE接口硬盘：</strong>表示为/dev/hda1、/dev/hdb …；</p>
<p>SCSI 接口的硬盘、SATA接口的硬盘表示为/dev/sda、/dev/sdb … … ；</p>
<p><strong>硬盘内的分区：</strong>如果X的值是1到4,表示硬盘的主分区（包含扩展分区）；逻辑分区从是从5开始的，比如/dev/hda5肯定是逻辑分区了；</p>
<p><strong>例如：</strong></p>
<p>用hda1、hda2、 hda5、hda6 来标识不同的分区。其中，字母a 代表第一块硬盘，b代表第二块硬盘，依次类推。而数字1 代表一块硬盘的第一个分区、2 代表第二个分区，依次类推。1 到4 对应的是主分区(Primary Partition)或扩展分区(Extension Partition)。从5开始，对应的都是硬盘的逻辑分区(Logical Partition)。一块硬盘即使只有一个主分区，逻辑分区也是从5开始编号的，这点应特别注意。</p>
<p><strong>总结：</strong>一个硬盘分区首先要大确认在哪个硬盘，然后再确认它所在硬盘内的哪个分区。</p>
<p>对于/dev/hda 类似的表示方法，也并不寞生吧；我们在Linux通过fdisk -l 就可以查到硬盘是/dev/hda还是/dev/hdb；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  　[root@localhost ~]# fdisk -l      　　</span><br><span class="line">   　Disk &#x2F;dev&#x2F;hda: 80.0 GB, 80026361856 bytes   　　255 heads, 63 sectors&#x2F;track, 9729 cylinders   　　Units &#x3D; cylinders of 16065 * 512 &#x3D; 8225280 bytes   　　 Device Boot Start End Blocks Id System   　　&#x2F;dev&#x2F;hda1 * 1 970 7791493+ 7 HPFS&#x2F;NTFS   　　&#x2F;dev&#x2F;hda2 971 9729 70356667+ 5 Extended   　　&#x2F;dev&#x2F;hda5 971 2915 15623181 b W95 FAT32   　　&#x2F;dev&#x2F;hda6 2916 4131 9767488+ 83 linux   　　&#x2F;dev&#x2F;hda7 4132 5590 11719386 83 linux   　　&#x2F;dev&#x2F;hda8 5591 6806 9767488+ 83 linux   　　&#x2F;dev&#x2F;hda9 6807 9657 22900626 83 linux   　　&#x2F;dev&#x2F;hda10 9658 9729 578308+ 82 linux swap &#x2F; Solaris</span><br></pre></td></tr></table></figure>

<p>请注意第一行， Disk /dev/hda: 80.0 GB, 80026361856 bytes ，这个就是表示机器中只有一个硬盘设备/dev/hda ，体积大小为 80.0G；下面的就是硬盘的分区，每个分区都有详细的信息，在这里不详细说了；</p>
<p><strong>Linux下磁盘分区和目录的关系如下：</strong></p>
<p>– 任何一个分区都必须挂载到某个目录上。</p>
<p>– 目录是逻辑上的区分。分区是物理上的区分。</p>
<p>– 磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作。</p>
<p>– 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。</p>
<h3 id="3-4-linux主要目录的功用。"><a href="#3-4-linux主要目录的功用。" class="headerlink" title="3.4 linux主要目录的功用。"></a><strong>3.4 linux主要目录的功用。</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin 二进制可执行命令   　　</span><br><span class="line"> &#x2F;dev 设备特殊文件   　　&#x2F;etc 系统管理和配置文件   　　&#x2F;etc&#x2F;rc.d 启动的配置文件和脚本   　　&#x2F;home 用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以用~user表示   　　&#x2F;lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件   　　&#x2F;sbin 系统管理命令，这里存放的是系统管理员使用的管理程序   　　&#x2F;tmp 公用的临时文件存储点   　　&#x2F;root 系统管理员的主目录（呵呵，特权阶级）   　　&#x2F;mnt 系统提供这个目录是让用户临时挂载其他的文件系统。  　　&#x2F;lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里   　　&#x2F;proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。  　　&#x2F;var 某些大文件的溢出区，比方说各种服务的日志文件   　　&#x2F;usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：  　　      &#x2F;usr&#x2F;X11R6 存放X window的目录   　　      &#x2F;usr&#x2F;bin 众多的应用程序   　　      &#x2F;usr&#x2F;sbin 超级用户的一些管理程序   　　      &#x2F;usr&#x2F;doc linux文档   　　      &#x2F;usr&#x2F;include linux下开发和编译应用程序所需要的头文件   　　      &#x2F;usr&#x2F;lib 常用的动态链接库和软件包的配置文件   　　      &#x2F;usr&#x2F;man 帮助文档   　　      &#x2F;usr&#x2F;src 源代码，linux内核的源代码就放在&#x2F;usr&#x2F;src&#x2F;linux里   　　      &#x2F;usr&#x2F;local&#x2F;bin 本地增加的命令   　　      &#x2F;usr&#x2F;local&#x2F;lib 本地增加的库</span><br></pre></td></tr></table></figure>

<h3 id="3-5-linux文件系统"><a href="#3-5-linux文件系统" class="headerlink" title="3.5  linux文件系统"></a><strong>3.5  linux文件系统</strong></h3><p>文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。</p>
<p><strong>1、文件系统类型：</strong></p>
<h4 id="ext2-：-早期linux中常用的文件系统-ext3-：-ext2的升级版，带日志功能-RAMFS-：-内存文件系统，速度很快-NFS-：-网络文件系统，由SUN发明，主要用于远程文件共享-MS-DOS-：-MS-DOS文件系统-VFAT-：-Windows-95-98-操作系统采用的文件系统-FAT-：-Windows-XP-操作系统采用的文件系统-NTFS：-Windows-NT-XP-操作系统采用的文件系统-HPFS-：-OS-2-操作系统采用的文件系统-PROC-虚拟的进程文件系统-ISO9660-：-大部分光盘所采用的文件系统-ufsSun-OS-所采用的文件系统-NCPFS-：-Novell-服务器所采用的文件系统-SMBFS-：-Samba-的共享文件系统-XFS-：-由SGI开发的先进的日志文件系统，支持超大容量文件-JFS-：IBM的AIX使用的日志文件系统-ReiserFS-基于平衡树结构的文件系统-udf-可擦写的数据光盘文件系统"><a href="#ext2-：-早期linux中常用的文件系统-ext3-：-ext2的升级版，带日志功能-RAMFS-：-内存文件系统，速度很快-NFS-：-网络文件系统，由SUN发明，主要用于远程文件共享-MS-DOS-：-MS-DOS文件系统-VFAT-：-Windows-95-98-操作系统采用的文件系统-FAT-：-Windows-XP-操作系统采用的文件系统-NTFS：-Windows-NT-XP-操作系统采用的文件系统-HPFS-：-OS-2-操作系统采用的文件系统-PROC-虚拟的进程文件系统-ISO9660-：-大部分光盘所采用的文件系统-ufsSun-OS-所采用的文件系统-NCPFS-：-Novell-服务器所采用的文件系统-SMBFS-：-Samba-的共享文件系统-XFS-：-由SGI开发的先进的日志文件系统，支持超大容量文件-JFS-：IBM的AIX使用的日志文件系统-ReiserFS-基于平衡树结构的文件系统-udf-可擦写的数据光盘文件系统" class="headerlink" title="ext2 ： 早期linux中常用的文件系统 ext3 ： ext2的升级版，带日志功能 RAMFS ： 内存文件系统，速度很快 NFS ： 网络文件系统，由SUN发明，主要用于远程文件共享 MS-DOS ： MS-DOS文件系统 VFAT ： Windows 95/98 操作系统采用的文件系统 FAT ： Windows XP 操作系统采用的文件系统 NTFS： Windows NT/XP 操作系统采用的文件系统 HPFS ： OS/2 操作系统采用的文件系统 PROC : 虚拟的进程文件系统 ISO9660 ： 大部分光盘所采用的文件系统 ufsSun : OS 所采用的文件系统 NCPFS ： Novell 服务器所采用的文件系统 SMBFS ： Samba 的共享文件系统 XFS ： 由SGI开发的先进的日志文件系统，支持超大容量文件 JFS ：IBM的AIX使用的日志文件系统 ReiserFS : 基于平衡树结构的文件系统 udf: 可擦写的数据光盘文件系统"></a><strong>ext2 ：</strong> 早期linux中常用的文件系统 <strong>ext3 ：</strong> ext2的升级版，带日志功能 <strong>RAMFS ：</strong> 内存文件系统，速度很快 <strong>NFS ：</strong> 网络文件系统，由SUN发明，主要用于远程文件共享 <strong>MS-DOS ：</strong> MS-DOS文件系统 <strong>VFAT ：</strong> Windows 95/98 操作系统采用的文件系统 <strong>FAT ：</strong> Windows XP 操作系统采用的文件系统 <strong>NTFS：</strong> Windows NT/XP 操作系统采用的文件系统 <strong>HPFS ：</strong> OS/2 操作系统采用的文件系统 <strong>PROC :</strong> 虚拟的进程文件系统 <strong>ISO9660 ：</strong> 大部分光盘所采用的文件系统 <strong>ufsSun :</strong> OS 所采用的文件系统 <strong>NCPFS ：</strong> Novell 服务器所采用的文件系统 <strong>SMBFS ：</strong> Samba 的共享文件系统 <strong>XFS ：</strong> 由SGI开发的先进的日志文件系统，支持超大容量文件 <strong>JFS ：</strong>IBM的AIX使用的日志文件系统 ReiserFS : 基于平衡树结构的文件系统 udf: 可擦写的数据光盘文件系统</h4><h4 id="2、文件系统特性："><a href="#2、文件系统特性：" class="headerlink" title="2、文件系统特性："></a><strong>2、文件系统特性：</strong></h4><p>磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个分区。格式化的目的是能使操作系统可以使用的文件系统格式（即我们上面提到文件系统类型）.</p>
<p>每种操作系统能够使用的文件系统并不相同. 如windows 98 以前的微软操作系统主要利用的文件系统是 FAT (或 FAT16)，windows 2000 以后的版本有所谓的 NTFS 文件系统，至于 Linux 的正统文件系统则为 Ext2 (Linux second extended file system, ext2fs)这一个。此外，在默认的情况下，windows 操作系统是不会认识 Linux 的 Ext2 的。</p>
<p>传统的磁盘与文件系统之应用中，一个分区就是只能够被格式化成为一个文件系统，所以我们可以说一个 filesystem 就是一个 partition。但是由于新技术的利用，例如我们常听到的LVM与软件磁盘阵列(software raid)， 这些技术可以将一个分区格式化为多个文件系统(例如LVM)，也能够将多个分区合成一个文件系统(LVM, RAID)！所以说，目前我们在格式化时已经不再说成针对 partition 来格式化了， 通常我们可以称呼一个可被挂载的数据为一个文件系统而不是一个分区喔！</p>
<p>那么文件系统是如何运行的呢？这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外， 通常含有非常多的属性，例如 Linux 操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中。另外，还有一个超级区块 (superblock) 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。</p>
<p>对于一个磁盘分区来说，在被指定为相应的文件系统后，整个分区被分为 1024，2048 和 4096 字节大小的块。根据块使用的不同，可分为：</p>
<p>1、超级块(Superblock): 这是整个文件系统的第一块空间。包括整个文件系统的基本信息，如块大小，inode/block的总量、使用量、剩余量，指向空间 inode 和数据块的指针等相关信息。</p>
<p>2、inode块(文件索引节点) : 文件系统索引,记录文件的属性。它是文件系统的最基本单元，是文件系统连接任何子目录、任何文件的桥梁。每个子目录和文件只有唯一的一个 inode 块。它包含了文件系统中文件的基本属性(文件的长度、创建及修改时间、权限、所属关系)、存放数据的位置等相关信息. 在 Linux 下可以通过 “ls -li” 命令查看文件的 inode 信息。硬连接和源文件具有相同的 inode 。</p>
<p>3、数据块(Block) :实际记录文件的内容，若文件太大时，会占用多个 block。为了提高目录访问效率，Linux 还提供了表达路径与 inode 对应关系的 dentry 结构。它描述了路径信息并连接到节点 inode，它包括各种目录信息，还指向了 inode 和超级块。</p>
<p>就像一本书有封面、目录和正文一样。在文件系统中，超级块就相当于封面，从封面可以得知这本书的基本信息；inode 块相当于目录，从目录可以得知各章节内容的位置；而数据块则相当于书的正文，记录着具体内容。</p>
<p>Linux正统的文件系统(如ext2、3等)将硬盘分区时会划分出超级块、inode Table区块和data block数据区域。一个文件由一个超级块、inode和数据区域块组成。Inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lEG57fUxgGiagsu2Ty4hUoPaKBu81GmhwLPJAc4nAc6icE8VfOZdgZdDpA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>ext2文件系统示意图</p>
<p>我们将 inode 与 block 区块用图解来说明一下，如下图所示，文件系统先格式化出 inode 与 block 的区块，假设某一个文件的属性与权限数据是放置到 inode 4 号(下图较小方格内)，而这个 inode 记录了文件数据的实际放置点为 2, 7, 13, 15 这四个 block 号码，此时我们的操作系统就能够据此来排列磁盘的阅读顺序，可以一口气将四个 block 内容读出来！那么数据的读取就如同下图中的箭头所指定的模样了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lExkXOIu9JicNV1EibibQSEcLezMzcicbQZ2d6mBa0NefDIKXth0rUGouuEg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图 inode/block 数据存取示意图</p>
<p>这种数据存取的方法我们称为索引式文件系统(indexed allocation)。那有没有其他的惯用文件系统可以比较一下啊？有的，那就是我们惯用的闪盘(闪存)，闪盘使用的文件系统一般为 FAT 格式。FAT 这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中， 其读取方式有点像下图所示:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lEicTYERpYiaUcHTbIntEic8A1lgZXX3YiaEpI8L5nBAv8ozsicHSv5xDly2g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图、FAT文件系统数据存取示意图</p>
<p>上图中我们假设文件的数据依序写入1-&gt;7-&gt;4-&gt;15号这四个 block 号码中， 但这个文件系统没有办法一口气就知道四个 block 的号码，他得要一个一个的将 block 读出后，才会知道下一个 block 在何处。如果同一个文件数据写入的 block 分散的太过厉害时，则我们的磁盘读取头将无法在磁盘转一圈就读到所有的数据， 因此磁盘就会多转好几圈才能完整的读取到这个文件的内容！</p>
<p>常常会听到所谓的“碎片整理”吧？ 需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能将会变的很差所致。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整在一起，这样数据的读取会比较容易啊！ 想当然尔，FAT 的文件系统需要经常的碎片整理一下，那么 Ext2 是否需要磁盘重整呢？</p>
<p>由于 Ext2 是索引式文件系统，基本上不太需要常常进行碎片整理的。但是如果文件系统使用太久， 常常删除/编辑/新增文件时，那么还是可能会造成文件数据太过于离散的问题，此时或许会需要进行重整一下的。不过，老实说，鸟哥倒是没有在 Linux 操作系统上面进行过 Ext2/Ext3 文件系统的碎片整理说！似乎不太需要啦！^_^</p>
<p>可以用ln命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：</p>
<p>硬连接：原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；</p>
<p>由于删除文件要在同一个索引节点属于唯一的连接时才能成功，因此可以防止不必要的误删除。</p>
<p>符号连接：用ln -s命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。</p>
<p>可以删除原有的文件而保存连接文件，没有防止误删除功能。</p>
<p>这一段的的内容过于抽象，又是节点又是数组的，我已经尽量通俗再通俗了，又不好加例子作演示。大家如果还是云里雾里的话，我也没有什么办法了，只有先记住，日后在实际应用中慢慢体会、理解了。这也是我学习的一个方法吧。</p>
<h3 id="3-6-文件系统在内核中的表示"><a href="#3-6-文件系统在内核中的表示" class="headerlink" title="3.6 文件系统在内核中的表示"></a><strong>3.6 文件系统在内核中的表示</strong></h3><p><strong>内核数据结构</strong></p>
<p>Linux内核的VFS子系统可以图示如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lE0SomiaP6IeXYX7pyspBiaMgmHCf0lOhM5PKm0PtBbecPfZd190KG5CiaA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>文件与IO: 每个进程在PCB（Process Control Block）中都保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，现在我们明确一下：已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体。</p>
<p>在file结构体中维护File Status Flag（file结构体的成员f_flags）和当前读写位置（file结构体的成员f_pos）。在上图中，进程1和进程2都打开同一文件，但是对应不同的file结构体，因此可以有不同的File Status Flag和读写位置。file结构体中比较重要的成员还有f_count，表示引用计数（Reference Count），后面我们会讲到，dup、fork等系统调用会导致多个文件描述符指向同一个file结构体，例如有fd1和fd2都引用同一个file结构体，那么它的引用计数就是2，当close(fd1)时并不会释放file结构体，而只是把引用计数减到1，如果再close(fd2)，引用计数就会减到0同时释放file结构体，这才真的关闭了文件。</p>
<p>每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。</p>
<p>file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说，read、write等文件操作的步骤和方法应该是一样的，调用的函数应该是相同的，所以图中的三个打开文件的file结构体指向同一个file_operations结构体。如果打开一个字符设备文件，那么它的read、write操作肯定和常规文件不一样，不是读写磁盘的数据块而是读写硬件设备，所以file结构体应该指向不同的file_operations结构体，其中的各种文件操作函数由该设备的驱动程序实现。</p>
<p>每个file结构体都有一个指向dentry结构体的指针，“dentry”是directory entry（目录项）的缩写。我们传给open、stat等函数的参数的是一个路径，例如/home/akaedu/a，需要根据路径找到文件的inode。为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache，其中每个节点是一个dentry结构体，只要沿着路径各部分的dentry搜索即可，从根目录/找到home目录，然后找到akaedu目录，然后找到文件a。dentry cache只保存最近访问过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。</p>
<p>每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示/home/akaedu/a和/home/akaedu/b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。每个inode结构体都有一个指向inode_operations结构体的指针，后者也是一组函数指针指向一些完成文件目录操作的内核函数。</p>
<p>和file_operations不同，inode_operations所指向的不是针对某一个文件进行操作的函数，而是影响文件和目录布局的函数，例如添加删除文件和目录、跟踪符号链接等等，属于同一文件系统的各inode结构体可以指向同一个inode_operations结构体。</p>
<p>inode结构体有一个指向super_block结构体的指针。super_block结构体保存着从磁盘分区的超级块读上来的信息，例如文件系统类型、块大小等。super_block结构体的s_root成员是一个指向dentry的指针，表示这个文件系统的根目录被mount到哪里，在上图的例子中这个分区被mount到/home目录下。</p>
<p>file、dentry、inode、super_block这几个结构体组成了VFS的核心概念。对于ext2文件系统来说，在磁盘存储布局上也有inode和超级块的概念，所以很容易和VFS中的概念建立对应关系。而另外一些文件系统格式来自非UNIX系统（例如Windows的FAT32、NTFS），可能没有inode或超级块这样的概念，但为了能mount到Linux系统，也只好在驱动程序中硬凑一下，在Linux下看FAT32和NTFS分区会发现权限位是错的，所有文件都是rwxrwxrwx，因为它们本来就没有inode和权限位的概念，这是硬凑出来的。</p>
<h3 id="3-6-挂载文件系统"><a href="#3-6-挂载文件系统" class="headerlink" title="3.6  挂载文件系统"></a><strong>3.6  挂载文件系统</strong></h3><p>linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。这里所说的“按一定方式”就是指的挂载。</p>
<p>将一个文件系统的顶层目录挂到另一个文件系统的子目录上，使它们成为一个整体，称为挂载。把该子目录称为挂载点.</p>
<p>例如要读取硬盘中的一个格式化好的分区、光盘或软件等设备时，必须先把这些设备对应到某个目录上，而这个目录就称为“挂载点（mount point）”，这样才可以读取这些设备。挂载后将物理分区细节屏蔽掉，用户只有统一的逻辑概念。所有的东西都是文件。</p>
<p><strong>注意：</strong>1、挂载点必须是一个目录。</p>
<p>2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。</p>
<p>对于其他操作系统建立的文件系统的挂载也是这样。但是需要理解的是：光盘、软盘、其他操作系统使用的文件系统的格式与linux使用的文件系统格式是不一样的。光盘是ISO9660；软盘是fat16或ext2；windows NT是fat16、NTFS；windows98是fat16、fat32；windows2000和windowsXP是fat16、fat32、 NTFS。挂载前要了解linux是否支持所要挂载的文件系统格式。</p>
<p>挂载时使用mount命令，其格式：mount [-参数] [设备名称] [挂载点]<br>其中常用的参数有</p>
<p>-t 指定设备的文件系统类型（什么提到的文件类型）<br>-o 指定挂载文件系统时的选项。有些也可用在/etc/fstab中。常用的有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">codepage&#x3D;XXX 代码页  </span><br><span class="line">iocharset&#x3D;XXX 字符集   ro 以只读方式挂载   rw 以读写方式挂载   nouser 使一般用户无法挂载   user 可以让一般用户挂载设备</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<p><strong>1、挂载windows的文件系统：</strong></p>
<p>1）首先我们使用sudo fdisk -l查看挂载的设备，例如最下面有：/dev/hda5<br>2）mkdir创建一个目录，这里的目录是作为挂在目录，就是你要把E盘挂到这个目录下：mk /mnt/winc<br>3）windows和linux使用的不是一个文件系统，一般情况下linux不挂载windows文件系统，所以要你手动mount：<br># mount -t vfat /dev/hda5 /mnt/winc  （ -t vfat指出这里的文件系统fat32）<br>现在就可以进入/mnt/winc等目录读写这些文件了。</p>
<p><strong>2、挂载光盘：# mk /mnt/cdrom</strong></p>
<p># mount -t iso9660 /dev/cdrom /mnt/cdrom (关盘的名字一般都是cdrom，这条命令一般都通用)</p>
<p>3、虚拟机共享文件夹：例如在VirtualBox下，主机是Windows，Ubuntu是Guest。共分三步：</p>
<p>1). 首先要安装虚拟电脑工具包：在VirtualBox的菜单里选择”设备”-&gt;”安装虚拟电脑工具包”，你会发现在Ubuntu桌面上多出一个光盘图标，这张光盘默认被自动加载到了文件夹/media/cdom0，而且/cdrom自动指向这个文件夹。默认设置下文件管理器会自动打开这张光盘，可以看到里面有个”VBoxLinuxAdditions.run”文件。打开一个命令行终端，依次输入”cd /cdrom”和”sudo sh ./VBoxLinuxAdditions.run”，不含双引号，开始安装工具包。安装完毕，会用英文提示要重启Ubuntu，建议立刻重启。重启后，比较明显的变化是鼠标是共享模式，并且剪贴板也和Windows共享了。如果有这些变化，说明虚拟电脑工具包已经装成功。</p>
<p>2). 下一步设置共享文件夹。</p>
<p>在共享文件夹设置窗口中，单击右侧的”添加一个共享文件夹”，路径选择你想要共享的Windows文件夹，共享名任取一个自己喜欢的，比如”myshare”，选项read-only是指是否只允许ubuntu读这个文件夹，请根据需要选择这个选项。</p>
<p>3). 在ubuntu下挂载这个共享文件夹:sudo mount -t vboxsf myshare /media/share<br>其中”myshare”是之前取的共享文件夹的名字，”/media/share”是要挂载到的目标文件.</p>
<h3 id="3-7-自动挂载windows分区"><a href="#3-7-自动挂载windows分区" class="headerlink" title="3.7  自动挂载windows分区"></a><strong>3.7  自动挂载windows分区</strong></h3><p>每次开机访问windows分区都要运行mount命令显然太烦琐，为什么访问其他的linux分区不用使用mount命令呢？</p>
<p>其实，每次开机时，linux自动将需要挂载的linux分区挂载上了。那么我们是不是可以设定让linux在启动的时候也挂载我们希望挂载的分区，如windows分区，以实现文件系统的自动挂载呢？</p>
<p>这是完全可以的。在/etc目录下有个fstab文件，它里面列出了linux开机时自动挂载的文件系统的列表。我的/etc/fstab文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 　&#x2F;dev&#x2F;hda2 &#x2F; ext3 defaults 1 1      　　</span><br><span class="line">  　&#x2F;dev&#x2F;hda1 &#x2F;boot ext3 defaults 1 2      　　</span><br><span class="line">  　none &#x2F;dev&#x2F;pts devpts gid&#x3D;5,mode&#x3D;620 0 0      　　</span><br><span class="line">  　none &#x2F;proc proc defaults 0 0      　　</span><br><span class="line">  　none &#x2F;dev&#x2F;shm tmpfs defaults 0 0      　　</span><br><span class="line">  　&#x2F;dev&#x2F;hda3 swap swap defaults 0 0      　　</span><br><span class="line">  　&#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom iso9660 noauto,codepage&#x3D;936,iocharset&#x3D;gb2312 0 0      　　</span><br><span class="line">  　&#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy auto noauto,owner,kudzu 0 0      　　</span><br><span class="line">  　&#x2F;dev&#x2F;hdb1 &#x2F;mnt&#x2F;winc vfat defaults,codepage&#x3D;936,iocharset&#x3D;cp936 0 0      　　</span><br><span class="line">  　&#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;wind vfat defaults,codepage&#x3D;936,iocharset&#x3D;cp936 0 0</span><br></pre></td></tr></table></figure>

<p>在/etc/fstab文件里，第一列是挂载的文件系统的设备名，第二列是挂载点，第三列是挂载的文件系统类型，第四列是挂载的选项，选项间用逗号分隔。第五六列不知道是什么意思，还望高手指点。</p>
<p>在最后两行是我手工添加的windows下的C；D盘，加了codepage=936和iocharset=cp936参数以支持中文文件名。参数defaults实际上包含了一组默认参数：</p>
<p>rw 以可读写模式挂载<br>suid 开启用户ID和群组ID设置位<br>dev 可解读文件系统上的字符或区块设备<br>exec 可执行二进制文件<br>auto 自动挂载<br>nouser 使一般用户无法挂载<br>async 以非同步方式执行文件系统的输入输出操作</p>
<p>大家可以看到在这个列表里，光驱和软驱是不自动挂载的，参数设置为noauto。（如果你非要设成自动挂载，你要确保每次开机时你的光驱和软驱里都要有盘，呵呵。)</p>
<h3 id="3-8-软连接、硬链接"><a href="#3-8-软连接、硬链接" class="headerlink" title="3.8 .软连接、硬链接"></a><strong>3.8 .软连接、硬链接</strong></h3><p>可以用ln命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：</p>
<p>硬连接：是给文件一个副本，原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；</p>
<p>修改其中一个，与其连接的文件同时被修改。如果删除其中任意一个其余的文件将不受影响。</p>
<p>由于删除文件要在同一个索引节点属于唯一的连接时才能成功，因此可以防止不必要的误删除。</p>
<p>符号连接（软连接）：用ln -s命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。</p>
<p>当然删除这个连接，也不会影响到源文件，但对连接文件的使用、引用都是直接调用源文件的。</p>
<p>具体关系可以看下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lESwS1gbZe2qh6ZHTNxCZOUxJ0sfniaYcPpsJCicWdxOL44FibCvjAcwoDw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图5：软链接和硬链接</p>
<p>从图上可以看出硬链接和软链接的区别：</p>
<blockquote>
<p>1：硬链接原文件和新文件的inode编号一致。而软链接不一样。</p>
<p>2：对原文件删除，会导致软链接不可用，而硬链接不受影响。</p>
<p>3：对原文件的修改，软、硬链接文件内容也一样的修改，因为都是指向同一个文件内容的。</p>
</blockquote>
<h3 id="3-9-文件目录管理命令"><a href="#3-9-文件目录管理命令" class="headerlink" title="3.9.文件目录管理命令"></a><strong>3.9.文件目录管理命令</strong></h3><p>磁盘和文件空间 ：fdisk df du</p>
<p>文件目录与管理：cd pwd mkdir rmdir ls cp rm mv</p>
<p>查看文件内容 cat、tac、more、less、head 、tail</p>
<p>文件目录与权限 ：chmod chown chgrp umask</p>
<p>文件查找：which、whereis、locate、find、find</p>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iblTYUnF9yPPAFqPibv6Siadtw5kYIvianGuggAAZcL0nicTqibicKG1MUJG8Nvic9BVDaXuJSlRZquoQJjNkNgglBRAxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>四、linux 应用</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OKdYEbfJSc6gicBpKXLM0OehXMoaLEVciciaZtGq2EVOCnYxayTAq4iat0n7tpp67RLQyAwnJ704cic8UPyaYhQicRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>标准的Linux系统一般都有一套都有称为应用程序的程序集，它包括文本编辑器、编程语言、X Window、办公套件、Internet工具和数据库等。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iblTYUnF9yPPAFqPibv6Siadtw5kYIvianGuggAAZcL0nicTqibicKG1MUJG8Nvic9BVDaXuJSlRZquoQJjNkNgglBRAxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>五、linux内核参数优化</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OKdYEbfJSc6gicBpKXLM0OehXMoaLEVciciaZtGq2EVOCnYxayTAq4iat0n7tpp67RLQyAwnJ704cic8UPyaYhQicRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>内核参数是用户和系统内核之间交互的一个接口，通过这个接口，用户可以在系统运行的同时动态更新内核配置，而这些内核参数是通过Linux Proc文件系统存在的。因此，可以通过调整Proc文件系统达到优化Linux性能的目的。</p>
<h1 id="VMware安装centos"><a href="#VMware安装centos" class="headerlink" title="VMware安装centos"></a>VMware安装centos</h1><p><a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/">http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/</a></p>
<p>DVD是基本版本（推荐使用这个）</p>
<p>Everything是所有</p>
<p>minial是最小的。后面那个数字是大小。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/14.1.linux/" data-id="ckq1xbdv0006dpwwd2smsczhz" data-title="linux" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-20.测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/20.%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:42:18.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/20.%E6%B5%8B%E8%AF%95/">测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>测试</p>
<p>首先会根据需求文档编写测试用例，用于指导如何测试，以及那些输入条件预期得到什么结果（需求文档，测试用例文档）</p>
<p>\1. UI测试：这是最基础的测试步骤，主要是按照需求文档，点击页面，看各个页面是否正确打开，是否与需求一致</p>
<p>\2. 白盒测试：此项主要是开发人员的自测，因为此项需要知道代码内部的逻辑，对照需求文档测试各个条件分支是否如预期的执行</p>
<p>\3. 黑盒测试：主要是测试人员完成的，此项不需要知道程序代码的内部逻辑，只需要关注输入条件，得到的输出结果是否与需求文档和测试用例相符合</p>
<p>\4. 边界条件测试：主要是测试各种边界值的情况，比如，只能输入正数的场景，如果输入0、或者负数是否会有相关提示</p>
<p>\5. 兼容性测试：按照需求文档的要求，需要兼容的操作系统平台或者浏览器种类和版本，都需要测试</p>
<p>\6. 性能测试：此项主要是通过测试工具，编写测试脚本，录制测试步骤，让测试工具模拟大数据量，多用户并发的操作，看看系统是否能够应付得了</p>
<p>\7. 用户交付测试：这是最后一个测试步骤了，主要是用户按照业务场景来模拟测试了，测试通过之后，就可以交互试用了</p>
<p>灰度测试，就是在某项产品或应用正式发布前，选择特定人群试用，逐步扩大其试用者数量，以便及时发现和纠正其中的问题，由“灰”到“黑”</p>
<p>基本测试的时候注意：</p>
<p>\1. 正确数据</p>
<p>\2. 错误数据</p>
<p>\3. 边界数据</p>
<p>//写测试类的时候，注意测试类中只调用，不创建方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/20.%E6%B5%8B%E8%AF%95/" data-id="ckq1xbdrh0011pwwd24qf68oj" data-title="测试" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-13.1.mybatis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/13.1.mybatis/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:42:08.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/13.1.mybatis/">mybatis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>框架一般都是有配置文件的，看官网文档最好。</p>
<p>Mybatis的学习：<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p>
<p>一、简介</p>
<p>\1. 基础：JDBC/Mysql/java基础/Maven/Junit</p>
<p>\2. 本来是aoache的一个开源项目ibatis，现在存于github</p>
<p>MyBatis 是一款优秀的<em><strong>*持久层框架*</strong></em></p>
<p>它支持自定义 SQL、存储过程以及高级映射</p>
<p>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作</p>
<p>MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<p>\3. maven仓库下载/github下载</p>
<p>\4. 持久化</p>
<p>数据持久化：持久化就是将程序的数据在持久状态和瞬时状态转化的过程</p>
<p>内存：断电即失、价格昂贵，因为有一些对象不能丢掉，所以需要持久化。</p>
<p>持久化：数据库（JDBC）、io文件持久化</p>
<p>\5. 持久层</p>
<p>Dao层/Service层/Controller层</p>
<p>完成持久化工作的代码，层界限十分明显。</p>
<p>\6. MyBatis的存在意义：</p>
<p>方便，更容易上手，灵活</p>
<p>传统的JDBC代码太复杂，需要简化。Mybatis是一个框架，可以自动化生成</p>
<p>将数据存入到数据库中，sql和代码分离，提高了可维护性；提供映射标签，支持对象和数据库的orm字段关系对应；提供对象关系映射标签，支持对象关系组件维护；提供xml标签，支持编写sql。</p>
<p>二、写一个程序</p>
<p>思路：搭建环境–导入mybatis–编写代码–测试</p>
<p>1.mysql中创建数据库资源</p>
<p>2.idea中新建一个普通的maven项目</p>
<p>3.删除src目录（以后只需要在父工程下创建module就会继承父工程的所有maven依赖）</p>
<p>4.导入maven依赖：mysql/mybatis/junit</p>
<p>5.创建一个新的module。</p>
<p>（每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。有了 SqlSessionFactory，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。）</p>
<p>在新module下的resource下新建一个xml配置文件，在官网上找到相关的配置复制进去，environments中可以配置多个环境。配置的url可以连接到数据库中查找，？后可以添加相关的配置，&amp;需要用&amp;；转义。（中间不要加中文注释）    </p>
<p>也可以不使用 XML 构建 SqlSessionFactory</p>
<p>6.创建一个utils工具类（查看官方文档有具体方法）</p>
<p>静态初始化模块sqlSessionFactory，静态方法得到SqlSession</p>
<p>\7. 编写代码：</p>
<p>以前：实体类pojo/Dao接口/接口实现类</p>
<p>现在：接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件</p>
<p>\8. 测试：</p>
<p>可能存在的错误：</p>
<p>在MapperRegistry中，类型接口是未知的（每一个Mapper.xml都需要在Mybatis核心配置文件中注册，这里的路径是/  不能是.）</p>
<p>在maven的pom.xml中Build中配置resources，防止我们的资源导出失败的问题</p>
<p>绑定的接口错误：namespace中的包名要和Dao/Mapper接口中的名字一致（必须要用.  不能用/）</p>
<p>方法名不对：id就是对应namespace中的方法名</p>
<p>返回类型不对：resultType是sql语句执行的返回值</p>
<p>参数类型：parameterType</p>
<p>标签不要匹配错误</p>
<p>NullPointerException空指针异常是因为sqlSessionFactory搞了两个</p>
<p>输出的xml文件中存在乱码问题：设置为UTF-8</p>
<p>最后用junit测试</p>
<p>三、CRUD</p>
<p>#{} 相当于是占位符   全限定名 别名</p>
<p>增删改需要提交事务：sqlSession.commit();</p>
<p>参数为int可以不用写</p>
<p>当报错的时候，读错要从后往前读</p>
<p>万能的Map：如果实体类中的属性有很多个，或者数据库的表/字段/参数过多时，可能直接传对象的属性不现实。所以可以使用map随意制造参数，通过键值对来传递（相当于是再new一个map，然后put参数，参数值，调用时候直接传map。会自动获取map参数对应的而参数值）。</p>
<p>Map传递参数，直接再sql中取出key即可。parameterType=“map”</p>
<p>对象传递参数，直接再sql中取对象的属性即可。parameterType=“object”</p>
<p>只有一个基本类型参数的情况下，可以直接再sql中取到。</p>
<p>多个参数可以用map，也可以用注解。</p>
<p>模糊查询：拼接参数的时候，防止sql注入的问题</p>
<p>1.java代码执行的时候，#{value} 参数中传递通配符 %*%</p>
<p>2.在sql拼接中使用通配符“%”+#{value}+“%”</p>
<p>四、配置解析</p>
<p>1.核心配置文件</p>
<p>Mybatis-config.xml（官方建议取这个名字）</p>
<p>configuration（配置）</p>
<p><a href="#properties">properties（属性）</a></p>
<p><a href="#settings">settings（设置）</a></p>
<p><a href="#typeAliases">typeAliases（类型别名）</a></p>
<p><a href="#typeHandlers">typeHandlers（类型处理器）</a></p>
<p><a href="#objectFactory">objectFactory（对象工厂）</a></p>
<p><a href="#plugins">plugins（插件）</a></p>
<p><a href="#environments">environments（环境配置）</a></p>
<p>environment（环境变量）</p>
<p>T    ransactionManager（事务管理器）</p>
<p>dataSource（数据源）</p>
<p><a href="#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></p>
<p><a href="#mappers">mappers（映射器）</a></p>
<h3 id="sql语句的where问题"><a href="#sql语句的where问题" class="headerlink" title="sql语句的where问题"></a>sql语句的where问题</h3><p>where后面加&lt; if &gt;的标签：</p>
<p>​    如果if存在的话，会直接连and，导致出现 where and 的错误语句</p>
<p>​    如果if不存在的话，会直接多出来where，导致错误语句</p>
<p> 1.给where 后面加上1=1，以后的条件都可以正常and  </p>
<p> 2.mybatis 使用where 标签将所有的查询条件包括在内。<br>mybatis 就会将where标签后面第一个and 去掉（where只会去掉第一个多出来的and 或者  or）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/13.1.mybatis/" data-id="ckq1xbdrc000npwwd72qb1ixn" data-title="mybatis" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-12.1.spring" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/12.1.spring/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:42:00.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/12.1.spring/">spring</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在Spring4.x中增加了新的特性：如果类只提供了一个带参数的构造方法，则不需要对对其内部的属性写@Autowired注解，Spring会自动为你注入属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看spring的版本</span></span><br><span class="line">String springVersion = SpringVersion.getVersion();</span><br><span class="line">String springBootVersion = SpringBootVersion.getVersion();</span><br><span class="line">System.out.println(springVersion);</span><br><span class="line">System.out.println(springBootVersion);</span><br></pre></td></tr></table></figure>

<p>只要用了spring框架，肯定到处都是@Autowired。4.3之后的功能，如果只有一个构造方法，自动用这个构造方法注入配合lombok的@RequiredArgsConstructor使用体验很好：</p>
<p>我们平时开发中的bean大部分都不写构造函数，系统默认一个无参构造函数，这就符合这一条件。</p>
<p><img src="https://img-blog.csdnimg.cn/20191018160134977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA3Mjk3MA==,size_16,color_FFFFFF,t_70" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101816003785.png"></p>
<p>此时helloService已经注入了，但是有些人会说以前加个@Autowired就行了，现在还要加个构造方法，更麻烦了，这时可以使用lombok插件，类上加@AllArgsConstructor就行了。</p>
<p><img src="https://img-blog.csdnimg.cn/20191018160429867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA3Mjk3MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在编写代码的时候，使用@Autowired注解是，发现IDE报的一个警告，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190606170140759.jpg" alt="img"> </p>
<p>Spring Team recommends “Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies”.</p>
<p>翻译：</p>
<p>Spring建议”总是在您的bean中使用构造函数建立依赖注入。总是使用断言强制依赖”。</p>
<p>这段代码警告原来的写法是：</p>
<p>@Autowired<br>private EnterpriseDbService service;<br>建议后写成下面的样子：</p>
<p>private final EnterpriseDbService service;<br>@Autowired<br>public EnterpriseDbController(EnterpriseDbService service) {<br> this.service = service;<br>}<br>奇怪，为何会有这样的建议。</p>
<p>我们知道：@Autowired 可以对成员变量、方法以及构造函数进行注释。那么对成员变量和构造函数进行注释又有什么区别呢？</p>
<p>@Autowired注入bean，相当于在配置文件中配置bean，并且使用setter注入。而对构造函数进行注释，就相当于是使用构造函数进行依赖注入了吧。莫非是这两种注入方法的不同。</p>
<p>以下是：@Autowired和构造方法执行的顺序解析</p>
<p>先看一段代码，下面的代码能运行成功吗？</p>
<p>@Autowired<br>private User user;<br>private String school;<br>public UserAccountServiceImpl(){<br> this.school = user.getSchool();<br>}<br>答案是不能。</p>
<p>因为Java类会先执行构造方法，然后再给注解了@Autowired 的user注入值，所以在执行构造方法的时候，就会报错。</p>
<p>报错信息可能会像下面：</p>
<p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘…’ defined in file [….class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate […]: Constructor threw exception; nested exception is java.lang.NullPointerException<br>报错信息说：创建Bean时出错，出错原因是实例化bean失败，因为bean时构造方法出错，在构造方法里抛出了空指针异常。</p>
<p>解决办法是，使用构造器注入，如下：</p>
<p>private User user;<br>private String school;<br>@Autowired<br>public UserAccountServiceImpl(User user){<br> this.user = user;<br> this.school = user.getSchool();<br>}<br>可以看出，使用构造器注入的方法，可以明确成员变量的加载顺序。</p>
<p>PS：Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法–&gt;@Autowired</p>
<p>@Autowired和构造方法执行的顺序解析</p>
<p>先看一段代码，下面的代码能运行成功吗？</p>
<p> @Autowired<br>    private User user;<br>    private String school;</p>
<pre><code>public UserAccountServiceImpl()&#123;
    this.school = user.getSchool();
&#125;
</code></pre>
<p>答案是不能。因为Java类会先执行构造方法，然后再给注解了@Autowired 的user注入值，所以在执行构造方法的时候，就会报错。<br>报错信息可能会像下面：</p>
<p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘…’ defined in file [….class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate […]: Constructor threw exception; nested exception is java.lang.NullPointerException</p>
<p>报错信息说：创建Bean时出错，出错原因是实例化bean失败，因为bean时构造方法出错，在构造方法里抛出了空指针异常。</p>
<p>解决办法是，使用构造器注入，如下：</p>
<p> private User user;<br>    private String school;</p>
<pre><code>@Autowired
public UserAccountServiceImpl(User user)&#123;
    this.user = user;
    this.school = user.getSchool();
&#125;
</code></pre>
<p>那么最开始Spring建议，为何要将成员变量加上final类型呢？</p>
<p>网上有解释如下：spring配置默认的bean的scope是singleton，也就是启动后一直有。通过设置bean的scope属性为prototype来声明该对象为动态创建。但是，如果你的service本身是singleton，注入只执行一次。</p>
<p>@Autowired本身就是单例模式，只会在程序启动时执行一次，即使不定义final也不会初始化第二次，所以这个final是没有意义的吧。</p>
<p>可能是为了防止，在程序运行的时候，又执行了一遍构造函数；</p>
<p>或者是更容易让人理解的意思，加上final只会在程序启动的时候初始化一次，并且在程序运行的时候不会再改变。</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>踩到一个坑，有一个接口，在这个接口的实现类里，需要用到@Autowired注解，一时大意，没有在实现类上加上@Component注解，导致了Spring报错，找不到这个类</p>
<p>一旦使用关于Spring的注解出现在类里，例如我在实现类中用到了@Autowired注解，被注解的这个类是从Spring容器中取出来的，那调用的实现类也需要被Spring容器管理，加上@Component</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;conversionImpl&quot;)</span></span><br><span class="line"><span class="comment">//其实默认的spring中的Bean id 为 conversionImpl(首字母小写)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConversionImpl</span> <span class="keyword">implements</span> <span class="title">Conversion</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient redisClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>介绍</p>
<p>开发中难免会遇到这个这个注解@Component</p>
<p>@Controller 控制器（注入服务）<br> 用于标注控制层，相当于struts中的action层</p>
<p>@Service 服务（注入dao）<br> 用于标注服务层，主要用来进行业务的逻辑处理</p>
<p>@Repository（实现dao访问）<br> 用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件</p>
<p>@Component （把普通pojo实例化到spring容器中，相当于配置文件中的 ）</p>
<p>泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</p>
<h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type1">异常处理方式一. @ExceptionHandler</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type2">异常处理方式二. 实现HandlerExceptionResolver接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type3">异常处理方式三. @ControllerAdvice+@ExceptionHandler</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/12.1.spring/" data-id="ckq1xbdra000jpwwdgxajfhuo" data-title="spring" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-8.6.VUE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/8.6.VUE/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:41:51.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/8.6.VUE/">VUE</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="VUE简介"><a href="#VUE简介" class="headerlink" title="VUE简介"></a>VUE简介</h1><p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。</p>
<p>Vue 只关注视图层， 采用自底向上增量开发的设计。</p>
<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<h1 id="VUE安装"><a href="#VUE安装" class="headerlink" title="VUE安装"></a>VUE安装</h1><h2 id="1-独立版本"><a href="#1-独立版本" class="headerlink" title="1.独立版本"></a>1.独立版本</h2><p>我们可以在 Vue.js 的官网上直接下载最新版本, 并用 <code>&lt;script&gt;</code> 标签引入。</p>
<h2 id="2-使用-CDN-方法"><a href="#2-使用-CDN-方法" class="headerlink" title="2.使用 CDN 方法"></a>2.使用 CDN 方法</h2><p>以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p>
<ul>
<li><strong>Staticfile CDN（国内）</strong> : <a target="_blank" rel="noopener" href="https://cdn.staticfile.org/vue/3.0.5/vue.global.js">https://cdn.staticfile.org/vue/3.0.5/vue.global.js</a></li>
<li><strong>unpkg</strong>：<a target="_blank" rel="noopener" href="https://unpkg.com/vue@next">https://unpkg.com/vue@next</a>, 会保持和 npm 发布的最新的版本一致。</li>
<li><strong>cdnjs</strong> : <a target="_blank" rel="noopener" href="https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.5/vue.global.js">https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.5/vue.global.js</a></li>
</ul>
<h2 id="3-NPM-方法"><a href="#3-NPM-方法" class="headerlink" title="3.NPM 方法"></a>3.NPM 方法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br><span class="line">2.3.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">升级 npm</span></span><br><span class="line">cnpm install npm -g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级或安装 cnpm</span></span><br><span class="line">npm install cnpm -g</span><br></pre></td></tr></table></figure>

<p>在用 Vue.js 构建大型应用时推荐使用 cnpm 安装，cnpm 能很好地和 Webpack 或 Browserify 模块打包器配合使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 最新稳定版</span><br><span class="line">$ cnpm install vue@next</span><br></pre></td></tr></table></figure>

<p>命令行工具</p>
<p>Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">$ cnpm install -g @vue&#x2F;cli</span><br><span class="line"># 安装完后查看版本</span><br><span class="line">$ vue --version</span><br><span class="line">@vue&#x2F;cli 4.5.11</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>vue-cli 3.x 和 vue-cli 2.x 使用了相同的 vue 命令，如果你之前已经安装了 vue-cli 2.x，它会被替换为 Vue-cli 3.x。</p>
<p>安装 @vue/cli-int：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm i -g @vue&#x2F;cli-init</span><br></pre></td></tr></table></figure>





<p>node版本</p>
<p>npm版本</p>
<p>vue版本</p>
<p>vue-cli版本</p>
<p>前端版本会有不兼容问题</p>
<p><strong>注意：*</strong>Vue.js 不支持 IE8 及其以下 IE 版本。*</p>
<h1 id="VUE的文件"><a href="#VUE的文件" class="headerlink" title="VUE的文件"></a>VUE的文件</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">vue-cource // 项目名称</span><br><span class="line">    |__ node_modules // 项目中的node依赖包</span><br><span class="line">    |__ public // public文件夹放公共文件</span><br><span class="line">    |    |__ favicon.ico // 标签栏的小图标</span><br><span class="line">    |    |__ index.html // 模板文件，最后打包后的index.html模板就是这个文件</span><br><span class="line">    |    </span><br><span class="line">    |__ src // 项目主文件</span><br><span class="line">    |    |__ api // api文件夹，项目的接口js文件都可以写在这里</span><br><span class="line">    |    |__ assets // 静态资源（图片、字体图标文件）</span><br><span class="line">    |    |    |__ img // 图片文件夹</span><br><span class="line">    |    |    |__ font // 字体图标文件夹</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ components // 组件</span><br><span class="line">    |    |__ config // 项目的配置（全局变量js文件）</span><br><span class="line">    |    |    |__ index.js     </span><br><span class="line">    |    |</span><br><span class="line">    |    |__ directive // vue的自定义指令文件夹</span><br><span class="line">    |    |    |__ index.js     </span><br><span class="line">    |    |</span><br><span class="line">    |    |__ lib // 全局方法放在这里</span><br><span class="line">    |    |    |__ util.js // 与业务结合的工具方法</span><br><span class="line">    |    |    |__ tools.js // 与业务无关的工具方法(例如日期转换时间戳方法)</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ mock // 模拟数据文件夹</span><br><span class="line">    |    |    |__ index.js</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ router // 路由文件夹</span><br><span class="line">    |    |    |__ index.js // 路由配置文件</span><br><span class="line">    |    |    |__ router.js // 拆分出来的routes数组</span><br><span class="line">    |    |__ store // Vuex配置文件夹</span><br><span class="line">    |    |    |__ module          // 模块文件夹</span><br><span class="line">    |    |    |__ plugin          // Vuex插件文件夹</span><br><span class="line">    |    |    |__ actions.js      // 异步调用接口方法都写在这里</span><br><span class="line">    |    |    |__ getters.js      // Vuex的计算属性都写在这里</span><br><span class="line">    |    |    |__ index.js        // Vuex主要配置管理文件</span><br><span class="line">    |    |    |__ mutations.js    // Vuex中的修改state的方法，都写在这里</span><br><span class="line">    |    |    |__ state.js        // Vuex的变量文件夹</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ views // 页面都写在这个文件夹中</span><br><span class="line">    |    |__ App.vue // 基础组件。项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。</span><br><span class="line">    |    |__ main.js // 项目入口文件（项目引入全局插件都在这里引入）项目的核心文件</span><br><span class="line">    |    </span><br><span class="line">    |__ .browserslistrc // 浏览器兼容</span><br><span class="line">    |__ .editorconfig // 编译器配置文件</span><br><span class="line">    |__ .eslintrc.js // 配置ESlint规则文件</span><br><span class="line">    |__ .gitignore // git提交的忽略文件</span><br><span class="line">    |__ babel.config.js // babel的配置文件，babel可以将es6、es7等等装换成es5兼容的代码</span><br><span class="line">    |__ package-lock.json // 锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致</span><br><span class="line">    |__ package.json // 项目名称、项目版本、项目描述、项目运行的一些脚本（依赖）</span><br><span class="line">    |__ postcss.config.js // css自动补充一些兼容性代码的配置（-webkit-、-moz-、-ms-之类的）</span><br><span class="line">    |__ README.en.md // 英文版项目说明</span><br><span class="line">    |__ README.md // 中文版项目说明</span><br><span class="line">    |__ vue.config.js // 配置文件</span><br></pre></td></tr></table></figure>



<h3 id="src-config-index-js"><a href="#src-config-index-js" class="headerlink" title="src/config/index.js"></a><strong>src/config/index.js</strong></h3><p><strong>当前项目的配置</strong></p>
<p><strong>config/index.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用 <strong>ES6</strong> 的 <strong>模块</strong> 导出一个对象，如果有 <strong>全局变量</strong> 都可以写在这里，在需要用到的地方直接这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  config  from  &#39;@&#x2F;config&#39;  &#x2F;&#x2F; nodejs就会自动找到他下面的index.js文件</span><br></pre></td></tr></table></figure>

<p>或者这样也可以找到这个 <strong>index</strong> 文件，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  config  from  &#39;@&#x2F;config&#x2F;index&#39; </span><br></pre></td></tr></table></figure>



<h3 id="src-router"><a href="#src-router" class="headerlink" title="src/router"></a>src/router</h3><p>分为<strong>正常路由结构</strong> 和 <strong>封装好的路由结构</strong></p>
<p><strong>正常路由</strong>：创建项目初始化路由 会在 src文件夹 下生成一个 router.js 文件。</p>
<p><strong>router.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import  Home  from  &#39;.&#x2F;views&#x2F;Home&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;,</span><br><span class="line">    name: &#39;home&#39;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;about&#39;,</span><br><span class="line">    name: &#39;about&#39;,</span><br><span class="line">    &#x2F;&#x2F; route level code-splitting</span><br><span class="line">    &#x2F;&#x2F; this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    &#x2F;&#x2F; which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;.&#x2F;views&#x2F;About.vue&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种只是 <strong>简单的路由（搭建项目初始化自动生成的路由文件）</strong> ，如果以后 <strong>复杂</strong> 起来会<strong>难以维护</strong>。</p>
<p><strong>封装路由</strong></p>
<ol>
<li>在 <strong>src目录</strong> 下创建一个 <strong>router文件夹</strong> ，这里的思想是把 <strong>routes数组</strong> 拆分成一个 <strong>单独的js文件</strong>，这样看着简洁也<strong>方便维护</strong>。</li>
</ol>
<p><img src="https://img.kancloud.cn/76/ee/76ee106ff5e570f4235eba358b6cbb6c_348x87.png" alt="img"></p>
<ol>
<li><strong>router文件夹</strong></li>
</ol>
<p><strong>index.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import routes from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes &#x2F;&#x2F; 这里使用ES6的简写写法，正常应该是这样写&#39;routes : routes &#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>router.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import  Home  from  &#39;@&#x2F;views&#x2F;Home&#39;</span><br><span class="line"></span><br><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;,</span><br><span class="line">    name: &#39;home&#39;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;about&#39;,</span><br><span class="line">    name: &#39;about&#39;,</span><br><span class="line">    &#x2F;&#x2F; route level code-splitting</span><br><span class="line">    &#x2F;&#x2F; this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    &#x2F;&#x2F; which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;@&#x2F;views&#x2F;About.vue&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="src-store"><a href="#src-store" class="headerlink" title="src/store"></a>src/store</h3><p>分为<strong>正常vuex结构</strong> 和 <strong>封装好的vuex结构</strong></p>
<p><strong>正常vuex</strong></p>
<p><strong>创建项目</strong> 初始化路由会在 <strong>src文件夹</strong> 下生成一个 <strong>store.js</strong> 文件。</p>
<p><strong>store.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种结构 <strong>看似简单</strong> ，后期项目 <strong>维护麻烦</strong> 。</p>
<p><strong>封装vuex</strong></p>
<p><strong>封装后</strong> 的结构，在 <strong>src目录</strong> 下创建一个 <strong>store文件夹</strong></p>
<p><img src="https://img.kancloud.cn/cd/c3/cdc31f614c6e19e0bbb0d9f705b05276_351x185.png" alt="img"></p>
<p>module文件夹</p>
<p>首先讲一下为什么会有 <strong>module文件夹</strong> ，因为项目如果有 <strong>好多vuex的状态</strong> ，如果都写在 <strong>sore.js</strong> 中，看起来会 <strong>杂乱无章</strong> ，都不知道哪个 <strong>vuex</strong> 的 <strong>状态</strong> 是哪个 <strong>模块</strong> 中使用的，所以有了 <strong>module文件夹</strong> ，例如我有一个 <strong>user模块</strong> 我只需要在 <strong>module文件夹</strong> 中创建一个 <strong>user.js</strong></p>
<p><strong>user.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">const mutations &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">const actions &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时只需要在 <strong>store文件夹</strong> 下的 <strong>index.js</strong> 中这样 <strong>引入</strong> 即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import state from &#39;.&#x2F;state&#39; &#x2F;&#x2F; state.js文件可以不写.js结尾，这样写也会自动找到state.js文件</span><br><span class="line">import mutations from &#39;.&#x2F;mutations&#39;</span><br><span class="line">import actions from &#39;.&#x2F;actions&#39;</span><br><span class="line">import user from &#39;.&#x2F;module&#x2F;user&#39; &#x2F;&#x2F; 引入模块文件</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state,  &#x2F;&#x2F; ES6对象简写的形式，state: state 等同与 state</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  modules: &#123; &#x2F;&#x2F; 模块引用</span><br><span class="line">    user</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>plugin文件夹</strong></p>
<p><strong>plugin文件夹</strong> 是存放 <strong>Vuex插件</strong> 的文件夹，假如我们这里有个持久化插件</p>
<p><strong>plugin/saveiInLocal.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 持久化储存插件：这个函数会在每次store实例初始化时调用。刷新浏览器后第一次要做的操作可以定义在这里</span><br><span class="line"> * @param store </span><br><span class="line"> *&#x2F;</span><br><span class="line">export default store &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果本地存储了state，就把这个stateJSON字符串转换成对象，替换到当前store实例的state</span><br><span class="line">    if(localStorage.state) store.replaceState(JSON.parse(localStorage.state))</span><br><span class="line">    store.subscribe((mutation, state) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 提交commit提交mutation之后执行这里，把state转换成JSON字符串储存到localStorage的state中</span><br><span class="line">        localStorage.state &#x3D; JSON.stringify(state)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>actions.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">export default actions</span><br></pre></td></tr></table></figure>

<p><strong>index.js</strong></p>
<p><strong>index.js</strong> 属于 <strong>根级别的Vuex</strong> 可以用来管理 <strong>根级别</strong> 的 <strong>actions</strong> 、 <strong>state</strong> 、 <strong>mutations</strong> 、 <strong>getters</strong> ，同样可以管理 <strong>模块（module）</strong> 中的 <strong>actions</strong> 、 <strong>state</strong> 、 <strong>mutations</strong>、 <strong>getter</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import state from &#39;.&#x2F;state&#39; &#x2F;&#x2F; state.js文件可以不写.js结尾，这样写也会自动找到state.js文件</span><br><span class="line">import getters from &#39;.&#x2F;getters&#39;</span><br><span class="line">import mutations from &#39;.&#x2F;mutations&#39;</span><br><span class="line">import actions from &#39;.&#x2F;actions&#39;</span><br><span class="line">import user from &#39;.&#x2F;module&#x2F;user&#39; &#x2F;&#x2F; 引入模块文件</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state,  &#x2F;&#x2F; ES6对象简写的形式，state: state 等同与 state</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  modules: &#123; &#x2F;&#x2F; 模块引用</span><br><span class="line">    user</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>mutations.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const mutations &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br><span class="line">export default mutations</span><br></pre></td></tr></table></figure>

<p><strong>state.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 状态写这里</span><br><span class="line">&#125;</span><br><span class="line">export default state</span><br></pre></td></tr></table></figure>

<p><strong>getters.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const getters &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default getters</span><br></pre></td></tr></table></figure>



<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p><strong>package.json</strong> 文件主要是 <strong>项目名称</strong> 、 <strong>项目版本</strong> 、 <strong>项目描述</strong> 、 <strong>项目运行的一些脚本（依赖）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;vue-cource&quot;, &#x2F;&#x2F; 项目名称</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;, &#x2F;&#x2F; 项目版本</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &#x2F;&#x2F; 运行指令</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;, &#x2F;&#x2F; 打包指令</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123; &#x2F;&#x2F; 项目打包后用到的依赖（运行依赖）</span><br><span class="line">    &quot;core-js&quot;: &quot;^2.6.5&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^2.6.10&quot;,</span><br><span class="line">    &quot;vue-router&quot;: &quot;^3.0.3&quot;,</span><br><span class="line">    &quot;vuex&quot;: &quot;^3.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123; &#x2F;&#x2F; 开发阶段用到的依赖（开发依赖）</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-babel&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-eslint&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-service&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;eslint-config-standard&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;babel-eslint&quot;: &quot;^10.0.1&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;^5.16.0&quot;,</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;node-sass&quot;: &quot;^4.9.0&quot;,</span><br><span class="line">    &quot;sass-loader&quot;: &quot;^7.1.0&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h3><p><strong>vue.config.js</strong> 是 <strong>vue</strong> 的 <strong>配置文件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 引入nodejs的path模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir) <span class="comment">// resolve方法用来加载路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_URL = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/iview-admin/&#x27;</span> : <span class="string">&#x27;/&#x27;</span> </span><br><span class="line"><span class="comment">// 判断当前为开发环境还是打包环境, &#x27;/&#x27;意思是代表指定在域名的根目录下，如果要指定到iview-admin下就这样写&#x27;/iview-admin/&#x27;, production为生产坏境，development为开发环境</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,                          <span class="comment">// 取消每次保存时都进行一次&#x27; ESLint &#x27;检测</span></span><br><span class="line">  publicPath: BASE_URL,                       <span class="comment">// 项目的基本路径,vuecli2.0时打包经常静态文件找不到，就是需要配置这个属性为&#x27;./&#x27;</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;                   <span class="comment">// 配置Webpack</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">    .set(<span class="string">&#x27;@&#x27;</span>, resolve(<span class="string">&#x27;src&#x27;</span>))                 <span class="comment">// 引入文件时候“ @ ”符号就代表src</span></span><br><span class="line">    .set(<span class="string">&#x27;_c&#x27;</span>, resolve(<span class="string">&#x27;src/components&#x27;</span>))     <span class="comment">// 引入组件文件夹中的文件就可以用“ _c ”代替src/components</span></span><br><span class="line">  &#125;,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,                 <span class="comment">// 打包时不生成.map文件，会减少打包体积，同时加快打包速度</span></span><br><span class="line">  devServer: &#123;                                <span class="comment">// 跨域有2种解决方案： 1. 在后端的header中配置， 2. 使用devServer来配置代理解决跨域</span></span><br><span class="line">    proxy: <span class="string">&#x27;http://localhost:4000&#x27;</span>            <span class="comment">// 这里写需要代理的URL,这里会告诉开发服务器，将任何未知请求匹配不到静态文件的请求，都代理到这个URL来满足跨域</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="VUEX"><a href="#VUEX" class="headerlink" title="VUEX"></a>VUEX</h1><p>当我们的应用遇到多个组件共享状态时，会需要多个组件依赖于同一状态抑或是来自不同视图的行为需要变更同一状态。以前的解决办法：</p>
<p><strong>a.将数据以及操作数据的行为都定义在父组件;</strong></p>
<p><strong>b.将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)</strong></p>
<p>传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。在搭建下面页面时，你可能会对 vue 组件之间的通信感到崩溃 ，特别是非父子组件之间通信。此时就应该使用vuex，轻松可以搞定组件间通信问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/23/1638b38a08088b12?w=1194&h=486&f=png&s=133255" alt="组件间通信"></p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。这里的关键在于集中式存储管理。**简单来说,对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)**。</p>
<p>原理</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/25/1656f2b9277ece19?w=761&h=464&f=png&s=124788" alt="img"></p>
<p>Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。</p>
<h4 id="2-简要介绍各模块在流程中的主要功能："><a href="#2-简要介绍各模块在流程中的主要功能：" class="headerlink" title="2.简要介绍各模块在流程中的主要功能："></a>2.简要介绍各模块在流程中的主要功能：</h4><ul>
<li>Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li>
<li>dispatch：操作行为触发方法，是唯一能执行action的方法。</li>
<li>actions：<strong>操作行为处理模块,由组件中的<code>$store.dispatch(&#39;action 名称&#39;, data1)</code>来触发。然后由commit()来触发mutation的调用 , 间接更新 state</strong>。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li>
<li>commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li>
<li>mutations：<strong>状态改变操作方法，由actions中的<code>commit(&#39;mutation 名称&#39;)</code>来触发</strong>。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li>
<li>state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li>
<li>getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li>
</ul>
<p>如果您的应用够简单，您最好不要使用 Vuex,因为使用 Vuex 可能是繁琐冗余的。一个简单的 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components.html#%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">global event bus</a> 就足够您所需了。但是，<strong>如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</strong></p>
<p>每一个 <strong>Vuex</strong> 应用的核心就是 <strong>store（仓库）</strong> 。<strong>store</strong> 基本上就是一个 <strong>容器</strong> ，它包含着你的 <strong>应用中大部分的状态 (state)</strong> 。<strong>Vuex</strong> 和 <strong>单纯的全局对象</strong> 有以下 <strong>两点不同</strong>：</p>
<ol>
<li><strong>Vuex</strong> 的 <strong>状态</strong> 存储是 <strong>响应式</strong> 的。当 <strong>Vue 组件</strong> 从 <strong>store</strong> 中 <strong>读取状态</strong> 的时候，若 <strong>store</strong> 中的<strong>状态发生变化</strong> ，那么 <strong>相应的组件也会得到更新</strong> 。</li>
<li>你 <strong>不能直接改变 store 中的状态</strong>。改变 <strong>store</strong> 中的 <strong>状态</strong> 的 <strong>唯一途径就是通过mutation</strong> 。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ol>
<h2 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h2><p><strong>Vuex</strong> 适合 <strong>大型复杂项目</strong> 中使用，进行 <strong>状态管理</strong>，我们的项目如果不是很复杂可以使用 <strong>Bus</strong> 来满足需求。</p>
<h2 id="state-与-getter"><a href="#state-与-getter" class="headerlink" title="state 与 getter"></a>state 与 getter</h2><p><img src="https://img.kancloud.cn/b3/f9/b3f994c71d894b582bae15b4a1df8ebb_701x551.png" alt="img"></p>
<p>上图就是 <strong>Vuex</strong> 状态管理的 <strong>流程</strong> ，在 <strong>Vue Components（组件）</strong> 里可以触发一个 <strong>Actions（Actions里可以做异步接口请求）</strong> ， <strong>请求完成</strong> 后触发一个 <strong>Mutations</strong> ，通过 <strong>Mutations</strong> 修改 <strong>State</strong> 的状态值，<strong>State</strong> 修改之后会触发 <strong>vue组件视图的渲染</strong> 。</p>
<p><strong>getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工</strong>。getters就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<h2 id="mutation-与-action-module"><a href="#mutation-与-action-module" class="headerlink" title="mutation 与 action / module"></a>mutation 与 action / module</h2><p><img src="https://img.kancloud.cn/b3/f9/b3f994c71d894b582bae15b4a1df8ebb_701x551.png" alt="img"></p>
<p>上图是 <strong>Vuex</strong> 状态管理的 <strong>流程</strong>，描述了从 <strong>Vue Components（组件）</strong> 执行 <strong>异步操作</strong> 的一个 <strong>环形流程</strong> ，实际上如果 <strong>没有异步操作的需求</strong> 就不用走 <strong>Actions</strong> 的这个步骤， <strong>2种操作（同步、异步操作）</strong> 的流程如下：</p>
<ol>
<li><strong>异步操作</strong>： <strong>Vue Components（组件）</strong> &gt; <strong>Actions（请求接口操作写这里）</strong> &gt; <strong>Mutations（接口成功返回值后在这里修改State的值）</strong> &gt; <strong>State状态更新</strong> &gt; <strong>Vue Components（组件）视图更新</strong></li>
<li><strong>同步操作</strong> ： <strong>Vue Components（组件）</strong> &gt; <strong>Mutations（修改State的值）</strong> &gt; <strong>State状态更新</strong> &gt; <strong>Vue Components（组件）视图更新</strong></li>
</ol>
<p>actions和上面的Mutations功能基本一样，不同点是，<strong>actions是异步的改变state状态，而Mutations是同步改变状态</strong>。</p>
<p>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态—-尤雨溪</p>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p><strong>Ajax</strong> 用来 <strong>请求后端接口</strong> 并且 <strong>取得返回数据</strong> ， 在 <strong>Vue</strong> 中 使用的是 <strong>Vue</strong> 官方推荐的 <strong>axios</strong> 库来作为 <strong>异步接口请求</strong> 的工具</p>
<p><strong>跨域</strong> 是受到 <strong>浏览器</strong> 的 <strong>同源策略</strong> 的影响，在一些情况下是 <strong>不允许通信的</strong> 。</p>
<p>在下面表格中列出了 <strong>跨域</strong> 的案例：</p>
<table>
<thead>
<tr>
<th align="left">URL</th>
<th align="left">说明</th>
<th align="left">是否允许通信</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.d.com/d.js">http://www.d.com/d.js</a> <br /><a target="_blank" rel="noopener" href="http://www.d.com/w.js">http://www.d.com/w.js</a></td>
<td align="left">同一域名下</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.d.com/lab/a.js">http://www.d.com/lab/a.js</a> <br /><a target="_blank" rel="noopener" href="http://www.d.com/src/b.js">http://www.d.com/src/b.js</a></td>
<td align="left">同一域名下不同文件夹</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.d.com:3333/a.js">http://www.d.com:3333/a.js</a> <br /><a target="_blank" rel="noopener" href="http://www.d.com:4444/b.js">http://www.d.com:4444/b.js</a></td>
<td align="left">同一域名不同端口</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.d.com/a.js">http://www.d.com/a.js</a> <br /><a target="_blank" rel="noopener" href="http://46.33.22.44/b.js">http://46.33.22.44/b.js</a></td>
<td align="left"><strong>域名和域名对应 IP</strong></td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.d.com/a.js">http://www.d.com/a.js</a> <br /><a target="_blank" rel="noopener" href="http://scipt.d.com/b.js">http://scipt.d.com/b.js</a></td>
<td align="left">主域相同，子域不同</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.d.com/a.js">http://www.d.com/a.js</a> <br /><a target="_blank" rel="noopener" href="http://d.com/b.js">http://d.com/b.js</a></td>
<td align="left">同一域名，不同二级域名（同上）</td>
<td align="left">不允许（cookie 这种情况下也不允许访问）</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.d.com/a.js">http://www.d.com/a.js</a> <br /><a target="_blank" rel="noopener" href="http://www.v.com/b.js">http://www.v.com/b.js</a></td>
<td align="left">不同域名</td>
<td align="left">不允许</td>
</tr>
</tbody></table>
<h3 id="前端解决跨域"><a href="#前端解决跨域" class="headerlink" title="前端解决跨域"></a>前端解决跨域</h3><p><strong>前端</strong> 需要在 <strong>vue.config.js</strong> 文件中通过 <strong>devServer</strong> 中的 <strong>proxy</strong> 来 <strong>配置代理</strong> 。</p>
<p><strong>原理</strong> ：我们在 <strong>本地开发</strong> 的时候，通过 <strong>vueServe</strong> 起一个 <strong>本地的开发服务</strong> ，这个 <strong>服务的地址</strong> 一般是 <strong>localhost</strong> ， <strong>端口</strong> 一般是 <strong>8080</strong> ，如果我们在 <strong>本地起一个 node 服务</strong> ，那么它的 <strong>端口</strong> 肯定是跟我们的 <strong>前端服务的端口</strong> 是不一样的，刚才在 上面表格中讲过 <strong>同一域名不同端口</strong> 也是 <strong>存在跨域问题</strong> ，是 <strong>不在同一个域下</strong> ，这个时候 <strong>调用接口</strong> 的话，受到 <strong>同源策略</strong> 影响，是 <strong>无法调取成功</strong> 的，我们可以用 <strong>proxy</strong> 来 <strong>设置代理</strong> ， <strong>它会把我们所有的接口，代理到目标URL下</strong> ，比如接口是 <strong>/api/getUserInfo</strong> ，我们 <strong>设置代理</strong> 是 <strong><a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000</a></strong> ，这样的话请求的接口就会被代理到 <strong><a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000</a></strong> 下，代理后请求接口时的<strong>URL</strong> ： <strong><a target="_blank" rel="noopener" href="http://localhost:4000/#/api/getUserInfo">http://localhost:4000/#/api/getUserInfo</a></strong> ， 例子如下：</p>
<p><strong>vue.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 引入nodejs的path模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir) <span class="comment">// resolve方法用来加载路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_URL = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/iview-admin/&#x27;</span> : <span class="string">&#x27;/&#x27;</span> <span class="comment">// 判断当前为开发环境还是打包环境, &#x27;/&#x27;意思是代表指定在域名的根目录下，如果要指定到iview-admin下就这样写&#x27;/iview-admin/&#x27;, production为生产坏境，development为开发环境</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,                          <span class="comment">// 取消每次保存时都进行一次&#x27; ESLint &#x27;检测</span></span><br><span class="line">  publicPath: BASE_URL,                       <span class="comment">// 项目的基本路径,vuecli2.0时打包经常静态文件找不到，就是需要配置这个属性为&#x27;./&#x27;</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;                   <span class="comment">// 配置Webpack</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">    .set(<span class="string">&#x27;@&#x27;</span>, resolve(<span class="string">&#x27;src&#x27;</span>))                 <span class="comment">// 引入文件时候“ @ ”符号就代表src</span></span><br><span class="line">    .set(<span class="string">&#x27;_c&#x27;</span>, resolve(<span class="string">&#x27;src/components&#x27;</span>))     <span class="comment">// 引入组件文件夹中的文件就可以用“ _c ”代替src/components</span></span><br><span class="line">  &#125;,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,                 <span class="comment">// 打包时不生成.map文件，会减少打包体积，同时加快打包速度</span></span><br><span class="line">  devServer: &#123;                                <span class="comment">// 跨域有2种解决方案： 1. 在后端的header中配置， 2. 使用devServer来配置代理解决跨域</span></span><br><span class="line">    proxy: <span class="string">&#x27;http://localhost:4000&#x27;</span>            <span class="comment">// 这里写需要代理的URL,这里会告诉开发服务器，将任何未知请求匹配不到静态文件的请求，都代理到这个URL来满足跨域</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代理的 <strong>URL地址</strong> 以及 <strong>端口号</strong> 一定要与服务端 <strong>一致</strong> 。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li><p><strong>前端配置代理</strong> 只是在 <strong>开发环境（develop）</strong> 好用，便于开发，在 <strong>生产环境（prod）</strong> 还是 <strong>需要由服务端解决跨域</strong> 。</p>
</li>
<li><p>这里需要注意，如果在 <strong>前端配置代理</strong> ，需要在 <strong>src/config/index.js（接下来的axios封装中用到了这个文件）</strong> 中添加一个 <strong>逻辑判断</strong> 如下：</p>
<p><strong>src/config/index.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果当前是生产环境用生产环境地址，如果是开发环境并且在vue.config.js中配置了代理，就用空字符串【&#39;&#39;】，如果未配置代理就用开发环境地址</span><br><span class="line">export const baseURL&#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;http:&#x2F;&#x2F;production.com&#39; : &#39;http:&#x2F;&#x2F;develop.com&#39;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="后端解决跨域"><a href="#后端解决跨域" class="headerlink" title="后端解决跨域"></a>后端解决跨域</h3><p>如果不在 <strong>设置代理</strong> ，可以在 <strong>后端设置header</strong> 来 <strong>解决跨域问题</strong> ，这里 <strong>后端</strong> 用的是 <strong>nodejs</strong> ，在<strong>express（nodejs的框架）</strong> 里使用 <strong>app.all</strong> 为 <strong>所有请求</strong> 都添加这 <strong>3 个 header</strong> 即可。</p>
<p><strong>app.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createError = <span class="built_in">require</span>(<span class="string">&#x27;http-errors&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;colors&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;morgan&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indexRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> usersRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/users&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// view engine setup</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="string">&#x27;views&#x27;</span>))</span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;jade&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(logger(<span class="string">&#x27;dev&#x27;</span>))</span><br><span class="line">app.use(express.json())</span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.use(cookieParser())</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123; <span class="comment">// 设置header</span></span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;X-Requested-With,Content-Type&#x27;</span>)</span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="string">&#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;</span>)</span><br><span class="line">	next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, indexRouter)</span><br><span class="line">app.use(<span class="string">&#x27;/users&#x27;</span>, usersRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// catch 404 and forward to error handler</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">	next(createError(<span class="number">404</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error handler</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// set locals, only providing error in development</span></span><br><span class="line">	res.locals.message = err.message</span><br><span class="line">	res.locals.error = req.app.get(<span class="string">&#x27;env&#x27;</span>) === <span class="string">&#x27;development&#x27;</span> ? err : &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// render the error page</span></span><br><span class="line">	res.status(err.status || <span class="number">500</span>)</span><br><span class="line">	res.render(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br></pre></td></tr></table></figure>

<h2 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h2><ol>
<li><p>首先在 <strong>src文件夹</strong> 下的 <strong>lib文件夹</strong> 中创建 <strong>axios.js</strong></p>
<p><strong>src/lib/axios.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; baseURL &#125; <span class="keyword">from</span> <span class="string">&#x27;@/config&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/lib/util&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">baseUrl = baseURL</span>)</span>&#123; <span class="comment">// baseUrl = baseURL 是ES6的默认值写法等同于 baseUrl = baseUrl || baseURL</span></span><br><span class="line">        <span class="built_in">this</span>.baseUrl = baseUrl <span class="comment">// this指向创建的实例，当你使用new HttpRequest创建实例时候，它会把this中定义的变量返回给你</span></span><br><span class="line">        <span class="built_in">this</span>.queue = &#123;&#125; <span class="comment">// 创建队列，每次请求都会向里面添加一个key:value，请求成功后就会去掉这个key:value，直到this.queue中没有属性值时，loading关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认options配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">getInsideConfig</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> config = &#123;</span><br><span class="line">            baseURL: <span class="built_in">this</span>.baseUrl,</span><br><span class="line">            headers: &#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;</span><br><span class="line">    distroy (url) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.queue[url]</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.queue).length) &#123;</span><br><span class="line">          <span class="comment">// Spin.hide()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">instance</span></span> - 通过axios创建的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">url</span></span> - 接口地址</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="function"><span class="title">interceptors</span>(<span class="params">instance, url</span>)</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求拦截器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">config</span></span> - 请求前的控制</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">error</span></span> - 出现错误的时候会提供一个错误信息</span></span><br><span class="line"><span class="comment">         */</span>    </span><br><span class="line">        instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 添加全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.queue).length)&#123;</span><br><span class="line">                <span class="comment">// Spin.show()</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">this</span>.queue[url] = <span class="literal">true</span></span><br><span class="line">            config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = getToken()</span><br><span class="line">            <span class="keyword">return</span> config</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 响应拦截器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">res</span></span> - 服务端返回的东西</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">error</span></span> - 出现错误的时候会提供一个错误信息</span></span><br><span class="line"><span class="comment">         */</span>            </span><br><span class="line">        instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.distroy(url) <span class="comment">// 关闭全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">const</span> &#123; data &#125; = res</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.distroy(url) <span class="comment">// 关闭全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error.response.data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">request</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create()</span><br><span class="line">        options = <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.getInsideConfig(), options) <span class="comment">//  Object.assign会将2个对象合并成1个对象，相同属性值会被后者覆盖</span></span><br><span class="line">        <span class="built_in">this</span>.interceptors(instance, options.url) <span class="comment">// 拦截器</span></span><br><span class="line">        <span class="keyword">return</span> instance(options)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HttpRequest</span><br></pre></td></tr></table></figure>

<p><strong>constructor方法</strong> 是 <strong>每一个类必须有的方法</strong> ，如果我们不定义这个 <strong>constructor方法</strong> ， <strong>class类</strong> 会默认添加一个 <strong>空的constructor方法（例如：constructor(){}）</strong> ，在 <strong>constructor方法</strong> 中可以 <strong>接收传入的参数</strong> ， 在我们 <strong>创建实例 new HttpRequest(‘参数’)</strong> 时候可以 <strong>在括号内传入参数</strong> ， 然后我们可以在 <strong>constructor方法</strong> 中 <strong>对参数做一些操作</strong> 。</p>
</li>
<li><p>上面把 <strong>baseUrl</strong> 抽离到了 <strong>config文件夹</strong> 里的 <strong>index.js 全局变量</strong> 中</p>
<p><strong>src/config/index.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果当前是生产环境用生产环境地址，如果是开发环境并且在vue.config.js中配置了代理，就用空字符串【&#39;&#39;】，如果未配置代理就用开发环境地址</span><br><span class="line">export const baseURL&#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;http:&#x2F;&#x2F;production.com&#39; : &#39;http:&#x2F;&#x2F;develop.com&#39;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><p>在 <strong>api文件夹</strong> 中创建 <strong>index.js</strong></p>
<p><strong>src/api/index.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import HttpRequest from &#39;@&#x2F;lib&#x2F;axios&#39;</span><br><span class="line">const axios &#x3D; new HttpRequest()</span><br><span class="line">export default axios</span><br></pre></td></tr></table></figure>

<p>在使用时候：我们创建一个储存用户接口的 <strong>uesr.js</strong> 文件</p>
<p><strong>src/api/user.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;.&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取用户信息接口</span><br><span class="line">export const getUserInfo &#x3D; (&#123; userId &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return axios.request(&#123;</span><br><span class="line">        url: &#39;&#x2F;getUserInfo&#39;,</span><br><span class="line">        method: &#39;post&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            userId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <strong>Home.vue</strong> 页面组件中这样 <strong>调用接口</strong></p>
<p><strong>Home.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;getInfo&quot;&gt;请求数据&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; getUserInfo &#125; from &#39;@&#x2F;api&#x2F;user&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getInfo()&#123;</span><br><span class="line">      getUserInfo(&#123; userId: 21 &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">      &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="渲染函数（render函数）"><a href="#渲染函数（render函数）" class="headerlink" title="渲染函数（render函数）"></a>渲染函数（render函数）</h1><p>在 <strong>Vue</strong> 中使用 <strong>渲染函数</strong> 来 <strong>创建视图模板</strong> ，并且会讲解 <strong>JSX</strong> 的 <strong>语法</strong> ，同时会补充2个内容，第一是 <strong>函数式组件</strong> ，第二是 <strong>作用域插槽</strong> 。</p>
<h2 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h2><p><strong>render函数</strong> ：可以用 <strong>函数的方式</strong> 渲染 <strong>dom元素</strong> 到页面中。</p>
<p>下面会讲解2种使用场景：</p>
<ol>
<li>在 <strong>main.js</strong> 中如何使用</li>
<li>在 <strong>.vue</strong> 文件中使用</li>
</ol>
<h3 id="render函数在main-js中使用"><a href="#render函数在main-js中使用" class="headerlink" title="render函数在main.js中使用"></a>render函数在main.js中使用</h3><p><strong>src/main.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39; &#x2F;&#x2F; app组件</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">import Bus from &#39;.&#x2F;lib&#x2F;bus&#39; &#x2F;&#x2F; 引入Bus</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line">Vue.prototype.$bus &#x3D; Bus &#x2F;&#x2F; 挂载Bus到Vue原型链（全局挂载Bus）</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(App) &#x2F;&#x2F; 渲染app组件</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p>我们首先在 <strong>main.js</strong> 中学习 <strong>render函数</strong> ， <strong>render</strong> 的 <strong>属性值</strong> 是一个 <strong>回调函数</strong> ，它的参数可以用括号包裹起来，例如这样： <strong>render: (h) =&gt; h(App)</strong> ，如果 <strong>只有一个参数就可以不用括号包裹</strong> ， <strong>h这个参数是一个方法</strong> ，这个方法能 <strong>创建一个虚拟节点</strong> ，<strong>这个函数 return 返回一个结果</strong> 。</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">参数</th>
<th align="left">是否必填</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>render函数：render: h =&gt; h(App)</strong></td>
<td align="left"><strong>h函数的第1个参数</strong>：<strong>要渲染的组件，或者一个标签字符串，或者也可以是一个函数</strong></td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><strong>h函数的第2个参数</strong>： 该参数是一个 <strong>配置对象</strong>，可以 <strong>通过该对象给元素设置属性</strong> ，例如 <strong>div</strong> 标签的 <strong>id、class 等等</strong></td>
<td align="left"><strong>否</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><strong>h函数的第3个参数</strong>：该 <strong>参数可以是字符串或者数组</strong>，主要作用是 <strong>给元素添加内容</strong></td>
<td align="left"><strong>否</strong></td>
</tr>
</tbody></table>
<ol>
<li><p><strong>h函数的参数1</strong></p>
<p><strong>说明</strong> ： <strong>第1个参数</strong> 是用来传入 <strong>元素标签</strong> 或者 <strong>组件</strong> 。</p>
<p>1.1. <strong>传入组件</strong> ：<strong>main.js</strong> 中 <strong>h函数</strong> 默认传入的是 <strong>app.vue页面组件</strong>，所以就会 <strong>渲染该组件</strong> ，下面引入之前封装的 <strong>CountTo 组件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">import Bus from &#39;.&#x2F;lib&#x2F;bus&#39;</span><br><span class="line">import CountTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入CountTo 组件</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line">Vue.prototype.$bus &#x3D; Bus</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(CountTo, &#123;</span><br><span class="line">    &#x2F;&#x2F; &#39;class&#39;: &#39;count-to&#39;, &#x2F;&#x2F; 给组件最外层盒子添加class类名</span><br><span class="line">    &#x2F;&#x2F; 或者这样写</span><br><span class="line">    &#x2F;&#x2F; &#39;class&#39;: [&#39;count-to&#39;, true ? &#39;count-to2&#39; : &#39;&#39;], </span><br><span class="line">    &#x2F;&#x2F; 或者这样写</span><br><span class="line">    &#39;class&#39;: &#123;</span><br><span class="line">      &#39;count-to&#39;: true,</span><br><span class="line">      &#39;count-to2&#39;: 1 &#x3D;&#x3D;&#x3D; 1,</span><br><span class="line">    &#125;, </span><br><span class="line">    attrs: &#123;&#125;, &#x2F;&#x2F; 定义属性id等等</span><br><span class="line">    style: &#123;&#125;, &#x2F;&#x2F; 定义样式</span><br><span class="line">    props: &#123; &#x2F;&#x2F; 添加属性 这里可以理解为就是&lt;count-to :endValue&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">      endValue: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; domProps: &#123; &#x2F;&#x2F; dom的一些属性</span><br><span class="line">    &#x2F;&#x2F;   innerHTML: &#39;11&#39; &#x2F;&#x2F; 可以设置标签的一些内容</span><br><span class="line">    &#x2F;&#x2F; &#125;,</span><br><span class="line">    on: &#123; &#x2F;&#x2F; 添加事件</span><br><span class="line">      &#39;on-animation-end&#39;: (val) &#x3D;&gt; &#123; &#x2F;&#x2F; 事件名</span><br><span class="line">        console.log(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    nativeOn: &#123; &#x2F;&#x2F; 组件内没有定义click事件时，给组件最外层元素绑定一个click事件</span><br><span class="line">      &#39;click&#39;: () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;click&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    directives: [], &#x2F;&#x2F; 可以定义自定义指令</span><br><span class="line">    scopedSlots: &#123;&#125;,</span><br><span class="line">    slot: &#39;&#39;, &#x2F;&#x2F; 插槽</span><br><span class="line">    key: &#39;&#39;, &#x2F;&#x2F; 设置一个值让每个组件的key不相等</span><br><span class="line">    ref: &#39;&#39; &#x2F;&#x2F; ref</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p>1.2. <strong>传入字符串</strong> ：也可以像下面写，这样页面中就 <strong>渲染</strong> 出一个 <strong>div标签</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p>1.3. <strong>传入函数</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let func &#x3D; ()&#x3D;&gt; &#39;h3&#39;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(func())</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>h函数的参数2</strong></p>
<p><strong>说明</strong> ： <strong>h函数</strong> 的 <strong>第2个参数是个对象</strong> ，用来 <strong>定义元素的一些属性</strong> 。</p>
<p>2.1. <strong>给元素设置属性</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#123;</span><br><span class="line">    attrs: &#123; &#x2F;&#x2F; 添加属性</span><br><span class="line">      id: &#39;box&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    style: &#123; &#x2F;&#x2F; 添加样式</span><br><span class="line">      color: &#39;red&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>h函数的参数3</strong></p>
<p><strong>说明</strong> ： <strong>h函数的第3个参数可以是字符串或者数组</strong> ，用来 <strong>定义元素的内容</strong> 。</p>
<p>3.1. <strong>传入字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#123;</span><br><span class="line">    attrs: &#123; &#x2F;&#x2F; 添加属性</span><br><span class="line">      id: &#39;box&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    style: &#123; &#x2F;&#x2F; 添加样式</span><br><span class="line">      color: &#39;red&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#39;我是div的内容&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>如果不设置样式可以直接忽略h函数的第2个参数</strong> , 直接写内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#39;123&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p>3.2. <strong>传入数组</strong></p>
<p>如果想让内容是 <strong>多个标签</strong> ，就需要 <strong>传入数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, [</span><br><span class="line">    h(&#39;span&#39;, &#39;111&#39;),</span><br><span class="line">    h(&#39;span&#39;, &#39;222&#39;)</span><br><span class="line">  ])</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<p>3.3. <strong>循环传入标签</strong></p>
<p>如果想实现一个类似 <strong>v-for</strong> 的效果，首先先看 <strong>正常循环列表写法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul @click&#x3D;&quot;handleClick&quot;&gt;</span><br><span class="line">        &lt;li @click.stop&#x3D;&quot;handleClick&quot; v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;list_item_$&#123;index&#125;&#96;&quot;&gt;&#123;&#123; item.name &#125;&#125; &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default&#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                list: [</span><br><span class="line">                    &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                    &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleClick(event)&#123;</span><br><span class="line">                console.log(event)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>接下来使用 <strong>render函数</strong> 实现上面的 <strong>循环列表跟点击事件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 点击事件</span><br><span class="line">const handleClick &#x3D; event &#x3D;&gt; &#123;</span><br><span class="line">  console.log(event)</span><br><span class="line">  event.stopPropagation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">let list &#x3D; [</span><br><span class="line">  &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">  &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 循环生成li</span><br><span class="line">const getLiEleArr &#x3D; (h) &#x3D;&gt; &#123;</span><br><span class="line">  return list.map((item, index) &#x3D;&gt; h(&#39;li&#39;, &#123;</span><br><span class="line">    on: &#123;</span><br><span class="line">      &#39;click&#39;: handleClick</span><br><span class="line">    &#125;,</span><br><span class="line">    key: &#96;list_item_$&#123;index&#125;&#96;</span><br><span class="line">  &#125;, item.name))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最终渲染</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;,[</span><br><span class="line">    h(&#39;ul&#39;, &#123;</span><br><span class="line">      on: &#123;</span><br><span class="line">        &#39;click&#39;: handleClick</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, getLiEleArr(h))</span><br><span class="line">  ])</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="render函数在-vue中使用"><a href="#render函数在-vue中使用" class="headerlink" title="render函数在.vue中使用"></a>render函数在.vue中使用</h3><p>有时 <strong>即使你封装好了组件，但是想根据自己的方式去定制组件内的元素以及内容</strong>，这时候就需要 <strong>给组件传入一个render函数</strong></p>
<ol>
<li><p><strong>父组件</strong></p>
<p>首先在 <strong>路由列表</strong> 的 <strong>路由对象</strong> 中添加新创建的 <strong>render-page</strong> 页面配置路由</p>
<p><strong>src/router/router.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;render-page&#39;,</span><br><span class="line">    name: &#39;&#x2F;render_page&#39;,</span><br><span class="line">    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;render-page&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后在 <strong>src/views/render-page.vue</strong> 页面 <strong>引入list组件</strong></p>
<p><strong>src/views/render-page.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, name)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            return h(&#39;i&#39;, &#123;</span><br><span class="line">                style: &#123;</span><br><span class="line">                    color: &#39;pink&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>子组件</strong></p>
<p><strong>src/components/list/list.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">          &lt;!-- 如果未传入render函数就span标签内容 --&gt;</span><br><span class="line">          &lt;span v-if&#x3D;&quot;!render&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">          </span><br><span class="line">          &lt;!-- 如果传入了render函数，就使用render函数自定义dom的节点来渲染 --&gt;</span><br><span class="line">          &lt;render-dom v-else :render-func&#x3D;&quot;render&quot; :name&#x3D;&quot;item.name&quot;&gt;&lt;&#x2F;render-dom&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 引入函数式组件</span><br><span class="line">import RenderDom from &#39;_c&#x2F;render-dom&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        RenderDom &#x2F;&#x2F; 注册函数式组件</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;,</span><br><span class="line">        render: &#123; &#x2F;&#x2F; render 函数</span><br><span class="line">            type: Function,</span><br><span class="line">            default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>定义一个 <strong>index.js 方便父组件引用</strong></p>
<p><strong>src/components/list/index.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import List from &#39;.&#x2F;list.vue&#39;</span><br><span class="line">export default List</span><br></pre></td></tr></table></figure>

<p>在上面的组件中使用到了 <strong>函数式组件</strong> ，这里写的 <strong>函数式组件</strong> 就是使用 <strong>reder函数 自定义一些想要的标签</strong> 然后 <strong>return</strong> 返回一个 <strong>虚拟节点</strong> ， <strong>最终渲染在使用函数式组件的地方</strong> ，<strong>函数式组件详解看下方的文档介绍</strong>。</p>
<p><strong>src/components/render-dom.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        name: String, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><p><strong>函数式组件</strong> ： <strong>只给它传入数据，它不做任何响应式的操作， 不监听传递给它的状态</strong> ，这个组件 <strong>没有生命周期和钩子函数</strong>，它 <strong>只是作为一个接收参数的函数</strong> ， 当 <strong>functional 设置为 true</strong> 时候，证明 <strong>它是一个没有状态的组件，也没有实例，就是一个对象</strong> ， 当 <strong>把这个对象引入到其他页面，当做一个组件去使用的时候，vue会把它做一个处理，会把 【render函数】里面逻辑返回的【虚拟节点】做一个渲染</strong> 。</p>
<p><strong>src/components/render-dom.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        name: String, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p><strong>JSX</strong> ：<strong>JSX</strong> 最先是 <strong>react</strong> 提出的， <strong>通过一种形式，在 js 里面写 html 标签，还有一些特定的语法</strong> ，最后会把这个 <strong>字符串</strong> 转译成 <strong>js</strong> ，去用 <strong>render函数</strong> 来做渲染。</p>
<h3 id="JSX渲染标签字符串"><a href="#JSX渲染标签字符串" class="headerlink" title="JSX渲染标签字符串"></a>JSX渲染标签字符串</h3><ol>
<li><p><strong>父组件</strong></p>
<p><strong>src/views/render-page.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, name)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * render函数方式</span><br><span class="line">             *&#x2F;</span><br><span class="line">            &#x2F;&#x2F; return h(&#39;i&#39;, &#123;</span><br><span class="line">            &#x2F;&#x2F;     style: &#123;</span><br><span class="line">            &#x2F;&#x2F;         color: &#39;pink&#39;</span><br><span class="line">            &#x2F;&#x2F;     &#125;</span><br><span class="line">            &#x2F;&#x2F; &#125;, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * JSX方式</span><br><span class="line">             * JSX与template模板对比</span><br><span class="line">             *   style:</span><br><span class="line">             *      template的标签中写法:style&#x3D;&quot;&#123; color: &#39;pink&#39; &#125;&quot;</span><br><span class="line">             *      JSX写法:style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;</span><br><span class="line">             *      JSX中style不需要添加双引号，属性都需要用&#123;&#125;包裹</span><br><span class="line">             * </span><br><span class="line">             *   事件:</span><br><span class="line">             *      template的标签中写法v-click&#x3D;&quot;handleClick&quot; 或者 @click&#x3D;&quot;handleClick&quot;</span><br><span class="line">             *      JSX写法on-click&#x3D;&#123; this.handleClick &#125;</span><br><span class="line">             *&#x2F;</span><br><span class="line">            return (</span><br><span class="line">                &lt;i on-click&#x3D;&#123; this.handleClick &#125; style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;&gt;&#123; name &#125;&lt;&#x2F;i&gt; </span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        handleClick(event)&#123;</span><br><span class="line">            console.log(event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>使用 <strong>JSX</strong> 时 <strong>render函数</strong> 的 <strong>形参必须是 h</strong> ，不可以改成其他的（例如 <strong>createElement</strong>）。以上代码中引入的 <strong>List组件</strong> 在上面的 <strong>render函数</strong> 文档中有写过，在此处就不再过多陈述。</p>
</li>
</ol>
<h3 id="JSX渲染组件"><a href="#JSX渲染组件" class="headerlink" title="JSX渲染组件"></a>JSX渲染组件</h3><ol>
<li><p><strong>父组件</strong></p>
<p><strong>src/views/render-page.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line">import CountTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入组件</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123; number: 100 &#125;,</span><br><span class="line">                &#123; number: 45 &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, number)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            return (</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 这里可以引入组件进行渲染，而且不用在components对象中注册</span><br><span class="line">                 * 事件分为2种：原生事件、自定义事件</span><br><span class="line">                 *  html标签：支持原生事件</span><br><span class="line">                 *  组件：支持原生事件(给下面的CountTo组件绑定一个原生click事件,就相当于给组件内的最外层元素绑定了一个click事件，</span><br><span class="line">                 *  写法：nativeOn-事件名称&#x3D;&#123;方法&#125;)、</span><br><span class="line">                 *  自定义事件(写法：on-自定义事件名称&#x3D;&#123;方法&#125;)</span><br><span class="line">                 *  template模板中的事件修饰符在JSX跟render函数中用到需要看文档</span><br><span class="line">                 * *&#x2F; </span><br><span class="line">                &lt;CountTo nativeOn-click&#x3D;&#123;this.handleClick&#125; on-on-animation-end&#x3D;&#123;this.handleEnd&#125; endValue&#x3D;&#123;number&#125; style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;&gt;&lt;&#x2F;CountTo&gt; </span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        handleClick(event)&#123;</span><br><span class="line">            console.log(event)</span><br><span class="line">        &#125;,</span><br><span class="line">        handleEnd()&#123;</span><br><span class="line">            console.log(&#39;end!&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>父组件中引入的 <strong><a target="_blank" rel="noopener" href="https://www.kancloud.cn/wangjiachong/vue_notes/1971966">CountTo组件</a></strong></p>
</li>
<li><p><strong>子组件</strong></p>
<p><strong>src/components/list.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li @mousemove&#x3D;&quot;handleMove&quot; v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">          &lt;!-- 如果未传入render函数就span标签内容 --&gt;</span><br><span class="line">          &lt;span v-if&#x3D;&quot;!render&quot;&gt;&#123;&#123; item.number &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">          </span><br><span class="line">          &lt;!-- 如果传入了render函数，就使用render函数自定义dom的节点来渲染 --&gt;</span><br><span class="line">          &lt;render-dom v-else :render-func&#x3D;&quot;render&quot; :number&#x3D;&quot;item.number&quot;&gt;&lt;&#x2F;render-dom&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 引入函数式组件</span><br><span class="line">import RenderDom from &#39;_c&#x2F;render-dom&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        RenderDom &#x2F;&#x2F; 注册函数式组件</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;,</span><br><span class="line">        render: &#123; &#x2F;&#x2F; render 函数</span><br><span class="line">            type: Function,</span><br><span class="line">            default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleMove(event)&#123;</span><br><span class="line">            &#x2F;&#x2F; 阻止默认行为（文字不可以选中复制）</span><br><span class="line">            event.preventDefault()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>list组件</strong> 对应的 <strong>index.js</strong>，用于 <strong>父组件方便引用</strong></p>
<p><strong>src/components/list/index.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import List from &#39;.&#x2F;list.vue&#39;</span><br><span class="line">export default List</span><br></pre></td></tr></table></figure>

<p><strong>子组件</strong> 中用到的 <strong>函数式组件 render-dom.js</strong></p>
<p><strong>src/components/render-dom.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        number: Number, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.number)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p><strong>定制组件内的元素以及内容</strong> ，用 <strong>render函数</strong> 以及 <strong>JSX</strong> 都比较繁琐，接下来用 <strong>作用域插槽</strong> 来实现这个需求。</p>
<ol>
<li><p><strong>父组件</strong></p>
<p><strong>src/views/render-page.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot;&gt;</span><br><span class="line">            &lt;h3 slot&#x3D;&quot;aa&quot;&gt;我是小明&lt;&#x2F;h3&gt;</span><br><span class="line">            &lt;coun-to slot-scope&#x3D;&quot;count&quot; :end-value&#x3D;&quot;count.number&quot;&gt;&lt;&#x2F;coun-to&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line">import CounTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入组件</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123; number: 100 &#125;,</span><br><span class="line">                &#123; number: 45 &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List,</span><br><span class="line">        CounTo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>子组件</strong></p>
<p><strong>src/components/list.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">            &lt;!-- 默认插槽 --&gt;</span><br><span class="line">            &lt;!-- &lt;slot&gt;&lt;&#x2F;slot&gt; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &lt;!-- 具名插槽 --&gt;</span><br><span class="line">            &lt;slot name&#x3D;&quot;aa&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        </span><br><span class="line">            &lt;!-- 作用域插槽 --&gt;</span><br><span class="line">            &lt;slot :number&#x3D;&quot;item.number&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>插槽总结</strong></p>
<p>3.1 <strong>匿名插槽</strong> 应用场景：<strong>组件内</strong> 只需要一个 <strong>插槽</strong> 的情况，可以使用 <strong>匿名插槽</strong> 。</p>
<p>3.2 <strong>具名插槽</strong> 应用场景：<strong>组件内</strong> 需要多个 <strong>插槽</strong> 的情况，可以使用 <strong>具名插槽</strong> 。</p>
<p>3.3 <strong>作用域插槽</strong>应用场景：<strong>父组件插槽插入的内容中</strong> 使用到了 <strong>组件内的数据</strong> 。</p>
</li>
</ol>
<h1 id="VUE的配置"><a href="#VUE的配置" class="headerlink" title="VUE的配置"></a>VUE的配置</h1><h1 id="VUE的路由：Vue-Router"><a href="#VUE的路由：Vue-Router" class="headerlink" title="VUE的路由：Vue Router"></a>VUE的路由：Vue Router</h1><p><strong>Vue Router</strong> 是 <strong>Vue</strong> 官方提供的 <strong>路由管理器</strong> ，可以进行 <strong>路由跳转</strong>，以及 <strong>页面之间跳转时传值</strong>，以及 <strong>路由拦截</strong> 等等操作</p>
<p>这里的路由并不是指我们平时所说的硬件路由器，<strong>这里的路由就是SPA（单页应用）的路径管理器</strong>。再通俗的说，vue-router就是<a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=webapp">WebApp</a>的链接路径管理系统。<br>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。<strong>路由模块的本质 就是建立起url和页面之间的映射关系</strong>。</p>
<p>至于我们为啥不能用a标签，这是因为用Vue做的都是单页应用（<strong>当你的项目准备打包时，运行<code>npm run build</code>时，就会生成dist文件夹，这里面只有静态资源和一个index.html页面</strong>），所以你写的<a></a>标签是不起作用的，你必须使用vue-router来进行管理。</p>
<p>实现原理</p>
<p>SPA(single page application):单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。<strong>单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面</strong>;vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。</p>
<h4 id="1、Hash模式："><a href="#1、Hash模式：" class="headerlink" title="1、Hash模式："></a>1、Hash模式：</h4><p><strong>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</strong> hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说<strong>Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据</strong></p>
<h4 id="2、History模式："><a href="#2、History模式：" class="headerlink" title="2、History模式："></a>2、History模式：</h4><p>由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main.js文件中</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当你使用 history 模式时，URL 就像正常的 url，例如 <a target="_blank" rel="noopener" href="http://yoursite.com/user/id%EF%BC%8C%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9C%8B%EF%BC%81">http://yoursite.com/user/id，比较好看！</a><br>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a target="_blank" rel="noopener" href="http://oursite.com/user/id">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。<br>所以呢，<strong>你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const routes &#x3D; [ </span><br><span class="line"> &#123;path: &quot;&#x2F;&quot;, name: &quot;homeLink&quot;, component:Home&#125;</span><br><span class="line"> &#123;path: &quot;&#x2F;register&quot;, name: &quot;registerLink&quot;, component: Register&#125;,</span><br><span class="line"> &#123;path: &quot;&#x2F;login&quot;, name: &quot;loginLink&quot;, component: Login&#125;,</span><br><span class="line"> &#123;path: &quot;*&quot;, redirect: &quot;&#x2F;&quot;&#125;]</span><br></pre></td></tr></table></figure>

<p>此处就设置如果URL输入错误或者是URL 匹配不到任何静态资源，就自动跳到到Home页面</p>
<h4 id="3、使用路由模块来实现页面跳转的方式"><a href="#3、使用路由模块来实现页面跳转的方式" class="headerlink" title="3、使用路由模块来实现页面跳转的方式"></a>3、使用路由模块来实现页面跳转的方式</h4><p>方式1：直接修改地址栏</p>
<p>方式2：this.$router.push(‘路由地址’)</p>
<p>方式3：<code>&lt;router-link to=&quot;路由地址&quot;&gt;&lt;/router-link&gt;</code></p>
<p>一、验证用户身份</p>
<p>大部分项目，除了登录页、重置密码页、用户协议页以外，页面都需要验证用户身份进行访问。使用 Vue Router 可以配合后端进行双重验证</p>
<p>给需要验证的路由对象添加 meta 字段，里面自定义一个代表验证的字段</p>
<p>（登录）验证身份方法：</p>
<p>1、给需要验证的路由对象添加 meta 字段，里面自定义一个代表验证的字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">	  name:&#39;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#39;bar&#39;,</span><br><span class="line">          component: Bar,</span><br><span class="line">          meta: &#123; </span><br><span class="line">              requiresAuth: true &#x2F;&#x2F; 添加该字段，表示进入这个路由是需要登录的</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2、在全局导航钩子里验证 requiresAuth 字段：</p>
<p>注意事项：</p>
<ul>
<li>使用 beforeEach 在路由变化前验证。验证原理是在跳转前，访问目标路由对象的 requiresAuth 字段判断是否需要验证用户身份，如为是，检测是否有保存用户信息（即用户登录成功后前端保存的信息，例如 token）</li>
<li>每个路由都有一个 $route.matched 数组，包含当前路由的父级路由对象和当前路由对象，在组件中可以通过 this.$route.matched 访问</li>
<li>beforeEach 的 to 参数即目标路由对象 $route，to.matched 即是它的路由数组</li>
<li>因此，使用 some 方法，只要路由数组里的任意路由对象需要验证身份，即进行验证</li>
<li>验证成功跳转正确页面；失败则跳到登录页，将目标地址附在 url 的 query 里，登录成功就跳转到目标地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  if (to.matched.some(record &#x3D;&gt; record.meta.requiresAuth)) &#123;</span><br><span class="line">    if (!auth.loggedIn()) &#123;  &#x2F;&#x2F; 没登录</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: &#39;&#x2F;login&#39;,</span><br><span class="line">        query: &#123; redirect: to.fullPath &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()  &#x2F;&#x2F; 确保一定要调用 next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next() &#x2F;&#x2F; 确保一定要调用 next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3、拦截 http 请求，验证用户身份</p>
<p>为了防止本地保存的 token 过期，需要拦截 http 请求，为每次请求头加上 token ，然后拦截 http 响应，根据响应内容判断是否需要跳回登录页面重新登录。使用 axios 的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; http request 拦截器</span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    config &#x3D;&gt; &#123;</span><br><span class="line">        if (auth.loggedIn()) &#123; &#x2F;&#x2F; 判断是否存在token，如果存在的话，则每个http header都加上token</span><br><span class="line">            config.headers.Authorization &#x3D; &#96;token $&#123;auth.loggedIn()&#125;&#96;;</span><br><span class="line">        &#125;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;,</span><br><span class="line">    err &#x3D;&gt; &#123;</span><br><span class="line">        return Promise.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http response 拦截器</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    response &#x3D;&gt; &#123;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;,</span><br><span class="line">    error &#x3D;&gt; &#123;</span><br><span class="line">        if (error.response) &#123;</span><br><span class="line">            switch (error.response.status) &#123;</span><br><span class="line">                case 401:</span><br><span class="line">                    &#x2F;&#x2F; Unauthorized</span><br><span class="line">                    &#x2F;&#x2F; 返回 401 清除token信息并跳转到登录页面</span><br><span class="line">                    auth.clear();</span><br><span class="line">                    router.replace(&#123;</span><br><span class="line">                        path: &#39;login&#39;,</span><br><span class="line">                        query: &#123;</span><br><span class="line">                            redirect: router.currentRoute.fullPath</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error.response.data) &#x2F;&#x2F; 返回接口返回的错误信息</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>二、定义用户权限能访问的页面</p>
<p>前端查看权限，也是配合后端进行某些页面的隐藏显示功能。一般应用于综合的办公系统，由 IT 部分配账号，不同部门的人只能看到自己负责的内容，例如行政部不会看到财务数据页面。</p>
<p>实现方法：</p>
<ol>
<li>与后端商定每个用户角色对应的 level 级别，以数值表示</li>
<li>前端路由每个页面的 meta 对象添加 level 字段，值为数组，里面是有权限访问页面的 level 数值</li>
<li>登录成功，后台返回用户 token 的同时，返回其所属的 level 字段</li>
<li>组件代码比较目标页面的 level 与用户 level，只显示包含在目标 level 数组里的页面</li>
<li>全局导航钩子 beforeEach 里比较目标页面的 level 与用户 level，包含在目标 level 数组里则正确跳转，反之取消跳转并提示权限不足</li>
</ol>
<blockquote>
<p>上面第5步是为了防止用户直接在浏览器输入目标地址</p>
</blockquote>
<p>三、其他内容控制</p>
<p>可以控制显示路由固定的搭配，例如某个路由地址的 title 是固定的字符串、固定的欢迎语、固定的 favicon 等。在组件里通过 this.$route.meta.xxx 访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#39;bar&#39;,</span><br><span class="line">          component: Bar,</span><br><span class="line">          meta: &#123; </span><br><span class="line">              title: &#39;标题&#39;,</span><br><span class="line">              message: &#39;欢迎您&#39;,</span><br><span class="line">              requiresAuth: true &#x2F;&#x2F; 添加该字段，表示进入这个路由是需要登录的</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>动态路由匹配是用于把某种模式匹配到的所有路由，全都映射到同个组件。通过给路由路径一个变量，即变成动态路由，把变化的内容赋值给变量即可。</p>
<p>例如文章详情页是一个组件，只有一个路由，从文章列表页点进来，变化的只是文章 id 而已。将其赋予给设定的变量，然后通过在组件里 watch $route 或者使用 beforeRouteUpdate 导航守卫监测路由变化，传递新的文章 id 获取文章详情即可。在组件里，可以通过<code>this.$route.params.xx</code>获取当前文章 id。</p>
<p>一个路由地址可以设置多个变量，适合有分叉情况的内容。例如 path: ‘/params/:foo/:bar’</p>
<blockquote>
<p>从文章列表页点进来即传递路由变量，有三种方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）&lt;router-link to&#x3D;&quot;&#x2F;params&#x2F;list&#x2F;1&quot;&gt;跳转到 &#x2F;params&#x2F;list&#x2F;1&lt;&#x2F;router-link&gt;&#96;</span><br><span class="line">（2）this.$router.push(&#123; name: &#39;articles&#39;, params: &#123; foo: &#39;list&#39;, bar: 1 &#125; &#125;)&#96;</span><br><span class="line">（3）this.$router.push(&#123; path: &#39;&#x2F;params&#x2F;list&#x2F;1&#39; &#125;) &#x2F;&#x2F; path 不能与 params 同时使用</span><br></pre></td></tr></table></figure>



<p>高级匹配模式</p>
<p>这里主要研究的是动态路由匹配的高级匹配模式，以达到合并差异不大的路由、减少路由数量的目的。</p>
<p>高级匹配即结合简单的正则匹配方法，给予路由更多的限制和操作空间。</p>
<p>1、可选路由参数</p>
<p>路由参数可选，添加与否都对应同一个组件。可以在组件里使用 v-if / v-show 结合 $route.params.xx 展现不同的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a param can be made optional by adding &quot;?&quot;</span><br><span class="line">&#123; path: &#39;&#x2F;optional-params&#x2F;:foo?&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个链接都对应同个组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-params&quot;&gt;&#x2F;optional-params&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-params&#x2F;foo&quot;&gt;&#x2F;optional-params&#x2F;foo&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

<p>2、精确匹配参数</p>
<p>只有参数通过正则匹配，完全符合格式，才能会跳转。例如只有参数是数字/手机号才允许跳转。适用于对第三方不规范格式的数据进行筛选。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a param can be followed by a regex pattern in parens</span><br><span class="line">&#x2F;&#x2F; this route will only be matched if :id is all numbers</span><br><span class="line">&#123; path: &#39;&#x2F;params-with-regex&#x2F;:id(\\d+)&#39; &#125;</span><br><span class="line">&#x2F;&#x2F; 只匹配数字</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;params-with-regex&#x2F;123&quot;&gt;&#x2F;params-with-regex&#x2F;123&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只匹配手机号</span><br><span class="line">&#123; path: &#39;&#x2F;params-with-regex&#x2F;:id(^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$)&#39; &#125;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;params-with-regex&#x2F;13800138000&quot;&gt;&#x2F;params-with-regex&#x2F;13800138000&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

<p>3、匹配任意参数</p>
<p>不对参数格式、数量进行限制，任意参数都可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; asterisk can match anything</span><br><span class="line">&#123; path: &#39;&#x2F;asterisk&#x2F;*&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个都是同一组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;asterisk&#x2F;foo&quot;&gt;&#x2F;asterisk&#x2F;foo&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;asterisk&#x2F;foo&#x2F;bar&quot;&gt;&#x2F;asterisk&#x2F;foo&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

<p>4、部分可选参数</p>
<p>结合可选路由参数与多路由参数，其中一部分参数可选。适用于分叉情况下不确定参数数量的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; make part of the path optional by wrapping with parens and add &quot;?&quot;</span><br><span class="line">&#123; path: &#39;&#x2F;optional-group&#x2F;(foo&#x2F;)?bar&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个都是同一组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-group&#x2F;bar&quot;&gt;&#x2F;optional-group&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-group&#x2F;foo&#x2F;bar&quot;&gt;&#x2F;optional-group&#x2F;foo&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>





<h3 id="路由的跳转"><a href="#路由的跳转" class="headerlink" title="路由的跳转"></a>路由的跳转</h3><p>1、router-link （声明式路由）</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 不带参数</span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;&#125;&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;</span>&gt;</span> //name,path都行, 建议用name  </span><br><span class="line">   // 注意：router-link中链接如果是&#x27;/&#x27;开始就是从根路由开始，如果开始不带&#x27;/&#x27;，则从当前路由开始。</span><br><span class="line"></span><br><span class="line">2.带参数</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;, params: &#123;id:1&#125;&#125;&quot;</span>&gt;</span>  </span><br><span class="line">// params传参数 (类似post)</span><br><span class="line">// 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot; </span><br><span class="line">// 不配置path ,第一次可请求,刷新页面id会消失</span><br><span class="line">// 配置path,刷新页面id会保留</span><br><span class="line"></span><br><span class="line">// html 取参  $route.params.id</span><br><span class="line">// script 取参  this.$route.params.id</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;, query: &#123;id:1&#125;&#125;&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>   2、router.push(编程式路由)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">router.push(&#39;home&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象</span><br><span class="line">router.push(&#123; path: &#39;home&#39; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命名的路由</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 带查询参数，变成 &#x2F;register?plan&#x3D;private</span><br><span class="line">router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userId &#x3D; &#39;123&#39;</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">router.push(&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user</span><br></pre></td></tr></table></figure>

<p>3、this.$router.push() (函数里面调用)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.  不带参数</span><br><span class="line"></span><br><span class="line">this.$router.push(&#39;&#x2F;home&#39;)</span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;&#125;)</span><br><span class="line">this.$router.push(&#123;path:&#39;&#x2F;home&#39;&#125;)</span><br><span class="line"></span><br><span class="line">2. query传参 </span><br><span class="line"></span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;)</span><br><span class="line">this.$router.push(&#123;path:&#39;&#x2F;home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; html 取参  $route.query.id</span><br><span class="line">&#x2F;&#x2F; script 取参  this.$route.query.id</span><br><span class="line"></span><br><span class="line">3. params传参</span><br><span class="line"></span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;,params: &#123;id:&#39;1&#39;&#125;&#125;)  &#x2F;&#x2F; 只能用 name</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 路由配置 path: &quot;&#x2F;home&#x2F;:id&quot; 或者 path: &quot;&#x2F;home:id&quot; ,</span><br><span class="line">&#x2F;&#x2F; 不配置path ,第一次可请求,刷新页面id会消失</span><br><span class="line">&#x2F;&#x2F; 配置path,刷新页面id会保留</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; html 取参  $route.params.id</span><br><span class="line">&#x2F;&#x2F; script 取参  this.$route.params.id</span><br><span class="line"></span><br><span class="line">4. query和params区别</span><br><span class="line">   query类似 get, 跳转之后页面 url后面会拼接参数,类似?id&#x3D;1, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在</span><br><span class="line"></span><br><span class="line">params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>this.$router.replace() (用法同上,push)</p>
</li>
<li><p>this.$router.go(n) ()</p>
</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$router.go(n)</span><br><span class="line">   向前或者向后跳转n个页面，n可为正整数或负整数</span><br></pre></td></tr></table></figure>

<p>  ps : 区别</p>
<p>  this.$router.push<br>  跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面<br>  this.$router.replace<br>  跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)</p>
<p>  this.$router.go(n)<br>  向前或者向后跳转n个页面，n可为正整数或负整数</p>
<p>注意：获取路由上面的参数，用的是$route，后面没有r<br>params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。<br>params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。<br>params、query不设置也可以传参，但是params不设置的时候，刷新页面或者返回参数会丢失，</p>
<p>两者都可以传递参数，区别是什么？<br>query 传参配置的是path，而params传参配置的是name，在params中配置path无效<br>query在路由配置不需要设置参数，而params必须设置<br>query传递的参数会显示在地址栏中<br>params传参刷新会无效，但是query会保存传递过来的值，刷新不变</p>
<p><strong>Vue router的query对象里的值的问题</strong></p>
<p>在使用 $router.push() 时，如果使用了query，则可以在跳转后从query中获取到对应的参数。如果传的是字符串自然没问题，但是如果传的其他类型的数据，在跳转之后是正常的，而跳转之后再刷新一遍页面的话，query里面的属性的值都会变成字符串。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123; name:&#39;product&#39;, query: &#123;canSee: false&#125; &#125;);</span><br></pre></td></tr></table></figure>

<p>　　最初跳转之后，this.$route.query.canSee打印的值是Boolean类型的。然后刷新一下，值就变成了String类型了。个人猜测是因为刷新后query的值是直接从页面URL中取的，而在页面URL上的参数的类型只能是字符串类型。</p>
<p><strong>解决方法</strong>：</p>
<p>　　1. 在传值之前把要传的参数单独放到一个对象里，在放到query里面，然后进行JSON.stringify()处理，到了目标页面后再进行JSON.parse()处理，还原对象。这种方法的好处是可以一次性处理多个参数，而且适用度高，建议使用这种方法。</p>
<p>　　2. 传值前不做处理，到了目标页面后再单独对原本为非字符串的数据进行JSON.parse()处理。缺点是字符串类型的数据不能如此处理，要确保该数据不是字符串类型的。局限性大，不推荐适用。</p>
<h3 id="vue项目中跳转到外部链接方法"><a href="#vue项目中跳转到外部链接方法" class="headerlink" title="vue项目中跳转到外部链接方法"></a>vue项目中跳转到外部链接方法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;goPage(&#x27;http://www.chao99.top&#x27;)&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    goPage (url) &#123;</span><br><span class="line">            window.location.href = url</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果用.push的路由跳转，会在路径外面再加一个基本的url导致出错，例如本地项目：会在外部链接前面加上了<a target="_blank" rel="noopener" href="http://localhost:8080/#/">http://localhost:8080/#/</a></p>
<p>一定要注意, 外部链接要加上 http:// , 不然跳转还是当前域名下</p>
<h2 id="VUE的图片路径"><a href="#VUE的图片路径" class="headerlink" title="VUE的图片路径"></a>VUE的图片路径</h2><p>官方文档没有存放静态的asset 文件了 ,静态现在存放在public 的里面. 但是在public里面去创建一个img 的文件,去放置图片,依然不可以. </p>
<p>所以 三种办法里面 只有require 使用vuecli3 ,</p>
<p>1、在模板中直接引入图片资源（这种一般是@ 或者./ 去引入）</p>
<p>2、将图片资源放在static文件夹下</p>
<p>3、图片资源在assets文件夹下，data中必须用require加载，否则会当成字符串来处理<br>(我自己目前就是放在assets 里面. 因为是本地上传的 在做假数据的时候准备做一个预览,或者说以后的默认图片就是它了)<br>第二种，只要给图片放在static文件夹下即可：原因如下</p>
<p>这里在使用vuecli脚手脚构建工具，目录下会生成一个static目录，表示的是静态目录，推荐大家将img 存放在这个目录下，那么在webpack编译以后，依旧是可以获取到这个目录下的路径，这样就解决了路径不符而导致图片加载不出来的问题！当然项目中用的一般都是绝对路径，少数图片的话，这种方式挺好<br>但是 重点: vuecli3 没有static 啊!!!</p>
<h1 id="VUE的模板语法"><a href="#VUE的模板语法" class="headerlink" title="VUE的模板语法"></a>VUE的模板语法</h1><p>Vue 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p>
<p>Vue 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。</p>
<p>结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上</p>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>数据绑定最常见的形式就是使用 **<code>&#123;&#123;...&#125;&#125;</code>**（双大括号）的文本插值：</p>
<h5 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h5><p><code>&lt;div id=&quot;app&quot;&gt;   &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt;</code></p>
<p><strong><code>&#123;&#123;...&#125;&#125;</code></strong> 标签的内容将会被替代为对应组件实例中 <strong>message</strong> 属性的值，如果 <strong>message</strong> 属性的值发生了改变，**<code>&#123;&#123;...&#125;&#125;</code>** 标签内容也会更新。</p>
<p>如果不想改变标签的内容，可以通过使用 <strong>v-once</strong> 指令执行一次性地插值，当数据改变时，插值处的内容不会更新。</p>
<p><code>&lt;span v-once&gt;这个将不会改变: &#123;&#123; message &#125;&#125;&lt;/span&gt;</code></p>
<h5 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h5><p>使用 v-html 指令用于输出 html 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v-html 指令</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用双大括号的文本插值: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用 v-html 指令: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> RenderHtmlApp = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      rawHtml: &#x27;<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>这里会显示红色！<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(RenderHtmlApp).mount(<span class="string">&#x27;#example1&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>HTML 属性中的值应使用 v-bind 指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>对于布尔属性，常规值为 true 或 false，如果属性值为 null 或 undefined，则该属性不会显示出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-bind:disabled&#x3D;&quot;isButtonDisabled&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>以上代码中如果 isButtonDisabled 的值是 null 或 undefined，则 disabled 属性甚至不会被包含在渲染出来的 <code>&lt;button&gt; </code>元素中。</p>
<p>以下实例判断 use 的值，如果为 true 使用 class1 类的样式，否则不使用该类：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v-bind 指令</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;r1&quot;</span>&gt;</span>修改颜色<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;use&quot;</span> <span class="attr">id</span>=<span class="string">&quot;r1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123;&#x27;class1&#x27;: use&#125;&quot;</span>&gt;</span></span><br><span class="line">    v-bind:class 指令</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      use: <span class="literal">false</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(app).mount(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><p>Vue.js 都提供了完全的 JavaScript 表达式支持。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 表达式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;5+5&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span>菜鸟教程<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> HelloVueApp = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      ok: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;RUNOOB!!&#x27;</span>,</span></span><br><span class="line">      id: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(HelloVueApp).mount(<span class="string">&#x27;#hello-vue&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  这是语句，不是表达式：--&gt;</span><br><span class="line">&#123;&#123; var a &#x3D; 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令是带有 v- 前缀的特殊属性。</p>
<p>指令用于在表达式的值改变时，将某些行为应用到 DOM 上。如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-if&#x3D;&quot;seen&quot;&gt;现在你看到我了&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      seen: true  &#x2F;* 改为false，信息就无法显示 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这里， v-if 指令将根据表达式 seen 的值( true 或 false )来决定是否插入 p 元素。</p>
<p>另外还有其它很多指令，每个都有特殊的功能。例如，v-for 指令可以绑定数组的数据来渲染一个项目列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;ol&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;site in sites&quot;&gt;</span><br><span class="line">      &#123;&#123; site.text &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      sites: [</span><br><span class="line">        &#123; text: &#39;Google&#39; &#125;,</span><br><span class="line">        &#123; text: &#39;Runoob&#39; &#125;,</span><br><span class="line">        &#123; text: &#39;Taobao&#39; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;菜鸟教程&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const HelloVueApp &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      url: &#39;https:&#x2F;&#x2F;www.runoob.com&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(HelloVueApp).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。</p>
<p>另一个例子是 v-on 指令，它用于监听 DOM 事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a @[event]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>在这里参数是监听的事件名。</p>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>修饰符是以半角句号 <strong>.</strong> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，**.prevent** 修饰符告诉 <strong>v-on</strong> 指令对于触发的事件调用 **event.preventDefault()**：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><p>在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">双向数据绑定</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Runoob!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>v-model</strong> 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。</p>
<p>按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。</p>
<p>以下实例在用户点击按钮后对字符串进行反转操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">字符串反转</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;&#x2F;title&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue@next&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;reverseMessage&quot;&gt;反转字符串&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Runoob!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage() &#123;</span><br><span class="line">      this.message &#x3D; this.message</span><br><span class="line">        .split(&#39;&#39;)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h4><p>Vue.js 为两个最为常用的指令提供了特别的缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h1 id="VUE的条件语句"><a href="#VUE的条件语句" class="headerlink" title="VUE的条件语句"></a>VUE的条件语句</h1><h1 id="VUE的循环语句"><a href="#VUE的循环语句" class="headerlink" title="VUE的循环语句"></a>VUE的循环语句</h1><h1 id="VUE的组件"><a href="#VUE的组件" class="headerlink" title="VUE的组件"></a>VUE的组件</h1><h1 id="VUE的计算属性"><a href="#VUE的计算属性" class="headerlink" title="VUE的计算属性"></a>VUE的计算属性</h1><h1 id="VUE的监听属性"><a href="#VUE的监听属性" class="headerlink" title="VUE的监听属性"></a>VUE的监听属性</h1><h1 id="VUE的样式绑定"><a href="#VUE的样式绑定" class="headerlink" title="VUE的样式绑定"></a>VUE的样式绑定</h1><h1 id="VUE的事件处理"><a href="#VUE的事件处理" class="headerlink" title="VUE的事件处理"></a>VUE的事件处理</h1><h3 id="VUE的方法"><a href="#VUE的方法" class="headerlink" title="VUE的方法"></a>VUE的方法</h3><p>方法名: async function () {}</p>
<p>async 方法名() {}</p>
<h1 id="VUE中用到的一些关键字"><a href="#VUE中用到的一些关键字" class="headerlink" title="VUE中用到的一些关键字"></a>VUE中用到的一些关键字</h1><h3 id="let、var和const"><a href="#let、var和const" class="headerlink" title="let、var和const"></a>let、var和const</h3><p>ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。</p>
<ol>
<li>var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。可以修改，如果不初始化会输出undefined，不会报错</li>
<li>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不可在声明之前调用，必须先定义再使用，否则会报错。不能定义同名变量。</li>
<li>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。</li>
</ol>
<p><strong>let和const属于局部变量，不会出现变量提升的情况，全局定义的let和const变量，不属于顶层变量，不属于window的属性</strong>。let和const不允许重复声明，let和const不会绑定全局作用域</p>
<p>变量提升：可以在变量定义前使用定义过的变量。</p>
<p>暂时性死区（TDZ）：在运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。常见于：let、const、import、class、typeof等</p>
<p><strong>let和const定义的变量都会被提升，但是不会被初始化，不能被引用</strong></p>
<h3 id="fullPath和path"><a href="#fullPath和path" class="headerlink" title="fullPath和path"></a>fullPath和path</h3><ul>
<li><p>$route.fullPath</p>
<ul>
<li>type: <code>string</code><br>The full resolved URL including query and hash.</li>
</ul>
</li>
<li><p>$route.path</p>
<ul>
<li>type: <code>string</code><br>A string that equals the path of the current route, always resolved as an absolute path. e.g. “/foo/bar”.</li>
</ul>
</li>
</ul>
<p>fullPath能缓存路由跳转后面携带的参数，刷新后依旧存在， 在PC端能起作用</p>
<p>而 path则不能缓存路由跳转后面携带的参数，所以path  能在<code>只有两层数据结构的</code>移动端起作用<br>   原因：</p>
<p>一般，移动端App 只能往里面走，表面和切换的页面是第一层， 点击功能按钮进去的是第二层。<br>这种层级的关系其实 是具有跳转作用，所以在第一层获取的数据，与第二层来回切换没问题。但是你第二层到第三层一来回切换，路由跳转携带的参数就丢失了。</p>
<p>fullPath匹配路由，path匹配路径。</p>
<p>例如：</p>
<p>路由是：<code>/path/one</code><br>真正路径是：<code>/path/true</code></p>
<p>那么此时path为<code>/path/true</code>，而fullPath为<code>/path/one</code></p>
<h3 id="this和that"><a href="#this和that" class="headerlink" title="this和that"></a>this和that</h3><p>在Vue中this始终指向Vue，但axios中this为undefined</p>
<p><img src="https://img-blog.csdn.net/20171102210352732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzgyMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>若需要赋值给变量用以渲染数据，可以通过=&gt;函数，这时this为Vue</p>
<p><img src="https://img-blog.csdn.net/20171102210527538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzgyMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>或者可以直接通过：<br>let that = this<br>将this保存在that中，再在函数中使用that均可 </p>
<p>个人理解：一般情况下，this就是此vue的页面，可以调用此页面的函数。但是涉及到异步axios时，this没有指向了。需要（）=&gt;{}，在{}里this才会指代vue。</p>
<p>如果不使用（）=&gt;{}方法，可以进行双向绑定：let that = this  ，将this保存在that中，再在函数中使用that均就可以了</p>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>return不论是什么，都是直接返回，即使是语句或者函数也不会执行的！是函数就返回该函数！</p>
<p>下面从一个例子来加深对return用法的理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(‘xxxx’)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; <span class="keyword">return</span> res.data.result.info &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在axios和ajax中经常会用到return，从上面的代码可以看到有两个return，每个return的作用都需要理解：</p>
<p>第一个return后面跟的是axios配置，这个return就是将整个axios返回出来；</p>
<p>第二个return是在axios请求成功后将响应数据返回出来，即第二个return就是将axios异步请求的数据返回出来。</p>
<p>函数中有ajax和axios调用的有异步和同步，是异步的话里面如果有return，在函数外层（函数是指getTable()）调用的时候会取不到数据，除非换成同步。如果想异步取到数据，就需要在函数外层也加个return，相当于把ajax或者axios 整个配置返回出来，返回出来的数据格式是[object,promise]，所以函数执行获得的数据格式就是[object,promise]，然后使用.then()的形式将里面返回的数据拿出来!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> getTable().then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="built_in">this</span>.tableData = res&#125;) <span class="comment">//此出先调用getTable()拿到axios的数据，然后在.then()出来结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此段代码的目的是将axios异步请求的结果返回出来，因为是异步所以不能直接在axios里return数据，所以需要在axios外层也加个return，这样就可以拿到了。</p>
<h3 id="set：this-set"><a href="#set：this-set" class="headerlink" title="set：this.$set"></a>set：this.$set</h3><p>由于JavaScript的限制，Vue不能检测以下变动的数组,页面不会刷新：</p>
<p>1.当你利用索引值直接设置一个项时。<code>vm.items[indexOfItem]=newValue</code></p>
<p>2.当你修改数组的长度时。<code>vm.items.length=newLength</code></p>
<p>使用Vue.set、vm.$set()或者数组的splice方法。使数值改变后，页面进行刷新后的效果展示</p>
<p>注：$set()方法调用时，页面会全部更新一遍</p>
<h1 id="VUE的生命周期"><a href="#VUE的生命周期" class="headerlink" title="VUE的生命周期"></a>VUE的生命周期</h1><p>生命周期：</p>
<p>​    beforecreate : 一般使用场景是在加 loading事件 的时候<br>​    created ：处于loading结束后，还做一些初始化，实现函数自执行（data数据已经初始化，但是DOM结构渲染完成，组件没有加载）<br>​    beforemount：处于组件创建完成，但未开始执行操作<br>​    mounted (安装)：处于发起后端请求，获取数据，配合路由钩子执行操作（DOM渲染完成，组件挂载完成 ）<br>​    beforeupdate、updated：处于数据更新的前后<br>​    beforeDestroy：当前组件还在的时候，想删除组件<br>​    destroyed ：当前组件已被销毁，清空相关内容</p>
<p><img src="/8.6.VUE/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVjlSR1A_dz0xMjAwJmg9MzAzOQ" alt="clipboard.png"></p>
<p>created 与 mounted 的区别</p>
<p>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。<br>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</p>
<p>mounted 与 methods 的区别</p>
<p>mounted 是生命周期方法之一，会在对应生命周期时执行。</p>
<p>methods 是Vue实例对象上绑定的方法，供当前Vue组件作用域内使用，未调用不会执行，只执行逻辑，返回值可有可无。</p>
<p>computed 与 watched 的区别</p>
<p>computed 是计算属性，也可以理解为一个方法。其中计算的结果如果不发生改变就不会触发，且必须返回一个值并在DOM中绑定的才能取得值。他可以自动获取数据的改变。</p>
<p>watched 属性是手动定义的所需监听的值，不同的数据可以在其中多次定义监听值，这时会消耗一定性能，他并不能像computed那样自动改变。</p>
<h1 id="和-的区别"><a href="#和-的区别" class="headerlink" title="==和===的区别"></a><code>==</code>和<code>===</code>的区别</h1><p>1<code>==</code>‘1’;这个等式是成立的；<br>1<code>===</code>‘1’;这个等式是不成立的。<br><code>==</code>只判断数值，<code>===</code>既判断数值，也判断类型。</p>
<h1 id="VUE项目的运行"><a href="#VUE项目的运行" class="headerlink" title="VUE项目的运行"></a>VUE项目的运行</h1><p>1.先加载依赖包：控制台直接输入<code> npm install</code></p>
<p>也可以webstorm软件进去右下角会出现一个<code> npm install</code>，直接点击</p>
<p>install的意思是安装前端用到的依赖包，运行之后，会生成一个node_modules文件。</p>
<p>2.本地运行项目可以控制台执行命令: <code>npm run serve</code>代表执行本地运行项目，此时运行的端口号默认为8080，后端的接口配置为.env.development（测试环境）文件下的端口号。</p>
<p>也可以使用webstorm自带的工具：右上角选“+”，找到npm，在npm的edit界面：Command设置为<code>run</code>，Scripts为 <code> serve</code>，（记得选当前文件的package.json）默认端口号为8080，也可以在Environment里自己写，port=XXXX（端口号自己随便设置）</p>
<p><img src="C:\Users\swx\AppData\Roaming\Typora\typora-user-images\image-20210412195648588.png" alt="image-20210412195648588"></p>
<p>运行后出现localhost：8080一般就成功了。</p>
<p>3.打包时控制台输入命令：<code>npm run build</code>，代表打包，完成后会生成一个dist文件夹，就是打包后的项目，部署到服务器即发布成功。build会执行.env.production（生产环境）下的配置</p>
<p>dist文件夹：</p>
<p>css文件夹下的.css文件是项目要用到的css文件,当你做webpack打包的时候，会把所有的css样式打包到这里<br>css文件夹下的.css.map文件是一个Source map文件，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。目的是帮助我们调试被压缩过的css代码，只是方便我们开发的时候做调试使用。<br>js文件夹下的.js.map依然是Source map文件，方便我们开发时调试js代码使用。<br>app.js文件里放的是项目中各个页面的逻辑代码<br>manifest.js文件可以理解为webpack打包生成的一个配置文件，我们一般不需要关心它<br>vendor.js放的是各个页面各个组件公用的一些代码<br>index.html使我们前端代码入口的一个html文件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/8.6.VUE/" data-id="ckq1xbdvy006ipwwdd1m8hx6n" data-title="VUE" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2.1.Typora使用快捷键" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/2.1.Typora%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:04:13.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/2.1.Typora%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/">Typora使用快捷键</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#+空格</td>
<td align="left">标题（几个#就是几级标题）</td>
</tr>
<tr>
<td align="left">ctrl+数字</td>
<td align="left">数字是几就是几级标题</td>
</tr>
<tr>
<td align="left">```+代码格式英文</td>
<td align="left">相应的代码块</td>
</tr>
<tr>
<td align="left">Ctrl+Shift+K</td>
<td align="left">插入代码块(```xxx)</td>
</tr>
<tr>
<td align="left">左下角启用源代码格式</td>
<td align="left">加```可以修改代码块的位置</td>
</tr>
<tr>
<td align="left">Ctrl + /</td>
<td align="left">源代码模式</td>
</tr>
<tr>
<td align="left">``中间放要引用的东西</td>
<td align="left">相应的代码片</td>
</tr>
<tr>
<td align="left">Ctrl+Shift+`</td>
<td align="left">插入代码片(<code>xxx</code>)</td>
</tr>
<tr>
<td align="left">—</td>
<td align="left">分隔符</td>
</tr>
<tr>
<td align="left">-+空格</td>
<td align="left">例举的圆点</td>
</tr>
<tr>
<td align="left">ctrl+b</td>
<td align="left">加粗</td>
</tr>
<tr>
<td align="left">Ctrl+U</td>
<td align="left">下划线</td>
</tr>
<tr>
<td align="left">Ctrl+I</td>
<td align="left">倾斜</td>
</tr>
<tr>
<td align="left">Ctrl+[</td>
<td align="left">减少缩进</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + V</td>
<td align="left">粘贴为纯文本</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ctrl+t</td>
<td align="left">插入一个表格</td>
</tr>
<tr>
<td align="left">表格里ctrl+回车</td>
<td align="left">下面新加一行</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Backspace</td>
<td align="left">删除行（在表中）</td>
</tr>
</tbody></table>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新</td>
<td align="left">Ctrl + N.</td>
<td align="left">Command + N.</td>
</tr>
<tr>
<td align="left">新窗户</td>
<td align="left">Ctrl + Shift + N.</td>
<td align="left">Command + Shift + N.</td>
</tr>
<tr>
<td align="left">打开</td>
<td align="left">Ctrl + O.</td>
<td align="left">Command + O.</td>
</tr>
<tr>
<td align="left">快速打开</td>
<td align="left">Ctrl + P.</td>
<td align="left">Command + Shift + O.</td>
</tr>
<tr>
<td align="left">重新打开已关闭的文件</td>
<td align="left">Ctrl + Shift + T.</td>
<td align="left">Command + Shift + T.</td>
</tr>
<tr>
<td align="left">另存为/重复</td>
<td align="left">Ctrl + Shift + S.</td>
<td align="left">Command + Shift + S.</td>
</tr>
<tr>
<td align="left">偏爱/偏好设置</td>
<td align="left">Ctrl +，</td>
<td align="left">Command +，</td>
</tr>
<tr>
<td align="left">关</td>
<td align="left">Ctrl + W</td>
<td align="left">Command + W</td>
</tr>
</tbody></table>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新段落</td>
<td align="left">输入</td>
<td align="left">输入</td>
</tr>
<tr>
<td align="left">新队</td>
<td align="left">Shift + Enter</td>
<td align="left">Shift + Enter</td>
</tr>
<tr>
<td align="left">复制为Markdown</td>
<td align="left">Ctrl + Shift + C.</td>
<td align="left">Command + Shift + C.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">Command + Shift + V.</td>
</tr>
<tr>
<td align="left">全选</td>
<td align="left">Ctrl + A.</td>
<td align="left">Command + A.</td>
</tr>
<tr>
<td align="left">选择行/句子 选择行（在表格中）</td>
<td align="left">Ctrl + L.</td>
<td align="left">Command + L.</td>
</tr>
<tr>
<td align="left">选择样式范围 选择单元格（在表格中）</td>
<td align="left">Ctrl + E.</td>
<td align="left">Command + E.</td>
</tr>
<tr>
<td align="left">选择Word</td>
<td align="left">Ctrl + D.</td>
<td align="left">Command + D.</td>
</tr>
<tr>
<td align="left">删除Word</td>
<td align="left">Ctrl + Shift + D.</td>
<td align="left">Command + Shift + D.</td>
</tr>
<tr>
<td align="left">跳到顶部</td>
<td align="left">Ctrl + Home</td>
<td align="left">Command +↑</td>
</tr>
<tr>
<td align="left">跳转到选择</td>
<td align="left">Ctrl + J</td>
<td align="left">Command + J</td>
</tr>
<tr>
<td align="left">跳到Buttom</td>
<td align="left">Ctrl + End</td>
<td align="left">Command +↓</td>
</tr>
<tr>
<td align="left">找</td>
<td align="left">Ctrl + F.</td>
<td align="left">Command + F.</td>
</tr>
<tr>
<td align="left">找下一个</td>
<td align="left">F3 /回车</td>
<td align="left">Command + G / Enter</td>
</tr>
<tr>
<td align="left">找到上一个</td>
<td align="left">Shift + F3 / Shift + Enter</td>
<td align="left">Command + Shift + G / Shift + Enter</td>
</tr>
<tr>
<td align="left">更换</td>
<td align="left">Ctrl + H.</td>
<td align="left">Command + H.</td>
</tr>
</tbody></table>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">段</td>
<td align="left">Ctrl + 0</td>
<td align="left">命令+ 0</td>
</tr>
<tr>
<td align="left">提高标题级别</td>
<td align="left">Ctrl + =</td>
<td align="left">命令+ =</td>
</tr>
<tr>
<td align="left">降低标题级别</td>
<td align="left">Ctrl + -</td>
<td align="left">命令+ -</td>
</tr>
<tr>
<td align="left">表</td>
<td align="left">Ctrl + T.</td>
<td align="left">Command + Option + T.</td>
</tr>
<tr>
<td align="left">代码围栏</td>
<td align="left">Ctrl + Shift + K.</td>
<td align="left">Command + Option + C.</td>
</tr>
<tr>
<td align="left">数学块</td>
<td align="left">Ctrl + Shift + M.</td>
<td align="left">Command + Option + B.</td>
</tr>
<tr>
<td align="left">引用</td>
<td align="left">Ctrl + Shift + Q.</td>
<td align="left">Command + Option + Q.</td>
</tr>
<tr>
<td align="left">订购清单</td>
<td align="left">Ctrl + Shift + [</td>
<td align="left">Command + Option + O.</td>
</tr>
<tr>
<td align="left">无序列表</td>
<td align="left">Ctrl + Shift +]</td>
<td align="left">Command + Option + U.</td>
</tr>
<tr>
<td align="left">减少缩进</td>
<td align="left">Ctrl +] / Shift + Tab</td>
<td align="left">Command +] / Shift + Tab</td>
</tr>
</tbody></table>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">罢工</td>
<td align="left">Alt + Shift + 5</td>
<td align="left">Control + Shift +`</td>
</tr>
<tr>
<td align="left">超链接</td>
<td align="left">Ctrl + K.</td>
<td align="left">Command + K.</td>
</tr>
<tr>
<td align="left">图片</td>
<td align="left">Ctrl + Shift + I</td>
<td align="left">Command + Control + I</td>
</tr>
<tr>
<td align="left">清除格式</td>
<td align="left">Ctrl + \</td>
<td align="left">命令+</td>
</tr>
</tbody></table>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">切换补充工具栏</td>
<td align="left">Ctrl + Shift + L.</td>
<td align="left">Command + Shift + L.</td>
</tr>
<tr>
<td align="left">大纲</td>
<td align="left">Ctrl + Shift + 1</td>
<td align="left">Command + Control + 1</td>
</tr>
<tr>
<td align="left">用品</td>
<td align="left">Ctrl + Shift + 2</td>
<td align="left">Command + Control + 2</td>
</tr>
<tr>
<td align="left">文件树</td>
<td align="left">Ctrl + Shift + 3</td>
<td align="left">Command + Control + 3</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Fouus模式</td>
<td align="left">F8</td>
<td align="left">F8</td>
</tr>
<tr>
<td align="left">打字机模式</td>
<td align="left">F9</td>
<td align="left">F9</td>
</tr>
<tr>
<td align="left">Toggler全屏</td>
<td align="left">F11</td>
<td align="left">Command + Option + F.</td>
</tr>
<tr>
<td align="left">真实大小</td>
<td align="left">Ctrl + Shift + 0</td>
<td align="left"><em>（不支持）</em></td>
</tr>
<tr>
<td align="left">放大</td>
<td align="left">Ctrl + Shift + =</td>
<td align="left"><em>（不支持）</em></td>
</tr>
<tr>
<td align="left">缩小</td>
<td align="left">Ctrl + Shift + -</td>
<td align="left"><em>（不支持）</em></td>
</tr>
<tr>
<td align="left">在打开的Documnets之间切换</td>
<td align="left">Ctrl + Tab</td>
<td align="left">命令+`</td>
</tr>
<tr>
<td align="left">切换DevTools</td>
<td align="left">Ctrl + Shift + I</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>基本功能快捷键</p>
<p>字体操作快捷键<br>功能    快捷键</p>
<p>删除线    Alt+Shift+5</p>
<p>插入功能快键键<br>功能    快键键<br>插入图片(本地图片可直接拖入)    Ctrl+Shift+I</p>
<p>插入有序列表    Ctrl+Shift+[<br>插入无序列表    Ctrl+Shift+]<br>插入超链接    Ctrl+K</p>
<p>插入公式块    Ctrl+Shift+M<br>插入引用块    Ctrl+Shift+Q</p>
<p>标题段落快捷键<br>MarkDown支持六级标题，可以使用Ctrl+数字 指定不同层次的标题和段落</p>
<p>功能    快捷键<br>段落（正文）    Ctrl+0</p>
<p>提升标题级别    Ctrl+‘+’<br>降低标题级别    Ctrl+‘-’</p>
<p>功能    快捷键</p>
<p>上移该行    Alt+↑<br>下移该行    Alt+↓<br>左移该列    Win键+←<br>右移该列    Win键+→<br>删除该行    Ctrl+退格键(BackSpace)<br>左右移动表格列的快捷键与WinDows系统自带的快捷键冲突，导致失效</p>
<p>删除行快捷键，不知道为什么没有生效</p>
<p>视图操作快捷键<br>侧边栏<br>功能    快捷键<br>大纲视图    Ctrl+Shift+1<br>文件列表视图    Ctrl+Shift+2<br>文件树视图<br>显示/隐藏侧边栏<br>放大视图    Ctrl+Shift+‘+’<br>缩小视图    Ctrl+Shift+‘-’<br>恢复原来大小视图    Ctrl+Shift+9</p>
<p>编辑模式<br>功能    快捷键<br>源代码模式    Ctrl+/<br>专注模式(当前编辑行为黑，其他行为灰色)    F8<br>打字机模式(光标始终在屏幕中央位置)    F9<br>其他<br>功能    快捷键<br>全屏    F11<br>应用内窗口切换    Ctrl+Tab<br>开发者工具    Shift+F12</p>
<p>搜索扩展快捷键<br>功能    快捷键</p>
<p>替换    Ctrl+H<br>查找下一个    F3<br>查找上一个    Shift+F3</p>
<p>基本操作快键键<br>选择操作<br>功能    快捷键<br>全选    Ctrl+A<br>选择当前行/句    Ctrl+L<br>选择当前格式文本    Ctrl+E<br>选择当前单词    Ctrl+D<br>删除当前单词    Ctrl+Shift+D</p>
<p>跳转操作<br>功能    快捷键<br>跳转到文首    Ctrl+Home<br>跳转到所选内容    Ctrl+J<br>跳转到文末    Ctrl+End</p>
<p>粘贴复制操作<br>功能    快捷键</p>
<p>复制为MarkDown标记语法    Ctrl+Shift+C<br>粘贴为纯文本    Ctrl+Shift+V</p>
<p>文件操作<br>功能    快捷键<br>新建    Ctrl+N<br>新建窗口(在Windows中，这两个作用一样)    Ctrl+Shift+N<br>打开文件    Ctrl+O<br>快速打开(在最近打开中打开)    Ctrl+P</p>
<p>偏好设置    Ctrl+，<br>关闭    Ctrl+W<br>重新打开关闭的文件    Ctrl+Shift+T</p>
<p>其他<br>功能    快捷键<br>清楚样式    Ctrl+<br>增加缩进    Ctrl+]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/2.1.Typora%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" data-id="ckq1xbdrf000zpwwddhwh403q" data-title="Typora使用快捷键" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-10.3.项目编写文档" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/10.3.%E9%A1%B9%E7%9B%AE%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T08:57:29.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/10.3.%E9%A1%B9%E7%9B%AE%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3/">编写文档</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>项目开发过程中为了增加程序的可读性和程序的健壮性， 方便后期程序的调试和维护，所以需要在开发过程中统一技术规范，一般会在项目初期确定好相关文档作为这一统一的规范。不同公司会对文档做不同要求，划不同的分类，但一般来说大致可以分为需求文档、接口文档、流程图（可以单独作为一份文件可以作为附件附在文档中）、变更文件等。</p>
<h1 id="需求文档"><a href="#需求文档" class="headerlink" title="需求文档"></a>需求文档</h1><p>在项目启动之后，项目的目标已经明确了，那么就要开始着手干活了，但是在干活之前，需要对整个项目分析透彻。</p>
<p>首先，开发人员要有随意转换身份的意识和能力。</p>
<p>1.明确产品功能</p>
<p>在分析业务时，站在用户的角度上，思考要做的产品能实现什么功能。把所有的功能点列出来！</p>
<p>2.分析某一功能点的流程</p>
<p>在罗列了所有的功能之后，需要站在开发者的角度分析每一个功能点，考虑从客户端到后台操作数据库的整个流程，可以从是什么、为什么、在哪、怎么做、谁来做、做完如何反馈、反馈给谁、上传到哪、服务器用什么数据库、数据库需要什么表、表里有什么字段、每个字段的属性及意义等等。</p>
<p>比如，我要要做一个软件中个人头像上传的功能，首先明确我做的是上传功能；为什么要上传？因为个人资料需要头像；怎么做上传？通过网络I/O实现；这个功能在什么位置？软件有个个人中心模块，个人中心里有个个人信息子模块，在这个模块里可以上传头像；谁上传？已经登录的用户；上传完之后如何反馈？弹窗提示上传成功；反馈给谁？客户端已登录的用户；上传到哪？服务器上；用什么数据库？MySQL;需要什么表？（存到）用户表；表里有什么字段？用户信息的基本字段；每个字段的属性及意义？略。在思考完这些问题之后，可以把一个功能点串成一条完整的从前端到数据库的线。</p>
<p>3.整合各个功能点–明确分工</p>
<p>在串完所有的功能点之后，站在一个高一层次的角度，把每个功能点之间的联系理清楚，按照相互的联系分工合作，优化其中的细节问题。</p>
<p>4.撰写需求文档</p>
<p>分工完成之后，按照第二步分析的内容，每个人把自己负责的功能整理成文档，最后合并文档，作为统一的需求文档。</p>
<p>5.绘制业务流程图</p>
<p>需求文档确定之后，绘制整个项目的业务流程图，这时候的流程图只需要包含前端的业务流程，后台实现的流程图不需要在需求文档中体现，而是放在后面的接口文档中。</p>
<h1 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h1><p>不同公司对接口文档的要求也不尽相同，但包括的内容却是大同小异的。封面、标题、审批页、修订历史以及格式字体等等是次要内容，主要内容包括：</p>
<p>1.请求地址</p>
<p>需要哪个线上地址就写哪个。注意不要犯低级错误，比如写错某个字母或者大小写问题。</p>
<p>2.接口信息</p>
<p>说明请求方式，是POST还是GET。</p>
<p>3.功能描述</p>
<p>清晰地描述接口功能，要求言简意赅，不要写太多废话，也不要遗漏任何细节。</p>
<p>4.接口参数说明</p>
<p>声明参数的名称，严格要求与调用一致，包括大小写；</p>
<p>简单说明参数的含义；</p>
<p>参数的数据类型，是string 、int 还是long等（例如参数为@RequestParam(“appKey”)  String appKey,  @RequestParam(“randomId”)  Integer randomId）；</p>
<p>备注部分，说明参数值是需要哪个公司提供，并详细说明参数怎么生成的，例如时间戳，是哪个时间段的；参数是否必填，一些参数是必须要有的，有些是可选参数，一定要注意写清晰。</p>
<p>5.返回值说明</p>
<p>有一个模板返回值，并说明每个返回参数的意义。提供一个真实的调用接口，真实的返回值。</p>
<p>6.接口调用限制</p>
<p>为了安全，双方采用一个一致的加密算法，保证接口调用的安全。</p>
<p>7.文档维护</p>
<p>文档维护时，修改内容部分需要有修改人、修改日期、版本号的信息。</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>流程图可以单独作为一份文件，也可以作为附件附在对应的文档中，具体执行按要求来。</p>
<p>1.业务流程图</p>
<p>2.程序结构图</p>
<p>3.程序流程图</p>
<h1 id="变更文件"><a href="#变更文件" class="headerlink" title="变更文件"></a>变更文件</h1><p>在开发过程中如果出现与预期计划、文档不一致的地方，则视为发生变更，此时大致需要提供以下信息：</p>
<p>1.版本历史（版本号、基本信息）</p>
<p>2.变更前现状</p>
<p>3.变更内容</p>
<p>4.影响评估</p>
<p>5.审批</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/10.3.%E9%A1%B9%E7%9B%AE%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3/" data-id="ckq1xbdr6000apwwd1rp7h104" data-title="编写文档" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/18/WebRTC%E7%9A%84%E5%AD%A6%E4%B9%A0/">WebRTC的学习</a>
          </li>
        
          <li>
            <a href="/2021/06/18/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/">流媒体协议</a>
          </li>
        
          <li>
            <a href="/2021/06/17/1.7.%E7%AE%80%E5%8E%86%E5%AE%8C%E5%96%84/">简历完善</a>
          </li>
        
          <li>
            <a href="/2021/06/08/%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/">搭建网站</a>
          </li>
        
          <li>
            <a href="/2021/06/03/%E6%94%BB%E7%A0%B4%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99/">攻破一个网站</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>