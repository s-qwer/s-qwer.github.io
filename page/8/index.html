<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/8/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-19.1.git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/16/19.1.git/" class="article-date">
  <time class="dt-published" datetime="2021-04-16T04:46:21.000Z" itemprop="datePublished">2021-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/16/19.1.git/">git</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>git是目前世界上最先进的分布式版本控制系统。<br>Linus在1991年创建了开源的Linux,从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux,但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，<strong>在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus,然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN,这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper,BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</strong>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个）,被BitMover公司发现了（监控工作做得不错！),于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后会严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：<br>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git!一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub,包括jQuery,PHP,Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>版本控制：可以解决多人同时开发的代码问题，也可以解决找回历史代码的问题。</p>
<p>分布式：Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。首先找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器“仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。可以自已搭建这台服务器，也可以使用GitHub网站。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>傻瓜式安装</p>
<h1 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h1><h2 id="在Windows的cmd-中使用linux的命令"><a href="#在Windows的cmd-中使用linux的命令" class="headerlink" title="在Windows的cmd 中使用linux的命令"></a>在Windows的cmd 中使用linux的命令</h2><p>cmd的命令功能肯定没有linux的命令功能好用，这点毋庸置疑。现在装好了Git，就可以在Windows的cmd中使用linux命令了。<br>关键词：环境变量 Git命令<br>怎么玩？如下2步操作：<br>假如你按照上述步骤将Git装在C盘，那么做如下操作：<br>操作1：找Git命令的【.exe文件】。</p>
<p>操作2：添加到环境变量，就可以在cmd里使用linux命令了。</p>
<p>最终效果：</p>
<p>PyCharm也可以使用linux命令。【环境变量–全局—使用】</p>
<p>备注：你可能需要关闭之前打开的cmd窗口/PyCharm窗口，重新打开新的cmd窗口//PyCharm窗口，使用命令才可能生效。<br>【效率会提高一点点】</p>
<h2 id="创建一个版本库"><a href="#创建一个版本库" class="headerlink" title="创建一个版本库"></a>创建一个版本库</h2><p>(1)新建一个目录git_test,在git_test目录下创建一个版本库，命令如下：</p>
<p>接着初始化仓库</p>
<p>说明：可以看到在git_test目录下创建了一个.git隐藏目录，这就是版本库目录。</p>
<p>4.版本的创建与回退<br>4.1 使用<br>(1)在git_test目录下创建一个文件code.txt,编辑内容如下：</p>
<p>(2)使用如下两条命令可以创建一个版本：<br>git add code.txt<br>git commit -m “版本1”</p>
<p>(3)使用如下命令可以查看版本记录：<br>git log</p>
<p>(4)继续编辑code.txt,在里面增加一行。</p>
<p>(5)使用如下命令再创建一个版本并查看版本记录：</p>
<p>(6)现在若想回到某一个版本，可以使用如下命令：</p>
<p>其中HEAD表示当前最新版本【请记死】，HEAD^表示当前版本的前一个版本，HEAD^^表示当前版本的前前个版本，也可以使用HEAD<del>1表示当前版本的前一个版本，HEAD</del>100表示当前版本的前100版本。</p>
<p>因为版本1的内容是1行：<br>this is the first line</p>
<p>因为版本2的内容是2行：<br>this is the first line<br>this is the second line</p>
<p>因为<br>$ git reset –hard HEAD^ HEAD is now at 51d36c7 版本1<br>使指针HEAD指向（倒退）到版本1，<br>因此打印的内容就是版本1的内容，即this is the first line</p>
<p>(7)假如我们现在又想回到版本2,这个时候怎么办？可以使用如下命令：<br>git reset –hard 版本号</p>
<p>（8）在终端执行如下命令：</p>
<p>版本2又回来了，内容也是原来的内容。</p>
<p>接着玩</p>
<p>退出终端，再重进：</p>
<p>这个重进终端的操作让我们看不到版本2的版本号，要回到版本2怎么办？<br>命令：git reflog来查看操作记录。</p>
<p>错误示例：<br>原因是按照当前版本1倒退的话，怎么也不会前进到版本2吧？逻辑错误。</p>
<p>正确实例：<br>要用到版本号。</p>
<p>查看版本2的内容：</p>
<p>不理解版本1，版本2有啥区别？<br>这个东西像游戏更新一样，版本2是在版本1的基础上添加新功能的，版本1内容不发生改变。例如王者荣耀版本更新，界面总会变化，但是英雄的属性（技能，名字）一般不会改变。</p>
<p>4.2 工作区和缓存区<br>4.2.1 工作区（WorkingDirectory)<br>工作区（WorkingDirectory) 电脑中的目录，比如我们的git_test,就是一个工作区。</p>
<p>4.2.2 版本库（Repository)<br>工作区有一个隐藏目录.git,这个不是工作区，而是git的版本库。git的版本库里存了很多东西，其中最重要的就是称为stage(或者叫index)的<br>暂存区，<br>还有git为我们自动创建的第一个分支master,以及指向master的一个指针叫HEAD。</p>
<p>因为我们创建git版本库时，git自动为我们创建了唯一一个master分 支，所以，现在，git commit就是往master分支上提交更改。<br>你可以简单理解为，需要提交的文件修改通通放到暂存区【计算机的缓存区】，然后，一次性提交暂存区的所有修改。</p>
<p>前面讲了我们把文件往版本库里添加的时候，是分两步执行的：<br>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区<br>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>(1)下面在git test目录下再创建一个文件code2.txt,然后编辑内容如下：</p>
<p>(2)然后编辑code.txt,操作如下：</p>
<p>注意的是创建文件和编辑文件都是在工作区里完成。<br>（3）使用如下命令查看当前工作树的状态：<br>git status</p>
<p>翻译一下：</p>
<p>上面提示我们code.txt被修改，而code2.txt没有被跟踪。</p>
<p>(4)我们使用如下命令把code.txt和code2.txt加入到暂存区，然后再执行git status命令，结果如下：</p>
<p>注意：所有的 git add 命令是把所有提交的修改存放到暂存区。</p>
<p>(5)然后，执行git commit就可以一次性把暂存区的所有修改提交到分支并创建一个版本。</p>
<p>注意：指针HEAD永远指向当前版本。此时当前版本是版本3。</p>
<p>(6)一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。执行如下命令可以发现：</p>
<p>现在我们的版本库变成了酱紫：</p>
<p>4.3 管理修改<br>git管理的文件的修改，它只会提交暂存区的修改来创建版本。<br>(1)编辑code.txt,并使用git add命令将其添加到暂存区中。</p>
<p>(2)继续编辑code.txt,并在其中添加一行。</p>
<p>(3)git commit创建一个版本，并使用git status查看，发现第二次修改code.txt内容之后，并没有将其添加的工作区，所以创建版本的时候并没有被提交。</p>
<p>注意：对于code.txt里的四行内容，每一个版本对应一行，例如版本1对应first line，以此类推。</p>
<p>4.4 撤销修改<br>(1)继续上面的操作，提示我们可使用git checkout – &lt;文件&gt;来丢弃工作区的改动。执行如下命令，发现工作区干净了，第二次的改动内容也没了。</p>
<p>(2)我们继续编辑code.txt,并在其中添加如下内容，并将其添加的暂存区。</p>
<p>(3)git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉，重新放回工作区。</p>
<p>(4)现在若想丢弃code.txt的修改，执行如下命令即可。</p>
<p>现在，如果你不但改错了东西，还从暂存区提交到了版本库，则需要进行版本回退。</p>
<p>小结：<br>场景1:当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用 命令git checkout – file<br>场景2:当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步：<br>第一步用命令git reset HEAD – file,就回到了场景1,<br>第二步按场景1操作。<br>场景3:已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节。</p>
<p>4.5 对比文件的不同<br>对比工作区和某个版本中文件的不同：</p>
<p>(1)继续编辑文件code.txt,在其中添加一行内容。</p>
<p>(2)现在要对比工作区中code.txt和HEAD版本中code.txt的不同。使用如下命令：</p>
<p>(3)使用如下命令丢弃工作区的改动。</p>
<p>对比两个版本间文件的不同：<br>(1)现在要对比HEAD和HEAD ^版本中code.txt的不同，使用如下命令：</p>
<p>反过来</p>
<p>4.6 删除文件<br>(1)我们把目录中的code2.txt删除。</p>
<p>这个时候，git知道删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻提示哪些文件被删除了。</p>
<p>(2)现在你有两个选择，一种情况是确实要从版本库中删除该文件，那就用命令 gitrm删掉【永久删除，无法撤消】，并且 git commit:</p>
<p>另一种情况是删错了，可以直接使用git checkout – code2.txt,这样文件code2.txt又回来了。<br>注意：两种情况有区别：<br>当执行第一种情况时【永久删除，无法撤消】，再执行第二种情况，会报错：</p>
<p>加长版：</p>
<p>简短版：</p>
<p>小结：<br>命令rm 删除是永久删除，要恢复数据的话可以恢复/扫描硬盘；<br>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<ol start="5">
<li>分支管理</li>
<li>1概念<br>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。<br>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了git又学会了SVN!</li>
</ol>
<p>分支在实际中有什么用呢？<br>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>5.2 创建与合并分支<br>git把我们之前每次提交的版本串成一条时间线，这条时间线就是一个分支。截止到目前只有一条时间线，在git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master,master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>(1)一开始的时候，master分支是一条线，git用master指向最新的提交，再用HEAD指向master,就能确定当前分支，以及当前分支的提交点：</p>
<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。<br>(2)当我们创建新的分支，例如dev时，git新建了一个指针叫dev,指向master相同的提交，再把HEAD指向dev,就表示当前分支在dev上：</p>
<p>git创建一个分支很快，因为除了增加一个dev指针，改变HEAD的指向，工作区的文件都没有任何变化。</p>
<p>(3)不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p>
<p>(4)假如我们在dev上的工作完成了，就可以把dev合并到master上。git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<p>git合并分支也很快，就改改指针，工作区内容也不变。<br>（5）合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<p>(1)执行如下命令可以查看当前有几个分支并且看到在哪个分支下工作。</p>
<p>(2)下面创建一个分支dev并切换到其上进行工作。</p>
<p>(3)下面我们修改code.txt内容，在里面添加一行，并进行提交。</p>
<p>(4)dev分支的工作完成，我们就可以切换回master分支：</p>
<p>查看code.txt,发现添加的内容没有了。因为那个提交是在dev分支上，而master分支此刻的提交点并没有变。【这里需要细细品味一下】</p>
<p>(5)现在，我们把dev分支的工作成果合并到master分支上：<br>git merge命令用于合并指定分支到当前分支。合并后，再查看code.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>
<p>注意到上面的rast-forward信息，Git告诉我们，这次合并是“快进模式“，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>(6)合并完成后，就可以放心地删除dev分支了，删除后，查看branch,就只剩下master分支了。</p>
<p>小结：<br>查看分支：git branch<br>创建分支：git branch <name><br>切换分支：git checkout <name><br>创建+切换分支：git checkout -b <name><br>合并某分支到当前分支：git merge <name><br>删除分支：git branch -d <name></p>
<p>5.3 解决冲突<br>合并分支往往也不是一帆风顺的。<br>(1)再创建一个新分支dev。</p>
<p>(2)修改code.txt内容，并进行提交。</p>
<p>(3)切换回master分支。</p>
<p>(4)在master的code.txt添加一行内容并进行提交。</p>
<p>这种情况下，git无法执行”快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。</p>
<p>(5)执行如下命令尝试将dev分支合并到master分支上来。</p>
<p>冲突原因：<br>现在，master分支和dev分支各自都分别有新的提交，并且编辑了同一个文件，变成了这样：</p>
<p>git告诉我们，code.txt文件存在冲突，必须手动解决冲突后再提交。</p>
<p>最重要的一步：</p>
<p>(6)git status也可以告诉我们冲突的文件：</p>
<p>(7)查看code.txt的内容。</p>
<p>(8)git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,========,&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记不同分支的内容，我们修改如下后保存：</p>
<p>(9)再提交。</p>
<p>(10)现在，master分支和dev分支变成了下图所示：</p>
<p>(11)用带参数的git log也可以看到分支的合并情况：</p>
<p>(12)最后工作完成，可以删除dev分支：</p>
<p>5.4 分支管理策略<br>通常，合并分支时，如果可能，git会用fast forward模式，但是有些快速合并不能成功而且合并时没有冲突，这个时候git会帮我们在合并之后做一次新的提交，但这种模式下，删除分支后，会丢掉分支信息。【弹窗说明信息】</p>
<p>(1)创建切换到dev分支下。</p>
<p>(2)新建一个文件code3.txt,编辑内容如下，并提交一个commit。</p>
<p>(3)切换回master分支，编辑code.txt并进行一个提交。</p>
<p>(4)合并dev分支的内容到master分支。</p>
<p>(5)出现如下提示时，这是因为这次不能进行快速合并，所以git提示输入合并说明信息，输入之后合并内容之后git会自动创建一次新的提交。</p>
<p>按 :x保存并退出。</p>
<p>(6)使用分支命令查看分支信息。</p>
<p>(7)删除dev分支。</p>
<p>如果要强制禁用fast forward模式，git就会在merge时生成一个新的commit,这样，从分支历史上就可以看出分支信息。<br>(1)创建并切换到dev分支。</p>
<p>(2)修改code.txt内容，并提交一个commit。</p>
<p>(3)切换回master分支。</p>
<p>（4）准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward:</p>
<p>因为本次合并要创建一个新的commit,所以加上-m参数，把commit描述写进去。</p>
<p>5.5 Bug分支<br>软件开发中，bug就像家常便饭一样，有了bug就需要修复，在git中，由于分支是如此的强大，所以，<br>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>(1)当你接到一个修复一个代号001的bug的任务时，很自然地，你想创建一个分支bug-001来修复它，但是，等等，当前正在dev上进行的工作还没有提交：<br>建议先敲clear清屏。</p>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug,怎么办？</p>
<p>(2)git还提供了一个stash功能，可以把当前工作现场“储藏“起来，等以后恢复现场后继续工作：【工作中可能会用到，在git pull之前先用这条命令。放入缓存是git stash，相对应的git stash pop从缓存中释放出来】</p>
<p>更多请参考：传送门<br>(3)首先确定要在哪个分支上修复bug,假定需要在master分支上修复，就从master创建临时分支：</p>
<p>(4)现在修复bug,这里假设把code.txt里的第9行删掉，然后提交。</p>
<p>(5)修复完成后，切换到master分支，并完成合并，最后删除bug-001分支。</p>
<p>(6)现在bug-001修复完成，是时候接着回到dev分支干活了！</p>
<p>(7)工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：【帮助我们列出保存的工作现场】</p>
<p>工作现场还在，git把stash内容存在某个地方了，需要恢复一下：</p>
<p>小结：<br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug,修复后，再git stash pop,恢复工作现场。</p>
<p>6.使用github<br>6.1 创建仓库<br>(1)注册github账户</p>
<p>登录后，点击”New respository”</p>
<p>(2)在新页面中，输入项目的名称【如2020】，勾选’readme.md’,点击’Create repository’</p>
<p>这里完成。</p>
<p>6.2 添加ssh账户<br>(1)点击账户头像后的下拉三角，选择’settings’如果某台机器需要与github上的仓库交互，那么就要把这台机器的ssh公钥添加到这个github账户上。</p>
<p>(2)在git的命令行中，回到用户的主目录下，编辑文件.gitconfig,修改某台机器的git配置。<br>修改为注册github时的邮箱，填写用户名。</p>
<p>完美：</p>
<p>6.3 克隆项目</p>
<p>接着：</p>
<p>6.4 上传分支/推送代码<br>(1)项目克隆到本地之后，执行如下命令创建分支：</p>
<p>(2)创建一个views.py并提交一个版本：</p>
<p>(3)推送前github上文件列表如下图:</p>
<p>(4)推送前github上分支列表如下图:</p>
<p>(5)推送分支，就是把该分支上的所有本地提交推送到远程库，推送时要指定本地分支，这样，git就会把该分支推送到远程库对应的远程分支上：<br>git push origin 分支名称<br>例：<br>git push origin smart</p>
<p>（6）再次查看github分支：<br>接下来操作重新加载页面：</p>
<p>点击smart,再点击views.py,如图所示：</p>
<p>6.5 将本地分支跟踪服务器分支<br> git branch –set-upstream-to=origin/远程分支名称 本地分支名称<br>1<br>例：</p>
<p>  git branch –set-upstream-to=origin/smart smart<br>1</p>
<p>我的社交网址：<a target="_blank" rel="noopener" href="https://github.com/Keegan-y">https://github.com/Keegan-y</a></p>
<p>6.6 从远程分支上拉取代码<br>git pull orgin 分支名称<br>例：<br>git pull orgin smart<br>使用上述命令会把远程分支smart上的代码下载并合并到本地所在分支。</p>
<p>7.工作使用git<br>不墨迹直接上代码：<br>loading…<br>项目经理：<br>(1)项目经理搭建项目的框架。<br>(2)搭建完项目框架之后，项目经理把项目框架代码放到服务器。</p>
<p>普通员工：<br>(1)在自己的电脑上，生成ssh公钥，然后把公钥给项目经理，项目经理把它添加的服务器上面。<br>(2)项目经理会给每个组员的项目代码的地址，组员把代码下载到自己的电脑上。<br>(3)创建本地的分支dev,在dev分支中进行每天的开发。<br>(4)每一个员工开发完自己的代码之后，都需要将代码发布远程的dev分支上。</p>
<p>项目里一般会有两个分支，如：<br>Master:用于保存发布的项目代码。<br>Dev:用于保存开发过程中的代码。所有的组员开发完自己的代码提交到该分支上。<br>补充小技巧：<br>首先，整体认知一下工作中git常用的就这么几个命令：<br>步骤1.创建项目目录，如git_test【强烈建议返回到2.安装配置一节，学一学在windows中用mkdir git_test。工作中点来点去，文件夹一多就不爽了，学会在windows上用linux命令，工作效率谁用谁知道<del>】<br>步骤2.git init【如果你考皮github上别人的代码，必须将别人的.git文件删掉。步骤：进入项目目录，如git_test，cd git_test，ls -al，rm -rf .git】【工作中linux必会的，赶快回到2.安装配置一节，学一学在windows使用linux命令，这样就不用装linux环境了，简单胜于复杂</del>】<br>步骤3.git add .<br>步骤4.git commit -m “整体提交”<br>步骤5.git remote add origin 【你的github/gitlab仓库地址】<br>步骤6.git checkout -b dev<br>步骤7.git push origin dev<br>当然不止于这7步，这些步骤会在你的实践中不断升华，壮大<del>。<br>先把git玩起来再说，否则很容易从入门到放弃。先玩起来</del><br>步骤操作如图所示：</p>
<p>可以看到，代码推到仓库了。<br>掌握了上面基本命令，记住使用步骤，强烈建议建议建议你在PyCharm/Goland上操作git，能可视化+带提示帮你提交代码，解决冲突【你在git bash里搞不定冲突，在PyCharm/Goland上操作一看就知道怎么做了，人家可视化+提示，你只需要手指点一点即可，很简单，节约你的时间】，工具是个好东西，前面的步骤都是为了这样一句话铺垫：【PyCharm/Goland上玩git】<br>【不会的可以在评论区留言，我看到后会继续在后文补充。既然是git使用教程，那就是成体系的，知识技能是结构化安放的，方便查，方便增，是不？】</p>
<p>到此，git使用教程就写完了，既是自己的实践记录【记不住哈哈】，也能帮助更多的道友管理控制代码，如果内容对读者有用，请关注我，为思考点赞！</p>
<p>最后奉上导图笔记：</p>
<p>8.思维导图笔记</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/16/19.1.git/" data-id="ckw61sdw20047oswd6jwve7zi" data-title="git" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-5.5.MySQL工具之Navicat" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:39:28.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/">MySQL工具之Navicat</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>安装Navicat</strong></p>
<p>因为工作原因，需要经常连接不同的数据库，这里我安装的是Navicat Premium版本，在公众号后台回复 <strong>Navicat</strong> 即可获取。</p>
<p>安装过程很简单，只要你能看懂中文，不停的下一步，等待安装完成即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2xKluMyr9zsylJ1bbEy5kAicNwLkqjO2V3j6G3XFBLhiaozUuKYzLCVkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>连接不同数据库</strong></p>
<p>这里分别介绍Oracle，MySQL，SQL Server这三种数据库的连接方法</p>
<p><strong>连接Oracle</strong></p>
<p>在连接Oracle之前我们需要先配置一下OCI文件，具体如下：</p>
<p>点开主菜单里的【工具】——【选项…】,在弹出的对话框中找的OCI选项</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ayiavVhGWNUtCxzSv7nRAL32mTpAlsHmG6XrhvA5NfV7JIUia6FnBDWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里就要把你安装的oracle的安装目录下的bin文件夹里面的oci.dll文件导入</p>
<p>E:\software\oracle\Oracle_win64\product\11.2.0\dbhome_1\BIN\oci.dll</p>
<p>以上是我的安装目录下的文件，大家根据自己的安装目录不同来导进来</p>
<p>导进来之后就重启Navicat，重启后会自动生效。</p>
<p>重启Navicat后，点击菜单栏的连接，选择Oracle，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2v4ibO1bTE1sICWwbjoGlYjlPrbKGNmCazdqNG3U4SJDY4lNvydb8vGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中做如下配置，其中连接名可以随意起，然后输入你要连接的主机名或IP地址，最后输入账号密码。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO26DXvmnuAFhema70Vibkj2nhLc13TEpb2SwxMibrVuY9ECoP4BudbRf0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你是使用DBA角色登录的，还需要点开高级选项卡，将角色选为DBA</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO225C85ic0Bd8oYibzpBoHLKtmog0ZBdlib7Pd8grxHDIia7aNwEVdfw46uA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置完了以后，我们可以点击连接测试</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2pBzAsdJSbnWUI9La2k8icmAKIbnMWpOMicy9FsgFO1CdKCiaC2p3OqUOA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">这样Oracle的连接就配置好了。</p>
<p><strong>连接MySQL和SQL Server</strong></p>
<p>MySQL和SQL Server的连接相对比较简单，只需要输入主机名或IP地址，账号密码即可，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2HxIZHHUhGKML0TC1mgA7djpa5KZ2cqyJyrW5HUAtr9xIwxAJBWxobg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2UzsMibLp6NUbiaAE5dNa09XeOjh61qyCmUib1uRzpy8p1PnwZd3FMuUxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置好后，点击连接测试，在弹出连接成功窗口就表示我们配置好了。</p>
<p>数据库连接成功后，下面是各个功能的介绍，我们以SQL Server数据库作为案例来介绍各个功能的使用。</p>
<p><strong>创建数据库</strong></p>
<p>右键我们刚新建的数据库连接——选择【新建数据库…】即可开始创建数据库了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO25lWoNb7icSiaocd6c07JMQRVdvqrXHpnPpmOWMkEXk5lSUPhTxCvE3Fg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以根据你的要求来进行配置，配置完以后，还可以在【SQL预览】看到完整的SQL代码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2f6LfOqSt2tKhHUhxV089tAicnqGw6gQr1ic6JpNzic21UDxVbicm2pul5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>数据传输</strong></p>
<p>数据传输，顾名思义就是将数据从其他地方传输到当前数据库，例如我们将SQL_Road数据库中的数据传输到刚才新建的Test数据库中。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO29JIouv6OTsvv1tVHEARMD95v6JjKVnvJ2Cw07xzqUAOPp9ktxpNueQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>右键刚才创建好的Test数据库，在弹出的选项中选择【数据传输…】，在弹出的窗口中我们配置源数据库为【SQL_Road】,目标数据库配置为【Test】，这样就可以将SQL_Road中的对象传输到Test了，支持传输的对象包括：表，视图，函数和存储过程，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2a5ovyOCg7icHWslZj0ZH0icOZG0GG2zF5McQWlWxXhb0h7IH8ScszhyQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始即可开始进行数据传输，传输效率还是很快的，即使你的数据量很大，也可以使用该方法进行数据传输，这里使用了不到2秒钟就将整个数据库对象迁移到新的数据库中了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2gYlkicBOLCHXSicuics171YBiaBM06vu5TsoxFD1v8tMiatk27AFnl8icDBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>此外如果你想导出整个数据库中的对象到文件，也可以使用该方法，只需要将方式改为文件即可，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2dKibsOAkMktKzv4RcEnGCzF21WvhA8u23aO8mxQoXNGpbLRXkjrrasw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你想自定义导出的内容，可以点击该窗口的【高级】选项进行自定义配置，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ibkdpgmia7AP9ciadmUt0kIpKZHJWBicQibibicdibEtaZFkHcicEGtjG1OSUCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置完成后，点击开始，就会将你选择的数据库对象以脚本的形式导出到文件中。</p>
<p>但是数据传输到文件有个不足的地方，就是会将数据记录也会一并导出，而很多时候，我们其实只需要表结构，那么我们可以使用下面的这个功能。</p>
<p><strong>转储SQL文件</strong></p>
<p>双击打开数据库后，我们右键架构名dbo，在弹出的选项中选择【转储SQL文件…】，这里还有两个子选项：【结构和数据…】和【仅结构…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2klrr7KbWlHjd8oVYVaFhibky2ywFHxDfGbU0SNr80OElzF5bTVOor1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>他们的区别就是一个有数据记录，一个没有数据记录，如果你只要数据结构可以只选择【仅结构…】，这样就可以大大节省导出时间了。</p>
<p><strong>打印模式/数据字典*<em>生成*</em></strong></p>
<p>做数据库仓库往往面对的不是几张表，往往是成百上千张数据表，该怎么维护对DBA是个非常头疼的事，如果有个数据表结构或数据字典之类的就非常完美了。</p>
<p>打印模式可以<strong>完美的生成所有表的数据表结构</strong>的。这里我们选择表数量较多的数据库ReportServer。右键dbo后，选择【打印模式…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2NIZlTicjuVONVpYrhO0W1IqAeicswxic28stRoicXeJokqNTBNSQ3L0zWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以看到右侧窗口里面出现了所有数据表的表结构，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2TvxbdBAlYHmoILKSDia33M0MIm0IAghtK3LXibzq5icU19hqlFYkESx0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>足足有10页之多，我们点击左上方的【打印】，将表结构打印成PDF文件，就可以得到一份非常完成的数据字典了，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2aud0pqYSgMzwR3nXRMTNGibYQP3zXkCDrbTEU8UhTKDUhwZ2UDZxrSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>内容中主键和索引也有仔细的标注出来，其中<strong>P代表主键</strong>，下面的<strong>index表示索引</strong>。</p>
<p>这个功能绝对是一个神器！</p>
<p><strong>在模式中查找</strong></p>
<p>这个功能主要用来查找数据或结果，当你需要从当前数据库中查找数据记录或对象中包含某些字符时，可以使用该功能，具体如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO26F4rBdtKPq3pM6kk4v0iboN54ExFSJ6P0A8JrFI9x7Aj1zEICJeYw3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中，我们查找pre的结构，就可以将当前数据库符合要求的的所有对象都查找出来，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2zfWey0meibpxuwyU8ljtT6r0JIvHybx1e5rCDeAHwty4T2PIEKdQ1uw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>逆向模式到模型</strong></p>
<p>这又是一个神仙技能，谁用谁知道，右键dbo在弹出的选项中选择【逆向模式到模型..】,如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2gqmyJ95SwfRD1sZgybhd30aOiaV4LFDDSSKG7icQyHRGbTicMvBSqYjMQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>它可以<strong>将当前数据库中创建的所有表，以E-R图的模型清楚的告诉你每个表之间的关联关系</strong>，包括主外键，表结构，关联关系等，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2uQjNXTMRT6dVMkyT4tsO8Bb1CnibJgJfWDEePaGpVe8sicmkHdib245iaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>你以为就这？</p>
<p>还支持<strong>模型转换，模型导出</strong>，说白了就是你可以<strong>将该模型转换成其他数据库的模型</strong>，从SQL Server转换成MySQL，Oracle，Postgresql都可以。点击左上角的三短横，选择【文件】——【模型转换】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2cyYKRyxc5KAibxWfnU2zWdvUn7wAicn2lxZCBSP8mibaOaiaUbW9TzWn9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中选择你要转换的类型，比如我们想转换成MySQL 5.6的，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2x6TSHrBrmkymXceib25CkBfqVibGJlYibS0PL6VpSrOBPiacP71D1iciaBHw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击确定后，即可将当前的SQL Server模型立马转换成MySQL 5.6。给大家看下对比效果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2BUAibtGeIM6N5WXroknLPhTjT4k0r9EaZA8QRgCKzsnnUHsfqict08Tw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>SQL Server模型</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2ImacDMUrYmibib6ZwhWa5hSwhtVXIhEUia6z4XxSz6chIVaeTzxmQcicuw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>MySQL模型</p>
<p>转换成功后可以直接将转换后的模型导出成对应的SQL。</p>
<p>点击【工具】——【导出SQL…】，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2SmPTTmH3LNPNNlmst71wAL7cpjlJuicBexVXBLh230wCzz2j3PGfvBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择导出位置，点确定即可，导出的SQL文件里面就是MySQL的建库代码了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2pvSqyJrD6aqeYmPh2lrIt56UXRL4RKyxzukKiaJ8GvaE2JGyjrKZx6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>能导出肯定就可以打印，同样如果需要将模型文件保存，也可以导出为PDF，PNG，SVG等格式，但是建议打印成PNG图片格式，因为PDF会分页，导致模型不完整。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2v0WVtdIJS4Qnj98H6rZwSic0mpKNvY4ML8OQEb4S5Y1cFk7icCmctdnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>打印出来的图片如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qEuaqnkFyFSumPrJqFyURO2VXiacibexrSpbeY1Y7kANuyIKGGobrsFNTiaolsaEMXRaDt8kXdeoibNLA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>新建表</strong></p>
<p>这个是比较常见的功能，相比其他管理工具，Navicat将建表过程中所涉及的各种常用功能都包含进去了，包含新字段，索引，主键，外键，唯一键等等与表有关的内容，具体如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgQEuibfiaJMxTYlVaxYzphdW6VfpKYm6uLw3X8dyOIWryib4Aw8OYCicCbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>针对表的几个常用功能，我们再详细给大家介绍一下</p>
<p><strong>字段</strong></p>
<p>字段的功能很多，也是其他功能的前提，意思是你必须先创建了字段才能使用后面的一些功能。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgNIZBSp4nV53ZvBRxLqcpa9YunxHyn1qtDLf9lmialP9BQsZN1zELt6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其中第一排的添加字段，插入字段，删除字段，可以通过字面意思来理解。</p>
<p>主键：选中某个字段，点击主键即可设置为主键</p>
<p>标识：勾选后一般用作自增长列来使用</p>
<p>注释：对字段的备注，通常为中文</p>
<p>名：字段存在表里的字段名</p>
<p>类型：字段数据类型</p>
<p>长度：字段的长度，通常int和datetime可以不设置长度。</p>
<p>比例：小数位数</p>
<p>不是Null：该字段是否为空，勾选不为空，不勾选为空。</p>
<p><strong>索引</strong></p>
<p>用来创建索引，只需要选定指定的列，就可以在对应的列上创建索引了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgZQSnF3fd6xNaee5ibV4VXEQ1u7cibJfo2D0NvfGbcic9C1l056rOP9fcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>名：索引的名称，通常按命名规范以index或idx开头，当然你也可以自定义。</p>
<p>字段：选择在哪个字段上创建索引。还可以选择排序规则，默认是升序ASC。</p>
<p>索引类型：不同的数据库索引类型不同，SQL Server类型一般为聚集索引（Clustered）和非聚集索引（Non-Clustered）</p>
<p>唯一键：用来限制字段的记录是否可以重复，勾选就是不可重复。</p>
<p><strong>外键</strong></p>
<p>用来创建外键约束的功能，目前的数据库设计中，通常不设置外键约束了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgYfEockSvWia9MOegfNXLnFeSzJLnO0GgDqBTouNbAAnx2xP7SFVKU9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>名：外键名称，通常以fk开头</p>
<p>字段：用来设置外键的字段</p>
<p>参考表：与之相关联的表</p>
<p>参考字段：与之相关联表中的字段</p>
<p>删除时：是否级联删除</p>
<p>更新时：是否级联更新</p>
<p><strong>唯一键</strong></p>
<p>区别于主键，唯一键具有唯一性</p>
<p>与主键的区别有：</p>
<p>1.主键不允许空值，唯一索引允许空值</p>
<p>2.主键只允许一个，唯一索引允许多个</p>
<p>3.主键产生唯一的聚集索引，唯一索引产生唯一的非聚集索引</p>
<p><strong>检查</strong></p>
<p>用来约束数据插入的合法性，对应SQL中的CHECK或DEFAULT</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgxCROXWLcic26pQfMYHDX8K5Let2XYlibrAYzYtiaMwElzkX17mt1mFrvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>触发器</strong></p>
<p>用来创建与表相关的触发器，其中触发器的使用可以查看历史文章：</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzA3MTg4NjY4Mw==&mid=2457301529&idx=2&sn=b3881753e41e401ac374057bce52e768&chksm=88a5602dbfd2e93bcae925b00130230e7e8f1b957f29ce2f3e7471c4076ebba3bf36ad2b4ab1&scene=21#wechat_redirect">SQL高级知识V2——触发器</a></p>
<p><strong>选项</strong></p>
<p>这里主要用来设置自增长的种子值（起始值）和增量</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgTr5rCyPoOtCZKcLA7ibtWLy8M1o4opjVATrsNBelsORc2SoBQ3elGjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>SQL预览</strong></p>
<p>这里可以看到我们刚才对表做的配置所对应的SQL语句</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgVe1icibSk4HTrcOZKR3hnXwUqL22Ofo1XfLtpfbibYTI0jMdBhUcn5kQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>查看对象模式</strong></p>
<p>创建好的表有三种查看方式：列表，详细信息和ER图，如下图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIovQPPbZyXibIAxiaY94ey9NUBALdy7jiaghl9WczAyTSFrLYB8dbNpJzibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>列表模式</strong></p>
<p>只显示表名，是表的默认显示方式</p>
<p><strong>详细信息模式</strong></p>
<p>会显示除了表名以为的其他信息，记录数，修改日期和表的注释等</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2vc7yZjic33zyty6PylhMMA9icpMGjtGb8croq8uo47TuF9RjtSyd3zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>ER图模式</strong></p>
<p>会以ER图的形式显示每个表之间的关联关系，如下图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoApicGEtFC7zxyYETTOrtKYs06TTTic2SNpsnEAKp99kTS3UvXYzXqFzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>导入向导</strong></p>
<p>用来引导用户导入数据到数据库对应的表</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qFfSo9UHuDNM7DO3hqcG0WgZSuMc6TCjM8JAytt1BYL0RvBNn7k1Lxafshibm5libYAUCzycBfmMc6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们打算将Customers.xlsx里的数据导入到表Customers中，具体操作如下：</p>
<p>在导入向导中选择要导入的文件类型，Navicat支持多种导入类型，这里我们选择导入Excel文档，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo4kDbmWv2gicpicrUlQtmq33Zua6RkT4sZQXhXr9ibCkPnp6lw50Y29a4g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>找的需要导入的文件，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo1oic8nEeeSjQic5fIqLcGETvcWeJAra33SRQ2dNJouJ9ePIpNZJyIVdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置字段名等内容，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIofmn6WiaXl270ic5y07kUErIXsYd4jy7a7YmbxyxfxguW716fRKJcnoDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择要导入的目标表，你也可以直接新建一张表，这里我们导入到目标表Orders，然后点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoTQ7UYQWjlr4dC3iaqrVkqWKVPNmptZrjAU6u9ZlrnP1vPLqLUVuJckA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置源表和目标表之间的字段对应关系，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoAo5sT3zWIOWYGCVKeC2DSPW0E0tM6z7GBM2XHwbTjo7HibAgXtzPYsw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择一个导入模式，如果是直接添加，可以选择添加模式，如果是要先清空目标表再导入可以选择复制模式，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJzoC5vQ9mb05YrSUsAoTR6FRGpgGmrSZIgq2Hke2Q1ZgA7a5xP0alA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始就可以导入数据了</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoqhr3jY27uwVkalMIMw3VNtY2ZsZsrMgXQCKoJFDPDH66By1IxYCHnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>导出向导</strong></p>
<p>需要将数据库里的数据导出可以使用导出向导，具体如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIosDqVIic9Fyw1GIzhhynAp1gj2YfBHUgEE53B03vdPOgDARQUsqBicvBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中选择导出文件类型，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo5SsBEomUrzic3fvd4TJr8Ig4sFTGGdHxtjCJMPjXU63pVEbmNUicexzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择需要导出的表，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIocqzcibg1sEPdpbx0f0FqziaiahGak5Iz24y2kWFtzm3BfOcEkalwDCKIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>选择需要导出的列，默认全部字段，也可以选择指定字段，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJuTZ3MzwxnY7PAbyvQypMRE4X4266DicRFzccGgKDibib8bwzHjBJ0VkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>定义一些附加选项，导出包含标题，遇到导出错误继续等，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoDqcgLqHnEASje1LdH85fxzASTibKuiaPuItStfxzjXKsydBho1xUpfQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击开始执行导出操作</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIotFkCMS4qmA9ZaU9lQV72kd9yf3xQuXH8tNQYy0Trjc89OaPJVfbODw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>新建查询</strong></p>
<p>新建查询有两种方式，可以直接右键选择新建查询，也可以点击菜单栏的查询-新建查询，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoZge8TTPMzoYaMaichOUmddo9OkwHGwIoVHSb7TpiauRtIgCHtnzZcoXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>查询功能</strong></p>
<p>查询是我们用的比较频繁的一个功能，在查询窗口里面有许多好用的功能</p>
<p><strong>智能提醒</strong></p>
<p>根据我们输入的字符来自动提醒一些关键字，字段名，表名，视图名，函数名等，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIodFO8VeLldjRGdxUUCu7JqaVDcZhpzu3ET8A2urodtyUE674d2P9R8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>美化SQL</strong></p>
<p>当你看到一段代码写的很复杂且都堆在一起，可以使用美化SQL功能，一键帮你把堆在一起的SQL美化得整整齐齐。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2ws81EQbUEv6OwTZVUCVv0SkYeQ4ibU7Mia0oUqubE856t8QFTYTZnkg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>美化前</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIop5eiciaJ9kT4iaL8sxibNmWaRI68twNTKSAUsiaF8lmc2N9OkJnhBb5lNGg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>美化后</p>
<p><strong>其他功能</strong></p>
<p>此外查询窗口还有很多其他功能，都集中在左上角的三短横上面，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoZfZE8m5xAlAiaWyiaoaB5ib4FJPHB48teicrvpL1iaZUc3mtIQ4ImHnBpKg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里将查询窗口的所有功能都汇集在一起，比如注释，查看执行计划，简化SQL等都在这里可以找到，小伙伴们可以一一尝试一下。</p>
<p><strong>创建视图</strong></p>
<p>Navicat提供一套创建视图的模板，主要是针对新手朋友。如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIotlErKxibGVngibLqbKfAmZmJgao6RMMOEOf1buYlRthMN4EMV1emOnRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里我们只需要写查询语句即可，在SQL预览里可以看到完整的SQL语句。如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo58Z7WQHwWh2LicjJAsBAAbEUictk2oYmex5u79n1C4SlHzmSsK6JA4MQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击预览，可以看到我们刚定义的视图结果，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoobd6t9vLPcZRnteqc9v8N0jeYhS5gtyCkicTPnh8ymjLHr5sKPjolgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>创建函数和存储过程</strong></p>
<p>函数和存储过程是类似的，区别是函数必须要有返回值，而存储过程可有可无。</p>
<p>他们也有一套模板，选择函数后点击新建函数，弹出如下对话框：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoJibuYXzHaia6wiaN41LwF9BQoqtteicJj4sDF5lFibicE6vXkYbT6F3ypGww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>输入函数名或过程名，然后选择你想是想创建函数还是存储过程。然后输入参数名称和类型，也可以不带参数，点击下一步</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoMVGCWGLLdRfME5vtAb7GP7jiaSZJ4bgwsmcZHVM1Cn1aCaEFVTDF6vg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>函数必须要有返回值，这里需要定义返回值类型，点击下一步或完成。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoc3Jq9L01h8luBsFpIPcibrqXOs4A6ibXqK5GEHQsibB8cRW5kia1FdO90A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里会配置函数的一些附加信息，通常不用配置，直接点击完成即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoTFmlaHv2ZIP9t0icQd6pMjFOAOHTibicYRdNXGTo18gyP0MPzDJueXRBQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后我们就可以看到函数的编辑窗口了</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIog39HtbibClCyegtdt1zjN8nIvxbIYcvpeLuaMI6oL7Dw5ic0copYAN2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>写好函数里的语句后点击运行即可开始测试了。</p>
<p><strong>备份和还原</strong></p>
<p>通过Navicat，我们可以很方便的完成备份和还原操作，我们先来备份一个文件。</p>
<p><strong>备份</strong></p>
<p>点击菜单栏的SQL Server备份——新建备份，在弹出的窗口中配置备份内容，然后点击生成SQL即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIowFVnb9HfcicQHiagCnb3HLzyvpicUpF7Cf9S5qBB7CmfUfFtpckMdcRQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在这里我们可以看到备份的代码，然后点备份就会开始备份</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIo2N7mdeSiaMqEKbib8784hD9cYszwMFVrU2k1eqOdWqfF3Qib2UGvkiabhw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>还原</strong></p>
<p>在备份完成后，我们可以选择还原该备份包</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoFbj8G9rvic4Pod7YeTzZDFm4hFEh6eibImpO9KF62UYuunZGOlC6qV7g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在弹出的对话框中可以配置相关信息</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoYkYWtRVp2H7l25ib5NPT6nQmdyx0v2eU6Rzmng4jvLFoQYnvWRYDn6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击生成SQL就会看到执行备份的SQL命令，点击还原即可开始执行</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoOXxlnPcECCGib8L7RGNOMze8FPzDmHiaib7BgGGlXQr0Yd6s0kLiaVzicqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>历史日志记录</strong></p>
<p>该功能可以很方便的查看到你在数据库中执行了哪些操作。点击菜单栏中的工具——历史日志，就可以看到我们的操作记录了，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/icbViakEeV5qHqCWBvw7MFea3YE2vSiaxIoNM11YDOPrBnV7ibs8eQwJorWiaTRo1icrlFZu2rIjjjssomNk5dAZlIuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="利用Navicat客户端实现定时插入删除数据"><a href="#利用Navicat客户端实现定时插入删除数据" class="headerlink" title="利用Navicat客户端实现定时插入删除数据"></a>利用Navicat客户端实现定时插入删除数据</h2><h3 id="开启MySQL定时"><a href="#开启MySQL定时" class="headerlink" title="开启MySQL定时"></a>开启MySQL定时</h3><p>查询状态</p>
<p>新建查询&gt;运行：SHOW VARIABLES LIKE ‘event_scheduler’<br>查询看到默认为关闭</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507145245502.png" alt="在这里插入图片描述"></p>
<p>修改为开启<br>执行：SET GLOBAL event_scheduler = ON<br>开启，再次查询为ON，ok</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507145450634.png" alt="在这里插入图片描述"></p>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507150455218.png" alt="在这里插入图片描述"></p>
<h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>打开窗口<br>一次点击 函数&gt;新建函数&gt;完成</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507143906791.png" alt="在这里插入图片描述"></p>
<p>创建函数<br>在begin和end之间写一条要执行的sql<br>每分钟新增一条数据（定时删除可看最下方ps内容）</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507144555462.png" alt="在这里插入图片描述"></p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">	INSERT INTO hello (text,date) VALUES (&quot;每分钟增加一条&quot;,NOW());</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>点保存，填写一个名字，再点击函数可以看到刚才新建的函数</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507144312305.png" alt="在这里插入图片描述"></p>
<h3 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h3><p>一次点击 事件&gt;新建 输入call +刚才函数起的名字，我的是：CALL hello_min_ins</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507144717427.png" alt="在这里插入图片描述"></p>
<p>点击 计划，设置 时间间隔和开始时间</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507145730541.png" alt="在这里插入图片描述"></p>
<p>起一个名字保存，点击事件可以看到刚才创建的事件<br>此事件用来定时调用之前创建的函数</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507145816934.png" alt="在这里插入图片描述"></p>
<p>完成<br>实现了每分钟新增一条数据</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507150518156.png" alt="在这里插入图片描述"></p>
<p>ps：如果想每分钟删除一条id最小的数据，新建函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">	DELETE FROM hello ORDER BY id LIMIT 1;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>ps：如果想每天删除七天前的数据，新建函数</p>
<p>ps：如果想每天删除七天前的数据，新建函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    DELETE FROM hello WHERE date &lt; DATE_SUB(CURDATE(), INTERVAL 7 DAY);</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


<p>事件里修改事件EVERY 1 DAY即可</p>
<p><img src="/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/20190507151600764.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/5.5.MySQL%E5%B7%A5%E5%85%B7%E4%B9%8BNavicat/" data-id="ckw61sdwb004woswd23wp441k" data-title="MySQL工具之Navicat" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-21.1.微信开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:36:09.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/">微信开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="微信公众平台开发"><a href="#微信公众平台开发" class="headerlink" title="微信公众平台开发"></a>微信公众平台开发</h1><h2 id="订阅号和服务号和企业号"><a href="#订阅号和服务号和企业号" class="headerlink" title="订阅号和服务号和企业号"></a>订阅号和服务号和企业号</h2><p>订阅号每天一条，收拢至订阅号文件夹，不强制推送；服务号每月一条，消息仍展示在聊天列表，但下发消息将即时提醒用户。</p>
<p>1、订阅号：主要偏于为用户传达资讯（类似报纸杂志），认证前后都是每天只可以群发一条消息。</p>
<p>2、服务号：主要偏于服务交互（类似银行，114，提供服务查询），认证前后都是每个月可群发4条消息；</p>
<p>3、企业号：主要用于公司内部通讯使用，需要先验证身份才可以关注成功企业号。</p>
<h2 id="验证登录和授权：AccessToken"><a href="#验证登录和授权：AccessToken" class="headerlink" title="验证登录和授权：AccessToken"></a>验证登录和授权：AccessToken</h2><h3 id="1-查看appid及appsecret"><a href="#1-查看appid及appsecret" class="headerlink" title="1.查看appid及appsecret"></a>1.查看appid及appsecret</h3><p>公众号后台界面查看</p>
<h3 id="2-获取accessToken"><a href="#2-获取accessToken" class="headerlink" title="2.获取accessToken"></a>2.获取accessToken</h3><p>1.临时方法获取</p>
<p>临时通过<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/debug/">在线测试</a> 或者 浏览器/postman等方式发送get请求获取返回结果里的accessToken</p>
<p>2.接口获取</p>
<p>第三方需要一个access_token获取和刷新的中控服务器（这个服务器会提前进行刷新，确保无缝连接）。</p>
<p>并发获取access_token会导致AccessToken互相覆盖，影响具体的业务功能，所以需要加并发锁</p>
<h2 id="用户标识：openid和UnionID"><a href="#用户标识：openid和UnionID" class="headerlink" title="用户标识：openid和UnionID"></a>用户标识：openid和UnionID</h2><p>为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID。如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下。绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID，可以在用户管理-获取用户基本信息（UnionID机制）文档了解详情。</p>
<p>​    <strong>一个用户对于一个公众号只会存在一个openid，即使取消关注了再关注，openid也不会改变。如果一个大公司下有多个公众号，会产生不同的openid，为了实现该公司下公众号间的数据互通，会有一个唯一的UnionID作为用户的唯一标识</strong></p>
<h2 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h2><p>公众号主要通过公众号消息会话和公众号内网页来为用户提供服务的：</p>
<h3 id="1、公众号消息会话"><a href="#1、公众号消息会话" class="headerlink" title="1、公众号消息会话"></a><strong>1、公众号消息会话</strong></h3><p>公众号是以微信用户的一个联系人形式存在的，消息会话是公众号与用户交互的基础。</p>
<p>目前公众号内主要有这样几类消息服务的类型，分别用于不同的场景。</p>
<p>1）群发消息：公众号可以以一定频次（订阅号为每天1次，服务号为每月4次），向用户群发消息，包括文字消息、图文消息、图片、视频、语音等。</p>
<p><strong>在公众号后台管理界面的创作管理可以编辑后选择群发</strong></p>
<p>2）被动回复消息：在用户给公众号发消息后，微信服务器会将消息发到开发者预先在开发者中心设置的服务器地址（开发者需要进行消息真实性验证），公众号可以在5秒内做出回复，可以回复一个消息，也可以回复命令告诉微信服务器这条消息暂不回复。被动回复消息可以设置加密（在公众平台官网的开发者中心处设置，设置后，按照消息加解密文档来进行处理。其他3种消息的调用因为是API调用而不是对请求的返回，所以不需要加解密）。</p>
<p>3）客服消息：在用户给公众号发消息后的48小时内，公众号可以给用户发送不限数量的消息，主要用于客服场景。用户的行为会触发事件推送，某些事件推送是支持公众号据此发送客服消息的，详见微信推送消息与事件说明文档。</p>
<p>4）模板消息：在需要对用户发送服务通知（如刷卡提醒、服务预约成功通知等）时，公众号可以用特定内容模板，主动向用户发送消息。</p>
<h3 id="2、公众号内网页"><a href="#2、公众号内网页" class="headerlink" title="2、公众号内网页"></a><strong>2、公众号内网页</strong></h3><p>许多复杂的业务场景，需要通过网页形式来提供服务，这时需要用到：</p>
<p>1）网页授权获取用户基本信息：通过该接口，可以获取用户的基本信息（获取用户的OpenID是无需用户同意的，获取用户的基本信息则需用户同意）</p>
<p>2）微信JS-SDK：是开发者在网页上通过JavaScript代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。</p>
<h2 id="全局返回码"><a href="#全局返回码" class="headerlink" title="全局返回码"></a>全局返回码</h2><p>公众号每次调用接口时，可能获得正确或错误的返回码，开发者可以根据返回码信息调试接口，排查错误</p>
<p>-1：系统繁忙，此时请开发者稍候再试</p>
<p>0：请求成功</p>
<p>4xxxx，6xxxx，9xxxx：各种问题的返回码</p>
<h2 id="开始开发"><a href="#开始开发" class="headerlink" title="开始开发"></a>开始开发</h2><h3 id="1-申请服务器"><a href="#1-申请服务器" class="headerlink" title="1.申请服务器"></a>1.申请服务器</h3><h3 id="2-搭建服务"><a href="#2-搭建服务" class="headerlink" title="2.搭建服务"></a>2.搭建服务</h3><p>后端程序配置微信的设置</p>
<h3 id="3-申请公众号"><a href="#3-申请公众号" class="headerlink" title="3.申请公众号"></a>3.申请公众号</h3><h3 id="4-开发者基本配置"><a href="#4-开发者基本配置" class="headerlink" title="4.开发者基本配置"></a>4.开发者基本配置</h3><h4 id="1-填写服务器配置"><a href="#1-填写服务器配置" class="headerlink" title="1.填写服务器配置"></a>1.填写服务器配置</h4><p>服务器地址（URL）、Token和EncodingAESKey</p>
<p>URL是开发者用来接收微信消息和事件的接口URL。</p>
<p>Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。</p>
<p>EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥</p>
<p>填写并提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求：signature（微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数），timestamp（时间戳），nonce（随机数），echostr（随机字符串）</p>
<p>通过检验signature对请求进行校验：</p>
<p>1）将token、timestamp、nonce三个参数进行字典序排序 </p>
<p>2）将三个参数字符串拼接成一个字符串进行sha1加密</p>
<p> 3）将加密后的字符串与signature对比，true表示是微信发来的，false表示不是微信。</p>
<p>若确认此次GET请求来自微信服务器，原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败</p>
<h4 id="2-后续可以在公众号后台的开发-基本配置里修改配置："><a href="#2-后续可以在公众号后台的开发-基本配置里修改配置：" class="headerlink" title="2.后续可以在公众号后台的开发/基本配置里修改配置："></a>2.后续可以在公众号后台的开发/基本配置里修改配置：</h4><p>开发者ID（AppID）：自动生成</p>
<p>开发者密码(AppSecret)：可以重置自动生成复制</p>
<p>IP白名单：配置自己的白名单以便调用测试接口获得access_token</p>
<p>服务器地址(URL)：http://外网IP/wx ，端口固定为80（http://外网IP/wx）</p>
<p>令牌(Token)：自主设置，这个token与前面的access_token不是一回事。这个token只用于验证开发者服务器</p>
<p>消息加解密密钥(EncodingAESKey)</p>
<h3 id="5-后端进行框架构思"><a href="#5-后端进行框架构思" class="headerlink" title="5.后端进行框架构思"></a>5.后端进行框架构思</h3><p>主要有三个部分：负责业务逻辑部分的服务器，负责对接微信API的API-Proxy服务器，以及唯一的AccessToken中控服务器</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xnC7SUbrIRwI8NhEGFeax6HoPcTMDqKGYxaSoNqBwocrj70Pt1EcKnQ/0?wx_fmt=png" alt="img"></p>
<p>1）AccessToken中控服务器：</p>
<p>负责： 提供主动刷新和被动刷新机制来刷新accessToken并存储（为了防止并发刷新，注意加并发锁），提供给业务逻辑有效的accessToken。</p>
<p>优点： 避免业务逻辑方并发获取access_token，避免AccessToken互相覆盖，提高业务功能的稳定性。</p>
<p>2）API-Proxy服务器：</p>
<p>负责：专一与微信API对接，不同的服务器可以负责对接不同的业务逻辑，更可进行调用频率、权限限制。</p>
<p>优点：某台API-proxy异常，还有其余服务器支持继续提供服务，提高稳定性，避免直接暴漏内部接口，有效防止恶意攻击，提高安全性</p>
<p>3）后端服务的服务器</p>
<h3 id="6-码代码"><a href="#6-码代码" class="headerlink" title="6.码代码"></a>6.码代码</h3><h3 id="7-在线测试"><a href="#7-在线测试" class="headerlink" title="7.在线测试"></a>7.在线测试</h3><p>在线测试接口可以输入access_token，进行接口测试，返回”请求失败”，说明代码有问题，检查代码逻辑。</p>
<p>“请求成功”，然后根据返回结果查看是否符合预期</p>
<h3 id="8-真实体验"><a href="#8-真实体验" class="headerlink" title="8.真实体验"></a>8.真实体验</h3><p>手机端微信关注测试</p>
<h2 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h2><ol>
<li>自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。</li>
<li>一级菜单最多4个汉字，二级菜单最多7个汉字，多出来的部分将会以“…”代替。</li>
<li>创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile（简介）页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果</li>
</ol>
<h3 id="设置类型："><a href="#设置类型：" class="headerlink" title="设置类型："></a>设置类型：</h3><ol>
<li><p>click：点击推事件。用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互；</p>
</li>
<li><p>view：跳转URL。用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。</p>
</li>
<li><p>scancode_push：扫码推事件用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。（这种是直接显示结果）</p>
</li>
<li><p>scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。（这种会直接返回公众号界面，并等待开发者下发消息）</p>
</li>
<li><p>pic_sysphoto：弹出系统拍照发图用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>pic_photo_or_album：弹出拍照或者相册发图用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。</p>
</li>
<li><p>pic_weixin：弹出微信相册发图器用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>location_select：弹出地理位置选择器用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。</p>
</li>
<li><p>media_id：下发消息（除文本消息）用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频、图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</p>
</li>
<li><p>view_limited：跳转图文消息URL用户点击view_limited类型按钮后，微信客户端将打开开发者在按钮中填写的永久素材id对应的图文消息URL，永久素材类型只支持图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</p>
</li>
</ol>
<p>view类型：弹出网页（pc版本）</p>
<p>media_id类型：显示图文消息</p>
<p>click类型：发现公众号系统提示：“该公众号暂时无法提供服务“</p>
<p>点击click类型button，微信后台会推送一个event类型的xml 给开发者，需要开发者进一步完善后台代码逻辑，增加对自定义菜单事件推送的响应，必须设置key值</p>
<h3 id="创建-修改接口："><a href="#创建-修改接口：" class="headerlink" title="创建/修改接口："></a>创建/修改接口：</h3><p>这里的url应该是直接的url，nginx配置后需要前后端代码进行重定向</p>
<p>“sub_button”: [ ]里为空，代表不包含二级菜单</p>
<p>需要先获得access_token，然后POST（使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN%EF%BC%8C%E8%AF%B7%E6%B1%82%E4%BD%93%E4%B8%BA%EF%BC%9A">https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN，请求体为：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;button&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            	&quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;安全帽绑定&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;http:&#x2F;&#x2F;elinktech.cn&#x2F;about.html&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;,</span><br><span class="line">        </span><br><span class="line">                    &#123;</span><br><span class="line">                &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;运营服务&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;http:&#x2F;&#x2F;elinktech.cn&#x2F;daohang.html&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;, </span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;view&quot;, </span><br><span class="line">                &quot;name&quot;: &quot;E联商城&quot;, </span><br><span class="line">                &quot;url&quot;: &quot;http:&#x2F;&#x2F;elinktech.cn&#x2F;shop.html&quot;, </span><br><span class="line">                &quot;sub_button&quot;: [ ]</span><br><span class="line">            &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回0表示设置成功。</p>
<p>需要修改时，直接按流程发送，只是请求体里的东西作修改即可，不需要删除已有的菜单栏</p>
<h3 id="查询接口："><a href="#查询接口：" class="headerlink" title="查询接口："></a>查询接口：</h3><p>GET <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/get_current_selfmenu_info?access_token=ACCESS_TOKEN%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84json%E5%8D%B3%E4%B8%BA%E6%8E%A5%E5%8F%A3">https://api.weixin.qq.com/cgi-bin/get_current_selfmenu_info?access_token=ACCESS_TOKEN，返回结果的json即为接口</a></p>
<h3 id="删除接口："><a href="#删除接口：" class="headerlink" title="删除接口："></a>删除接口：</h3><p>GET <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN%EF%BC%8C%E8%BF%94%E5%9B%9E0%E5%8D%B3%E4%B8%BA%E5%88%A0%E9%99%A4%E6%88%90%E5%8A%9F">https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN，返回0即为删除成功</a></p>
<h3 id="事件推送："><a href="#事件推送：" class="headerlink" title="事件推送："></a>事件推送：</h3><p>用户点击自定义菜单后，微信会把事件推送给开发者，请注意，点击菜单弹出子菜单，不会产生上报</p>
<p>推送的事件有10种类型，对应接口的type：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[FromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>123456789<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[event]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Event</span>&gt;</span>&lt;![CDATA[CLICK]]&gt;<span class="tag">&lt;/<span class="name">Event</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">EventKey</span>&gt;</span>&lt;![CDATA[EVENTKEY]]&gt;<span class="tag">&lt;/<span class="name">EventKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="个性化菜单接口"><a href="#个性化菜单接口" class="headerlink" title="个性化菜单接口"></a>个性化菜单接口</h3><p>可以通过该接口，让公众号的不同用户群体看到不一样的自定义菜单</p>
<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包发到开发者填写的URL上。</p>
<h3 id="1-接收文本消息"><a href="#1-接收文本消息" class="headerlink" title="1.接收文本消息"></a>1.接收文本消息</h3><p> 1.粉丝给公众号发送的文本消息</p>
<p>粉丝给公众号发送文本消息：“欢迎开启公众号开发者模式”，在开发者后台，收到公众平台发送的xml 如下：（下文均隐藏了ToUserName 及 FromUserName 信息）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[公众号]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[粉丝号]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1460537339<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[欢迎开启公众号开发者模式]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>6272960105994287618<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>createTime 是微信公众平台记录粉丝发送该消息的具体时间</p>
<p>text: 用于标记该xml 是文本消息，一般用于区别判断</p>
<p>欢迎开启公众号开发者模式: 说明该粉丝发给公众号的具体内容是欢迎开启公众号开发者模式</p>
<p>MsgId: 是公众平台为记录识别该消息的一个标记数值, 微信后台系统自动产生</p>
<ol start="2">
<li>被动回复文本消息</li>
</ol>
<p>即公众号给粉丝发送的文本消息，官方wiki链接: <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message">被动回复用户消息</a></p>
<p>特别强调：</p>
<p>1） 被动回复消息，即发送被动响应消息，不同于客服消息接口</p>
<p>2） 它其实并不是一种接口，而是对微信服务器发过来消息的一次回复</p>
<p>3） 收到粉丝消息后不想或者不能5秒内回复时，需回复“success”字符串</p>
<p>4） 客服接口在满足一定条件下随时调用</p>
<p>公众号想回复给粉丝一条文本消息，内容为“test”, 那么开发者发送给公众平台后台的xml 内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[粉丝号]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[公众号]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1460541339<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[test]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>特别备注：</p>
<p>1）ToUserName（接受者）、FromUserName(发送者) 字段请实际填写。</p>
<p>2）createtime 只用于标记开发者回复消息的时间，微信后台发送此消息都是不受这个字段约束。</p>
<p>3）text : 用于标记 此次行为是发送文本消息 （当然可以是image/voice等类型）。</p>
<p>4）文本换行 ‘\n’。</p>
<p> 3.回复success问题</p>
<p>查询官方wiki 开头强调： 假如服务器无法保证在五秒内处理回复，则必须回复“success”或者“”（空串），否则微信后台会发起三次重试。</p>
<p>解释一下为何有这么奇怪的规定。发起重试是微信后台为了尽可以保证粉丝发送的内容开发者均可以收到。如果开发者不进行回复，微信后台没办法确认开发者已收到消息，只好重试。</p>
<p>真的是这样子吗？尝试一下收到消息后，不做任何回复。在日志中查看到微信后台发起了三次重试操作，日志截图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xauONdVFJvic1Wfzxa0HnSEZ5libLcYibWWkb7gNDjt56DFs8kiaY3OtFtw/0?wx_fmt=png" alt="img"></p>
<p>三次重试后，依旧没有及时回复任何内容，系统自动在粉丝会话界面出现错误提示“该公众号暂时无法提供服务，请稍后再试”。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xBp7Iiam8ydK0W4MOZa9bfHKgTesMkj3HXOnsYxttsodweib7mH9y5eQg/0?wx_fmt=png" alt="img"></p>
<p>如果回复success，微信后台可以确定开发者收到了粉丝消息，没有任何异常提示。因此请大家注意回复success的问题。</p>
<ol start="4">
<li>流程图</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xEVXiblIZm80UCBlia6vYiaXD7Od9Ev3nujHoNkNCubr9WPo8L7opJGhIA/0?wx_fmt=png" alt="img"></p>
<h3 id="2-接收图片消息"><a href="#2-接收图片消息" class="headerlink" title="2.接收图片消息"></a>2.接收图片消息</h3><p>MediaID</p>
<p>目的：</p>
<p>1）引入素材管理</p>
<p>2）以文本消息，图片消息为基础，可自行理解剩余的语音消息、视频消息、地理消息等</p>
<p>预实现功能：</p>
<p>接受粉丝发送的图片消息，并立马回复相同的图片给粉丝。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0x6zWAJ79NkGrlg34cGBjvqxtSxSVw5gPMsmlygTyhdDblrsNiaCX8GhQ/0?wx_fmt=png" alt="img"></p>
<p> 1.接收图片消息</p>
<p>即粉丝给公众号发送的图片消息。官方wiki链接：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html">消息管理/接收消息-接受普通消息/ 图片消息</a>从实例讲解，粉丝给公众号发送一张图片消息，在公众号开发者后台接收到的xml如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml&gt;</span><br><span class="line"> &lt;ToUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/ToUserName&gt;</span><br><span class="line"> &lt;FromUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/FromUserName&gt;</span><br><span class="line"> &lt;CreateTime&gt;1460536575&lt;/CreateTime&gt;</span><br><span class="line"> &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;</span><br><span class="line"> &lt;PicUrl&gt;&lt;![CDATA[http://mmbiz.qpic.cn/xxxxxx /0]]&gt;&lt;/PicUrl&gt;</span><br><span class="line"> &lt;MsgId&gt;6272956824639273066&lt;/MsgId&gt;</span><br><span class="line"> &lt;MediaId&gt;&lt;![CDATA[gyci5a-xxxxx-OL]]&gt;&lt;/MediaId&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure>

<p>特别说明：</p>
<p>PicUrl: 这个参数是微信系统把“粉丝“发送的图片消息自动转化成url。 这个url可用浏览器打开查看到图片。</p>
<p>MediaId: 是微信系统产生的id 用于标记该图片，详情可参考wiki<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1444738727&token=&lang=zh_CN">素材管理/获取临时素材</a>，</p>
<p> 2.被动回复图片消息</p>
<p>即公众号给粉丝发送的图片消息。官方wiki链接：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140543&token=&lang=zh_CN">消息管理/发送消息-被动回复用户消息/ 图片消息</a>)</p>
<p>特别说明：</p>
<p>1） 被动回复消息，即发送被动响应消息，不同于客服消息接口</p>
<p>2） 它其实并不是一种接口，而是对微信服务器发过来消息的一次回复</p>
<p>3） 收到粉丝消息后不想或者不能5秒内回复时，需回复“success”字符串</p>
<p>4） 客服接口在满足一定条件下随时调用</p>
<p>开发者发送给微信后台的xml 如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;xml&gt;</span><br><span class="line"> &lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt;</span><br><span class="line"> &lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt;</span><br><span class="line"> &lt;CreateTime&gt;1460536576&lt;/CreateTime&gt;</span><br><span class="line"> &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;</span><br><span class="line"> &lt;Image&gt;</span><br><span class="line"> &lt;MediaId&gt;&lt;![CDATA[gyci5oxxxxxxv3cOL]]&gt;&lt;/MediaId&gt;</span><br><span class="line"> &lt;/Image&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure>

<p>这里填写的MediaId的内容，其实就是粉丝的发送图片的原MediaId，所以粉丝收到了一张一模一样的原图。 如果想回复粉丝其它图片怎么呢？</p>
<p>1） 新增素材，请参考 新增临时素材 或者 新增永久素材</p>
<p>2） 获取其MediaId，请参考 获取临时素材MediaID 或者 获取永久素材MediaID</p>
<p>3.3 流程图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PiajxSqBRaEIQxibpLbyuSK9XkjDgZoL0xDdfzVUuLvr3iaR3BvJnkkL9kATK0TgmFXsF2tPHTlpulfJ6eU930a1Q/0?wx_fmt=png" alt="img"></p>
<h3 id="3-语音消息"><a href="#3-语音消息" class="headerlink" title="3.语音消息"></a>3.语音消息</h3><h3 id="4-视频消息"><a href="#4-视频消息" class="headerlink" title="4.视频消息"></a>4.视频消息</h3><h3 id="5-小视频消息"><a href="#5-小视频消息" class="headerlink" title="5.小视频消息"></a>5.小视频消息</h3><h3 id="6-地理位置信息"><a href="#6-地理位置信息" class="headerlink" title="6.地理位置信息"></a>6.地理位置信息</h3><h3 id="7-链接消息"><a href="#7-链接消息" class="headerlink" title="7.链接消息"></a>7.链接消息</h3><h2 id="接收事件推送"><a href="#接收事件推送" class="headerlink" title="接收事件推送"></a>接收事件推送</h2><p>只有点击了微信的自定义菜单，才会被认定为是一个事件，向指定的url发送事件推送的xml</p>
<h3 id="1-关注-取消关注事件"><a href="#1-关注-取消关注事件" class="headerlink" title="1 关注/取消关注事件"></a>1 关注/取消关注事件</h3><p>用户在关注与取消关注公众号时，微信会把这个事件推送到开发者填写的URL。方便开发者给用户下发欢迎消息或者做帐号的解绑。为保护用户数据隐私，开发者收到用户取消关注事件时需要删除该用户的所有信息</p>
<h3 id="2-扫描带参数二维码事件"><a href="#2-扫描带参数二维码事件" class="headerlink" title="2 扫描带参数二维码事件"></a>2 扫描带参数二维码事件</h3><p>用户扫描带场景值二维码时，可能推送以下两种事件：</p>
<ol>
<li>如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。</li>
<li>如果用户已经关注公众号，则微信会将带场景值扫描事件推送给开发者</li>
</ol>
<h3 id="3-上报地理位置事件"><a href="#3-上报地理位置事件" class="headerlink" title="3 上报地理位置事件"></a>3 上报地理位置事件</h3><p>用户同意上报地理位置后，每次进入公众号会话时，都会在进入时上报地理位置，或在进入会话后每5秒上报一次地理位置，公众号可以在公众平台网站中修改以上设置。上报地理位置时，微信会将上报地理位置事件推送到开发者填写的URL。</p>
<h3 id="4-自定义菜单事件"><a href="#4-自定义菜单事件" class="headerlink" title="4 自定义菜单事件"></a>4 自定义菜单事件</h3><p>用户点击自定义菜单后，微信会把点击事件推送给开发者，请注意，点击菜单弹出子菜单，不会产生上报</p>
<h3 id="5-点击菜单拉取消息时的事件推送"><a href="#5-点击菜单拉取消息时的事件推送" class="headerlink" title="5 点击菜单拉取消息时的事件推送"></a>5 点击菜单拉取消息时的事件推送</h3><h3 id="6-点击菜单跳转链接时的事件推送"><a href="#6-点击菜单跳转链接时的事件推送" class="headerlink" title="6 点击菜单跳转链接时的事件推送"></a>6 点击菜单跳转链接时的事件推送</h3><h2 id="被动回复用户消息"><a href="#被动回复用户消息" class="headerlink" title="被动回复用户消息"></a>被动回复用户消息</h2><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。</p>
<p>严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。</p>
<p>1、直接回复success（推荐方式） 2、直接回复空串（指字节长度为0的空字符串，而不是XML结构体中content字段的内容为空）</p>
<p>1、开发者在5秒内未回复任何内容 2、开发者回复了异常数据，比如JSON数据等</p>
<p>就会出现<strong>“该公众号暂时无法提供服务，请稍后再试”</strong></p>
<p>回复文本消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toXML</span><span class="params">(String toUserName,String fromUserName,String text)</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;xml&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;ToUserName&gt;&lt;![CDATA[&quot;</span>+toUserName+<span class="string">&quot;]]&gt;&lt;/ToUserName&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;FromUserName&gt;&lt;![CDATA[&quot;</span>+fromUserName+<span class="string">&quot;]]&gt;&lt;/FromUserName&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;CreateTime&gt;&quot;</span>+System.currentTimeMillis()/<span class="number">1000</span>+<span class="string">&quot;&lt;/CreateTime&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;Content&gt;&lt;![CDATA[&quot;</span>+text+<span class="string">&quot;]]&gt;&lt;/Content&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;/xml&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回复图片消息</p>
<p>这里的media_id需要先调用接口上传图片。图片格式为jpg才能成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toImageXML</span><span class="params">(String toUserName,String fromUserName,String media_id)</span></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;xml&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;ToUserName&gt;&lt;![CDATA[&quot;</span>+toUserName+<span class="string">&quot;]]&gt;&lt;/ToUserName&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;FromUserName&gt;&lt;![CDATA[&quot;</span>+fromUserName+<span class="string">&quot;]]&gt;&lt;/FromUserName&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;CreateTime&gt;&quot;</span>+System.currentTimeMillis()/<span class="number">1000</span>+<span class="string">&quot;&lt;/CreateTime&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;Image&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;MediaId&gt;&lt;![CDATA[&quot;</span>+media_id+<span class="string">&quot;]]&gt;&lt;/MediaId&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;/Image&gt;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;&lt;/xml&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些回复用户消息都是一般只能回复一条，如果两条的话，还需要调用客服回复消息接口。</p>
<h2 id="自动回复规则"><a href="#自动回复规则" class="headerlink" title="自动回复规则"></a>自动回复规则</h2><p>开发者可以通过该接口，获取公众号当前使用的自动回复规则，包括关注后自动回复、消息自动回复（60分钟内触发一次）、关键词自动回复</p>
<h2 id="模板消息"><a href="#模板消息" class="headerlink" title="模板消息"></a>模板消息</h2><ol>
<li>模板消息调用时主要需要模板ID和模板中各参数的赋值内容</li>
<li>模板中参数内容必须以”.DATA”结尾，否则视为保留字</li>
<li>模板保留符号””</li>
</ol>
<p>在模版消息发送任务完成后，微信服务器会将是否送达成功作为通知，发送到开发者中心中填写的服务器配置地址中</p>
<h2 id="微信网页开发"><a href="#微信网页开发" class="headerlink" title="微信网页开发"></a>微信网页开发</h2><h3 id="适配问题"><a href="#适配问题" class="headerlink" title="适配问题"></a>适配问题</h3><p>安卓版微信直接调用系统浏览器内核，它是用chrome改造做的一套WKwebView,概念上类似是一套组件，目前的安卓微信浏览器都是使用的QQ浏览器的X5内核。</p>
<p>iOS则是调用safari，但微信<strong>iOS客户端</strong>于2017年3月1日前逐步升级为WKWebview内核。ios也可以自己切换为UIWebview。微信内任意入口进入任意网页，在网页加载成功后向下拉动页面（或点击网页右上角菜单按钮），使之显示出地址栏，当地址栏以 “此网页由” 开头即为当前使用WKWebview（目前基本都是这个），若以“网页由”则是使用的UIWebview</p>
<h3 id="网页授权"><a href="#网页授权" class="headerlink" title="网页授权"></a>网页授权</h3><p>如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。</p>
<p>OAuth2.0鉴权</p>
<h4 id="1、引导用户进入授权页面同意授权，获取code"><a href="#1、引导用户进入授权页面同意授权，获取code" class="headerlink" title="1、引导用户进入授权页面同意授权，获取code"></a>1、引导用户进入授权页面同意授权，获取code</h4><p>在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），引导关注者打开如下页面：<a target="_blank" rel="noopener" href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a> 若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。</p>
<p>尤其注意：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问。</p>
<p>如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE</p>
<p>跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。</p>
<p>code说明 ： code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期</p>
<p><strong>关于网页授权回调域名的说明</strong></p>
<p>1、在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；</p>
<p>2、授权回调域名配置规范为全域名，比如需要网页授权的域名为：<a target="_blank" rel="noopener" href="http://www.qq.com,配置以后此域名下面的页面http//www.qq.com/music.html">www.qq.com，配置以后此域名下面的页面http://www.qq.com/music.html</a> 、 <a target="_blank" rel="noopener" href="http://www.qq.com/login.html">http://www.qq.com/login.html</a> 都可以进行OAuth2.0鉴权。但<a target="_blank" rel="noopener" href="http://pay.qq.com/">http://pay.qq.com</a> 、 <a target="_blank" rel="noopener" href="http://music.qq.com/">http://music.qq.com</a> 、 <a target="_blank" rel="noopener" href="http://qq.com/">http://qq.com</a> 无法进行OAuth2.0鉴权</p>
<p>3、如果公众号登录授权给了第三方开发者来进行管理，则不必做任何设置，由第三方代替公众号实现网页授权即可</p>
<p><strong>关于网页授权的两种scope的区别说明</strong></p>
<p>1、以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p>
<p>2、以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</p>
<p>3、用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p>
<h4 id="2、通过code换取网页授权access-token（与基础支持中的access-token不同）"><a href="#2、通过code换取网页授权access-token（与基础支持中的access-token不同）" class="headerlink" title="2、通过code换取网页授权access_token（与基础支持中的access_token不同）"></a>2、通过code换取网页授权access_token（与基础支持中的access_token不同）</h4><p>这里通过code换取的是一个特殊的网页授权access_token,与基础支持中的access_token（该access_token用于调用其他接口）不同。公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。</p>
<p>尤其注意：由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起</p>
<p>获取code后，请求以下链接获取access_token： <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</a></p>
<p><strong>关于网页授权access_token和普通access_token的区别</strong></p>
<p>1、微信网页授权是通过OAuth2.0机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权access_token），通过网页授权access_token可以进行授权后接口调用，如获取用户基本信息；</p>
<p>2、其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用。</p>
<h4 id="3、如果需要，开发者可以刷新网页授权access-token，避免过期"><a href="#3、如果需要，开发者可以刷新网页授权access-token，避免过期" class="headerlink" title="3、如果需要，开发者可以刷新网页授权access_token，避免过期"></a>3、如果需要，开发者可以刷新网页授权access_token，避免过期</h4><p>由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token有效期为30天，当refresh_token失效之后，需要用户重新授权</p>
<p>获取第二步的access_token后，请求以下链接获取refresh_token： <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN">https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN</a></p>
<h4 id="4、通过网页授权access-token和openid获取用户基本信息（支持UnionID机制）"><a href="#4、通过网页授权access-token和openid获取用户基本信息（支持UnionID机制）" class="headerlink" title="4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）"></a>4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</h4><p>如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了</p>
<p>http：GET（请使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</a></p>
<p><strong>关于UnionID机制</strong></p>
<p>1、请注意，网页授权获取用户基本信息也遵循UnionID机制。即如果开发者有在多个公众号，或在公众号、移动应用之间统一用户帐号的需求，需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用UnionID机制来满足上述需求。</p>
<p>2、UnionID机制的作用说明：如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性，因为同一用户，对同一个微信开放平台下的不同应用（移动应用、网站应用和公众帐号），unionid是相同的。</p>
<p><strong>关于特殊场景下的静默授权</strong></p>
<p>1、上面已经提到，对于以snsapi_base为scope的网页授权，就静默授权的，用户无感知；</p>
<p>2、对于已关注公众号的用户，如果用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是scope为snsapi_userinfo，也是静默授权，用户无感知。</p>
<p><strong>检验授权凭证（access_token）是否有效</strong></p>
<p>http：GET（请使用https协议） <a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID">https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID</a></p>
<p>返回0代表有效</p>
<h3 id="网页开发样式库：WEBUI"><a href="#网页开发样式库：WEBUI" class="headerlink" title="网页开发样式库：WEBUI"></a>网页开发样式库：WEBUI</h3><h3 id="微信JS-SDK"><a href="#微信JS-SDK" class="headerlink" title="微信JS-SDK"></a>微信JS-SDK</h3><p>是<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/cgi-bin/loginpage?t=wxm2-login&lang=zh_CN">微信公众平台</a> 面向网页开发者提供的基于微信内的网页开发工具包</p>
<p>通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验</p>
<h4 id="1-绑定域名"><a href="#1-绑定域名" class="headerlink" title="1.绑定域名"></a>1.<strong>绑定域名</strong></h4><p>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。</p>
<p>备注：登录后可在“开发者中心”查看对应的接口权限</p>
<h4 id="2-引入JS文件"><a href="#2-引入JS文件" class="headerlink" title="2.引入JS文件"></a>2.<strong>引入JS文件</strong></h4><p>在需要调用JS接口的页面引入JS文件，（支持https）：<a target="_blank" rel="noopener" href="http://res.wx.qq.com/open/js/jweixin-1.6.0.js">http://res.wx.qq.com/open/js/jweixin-1.6.0.js</a></p>
<p>如需进一步提升服务稳定性，当上述资源不可访问时，可改访问：<a target="_blank" rel="noopener" href="http://res2.wx.qq.com/open/js/jweixin-1.6.0.js">http://res2.wx.qq.com/open/js/jweixin-1.6.0.js</a> （支持https）。</p>
<p>备注：支持使用 AMD/CMD 标准模块加载方法加载</p>
<h4 id="3-通过config接口注入权限验证配置"><a href="#3-通过config接口注入权限验证配置" class="headerlink" title="3.通过config接口注入权限验证配置"></a>3.<strong>通过config接口注入权限验证配置</strong></h4><p>所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用（同一个url仅需调用一次，对于变化url的SPA的web app可在每次url变化时进行调用,目前Android微信客户端不支持pushState的H5新特性，所以使用pushState来实现web app的页面会导致签名失败，此问题会在Android6.2中修复）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">  debug: <span class="literal">true</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">  appId: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">  timestamp: , <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">  nonceStr: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">  signature: <span class="string">&#x27;&#x27;</span>,<span class="comment">// 必填，签名</span></span><br><span class="line">  jsApiList: [] <span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h5 id="签名算法：JS-SDK使用权限签名算法"><a href="#签名算法：JS-SDK使用权限签名算法" class="headerlink" title="签名算法：JS-SDK使用权限签名算法"></a>签名算法：JS-SDK使用权限签名算法</h5><p><strong>jsapi_ticket（通过access_token获取）</strong></p>
<p>生成签名之前必须先了解一下jsapi_ticket，jsapi_ticket是公众号用于调用微信JS接口的临时票据。正常情况下，jsapi_ticket的有效期为7200秒，通过access_token来获取。由于获取jsapi_ticket的api调用次数非常有限，频繁刷新jsapi_ticket会导致api调用受限，影响自身业务，开发者必须在自己的服务全局缓存jsapi_ticket 。</p>
<ol>
<li>参考以下文档获取access_token（有效期7200秒，开发者必须在自己的服务全局缓存access_token）：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html">https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html</a></li>
<li>用第一步拿到的access_token 采用http GET方式请求获得jsapi_ticket（有效期7200秒，开发者必须在自己的服务全局缓存jsapi_ticket）：<a target="_blank" rel="noopener" href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi</a></li>
</ol>
<p>成功返回如下JSON：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;errcode&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;errmsg&quot;</span>:<span class="string">&quot;ok&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;ticket&quot;</span>:<span class="string">&quot;bxLdikRXVbTPdHSM05e5u5sUoXNKd8-41ZO3MhKoyN5OfkWITDGgnr2fwJ0m9E8NYzWKVZvdVtaUgWvsdshFKA&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span>:<span class="number">7200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得jsapi_ticket之后，就可以生成JS-SDK权限验证的签名了。</p>
<p><strong>签名算法（通过jsapi_ticket，noncestr，timestamp，url获取）</strong></p>
<p>签名生成规则如下：参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分） 。对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。</p>
<p>即signature=sha1(string1)。 示例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">noncestr=Wm3WZYTPz0wzccnW</span><br><span class="line">jsapi_ticket=sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg</span><br><span class="line">timestamp=1414587457</span><br><span class="line">url=http://mp.weixin.qq.com?params=value</span><br></pre></td></tr></table></figure>

<p>步骤1. 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsapi_ticket=sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg&amp;noncestr=Wm3WZYTPz0wzccnW&amp;timestamp=1414587457&amp;url=http://mp.weixin.qq.com?params=value</span><br></pre></td></tr></table></figure>

<p>步骤2. 对string1进行sha1签名，得到signature：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0f9de62fce790f9a083d5c99e95740ceb90c27ed</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ol>
<li>签名用的noncestr和timestamp必须与wx.config中的nonceStr和timestamp相同。</li>
<li>签名用的url必须是调用JS接口页面的完整URL。</li>
<li>出于安全考虑，开发者必须在服务器端实现签名的逻辑。</li>
</ol>
<h4 id="4-通过ready接口处理成功验证"><a href="#4-通过ready接口处理成功验证" class="headerlink" title="4.通过ready接口处理成功验证"></a>4.<strong>通过ready接口处理成功验证</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-通过error接口处理失败验证"><a href="#5-通过error接口处理失败验证" class="headerlink" title="5.通过error接口处理失败验证"></a>5.<strong>通过error接口处理失败验证</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.error(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h5 id="接口调用说明"><a href="#接口调用说明" class="headerlink" title="接口调用说明"></a><strong>接口调用说明</strong></h5><p>在4的ready接口下可以继续调用以下接口：</p>
<p>所有接口通过wx对象(也可使用jWeixin对象)来调用，参数是一个对象，除了每个接口本身需要传的参数之外，还有以下通用参数：</p>
<ol>
<li>success：接口调用成功时执行的回调函数。</li>
<li>fail：接口调用失败时执行的回调函数。</li>
<li>complete：接口调用完成时执行的回调函数，无论成功或失败都会执行。</li>
<li>cancel：用户点击取消时的回调函数，仅部分有用户取消操作的api才会用到。</li>
<li>trigger: 监听Menu中的按钮点击时触发的方法，该方法仅支持Menu中的相关接口。</li>
</ol>
<p>备注：不要尝试在trigger中使用ajax异步请求修改本次分享的内容，因为客户端分享操作是一个同步操作，这时候使用ajax的回包会还没有返回。</p>
<p>以上几个函数都带有一个参数，类型为对象，其中除了每个接口本身返回的数据之外，还有一个通用属性errMsg，其值格式如下：</p>
<p>调用成功时：”xxx:ok” ，其中xxx为调用的接口名</p>
<p>用户取消时：”xxx:cancel”，其中xxx为调用的接口名</p>
<p>调用失败时：其值为具体错误信息</p>
<h5 id="基础接口"><a href="#基础接口" class="headerlink" title="基础接口"></a><strong>基础接口</strong></h5><p><strong>判断当前客户端版本是否支持指定JS接口。</strong>这个接口是最基本的接口，一般都需要先拿这个接口验证一下，再在这个接口下调用你所需要使用的接口。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wx.checkJsApi(&#123;</span><br><span class="line">  jsApiList: [<span class="string">&#x27;chooseImage&#x27;</span>], <span class="comment">// 需要检测的JS接口列表，所有JS接口列表见附录2,</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以键值对的形式返回，可用的api值true，不可用为false</span></span><br><span class="line">  <span class="comment">// 如：&#123;&quot;checkResult&quot;:&#123;&quot;chooseImage&quot;:true&#125;,&quot;errMsg&quot;:&quot;checkJsApi:ok&quot;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>备注：checkJsApi接口是客户端6.0.2新引入的一个预留接口，第一期开放的接口均可不使用checkJsApi来检测</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">doscan</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">let</span> url = location.href.split(<span class="string">&quot;#&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">      url = <span class="built_in">encodeURIComponent</span>(url)</span><br><span class="line">      <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.$request.get(<span class="string">&quot;/ticket?url=&quot;</span> + url)<span class="comment">//这个后端接口就是将url解析得到url，然后获取jsapiTicket，然后随机生成字符串，然后获取时间戳，以上四个参数获取签名。将前端所需要的参数封装传回来。</span></span><br><span class="line">      <span class="keyword">if</span> (res.data.code !== <span class="number">200</span>) &#123;</span><br><span class="line">        _this.$toast.fail(res.data.msg)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//通过config接口注入权限验证配置</span></span><br><span class="line">      wx.config(&#123;</span><br><span class="line">        debug: <span class="literal">false</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">        appId: res.data.data.appId, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">        timestamp: res.data.data.timestamp, <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">        nonceStr: res.data.data.noncestr, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">        signature: res.data.data.signature,<span class="comment">// 必填，签名</span></span><br><span class="line">        jsApiList: [<span class="string">&#x27;scanQRCode&#x27;</span>, <span class="string">&#x27;checkJsApi&#x27;</span>] <span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 错误时</span></span><br><span class="line">      wx.error(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      wx.ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        wx.checkJsApi(&#123;</span><br><span class="line">          <span class="comment">// 判断当前客户端版本是否支持指定JS接口</span></span><br><span class="line">          jsApiList: [<span class="string">&quot;scanQRCode&quot;</span>],</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 以键值对的形式返回，可用true，不可用false。如：&#123;&quot;checkResult&quot;:&#123;&quot;scanQRCode&quot;:true&#125;,&quot;errMsg&quot;:&quot;checkJsApi:ok&quot;&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (res.checkResult.scanQRCode === <span class="literal">true</span>) &#123;</span><br><span class="line">              wx.scanQRCode(&#123;</span><br><span class="line">                <span class="comment">// 微信扫一扫接口</span></span><br><span class="line">                desc: <span class="string">&quot;scanQRCode desc&quot;</span>,</span><br><span class="line">                needResult: <span class="number">1</span>, <span class="comment">// 默认为0，扫描结果由微信处理，1则直接返回扫描结果，</span></span><br><span class="line">                scanType: [<span class="string">&quot;qrCode&quot;</span>, <span class="string">&quot;barCode&quot;</span>], <span class="comment">// 可以指定扫二维码还是一维码，默认二者都有</span></span><br><span class="line">                success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(res);</span><br><span class="line">                  <span class="comment">//用正则排除明显错误的帽子编码</span></span><br><span class="line">                  <span class="keyword">if</span> (<span class="regexp">/^H(CS|FY|YY)[YWBR][0-9]&#123;8&#125;$/</span>.test(res.resultStr)) &#123;</span><br><span class="line">                    _this.adminForm.nodeNum = res.resultStr;</span><br><span class="line">                    _this.bindForm.nodeNum = res.resultStr;</span><br><span class="line">                  &#125;</span><br><span class="line">                  _this.getNodeInfo();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              alert(<span class="string">&quot;抱歉，当前客户端版本不支持扫一扫&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          fail: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 检测getNetworkType该功能失败时处理</span></span><br><span class="line">            alert(<span class="string">&quot;检测getNetworkType该功能失败&quot;</span> + res);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>





<h3 id="WEB开发者工具"><a href="#WEB开发者工具" class="headerlink" title="WEB开发者工具"></a>WEB开发者工具</h3><p>调试工具</p>
<h3 id="云开发"><a href="#云开发" class="headerlink" title="云开发"></a>云开发</h3><p>开发者可以使用云开发开发微信小程序、小游戏、公众号，无需搭建服务器，即可使用云端能力。</p>
<p>云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。</p>
<h2 id="Cookie和LocalStorage设置相关"><a href="#Cookie和LocalStorage设置相关" class="headerlink" title="Cookie和LocalStorage设置相关"></a>Cookie和LocalStorage设置相关</h2><p>一：退出微信账号后，将会清空所有Cookie和LocalStorage。</p>
<p>二：页面功能依赖Cookie，或有涉及到Cookie的相关逻辑 WKWebview内部实现变更，会影响目前页面Cookie相关的逻辑。</p>
<p>变化1：跨域存取Cookie 问题说明：在访问一个页面A时，如果页面A引用了另一个页面B的资源（页面A和B为不同的域名），这时页面B就被认为是第三方页面。若在页面B中设置Cookie，就会命中WKWebview下阻止第三方跨域设置Cookie的安全策略，导致问题出现。 适配建议： 在WKWebview中是默认阻止跨域的第三方设置Cookie。所有通过Cookie传递的信息，可通过业务后台存储需要传递的信息，然后给页面一个存储信息相对应的access_token加密码，再通过Url中加入自己业务的access_token进行页面间的信息传递。</p>
<p>变化2：微信原生层面的网络请求读取不到WKWebview中设置的cookie，即使域名是相同的。 问题说明：如果页面的资源或图片存储的服务器依赖校验Cookie来返回数据的情况，在切换到WKWebview后，在微信内长按保存，或者点击预览大图时，原生层面发起的网络请求将不会完整地带上所设置的Cookie，会导致图片保存失败或预览失败。 适配建议： 建议静态资源cookie free。如果确实有信息需要传递，可通过业务后台存储需要传递的信息，然后给页面一个存储信息相对应的access_token加密码，再通过Url中加入自己业务的access_token进行页面间信息传递。</p>
<p>除上述两种情况，开发者不用担心其他情况下Cookie丢失的问题，所有请求都会带上完整的Cookie</p>
<h2 id="微信公众号网页引导用户关注公众号（非官方方法）"><a href="#微信公众号网页引导用户关注公众号（非官方方法）" class="headerlink" title="微信公众号网页引导用户关注公众号（非官方方法）"></a>微信公众号网页引导用户关注公众号（非官方方法）</h2><ol>
<li><p>登陆微信公众号后台(<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com</a>);</p>
</li>
<li><p>按F12打开调试面板,在console栏输入:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wx.commonData.data.uin_base64</span><br></pre></td></tr></table></figure>

<p>如图：<br><img src="https://img2020.cnblogs.com/blog/1820240/202004/1820240-20200405151248267-171244144.png" alt="img"></p>
</li>
<li><p>把显示出来的字符串替换到下面的括号里;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;mp&#x2F;profile_ext?action&#x3D;home&amp;__biz&#x3D;(上面获取到的uin_base64)#wechat_redirect</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;mp&#x2F;profile_ext?action&#x3D;home&amp;__biz&#x3D;MzxxxxxxxxxxOQ&#x3D;&#x3D;#wechat_redirect</span><br></pre></td></tr></table></figure></li>
<li><p>根据业务需求将拼接好的链接放到程序中，例如当用户点击时，跳转至此链接,引导用户关注公众号;</p>
</li>
<li><p>此方法打开公众号页面后，关注按钮会消失，不过点击顶部公众号名称时，仍可跳转到有关注入口的页面;</p>
</li>
</ol>
<h2 id="客服"><a href="#客服" class="headerlink" title="客服"></a>客服</h2><p><strong>谨慎评估客服接待能力</strong></p>
<h3 id="自动回复"><a href="#自动回复" class="headerlink" title="自动回复"></a>自动回复</h3><p>微信后台提供的关键词自动回复：用户咨询之后，系统会自动匹配关键词，匹配不上的推送给多客服</p>
<p>关键词自动回复设置上限200条，每条最多10个关键词。加起来也就2000个关键词，适合<strong>业务类型简单，咨询问题比较集中</strong>。或者<strong>粉丝比较少</strong>的阶段</p>
<p>如果后台配置麻烦，可以二次开发接口，在自己的服务器后台通过接口添加关键词回复：（缺点：可能客户咨询的问题千奇百怪无法正确匹配）</p>
<p>如果用户咨询未匹配到关键词，系统会给出7个大的问题分类，用户可以回复问题编号。系统自动回复二级问题分类。然后在各个问题之间，设置一些相关问题编号。 　　</p>
<p>通过这种主要问题框架引导+关键词匹配的方式，自动回复匹配率提升效果非常明显。适用于<strong>用户问题比较集中</strong></p>
<p>还可以找做客服机器人的供应商，通过人工智能+语言搜索引擎，自动识别用户语义。根据用户的意思，推荐相关问题。这样你只用维护自己的问题库，机器人帮你解决用户提问分析。还有一些<strong>智能机器人</strong>，对接公司本身的数据库。通过对用户标签/行为/状态的分析，及规则设定。推测用户可能要问的问题，或者动态生成定制化的客服页。</p>
<h3 id="客服回复"><a href="#客服回复" class="headerlink" title="客服回复"></a>客服回复</h3><p>多客服回复，即人工回复：适用于个性化问题，需要配备人工回答</p>
<p>实现方式：简单的自动回复过滤+1个人工+尽量引导自助服务</p>
<p>客服回复分类：</p>
<p>1.根据业务分类：1号客服负责哪个系列商品</p>
<p>2.根据不同状态分类：1号客服负责售前，售后</p>
<p>3.根据客户身份分类：普通和vip专属客服</p>
<p>还可以找客服端供应商，功能完善。除了微信之外，很多还支持app、pc、电话等全渠道接入。在咨询数据、工作量统计、客服监控等方面也比较完善。有的也配备了智能机器人、可视化IVR（交互式语音应答）操作面板等；或者邮件、短信等营销通道；再或者CRM（客户关系管理）后台。</p>
<h4 id="开通微信后台的服务下的对话能力，原导购（推荐）"><a href="#开通微信后台的服务下的对话能力，原导购（推荐）" class="headerlink" title="开通微信后台的服务下的对话能力，原导购（推荐）"></a>开通微信后台的服务下的对话能力，原导购（推荐）</h4><p>可以在微信后台配置，在微信上的小程序服务号对话助手完成对话，根据用户绑定到具体的顾问。顾问可以生成自己的二维码，当客户扫描后会自动绑定到当前顾问；也可以后台直接分配。但是顾问只能主动给用户发几次消息 （以设置好的微信身份）</p>
<p>后台会有数据统计信息</p>
<h4 id="开通微信后台的服务下的客服"><a href="#开通微信后台的服务下的客服" class="headerlink" title="开通微信后台的服务下的客服"></a>开通微信后台的服务下的客服</h4><p>由多客服功能更新来，现在是新版的客服功能。</p>
<p>可以绑定微信号，在网页版接入回复消息（以设置好的客服身份）。客服功能会在云端保存30天的聊天记录</p>
<p>只提供网页版聊天。不支持下载聊天记录，不支持手机端使用，不支持关闭会话，不支持发送语音，目前仅支持发送图片</p>
<p>咨询列表是按时间倒序排列。咨询量大的情况下，每次都是接进最近提问的，前面未接入的更是一直等不到</p>
<p>(进行绑定的时候一直显示系统繁忙，请稍后再试)</p>
<h4 id="开发接口"><a href="#开发接口" class="headerlink" title="开发接口"></a>开发接口</h4><p>上面两个服务都可以在后台直接配置，是微信官方给的服务。也可以自己二次开发，设置更多的功能</p>
<p>如果需要更强大的功能，又没有能力开发接口，可以直接使用第三方的服务：当用户发消息后，程序将消息转发给第三方，第三方通知给个人及时回复。</p>
<p>自己开发：</p>
<p>参照<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Service_Center_messages.html%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9A%84%E5%AE%A2%E6%9C%8D%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3">https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Service_Center_messages.html官方文档的客服消息接口</a></p>
<h2 id="微信公众号支付（微信）"><a href="#微信公众号支付（微信）" class="headerlink" title="微信公众号支付（微信）"></a>微信公众号支付（微信）</h2><p><img src="/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/20180516205134721" alt="img"></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><strong>1.分为V2和V3</strong>（目前采用v2，因为文档和示例多了点）</p>
<p>2014年9月10号之前申请的为v2版，之后申请的都为v3版</p>
<p>微信支付V2版中的参数如下：<br>AppID<br>AppSecret<br><strong>支付专用签名串PaySignKey</strong><br>商户号PartnerID<br>初始密钥PartnerKey<br>并且包含一个证书文件: 安全证书</p>
<p>微信支付V3版中的参数如下：<br>AppID<br>AppSecret<br>商户号PartnerID<br>初始密钥PartnerKey<br>商户号MCHID<br>申请编号<br>商户平台登录帐号<br>商户平台登录密码<br>包含5个证书文件（证书pkcs12格式、证书pem格式、证书密钥pem格式、CA证书， 安全证书）</p>
<p><strong>2.分为普通商户和特约商户</strong></p>
<p>微信支付服务商可以非常方便的给企业开通微信支付商户，这种微信服务商开通的微信支付商户，我们通常称为子账户，微信官方称为：特约商户。特约商户与普通商户功能基本上是一样的，唯一区别就是支付流程上有些不同。子账户需要通过服务商中转，同时需要添加Sub_APPID，才能支付成功。</p>
<p><img src="/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/20160812221427.png" alt="20160812221427"></p>
<p>1、微信普通商户，需要公众号认证才能开通。而特约商户不需要公众号即可由服务商开通，但是如果想用公众号支付，仍然需要绑定已经认证的微信公众号（服务号）。</p>
<p>2、虽然特约商户号，可以不认证服务号就能开通（节约300元/年），但是不绑定服务号，只能使用微信扫码支付，适合线下店铺使用。如果有线上业务建议使用普通商户。</p>
<p>3、大部分第三方平台或微信应用都不支持特约商户的模式（Sub_APPID），所以建议如果有网站业务需要微信收款，还是使用普通微信商户吧。</p>
<h3 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h3><p>用户点击一个支付按钮–&gt;{后台一大推处理}–&gt;用户看到了一个输入密码的界面，包含金额等一些信息–&gt;用户输入密码后出来一个支付成功的页面–&gt;返回系统自己的页面</p>
<h3 id="准备工作（进行配置）"><a href="#准备工作（进行配置）" class="headerlink" title="准备工作（进行配置）"></a>准备工作（进行配置）</h3><p>微信公众号后台，微信支付，开发配置中有一个支付授权目录，测试授权目录，测试白名单</p>
<h3 id="1）获取用户授权（之前的设置获取openid）"><a href="#1）获取用户授权（之前的设置获取openid）" class="headerlink" title="1）获取用户授权（之前的设置获取openid）"></a>1）获取用户授权（之前的设置获取openid）</h3><p>获得用户openid</p>
<h3 id="2）调用统一下单接口获取预支付id（后端程序获取prepay-id返回给前端参数）"><a href="#2）调用统一下单接口获取预支付id（后端程序获取prepay-id返回给前端参数）" class="headerlink" title="2）调用统一下单接口获取预支付id（后端程序获取prepay_id返回给前端参数）"></a>2）调用统一下单接口获取预支付id（后端程序获取prepay_id返回给前端参数）</h3><p>都在后端获取</p>
<p>参考<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_4">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_4</a></p>
<p>请求的url：<a target="_blank" rel="noopener" href="https://api.mch.weixin.qq.com/pay/unifiedorder">https://api.mch.weixin.qq.com/pay/unifiedorder</a></p>
<p>请求方式：POST</p>
<p>请求的参数列表：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>名称</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td><strong>appid</strong></td>
<td>应用ID</td>
<td>登陆微信公众号后台-开发-基本配置</td>
</tr>
<tr>
<td><strong>mch_id</strong></td>
<td>微信支付商户号</td>
<td>登陆微信支付后台，即可看到</td>
</tr>
<tr>
<td>device_info</td>
<td>设备号</td>
<td>终端设备号(门店号或收银设备ID)，注意：PC网页或公众号内支付请传”WEB”</td>
</tr>
<tr>
<td><strong>body</strong></td>
<td>商品描述</td>
<td>商品或支付单简要描述（中文可能会存在签名错误）</td>
</tr>
<tr>
<td><strong>trade_type</strong></td>
<td>交易类型</td>
<td>JSAPI（公众号支付），NATIVE（原生扫码支付），APP（app支付）<br />MICROPAY–刷卡支付，刷卡支付有单独的支付接口，不调用统一下单接口<br />（参考<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2%EF%BC%89">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2）</a></td>
</tr>
<tr>
<td><strong>nonce_str</strong></td>
<td>随机字符串</td>
<td>不长于32位（参考算法<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3%EF%BC%89">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3）</a></td>
</tr>
<tr>
<td><strong>notify_url</strong></td>
<td>通知地址</td>
<td>接收微信支付异步通知回调地址，通知url必须为直接可访问的url，不能携带参数</td>
</tr>
<tr>
<td><strong>out_trade_no</strong></td>
<td>商户订单号</td>
<td>商户系统内部的订单号,32个字符内、可包含字母<br />（参考<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2%EF%BC%89">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2）</a></td>
</tr>
<tr>
<td><strong>total_fee</strong></td>
<td>总金额</td>
<td>订单总金额，单位为分</td>
</tr>
<tr>
<td>openid</td>
<td>用户标识</td>
<td>trade_type=JSAPI，此参数必传，用户在商户appid下的唯一标识</td>
</tr>
<tr>
<td><strong>sign</strong></td>
<td>签名</td>
<td>官方给的签名算法（参考<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3%EF%BC%89">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3）</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>spbill_create_ip</strong></td>
<td>终端ip</td>
<td>调用微信支付API的机器ip（支持ipv4和ipv6）</td>
</tr>
<tr>
<td>receipt</td>
<td>开发票入口开放标识</td>
<td>传入Y时，支付成功和支付详情页将出现开票入口（需在后台开通电子发票功能，该字段才可用）</td>
</tr>
<tr>
<td>key（生成key需要）</td>
<td>参与签名的参数</td>
<td>key设置路径：微信商户平台(pay.weixin.qq.com)–&gt;账户设置–&gt;API安全–&gt;密钥设置</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>获得sign：</p>
<p>1.把所有要传递的参数键值对去掉值是空的，剩下的参数名ASCII码从小到大排序后，使用URL键值对格式（key1=value1&amp;key2=value2…）拼接成StringA</p>
<p>2.把StringA后面多加一组键值&amp;key=商户平台密钥获得StringB</p>
<p>3.把StringB按要求做”MD5”或”HMAC-SHA256”计算，并将结果字符转为大写即可得到sign</p>
<p>调用微信的统一下单地址：<a target="_blank" rel="noopener" href="https://api.mch.weixin.qq.com/pay/unifiedorder">https://api.mch.weixin.qq.com/pay/unifiedorder</a></p>
<p>调用统一下单地址时 传的参数个参数名称和参数值与生成签名时相比<strong>多了一个sign</strong>的参数，其他参数名称需要全部相同,nonce_str的值可以不同</p>
<p>获取预支付ID时，如果返回值是【签名错误】。那真是的你的签名错了，请仔细核对生成sign的参数名称、参数值和调用统一下单接口的参数名称和参数值</p>
<p>最终需要得到：prepay_id</p>
<p>将参数返回给前端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">weiXinPay</span><span class="params">(OrderDTO orderDTO)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前端传来的是：&quot;</span>+orderDTO);</span><br><span class="line">        System.out.println(<span class="string">&quot;回调地址是：&quot;</span>+orderDTO.getPath());</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        <span class="comment">//请求参数</span></span><br><span class="line">        String total_fee = orderDTO.getPrice().multiply(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;100&quot;</span>)).intValue()+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        Map&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//appid</span></span><br><span class="line">        data.put(<span class="string">&quot;appid&quot;</span>,Constant.APP_ID);</span><br><span class="line">        <span class="comment">//商户号</span></span><br><span class="line">        data.put(<span class="string">&quot;mch_id&quot;</span>,Constant.MCH_ID);</span><br><span class="line">        <span class="comment">//支付类型</span></span><br><span class="line">        data.put(<span class="string">&quot;trade_type&quot;</span>,<span class="string">&quot;JSAPI&quot;</span>);</span><br><span class="line">        <span class="comment">//随机字符串</span></span><br><span class="line">        data.put(<span class="string">&quot;nonce_str&quot;</span>,WXPayUtil.generateNonceStr());</span><br><span class="line">        <span class="comment">//openid</span></span><br><span class="line">        data.put(<span class="string">&quot;openid&quot;</span>, UserUtil.getCurrentOpenid());</span><br><span class="line">        <span class="comment">//请求的ip地址</span></span><br><span class="line">        data.put(<span class="string">&quot;spbill_create_ip&quot;</span>,HttpUtil.getIpAddr(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回地址（接收微信支付异步通知回调地址）</span></span><br><span class="line">        data.put(<span class="string">&quot;notify_url&quot;</span>, orderDTO.getPath());</span><br><span class="line">        <span class="comment">//商品信息，前端传</span></span><br><span class="line">        data.put(<span class="string">&quot;body&quot;</span>,orderDTO.getDescription());</span><br><span class="line">        <span class="comment">//订单号，前端传</span></span><br><span class="line">        data.put(<span class="string">&quot;out_trade_no&quot;</span>,orderDTO.getOrderId());</span><br><span class="line">        <span class="comment">//订单总金额</span></span><br><span class="line">        data.put(<span class="string">&quot;total_fee&quot;</span>,total_fee);</span><br><span class="line">        <span class="comment">//生成签名（通过上述所有参数生成）</span></span><br><span class="line">        data.put(<span class="string">&quot;sign&quot;</span>, WXPayUtil.generateSignature(data, Constant.API_KEY));</span><br><span class="line">        <span class="comment">//打印xml信息</span></span><br><span class="line">        String xml = WXPayUtil.mapToXml(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用统一下单接口前的参数xml:\n&quot;</span> + xml);</span><br><span class="line">        <span class="comment">//调用统一下单接口,获取prepay_id</span></span><br><span class="line">        WXPay wxPay = <span class="keyword">new</span> WXPay(<span class="keyword">new</span> WeiXinPayConfig());</span><br><span class="line">        Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data);</span><br><span class="line">        String prePayId = resp.get(<span class="string">&quot;prepay_id&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;微信生成预订单：&quot;</span> + prePayId);</span><br><span class="line">        System.out.println(<span class="string">&quot;resp:&quot;</span> + resp);</span><br><span class="line">        <span class="comment">//返回参数</span></span><br><span class="line">            Map&lt;String, String&gt; jsapiPayParam = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            String timeStamp = String.valueOf(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">            jsapiPayParam.put(<span class="string">&quot;appId&quot;</span>, data.get(<span class="string">&quot;appid&quot;</span>));</span><br><span class="line">            jsapiPayParam.put(<span class="string">&quot;timeStamp&quot;</span>, timeStamp);</span><br><span class="line">            jsapiPayParam.put(<span class="string">&quot;nonceStr&quot;</span>, data.get(<span class="string">&quot;nonce_str&quot;</span>));</span><br><span class="line">            jsapiPayParam.put(<span class="string">&quot;package&quot;</span>, <span class="string">&quot;prepay_id=&quot;</span> + resp.get(<span class="string">&quot;prepay_id&quot;</span>));</span><br><span class="line">            jsapiPayParam.put(<span class="string">&quot;signType&quot;</span>, WXPayConstants.MD5);</span><br><span class="line">            jsapiPayParam.put(<span class="string">&quot;paySign&quot;</span>, WXPayUtil.generateSignature(jsapiPayParam, Constant.API_KEY));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回给前端的是：&quot;</span>+jsapiPayParam);</span><br><span class="line">        <span class="keyword">return</span> R.restResult(jsapiPayParam, ResApiSuccessCode.SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3）H5调起微信支付的内置JS（前端通过参数回调起微信的支付工具）"><a href="#3）H5调起微信支付的内置JS（前端通过参数回调起微信的支付工具）" class="headerlink" title="3）H5调起微信支付的内置JS（前端通过参数回调起微信的支付工具）"></a>3）H5调起微信支付的内置JS（前端通过参数回调起微信的支付工具）</h3><p>后台传回前台的参数</p>
<p>注意：WeixinJSBridge内置对象在其他浏览器中无效。</p>
<p>getBrandWCPayRequest<strong>参数定义</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>appId</td>
<td>应用ID</td>
<td>永远不变</td>
</tr>
<tr>
<td>timeStamp</td>
<td>时间戳</td>
<td>工具类调用（参考<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2%EF%BC%89">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2）</a></td>
</tr>
<tr>
<td>nonceStr</td>
<td>随机字符串</td>
<td>跟上面一样</td>
</tr>
<tr>
<td>package</td>
<td>订单详情扩展字符串</td>
<td>统一下单接口返回的prepay_id参数值，提交格式如：prepay_id=***</td>
</tr>
<tr>
<td>signType</td>
<td>签名方式</td>
<td>签名算法，暂支持MD5</td>
</tr>
<tr>
<td>paySign</td>
<td>签名</td>
<td>这个签名，要重新生成，在后台（上面5个参数+key生成）</td>
</tr>
</tbody></table>
<p>注：生成prepay_id时appid是小写的i,生成paySign时，appId是大写的I</p>
<p><strong>返回结果值说明</strong>：</p>
<table>
<thead>
<tr>
<th align="left">返回值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">get_brand_wcpay_request:ok</td>
<td align="left">支付成功</td>
</tr>
<tr>
<td align="left">get_brand_wcpay_request:cancel</td>
<td align="left">支付过程中用户取消</td>
</tr>
<tr>
<td align="left">get_brand_wcpay_request:fail</td>
<td align="left">支付失败</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">vue中使用：</span><br><span class="line"><span class="comment">//先调取微信的支付方法</span></span><br><span class="line">    <span class="function"><span class="title">pay</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span>  <span class="built_in">window</span>.WeixinJSBridge == <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">          <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;WeixinJSBridgeReady&#x27;</span>, <span class="built_in">this</span>.onBridgeReady(), <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.attachEvent) &#123;</span><br><span class="line">          <span class="built_in">document</span>.attachEvent(<span class="string">&#x27;WeixinJSBridgeReady&#x27;</span>, <span class="built_in">this</span>.onBridgeReady());</span><br><span class="line">          <span class="built_in">document</span>.attachEvent(<span class="string">&#x27;onWeixinJSBridgeReady&#x27;</span>, <span class="built_in">this</span>.onBridgeReady());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onBridgeReady();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">//再调微信的支付组件</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">onBridgeReady</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.$request.post(<span class="string">&#x27;/wxjspay&#x27;</span>, &#123; <span class="attr">orderSn</span>:<span class="built_in">this</span>.orderId,<span class="attr">amount</span>:<span class="built_in">this</span>.price &#125;);</span><br><span class="line">       res.data = res.data.data;</span><br><span class="line">        <span class="built_in">window</span>.WeixinJSBridge.invoke(</span><br><span class="line">            <span class="string">&#x27;getBrandWCPayRequest&#x27;</span>, &#123;</span><br><span class="line">              <span class="string">&#x27;appId&#x27;</span>: res.data.appId, <span class="comment">// 公众号名称，由商户传入</span></span><br><span class="line">              <span class="string">&#x27;timeStamp&#x27;</span>: res.data.timeStamp, <span class="comment">// 时间戳，自1970年以来的秒数</span></span><br><span class="line">              <span class="string">&#x27;nonceStr&#x27;</span>: res.data.nonceStr, <span class="comment">// 随机串</span></span><br><span class="line">              <span class="string">&#x27;package&#x27;</span>: res.data.package,</span><br><span class="line">              <span class="string">&#x27;signType&#x27;</span>: res.data.signType, <span class="comment">// 微信签名方式：</span></span><br><span class="line">              <span class="string">&#x27;paySign&#x27;</span>: res.data.paySign <span class="comment">// 微信签名</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//付款成功后运行到这个方法</span></span><br><span class="line">            <span class="keyword">if</span> (res.err_msg === <span class="string">&#x27;get_brand_wcpay_request:ok&#x27;</span> || res.err_msg === <span class="string">&quot;get_brand_wcpay_request:fail&quot;</span>) &#123;</span><br><span class="line">                 <span class="comment">// 使用res.err_msg判断前端返回,微信团队郑重提示：</span></span><br><span class="line">                <span class="comment">// res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。还需要校验微信的返回信息和使用查单接口来判断是否真的支付成功。</span></span><br><span class="line">              <span class="comment">//调用查单接口</span></span><br><span class="line">              <span class="built_in">this</span>.queryOrder();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              alert(<span class="string">&quot;取消支付，订单未完成！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">     &#125;,</span><br><span class="line"><span class="comment">//最后进行支付的查单确认         </span></span><br><span class="line"><span class="function"><span class="title">queryOrder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">      <span class="comment">//调用系统内的查单接口：微信的回调处理后会将支付状态改变</span></span><br><span class="line">      <span class="built_in">this</span>.$request.post(<span class="string">&#x27;/shop/order/queryorder&#x27;</span>, &#123;<span class="attr">orderSn</span>: <span class="built_in">this</span>.orderSn&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">          alert(<span class="string">&quot;支付成功&quot;</span>)</span><br><span class="line">          <span class="built_in">this</span>.times = <span class="number">1</span></span><br><span class="line">          <span class="comment">//跳转到订单详情页面</span></span><br><span class="line">          self.$router.replace(&#123;<span class="attr">path</span>: <span class="string">&#x27;orderDetail&#x27;</span>, <span class="attr">query</span>: &#123;<span class="attr">current</span>: <span class="string">&quot;2&quot;</span>,<span class="attr">orderSn</span>: <span class="built_in">this</span>.orderSn,<span class="attr">flag</span>:!<span class="built_in">this</span>.role&#125;&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//调用微信的查单接口</span></span><br><span class="line">          <span class="built_in">this</span>.$request.post(<span class="string">&#x27;/shop/querypay&#x27;</span>, &#123;<span class="attr">orderSn</span>: <span class="built_in">this</span>.orderSn&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">              alert(<span class="string">&quot;支付成功&quot;</span>)</span><br><span class="line">              <span class="built_in">this</span>.times = <span class="number">1</span></span><br><span class="line">              <span class="comment">//跳转到订单详情页面</span></span><br><span class="line">              self.$router.replace(&#123;<span class="attr">path</span>: <span class="string">&#x27;orderDetail&#x27;</span>, <span class="attr">query</span>: &#123;<span class="attr">current</span>: <span class="string">&quot;2&quot;</span>,<span class="attr">orderSn</span>: <span class="built_in">this</span>.orderSn,<span class="attr">flag</span>:!<span class="built_in">this</span>.role&#125;&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              alert(<span class="string">&quot;稍后进入订单管理页核实订单状态，不要重复发起支付&quot;</span>);</span><br><span class="line">              <span class="built_in">this</span>.times = <span class="number">1</span></span><br><span class="line">              self.$router.replace(&#123;<span class="attr">path</span>: <span class="string">&#x27;orderDetail&#x27;</span>, <span class="attr">query</span>: &#123;<span class="attr">current</span>: <span class="string">&quot;1&quot;</span>,<span class="attr">orderSn</span>: <span class="built_in">this</span>.orderSn,<span class="attr">flag</span>:!<span class="built_in">this</span>.role&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="4）支付完成后，微信回调URL的处理（设定的url对结果处理）"><a href="#4）支付完成后，微信回调URL的处理（设定的url对结果处理）" class="headerlink" title="4）支付完成后，微信回调URL的处理（设定的url对结果处理）"></a>4）支付完成后，微信回调URL的处理（设定的url对结果处理）</h3><p>1）解析传过来的流信息，通过重新签名的方式验证流中包含的信息的正确性。就是验证sign，判断这个信息到底是不是微信发的</p>
<p>2）return_code和result_code都是SUCCESS的话，处理商户自己的业务逻辑。就是订单的支付状态啊等一些信息。</p>
<p>3）告诉微信，我收到你的返回值了。不用在发了。</p>
<p>和支付宝不同，微信返回的是数据流</p>
<p>1、商户系统对于支付结果通知的内容一定要做签名验证,并校验返回的订单金额是否与商户侧的订单金额一致，防止数据泄露导致出现“假通知”，造成资金损失。</p>
<p>2、当收到通知进行处理时，首先检查对应业务数据的状态，判断该通知是否已经处理过，如果没有处理过再进行处理，如果处理过直接返回结果成功。在对业务数据进行状态检查和处理之前，要采用数据锁进行并发控制，以避免函数重入造成的数据混乱。</p>
<p>3、技术人员可登进微信商户后台扫描加入接口报警群，获取接口告警信息。</p>
<p><strong>接口链接</strong></p>
<p>该链接是通过【统一下单API】中提交的参数notify_url设置，如果链接无法访问，商户将无法接收到微信通知。</p>
<p>通知url必须为直接可访问的url，不能携带参数。公网域名必须为https，如果是走专线接入，使用专线NAT IP或者私有回调域名可使用http。</p>
<p>● notify_url需要填写商户自己系统的真实地址，不能填写接口文档或demo上的示例地址。<br>● notify_url必须是以https://或http://开头的完整全路径地址，并且确保url中的域名和IP是外网可以访问的，不能填写localhost、127.0.0.1、192.168.x.x等本地或内网IP。<br>● notify_url不能携带参数。</p>
<p>示例：notify_url：“<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wxpay/pay.action%E2%80%9D">https://pay.weixin.qq.com/wxpay/pay.action”</a></p>
<p>● 返回报文必须是xml格式，字段名需与接口文档说明的一致，报文前后和各字段标签中间不能包含特殊字符。</p>
<p>● notify_url的代码处理逻辑不能做登录态校验。<br>● 商户系统收到支付结果通知，需要在5秒内返回应答报文，否则微信支付认为通知失败，后续会重复发送通知。<br>● 同样的通知可能会多次发送给商户系统，商户系统必须能够正确处理重复的通知。如果已处理过，直接给微信支付返回成功。<br>● 商户侧对微信支付回调IP有防火墙策略限制的，需要对以下IP段开通白名单：</p>
<p>上海电信出口网段：101.226.103.0/25<br>上海联通出口网段：140.207.54.0/25<br>上海CAP出口网段：121.51.58.128/25（新增）<br>深圳电信出口网段：183.3.234.0/25<br>深圳联通出口网段：58.251.80.0/25<br>深圳CAP出口网段：121.51.30.128/25（新增）<br>香港出口网段：203.205.219.128/25<br>*注意：上海CAP、深圳CAP的出口为新增，商户侧需要新开防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;支付完成后，微信会把相关支付和用户信息发送到商户设定的通知URL，需要在这个URL下进行代码：验证签名，并回应微信。</span><br><span class="line">&#x2F;&#x2F;对后台通知交互时，如果微信收到商户的应答不是成功或超时，微信认为通知失败，微信会通过一定的策略（如30分钟共8次）定期重新发起通知，尽可能提高通知的成功率，但微信不保证通知最终能成功。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;商户自行增加处理流程,</span><br><span class="line">&#x2F;&#x2F;例如：更新订单状态</span><br><span class="line">&#x2F;&#x2F;例如：数据库操作</span><br><span class="line">&#x2F;&#x2F;例如：推送支付完成信息</span><br></pre></td></tr></table></figure>

<p><strong>微信服务器返回给url的参数</strong></p>
<table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">变量名</th>
<th align="left">必填</th>
<th align="left">类型</th>
<th align="left">示例值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">返回状态码</td>
<td align="left">return_code</td>
<td align="left">是</td>
<td align="left">String(16)</td>
<td align="left">SUCCESS</td>
<td align="left">SUCCESS/FAIL此字段是通信标识，非交易标识，交易是否成功需要查看result_code来判断</td>
</tr>
<tr>
<td align="left">返回信息</td>
<td align="left">return_msg</td>
<td align="left">否</td>
<td align="left">String(128)</td>
<td align="left">签名失败</td>
<td align="left">返回信息，如非空，为错误原因签名失败参数格式校验错误</td>
</tr>
</tbody></table>
<p>在return_code为SUCCESS的时候有返回</p>
<table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">变量名</th>
<th align="left">必填</th>
<th align="left">类型</th>
<th align="left">示例值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">小程序ID</td>
<td align="left">appid</td>
<td align="left">是</td>
<td align="left">String(32)</td>
<td align="left">wx8888888888888888</td>
<td align="left">微信分配的小程序ID</td>
</tr>
<tr>
<td align="left">商户号</td>
<td align="left">mch_id</td>
<td align="left">是</td>
<td align="left">String(32)</td>
<td align="left">1900000109</td>
<td align="left">微信支付分配的商户号</td>
</tr>
<tr>
<td align="left">设备号</td>
<td align="left">device_info</td>
<td align="left">否</td>
<td align="left">String(32)</td>
<td align="left">013467007045764</td>
<td align="left">微信支付分配的终端设备号，</td>
</tr>
<tr>
<td align="left">随机字符串</td>
<td align="left">nonce_str</td>
<td align="left">是</td>
<td align="left">String(32)</td>
<td align="left">5K8264ILTKCH16CQ2502SI8ZNMTM67VS</td>
<td align="left">随机字符串，不长于32位</td>
</tr>
<tr>
<td align="left">签名</td>
<td align="left">sign</td>
<td align="left">是</td>
<td align="left">String(32)</td>
<td align="left">C380BEC2BFD727A4B6845133519F3AD6</td>
<td align="left">签名，详见<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3">签名算法</a></td>
</tr>
<tr>
<td align="left">签名类型</td>
<td align="left">sign_type</td>
<td align="left">否</td>
<td align="left">String(32)</td>
<td align="left">HMAC-SHA256</td>
<td align="left">签名类型，目前支持HMAC-SHA256和MD5，默认为MD5</td>
</tr>
<tr>
<td align="left">业务结果</td>
<td align="left">result_code</td>
<td align="left">是</td>
<td align="left">String(16)</td>
<td align="left">SUCCESS</td>
<td align="left">SUCCESS/FAIL</td>
</tr>
<tr>
<td align="left">错误代码</td>
<td align="left">err_code</td>
<td align="left">否</td>
<td align="left">String(32)</td>
<td align="left">SYSTEMERROR</td>
<td align="left">错误返回的信息描述</td>
</tr>
<tr>
<td align="left">错误代码描述</td>
<td align="left">err_code_des</td>
<td align="left">否</td>
<td align="left">String(128)</td>
<td align="left">系统错误</td>
<td align="left">错误返回的信息描述</td>
</tr>
<tr>
<td align="left">用户标识</td>
<td align="left">openid</td>
<td align="left">是</td>
<td align="left">String(128)</td>
<td align="left">wxd930ea5d5a258f4f</td>
<td align="left">用户在商户appid下的唯一标识</td>
</tr>
<tr>
<td align="left">是否关注公众账号</td>
<td align="left">is_subscribe</td>
<td align="left">是</td>
<td align="left">String(1)</td>
<td align="left">Y</td>
<td align="left">用户是否关注公众账号，Y-关注，N-未关注</td>
</tr>
<tr>
<td align="left">交易类型</td>
<td align="left">trade_type</td>
<td align="left">是</td>
<td align="left">String(16)</td>
<td align="left">JSAPI</td>
<td align="left">JSAPI、NATIVE、APP</td>
</tr>
<tr>
<td align="left">付款银行</td>
<td align="left">bank_type</td>
<td align="left">是</td>
<td align="left">String(32)</td>
<td align="left">CMC</td>
<td align="left">银行类型，采用字符串类型的银行标识，银行类型见<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2">银行列表</a></td>
</tr>
<tr>
<td align="left">订单金额</td>
<td align="left">total_fee</td>
<td align="left">是</td>
<td align="left">int</td>
<td align="left">100</td>
<td align="left">订单总金额，单位为分</td>
</tr>
<tr>
<td align="left">应结订单金额</td>
<td align="left">settlement_total_fee</td>
<td align="left">否</td>
<td align="left">int</td>
<td align="left">100</td>
<td align="left">应结订单金额=订单金额-非充值代金券金额，应结订单金额&lt;=订单金额。</td>
</tr>
<tr>
<td align="left">货币种类</td>
<td align="left">fee_type</td>
<td align="left">否</td>
<td align="left">String(8)</td>
<td align="left">CNY</td>
<td align="left">货币类型，符合ISO4217标准的三位字母代码，默认人民币：CNY，其他值列表详见<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2">货币类型</a></td>
</tr>
<tr>
<td align="left">现金支付金额</td>
<td align="left">cash_fee</td>
<td align="left">是</td>
<td align="left">int</td>
<td align="left">100</td>
<td align="left">现金支付金额订单现金支付金额，详见<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2">支付金额</a></td>
</tr>
<tr>
<td align="left">现金支付货币类型</td>
<td align="left">cash_fee_type</td>
<td align="left">否</td>
<td align="left">String(16)</td>
<td align="left">CNY</td>
<td align="left">货币类型，符合ISO4217标准的三位字母代码，默认人民币：CNY，其他值列表详见<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2">货币类型</a></td>
</tr>
<tr>
<td align="left">总代金券金额</td>
<td align="left">coupon_fee</td>
<td align="left">否</td>
<td align="left">int</td>
<td align="left">10</td>
<td align="left">代金券金额&lt;=订单金额，订单金额-代金券金额=现金支付金额，详见<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2">支付金额</a></td>
</tr>
<tr>
<td align="left">代金券使用数量</td>
<td align="left">coupon_count</td>
<td align="left">否</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left">代金券使用数量</td>
</tr>
<tr>
<td align="left">代金券类型</td>
<td align="left">coupon_type_$n</td>
<td align="left">否</td>
<td align="left">String</td>
<td align="left">CASH</td>
<td align="left">CASH–充值代金券 NO_CASH—非充值代金券并且订单使用了免充值券后有返回（取值：CASH、NO_CASH）。$n为下标，该笔订单使用多张代金券时，从0开始编号，举例：coupon_type_0、coupon_type_1<strong>注意：</strong>只有下单时订单使用了优惠，回调通知才会返回券信息。 下列情况可能导致订单不可以享受优惠：<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/danpin.php?chapter=9_202&index=7#menu4">可能情况</a>。</td>
</tr>
<tr>
<td align="left">代金券ID</td>
<td align="left">coupon_id_$n</td>
<td align="left">否</td>
<td align="left">String(20)</td>
<td align="left">10000</td>
<td align="left">代金券ID,$n为下标，该笔订单使用多张代金券时，从0开始编号，举例：coupon_id_0、coupon_id_1 <strong>注意：</strong>只有下单时订单使用了优惠，回调通知才会返回券信息。 下列情况可能导致订单不可以享受优惠：<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/danpin.php?chapter=9_202&index=7#menu4">可能情况</a>。</td>
</tr>
<tr>
<td align="left">单个代金券支付金额</td>
<td align="left">coupon_fee_$n</td>
<td align="left">否</td>
<td align="left">int</td>
<td align="left">100</td>
<td align="left">单个代金券支付金额,$n为下标，从0开始编号</td>
</tr>
<tr>
<td align="left">微信支付订单号</td>
<td align="left">transaction_id</td>
<td align="left">是</td>
<td align="left">String(32)</td>
<td align="left">1217752501201407033233368018</td>
<td align="left">微信支付订单号</td>
</tr>
<tr>
<td align="left">商户订单号</td>
<td align="left">out_trade_no</td>
<td align="left">是</td>
<td align="left">String(32)</td>
<td align="left">1212321211201407033568112322</td>
<td align="left">商户系统内部订单号，要求32个字符内，只能是数字、大小写字母_-|*@ ，且在同一个商户号下唯一。</td>
</tr>
<tr>
<td align="left">商家数据包</td>
<td align="left">attach</td>
<td align="left">否</td>
<td align="left">String(128)</td>
<td align="left">123456</td>
<td align="left">商家数据包，原样返回</td>
</tr>
<tr>
<td align="left">支付完成时间</td>
<td align="left">time_end</td>
<td align="left">是</td>
<td align="left">String(14)</td>
<td align="left">20141030133525</td>
<td align="left">支付完成时间，格式为yyyyMMddHHmmss，如2009年12月25日9点10分10秒表示为20091225091010。其他详见<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_2">时间规则</a></td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appid</span>&gt;</span>&lt;![CDATA[wxb1427ebebeeaxxxx]]&gt;<span class="tag">&lt;/<span class="name">appid</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bank_type</span>&gt;</span>&lt;![CDATA[CFT]]&gt;<span class="tag">&lt;/<span class="name">bank_type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">cash_fee</span>&gt;</span>&lt;![CDATA[1]]&gt;<span class="tag">&lt;/<span class="name">cash_fee</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果有鼓励金--&gt;</span></span><br><span class="line">coupon_count</span><br><span class="line">coupon_fee</span><br><span class="line">coupon_fee_0</span><br><span class="line">coupon_id_0</span><br><span class="line">的这4个参数中coupon_fee_0和coupon_id_0，官方给出的参数是`coupon_id_$n`和`coupon_fee_$n`，$n为下标，从0开始编号。在处理验签时是将xml转化成了JAVA对象，对于这种动态的参数目前没有什么好的解决方案，目前因为只有 `_0`，所以只定义了一个参数叫做`_0`</span><br><span class="line">    <span class="tag">&lt;<span class="name">coupon_count</span>&gt;</span>&lt;![CDATA[1]]&gt;<span class="tag">&lt;/<span class="name">coupon_count</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">coupon_fee</span>&gt;</span>30<span class="tag">&lt;/<span class="name">coupon_fee</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">coupon_fee_0</span>&gt;</span>&lt;![CDATA[30]]&gt;<span class="tag">&lt;/<span class="name">coupon_fee_0</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">coupon_id_0</span>&gt;</span>&lt;![CDATA[2000000001082991244]]&gt;<span class="tag">&lt;/<span class="name">coupon_id_0</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果有鼓励金-end--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">device_info</span>&gt;</span>&lt;![CDATA[WEB]]&gt;<span class="tag">&lt;/<span class="name">device_info</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">fee_type</span>&gt;</span>&lt;![CDATA[CNY]]&gt;<span class="tag">&lt;/<span class="name">fee_type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">is_subscribe</span>&gt;</span>&lt;![CDATA[Y]]&gt;<span class="tag">&lt;/<span class="name">is_subscribe</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mch_id</span>&gt;</span>&lt;![CDATA[132186xxxx]]&gt;<span class="tag">&lt;/<span class="name">mch_id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">nonce_str</span>&gt;</span>&lt;![CDATA[07FC15C9D169EE48573EDD749D25945D]]&gt;<span class="tag">&lt;/<span class="name">nonce_str</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">openid</span>&gt;</span>&lt;![CDATA[oo8WUt0taCqjt552htW1vw-xxxxx]]&gt;<span class="tag">&lt;/<span class="name">openid</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">out_trade_no</span>&gt;</span>&lt;![CDATA[你的订单编号]]&gt;<span class="tag">&lt;/<span class="name">out_trade_no</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span class="tag">&lt;/<span class="name">result_code</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">return_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span class="tag">&lt;/<span class="name">return_code</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">sign</span>&gt;</span>&lt;![CDATA[E69940B3EDC437CB5A181210D523806E]]&gt;<span class="tag">&lt;/<span class="name">sign</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">time_end</span>&gt;</span>&lt;![CDATA[20160621134204]]&gt;<span class="tag">&lt;/<span class="name">time_end</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">total_fee</span>&gt;</span>1<span class="tag">&lt;/<span class="name">total_fee</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">trade_type</span>&gt;</span>&lt;![CDATA[JSAPI]]&gt;<span class="tag">&lt;/<span class="name">trade_type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">transaction_id</span>&gt;</span>&lt;![CDATA[400386200120160621763973xxxx]]&gt;<span class="tag">&lt;/<span class="name">transaction_id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br><span class="line">上述微信返回的xml中含有很多字段。使用上述xml中，除sign以外的值+key，进行签名。包含result_code和return_code。</span><br></pre></td></tr></table></figure>

<p><img src="/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/456549-20160621183614600-1536932315.png" alt="img"></p>
<p>1.用微信回调函数中传的参数，进行重新签名。将获得的签名与xml中的sign对比，如果相同，证明是微信返回的通知</p>
<p>2.进行支付完的逻辑处理</p>
<p>3.返回给微信收到的消息（参考<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_7%EF%BC%89">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_7）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String xml &#x3D; &quot;&lt;xml&gt; &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;&#x2F;return_code&gt;&lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;&#x2F;return_msg&gt;&lt;&#x2F;xml&gt;&quot;;</span><br><span class="line">response.getWriter().write(xml);</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appid</span>&gt;</span>&lt;![CDATA[wx2421b1c4370ec43b]]&gt;<span class="tag">&lt;/<span class="name">appid</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">attach</span>&gt;</span>&lt;![CDATA[支付测试]]&gt;<span class="tag">&lt;/<span class="name">attach</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bank_type</span>&gt;</span>&lt;![CDATA[CFT]]&gt;<span class="tag">&lt;/<span class="name">bank_type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fee_type</span>&gt;</span>&lt;![CDATA[CNY]]&gt;<span class="tag">&lt;/<span class="name">fee_type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">is_subscribe</span>&gt;</span>&lt;![CDATA[Y]]&gt;<span class="tag">&lt;/<span class="name">is_subscribe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mch_id</span>&gt;</span>&lt;![CDATA[10000100]]&gt;<span class="tag">&lt;/<span class="name">mch_id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nonce_str</span>&gt;</span>&lt;![CDATA[5d2b6c2a8db53831f7eda20af46e531c]]&gt;<span class="tag">&lt;/<span class="name">nonce_str</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">openid</span>&gt;</span>&lt;![CDATA[oUpF8uMEb4qRXf22hE3X68TekukE]]&gt;<span class="tag">&lt;/<span class="name">openid</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">out_trade_no</span>&gt;</span>&lt;![CDATA[1409811653]]&gt;<span class="tag">&lt;/<span class="name">out_trade_no</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span class="tag">&lt;/<span class="name">result_code</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">return_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span class="tag">&lt;/<span class="name">return_code</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sign</span>&gt;</span>&lt;![CDATA[B552ED6B279343CB493C5DD0D78AB241]]&gt;<span class="tag">&lt;/<span class="name">sign</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">time_end</span>&gt;</span>&lt;![CDATA[20140903131540]]&gt;<span class="tag">&lt;/<span class="name">time_end</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">total_fee</span>&gt;</span>1<span class="tag">&lt;/<span class="name">total_fee</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">coupon_fee</span>&gt;</span>&lt;![CDATA[10]]&gt;<span class="tag">&lt;/<span class="name">coupon_fee</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">coupon_count</span>&gt;</span>&lt;![CDATA[1]]&gt;<span class="tag">&lt;/<span class="name">coupon_count</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">coupon_type</span>&gt;</span>&lt;![CDATA[CASH]]&gt;<span class="tag">&lt;/<span class="name">coupon_type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">coupon_id</span>&gt;</span>&lt;![CDATA[10000]]&gt;<span class="tag">&lt;/<span class="name">coupon_id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">trade_type</span>&gt;</span>&lt;![CDATA[JSAPI]]&gt;<span class="tag">&lt;/<span class="name">trade_type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transaction_id</span>&gt;</span>&lt;![CDATA[1004400740201409030005092168]]&gt;<span class="tag">&lt;/<span class="name">transaction_id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>需要返回给微信的参数</strong></p>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">return_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span class="tag">&lt;/<span class="name">return_code</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">return_msg</span>&gt;</span>&lt;![CDATA[OK]]&gt;<span class="tag">&lt;/<span class="name">return_msg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="5）支付后的验证（前端获得支付结果后需要进行查单）"><a href="#5）支付后的验证（前端获得支付结果后需要进行查单）" class="headerlink" title="5）支付后的验证（前端获得支付结果后需要进行查单）"></a>5）支付后的验证（前端获得支付结果后需要进行查单）</h3><p><img src="/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/chapter23_9.png" alt="img"></p>
<p>1、 前端返回“用户取消”的情况，则订单状态保持未支付状态，并提示用户支付未完成。</p>
<p>2、前端返回“成功”或“报错”的情况，商户需要调用商户<strong>查单接口</strong>，确认订单状态。</p>
<pre><code>1）如果商户查单接口明确返回支付成功，则给用户展示支付成功页。

2）如果商户查单接口返回订单未支付，需要提醒用户“稍后进入订单管理页核实订单状态，不要重复发起支付”。商户后端需要及时获取、更新订单状态，实现逻辑参考【后端服务处理】。当用户再次进入订单管理页面，对未支付的订单再次发起支付时，商户应该使用原单号发起，不要更换支付单号，避免用户重复支付。
</code></pre>
<h4 id="【定时轮询查单】"><a href="#【定时轮询查单】" class="headerlink" title="【定时轮询查单】"></a><strong>【定时轮询查单】</strong></h4><p>如果长时间没有收到支付结果通知，商户后台应该定时轮询调用《<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_2">微信支付查单接口</a>》去核实订单状态。</p>
<p><strong>方案一</strong></p>
<p>以订单下单成功时间为基准（或者以前端支付返回成功或者报错后，第一次调用商户查单接口未成功的时间为基准），每隔5秒/30秒/1分钟/3分钟/5分钟/10分钟/30分钟调用《<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_2">微信支付查单接口</a>》查询一次，最后一次查询还是未返回支付成功状态，则停止后续查询，并调用《<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_3">关单接口</a>》关闭订单。（轮询时间间隔和次数，商户可以根据自身业务场景灵活设置）</p>
<p><strong>方案二</strong></p>
<p>定时任务每隔30秒启动一次，找出最近10分钟内创建并且未支付的订单，调用《<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_2">微信支付查单接口</a>》核实订单状态。系统记录订单查询的次数，在10次查询之后状态还是未支付成功，则停止后续查询，并调用《<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_3">关单接口</a>》关闭订单。（轮询时间间隔和次数，商户可以根据自身业务场景灵活设置）</p>
<h4 id="【T-1日对账处理】"><a href="#【T-1日对账处理】" class="headerlink" title="【T+1日对账处理】"></a><strong>【T+1日对账处理】</strong></h4><p>1、商户在T+1日上午10点以后，调用《<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_6">微信支付对账单下载接口</a>》，或者登录微信商户平台手工下载T日交易账单，然后根据对账单中的订单数据，逐笔与商户系统中的订单核对。</p>
<p>2、核对时有如下几种情况：</p>
<p>  1)订单匹配成功，并且状态都是支付成功：正常情况，对账成功。</p>
<p>  2)订单匹配成功，但是商户侧状态非支付成功：商户根据自身业务情况，决定是否把订单状态更新为支付成功并给用户发货，或者是给用户发起退款。</p>
<p>  3)订单匹配失败，对账单中的单号在商户系统未找到记录：异常情况，需要商户排查系统是否出现数据异常。</p>
<p>  4)订单匹配失败，商户系统中成功的订单在对账单中未找到记录：异常情况，需要商户排查是否订单处理逻辑有bug。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>微信公众号的支付：（需严格按照微信的开发文档填写对应参数，否则接口调用失败！）</p>
<p>1.前端调用起微信支付的组件WeixinJSBridge</p>
<p>2.后端调用统一下单的接口，将返回值传入前端方法里的参数：WeixinJSBridge.invoke（）</p>
<p>3.前端根据方法的参数向微信服务器请求。后端会向统一下单时设置的url传xml格式的结果，需要进行逻辑处理并返回信息。前端会返回res.err_msg，根据返回值get_brand_wcpay_request的结果进行后续操作：</p>
<p>1）ok或者fail ：调用后台的查单接口，订单变为已支付提示成功，订单未变提示等待，然后调用微信的查单接口进行查单</p>
<p>2）cancel：提示取消订单的信息</p>
<p>4.进行支付时进行倒计时，倒计时结束后调用关闭订单接口</p>
<p>5.第二天调用对账单接口进行对账</p>
<h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><p>1.支付的前端页面必须同步，不能使用异步方法。</p>
<p>2.支付的统一下单里的参数，商品描述和系统内的订单号必须统一，否则一样的订单号，描述不一样，微信会认为是不同的两个订单，返回201 商户订单号重复。</p>
<p>3.如果prepay_id为null，前端取不到package里的prepay_id，会显示缺少total_fee。</p>
<h2 id="微信公众号支付（支付宝）"><a href="#微信公众号支付（支付宝）" class="headerlink" title="微信公众号支付（支付宝）"></a>微信公众号支付（支付宝）</h2><p>微信公众号里调用支付宝接口只能使用网页支付</p>
<p><img src="/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/20170815164444076" alt="img"></p>
<h3 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1.配置环境"></a>1.配置环境</h3><p>1.创建应用，签约“手机网站支付”功能。然后配置关键参数</p>
<p>微信公众号里接入支付宝的其它方法，由于2家的竞争对象，微信中无法打开支付宝收款是微信浏览器限制所致，可以引导用户转到系统浏览器，即可用支付宝收款</p>
<h2 id="关闭微信浏览器的方法"><a href="#关闭微信浏览器的方法" class="headerlink" title="关闭微信浏览器的方法"></a>关闭微信浏览器的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;WeixinJSBridgeReady&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">window</span>.WeixinJSBridge.call(<span class="string">&#x27;closeWindow&#x27;</span>); &#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">window</span>.WeixinJSBridge.call(<span class="string">&#x27;closeWindow&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.每个接口都有每日接口<strong>调用频次</strong>限制，可以在公众平台官网-开发者中心处查看具体频次。</p>
<p>2.公众平台以<strong>access_token</strong>为接口调用凭据，来调用接口，所有接口的调用需要先获取access_token，access_token在2小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储，详见获取接口调用凭据（access_token）文档</p>
<p>3.公众平台接口调用仅支持<strong>80端口</strong></p>
<p>微信公众号接口必须以http://或https://开头，分别支持80端口和443端口</p>
<p>4.涉及<strong>用户数据</strong>：</p>
<ul>
<li>您的服务需要收集用户任何数据的，必须事先获得用户的明确同意，且仅应当收集为运营及功能实现目的而必要的用户数据， 同时应当告知用户相关数据收集的目的、范围及使用方式等，保障用户知情权。</li>
<li>您收集用户的数据后，必须采取必要的保护措施，防止用户数据被盗、泄漏等。</li>
<li>您在特定微信公众号中收集的用户数据仅可以在该特定微信公众号中使用，不得将其使用在该特定微信公众号之外或为其他任何目的进行使用，也不得以任何方式将其提供给他人。</li>
<li>如果腾讯认为您收集、使用用户数据的方式，可能损害用户体验，腾讯有权要求您删除相关数据并不得再以该方式收集、使用用户数据。</li>
<li>一旦您停止使用本服务，或腾讯基于任何原因终止您使用本服务，您必须立即删除全部因使用本服务而获得的数据（包括各种备份）， 且不得再以任何方式进行使用。</li>
</ul>
<p>其他规范：</p>
<ul>
<li>请勿为任何用户自动登录到微信公众平台提供代理身份验证凭据。</li>
<li>请勿提供跟踪功能，包括但不限于识别其他用户在个人主页上查看、点击等操作行为。</li>
<li>请勿自动将浏览器窗口定向到其他网页。</li>
<li>请勿设置或发布任何违反相关法规、公序良俗、社会公德等的玩法、内容等。</li>
<li>请勿公开表达或暗示，您与腾讯之间存在合作关系，包括但不限于相互持股、商业往来或合作关系等，或声称腾讯对您的认可。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/21.1.%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/" data-id="ckw61sdzw007coswd9o7g3stg" data-title="微信开发" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-22.1.计算机基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:30:15.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。"><a href="#计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。" class="headerlink" title="计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。"></a>计算机五大基础部件：存储器、控制器、运算器、输入设备、输出设备。</h3><p>存储器分为内存和磁盘。</p>
<h3 id="一、CPU"><a href="#一、CPU" class="headerlink" title="一、CPU"></a>一、CPU</h3><p>1.计算机核心组件，在单个计算机芯片上放置数十亿个微型晶体管来构建成CPU。</p>
<p>2.CPU的核心是从程序或应用程序获取指令并执行计算。提取，解码，执行。从系统的RAM（随机存取存储器，也叫主存）中提取指令然后解码该指令的实际内容，然后再由CPU相关部分执行。</p>
<p>3.主要由两部分组成：控制单元和算术逻辑单元（ALU）。</p>
<p>控制单元：从内存中提取指令并解码执行。</p>
<p>算术逻辑单元：处理算术和逻辑运算。</p>
<p>从功能看，由四部分:寄存器n个和控制器、运算器、时钟。由电信号连通。</p>
<p>CPU是一系列寄存器的集合体。</p>
<p><strong>累加寄存器</strong>、<strong>标志寄存器</strong>、<strong>程序计数器</strong>、基址寄存器、变址寄存器、通用寄存器、<strong>指令寄存器</strong>、<strong>栈寄存器</strong>。（基址变址通用有多个，其余都是只有一个）</p>
<p>（1）程序计数器：用来存储下一条指令所在单元的地址。程序计数器控制着程序的流程。</p>
<p>（2）标志寄存器：保存累加寄存器的运算结果，也负责溢出（指运算的指令超过了寄存器的长度范围）和奇偶校验。标志寄存器的第一个字节为1则为正，第二个字节为1则为0，第三个字节为1则为负数。</p>
<p>（CPU执行机制有个比较运算，实际上是减法运算，其结果记录在标志寄存器上）</p>
<p>函数调用机制：call指令调用和return指令返回，中间是栈</p>
<p>（3）基址寄存器和变址寄存器：用过这两个寄存器可以实现对主存上的特定区域进行划分，来实现类似<strong>数组</strong>的操作。</p>
<p>实际地址=基址寄存器的值+变址寄存器的值</p>
<table>
<thead>
<tr>
<th>寄存器名</th>
<th>名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td>eax</td>
<td>累加寄存器</td>
<td>运算</td>
</tr>
<tr>
<td>ebc</td>
<td>基址存储器</td>
<td>存储内存地址</td>
</tr>
<tr>
<td>ecx</td>
<td>计数存储器</td>
<td>计算循环次数</td>
</tr>
<tr>
<td>edx</td>
<td>数据寄存器</td>
<td>存储数据</td>
</tr>
<tr>
<td>esi</td>
<td>源基址寄存器</td>
<td>存储数据发送源的内存地址</td>
</tr>
<tr>
<td>edi</td>
<td>目的基址寄存器</td>
<td>存储数据发送目标的内存地址</td>
</tr>
<tr>
<td>ebp</td>
<td>扩展基址寄存器</td>
<td>存储数据存储领域基点的内存地址</td>
</tr>
<tr>
<td>esp</td>
<td>扩展栈指针寄存器</td>
<td>存储栈中最高位数据的内存地址</td>
</tr>
</tbody></table>
<p>数据的销毁：栈中存在两个参数，可通过两次pop指令可以将栈内的数据销毁；也可采用esp寄存器+8的方式更有效率（只需处理一次）：数值的单位是4字节，esp寄存器+8相当于pop2次，虽然内存中的数据实际上还残留着，但只要把esp寄存器的值更新为数据存储地址前面的数据位置，该数据就相当于销毁了。</p>
<p>函数的参数是通过栈来传递，返回值是通过寄存器返回的。</p>
<p>∷CPU指令执行过程:取指令，指令译码，执行指令，访存取数，结果写回。</p>
<h3 id="二、内存（内部存储设备）"><a href="#二、内存（内部存储设备）" class="headerlink" title="二、内存（内部存储设备）"></a>二、内存（内部存储设备）</h3><ol>
<li><p>也叫主存。是与CPU进行沟通的桥梁。通过控制芯片相连，由可读写的元素构成，每个字节（1byte=8bits）都有一个地址编号。CPU通过地址从内存中读取数据和指令，也可以根据地址写入数据。计算机所有程序的运行都是在主存中运行的。当计算机关闭时，内存中的指令和数据就会被清除。</p>
</li>
<li><p>作用：存放CPU中的运算数据，与硬盘等外部存储设备交换的数据。其运行决定了计算机的稳定运行。</p>
</li>
<li><p>内存的内部由各种IC电路组成，可分为三种：</p>
</li>
</ol>
<p>（1）随机存储器（RAM）：最重要的一种，可读可写，机器关闭时，信息会丢失。</p>
<p>（2）只读存储器（ROM）：只可读，机器关闭时，信息不会丢失。</p>
<p>程序的运行环境，存在着名为BIOS（Basic Input/Output System）的系统。BIOS存储在ROM中，是预先内置在计算机主机内部的程序，记录了用来控制外围设备的程序和数据。BIOS除了键盘、磁盘、显卡等基本控制外，还有引导程序的功能。<strong>引导程序</strong>是存储在启动驱动器启示区域的小程序。操作系统的启动驱动器一般是硬盘，也有CD-ROM和软盘。</p>
<p>（3）高速缓存（Cache）：分为一级缓存（L1 Cache）、二级缓存、三级缓存。位于内存和CPU之间，是一个读写速度比内存更快的存储器。</p>
<p>内存IC：一个完整的结构，内部有电源，地址信号，控制信号和用于寻址的IC<strong>引脚（Pin）</strong>来进行数据的读写。IC就是集成电器（integrated circuit）</p>
<p>存储方式有两种:低字节序列（将数据低位存储在内存低位地址）和高字节序列（将数据的高位存储在内存的低位）。</p>
<p>数组是内存的实现。</p>
<ol start="4">
<li>虚拟内存是内存和磁盘交互的第二个媒介，是把磁盘的一部分作为假想内存来使用。虚拟内存在硬盘上的存在形式就是PAGEFILE.SYS这个页面文件。</li>
</ol>
<p>当内存不足时可借助虚拟内存运行程序，通过置换（swap）。分为分页式和分段式。</p>
<p>Windows操作系统：</p>
<p>1.Windows是以图形界面为基础的操作系统，前身是MS-DOC（16位操作系统）。</p>
<p>2.有两个版本32和64位。（指的是处理效率最高的数据大小）</p>
<p>3.通过API（Application Programming Interface，应用程序接口）函数集成来提供系统调用。API通过多个DLL文件来提供。</p>
<p>4.通过WYSIWYG（what you see is what you get）实现打印输出。</p>
<p>5.提供多任务功能：通过时钟分割技术来实现，底层是cpu时间切片，这也是多线程多任务的核心。</p>
<p>6.提供网络功能和数据库功能。它们和操作系统很接近，所以被称为中间件而不是应用。操作系统+中间件=系统软件。</p>
<p>7.即插即用实现设备驱动的自动设定。</p>
<p>节约内存有两种方式：增加内存的容量，加内存条；优化应用程序，使其尽可能变小。</p>
<p>怎样优化应用程序呢？</p>
<p>1.可以通过DLL文件实现函数共有。</p>
<p>DLL（Dynamic Link Library）文件是一种动态链接库文件，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。多个应用可以共有一个DLL文件从而达到节约内存的效果。</p>
<p>2.通过调用_stdcall来减少程序文件的大小。</p>
<p> <code>_stdcall</code>是standard call（标准调用）。Windows提供的DLL函数都是通过<code>_stdcall</code>调用。</p>
<p>三、磁盘（外部存储设备）</p>
<p>内存通过电流实现存储，磁盘通过磁记录技术来实现存储。</p>
<p>早期磁盘：软盘。如今用的是硬磁盘。磁盘中存储的程序必须加载到内存中才能运行。</p>
<p>磁盘的缓存叫做磁盘缓存，指的是把从磁盘中读出的数据存储到内存的方式，磁盘缓存大大改善了磁盘访问的速度。磁盘缓存是内存的一部分。</p>
<p>磁盘的物理结构指的是磁盘存储数据的形式。通过其物理表面划分成多个空间来使用，划分方式：可变长方式和扇区方式（一般是这种）。</p>
<p>扇区是对磁盘进行物理读写的最小单位。</p>
<p>四、操作系统环境</p>
<p>程序要运行需要运行环境。运行环境=操作系统+硬件。</p>
<p>操作系统又可以被称为软件，是由一系列的指令组成的。分为：Windows、Linux、Unix、FreeBSD(Unix系统的一种)。监控程序（加载程序、运行程序）可以说是操作系统的原型。后来又加上了基本的输入输出程序，再后来加上了硬件控制程序、编程语言处理器（汇编、编译、解析）、各种应用程序。操作系统其实就是多个程序的集合体。</p>
<p>Windows操作的是硬件而不是软件，软件通过操作windows系统可以达到控制硬件的目的。程序员没法直接控制硬件，且windows屏蔽了控制硬件的细节，但是windows却开放了系统调用功能来实现对硬件的控制，系统调用称为API，API就是应用调用的函数，这些函数的实体被存放在DLL文件中。</p>
<p>CPU的类型不同，所对应的机器的语言也不同。操作系统的类型不同，应用程序向操作系统传递指令的途径（称为API，Application Programming Interface）也不同。</p>
<p>五、显卡</p>
<p>承担图形的输出任务。又被称为图形处理器（Graphic Processing Unit,GPU）。</p>
<p>显示器中显示的信息一直存储在某内存中，该内存称为VRAM（Video RAM），在程序中，只要往VRAM中写入数据，该数据就会在显示器中显示出来。实现该功能的程序，是由操作系统或者BIOS提供，并借助中断来处理。</p>
<p>集成显卡：集成显卡是一种特殊的显卡，它一般不带有显存，而是使用系统的一部分主内存作为显存，具体的数量是系统根据需要自动动态调整的。</p>
<p>独立显卡：独立显卡简称独显，是指成独立的板卡，需要插在主板的相应接口上的显卡。独立显卡又分为内置独立显卡和外置显卡。独立显卡具备单独的显存，不占用系统内存，而且技术上领先于集成显卡，能够提供更好的显示效果和运行性能。</p>
<p>六、外围设备</p>
<p>1.IO端口</p>
<p>计算机主机中，附带了用来连接显示器以及键盘等外围设备的连接器，连接器内部都连接有用来交换计算机主机内外围设备之间电流特性的IC，这些IC统称为IO控制器。IO控制器中有用于临时保存输入输出数据的内存，被称为寄存器（与CPU的寄存器不同），这些内存就是端口。一个io控制器可以控制多个设备，各端口之间通过端口号来区分。端口号也被称为IO地址。</p>
<p>2.IRQ实现中断</p>
<p>外围设备的中断请求：IRQ（Interrupt Request）代表的就是中断请求。IRQ用来暂停当前正在运行的程序，并跳转到其他程序运行的必要机制，该机制被称为处理中断。实施中断请求的是连接外围设备的io控制器，负责实施中断处理的是CPU，外围设备的中断请求会使用不同于IO端口的其他编号，这个编号叫中断编号。操作系统以及BIOS则会提供响应中断编号的中断处理程序。</p>
<p>假如有多个外围设备请求中断的话，可以在IO控制器和CPU之间加入名为中断控制器的IC进行缓冲。</p>
<p>3.DMA实现短时间内大量数据传输</p>
<p>DMA（Direct Memory Access）：指在不通过CPU的情况下，外围设备直接和主存进行数据传输。磁盘等外围设备都用到了DMA机制</p>
<p>假如多个设备设定成相同的端口号、IRQ和DMA通道的话，计算机就无法正常工作，会提示设备冲突。</p>
<p>网址后缀名：</p>
<p>.org  非盈利性组织</p>
<p>.com  商业机构</p>
<p>.cn  政府</p>
<p>.edu  教育</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/22.1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ckw61sduv000soswdgqp7gaji" data-title="计算机基础知识" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库和SQL语句" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:29:35.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/">数据库和SQL语句</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数据库就是一个文件系统，通过标准的SQL语句获取数据</p>
<p>关系型数据库：存放的是实体之间的关系</p>
<p>ER模型图：E：Entity  R：Relational  （实体用矩形，属性用椭圆，关系用菱形）</p>
<p>表：对应一个实体类</p>
<p>对数据库的添加，修改，删除，查询操作</p>
<p>对数据库表的添加，修改，删除，查询操作</p>
<p>对数据库表记录的添加，修改，删除，查询操作</p>
<p>常见的关系型数据库：</p>
<p><strong>MySQL</strong></p>
<p><strong>Oracle</strong></p>
<p>SQLServer</p>
<p>DB2</p>
<p>SyBase</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml1960\wps18.jpg" alt="img"> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL%E8%AF%AD%E5%8F%A5/" data-id="ckw61sdvy003voswd74zv0tsp" data-title="数据库和SQL语句" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-15.1.Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/15.1.Redis/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T05:28:54.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/15.1.Redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个开源的使用ANSI <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1219.htm">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1088.htm">数据库</a>，并提供多种语言的APIRedis是一个开源的使用ANSI <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1219.htm">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1088.htm">数据库</a>，并提供多种语言的API</p>
<p>从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助</p>
<p>Redis是 NoSQL（not only SQL）技术阵营中的一员，它通过多种键值数据类型来适应不同场景下的存储需求，借助一些高层级的接口使用其可以胜任，如缓存、队列系统的不同角色</p>
<p>Redis可以保存在内存中（性能非常好），也可以持久化在文件中</p>
<p>Redis的官网: <a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<p>经常用的数据成缓存，所以用redis</p>
<p>特性：</p>
<p>1.Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</p>
<p>2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</p>
<p>3.Redis支持数据的备份，即master-slave模式的数据备份</p>
<p>优势：</p>
<p>1.性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s</p>
<p>2.丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作</p>
<p>3.原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行</p>
<p>4.丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性</p>
<h1 id="Redis下载及安装"><a href="#Redis下载及安装" class="headerlink" title="Redis下载及安装"></a>Redis下载及安装</h1><p>Redis版本说明</p>
<p>Redis原生只支持linux系统。Redis官方是不支持windows平台，windows版本是微软自己建立的分支，基于官方的redis源码上进行编译、发布、维护的，所以window平台上的redis版本都略低于官方版本</p>
<p>当前redis最新版本是6.0</p>
<p>可以直接在windows上下载，通过上传工具上传到linux系统，也可以在linux下直接复制最新稳定版本下载链接的网址，然后wget+网址（这种方式必须要求可以上网）</p>
<p><img src="/15.1.Redis/image-20210906143052942.png" alt="image-20210906143052942"></p>
<p>Redis安装：</p>
<p>1.将redis.tar.gz解压：tar -zxvf redis-3.2.8.tar.gz</p>
<p>mkdir redis  建一个目录</p>
<p>2.进入redis-3.2.8目录：cd redis-3.2.8</p>
<p>3.对redis进行编译:make  </p>
<p>4.安装到指定的目录：make PREFIX=/usr/local/redis install</p>
<p>如果安装redis是报下面的错误，是因为系统没有安装gcc环境，缺少依赖</p>
<p><img src="/15.1.Redis/image-20210906143205630.png" alt="image-20210906143205630"></p>
<p>解决方案：</p>
<p><img src="/15.1.Redis/image-20210906143234917.png" alt="image-20210906143234917"></p>
<p>安装完成后，对redis进行重新编译安装</p>
<p>redis安装完成后，我们进入目录bin中查看</p>
<p><img src="/15.1.Redis/image-20210906143248752.png" alt="image-20210906143248752"></p>
<p>redis-server          redis服务器</p>
<p>redis-cli           redis命令行客户端</p>
<p>redis-benchmark          redis性能测试工具</p>
<p>redis-check-aof         AOF文件修复工具</p>
<p>redis-check-rdb          RDB文件检索工具</p>
<p>redis客户端测试：</p>
<p>1.启动redis服务</p>
<p>./redis-server是可以启动的，但是有风险，只在测试环境下可以。正常启动需要加载配置文件</p>
<p>注意：我们需要将redis编译后的目录中的redis.conf文件copy到我们自己的redis目录中。 cp redis.conf /usr/local/redis </p>
<p>这个redis.conf文件是redis的配置文件</p>
<p><img src="/15.1.Redis/image-20210906143315774.png" alt="image-20210906143315774"></p>
<p>在输入</p>
<p><img src="/15.1.Redis/image-20210906143402387.png" alt="image-20210906143402387"></p>
<p>就可以启动</p>
<p>注意:前面是redis-server服务，后面redis.conf配置文件</p>
<p><img src="/15.1.Redis/image-20210906143424416.png" alt="image-20210906143424416"></p>
<p>Redis占用的端口是6379</p>
<p>可以通过redis-cli命令行客户端来测试redis是否启动成功</p>
<p><img src="/15.1.Redis/image-20210906143434276.png" alt="image-20210906143434276"></p>
<p>其他ip地址不能连接是因为配置文件中只允许回环地址127.0.0.1连接</p>
<p>windows版redis</p>
<p>github下载或者百度网盘找到.msi的安装包，按步骤安装。</p>
<p>验证：</p>
<p>1、打开cmd窗口，输入redis-cli.exe -h 127.0.0.1 -p 6379后回车，出现127.0.0.1：6379说明redis安装且连接成功</p>
<p>2.试下是否能够存储成功：set key1 value1       get key1</p>
<p>3.设置redis密码：</p>
<p>​    查看密码：config get requirepass</p>
<p>​    设置密码：config set requirepass 123456</p>
<p>​    除去密码：config set requirepass ‘’</p>
<p>4.带密码登录，不然提示没有权限</p>
<p>redis-cli.exe -h 127.0.0.1 -p 6379 -a 密码</p>
<p>redis-cli.exe -h 127.0.0.1 -p 6379后进行操作提示没有权限时，  auth 密码</p>
<p>以上为设置临时密码，也可以设置临时密码为root：</p>
<p>找到redis目录下redis-server.exe点击运行，再点击redis-cli.exe运行。输入config set requirepass root,回车即可</p>
<p>root 就是redis的临时密码。验证是否成功设置 ，输入auth root 如果返回OK就说明成功</p>
<p>设置永久的密码为root：</p>
<p>需要在redis.conf或redis.windows.conf中输入requirepass root，保存后，在该redis目录下的路径栏输入cmd，进入命令模式，输入<code>redis-server.exe redis.windows.conf</code>   打开redis</p>
<p>如果直接输入此命令不行，则将redis-server.exe直接拖进命令框中，即显示的是redis-server.exe的全路径 再跟上配置文件的命令   启动服务端</p>
<h1 id="Redis数据类型与常见操作"><a href="#Redis数据类型与常见操作" class="headerlink" title="Redis数据类型与常见操作"></a>Redis数据类型与常见操作</h1><p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）</p>
<h2 id="string类型常见操作"><a href="#string类型常见操作" class="headerlink" title="string类型常见操作"></a>string类型常见操作</h2><p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。</p>
<p>在Redis中字符串类型的Value最多可以容纳的数据长度是512M</p>
<p>常见操作（小写也可）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">SET key value 	 </span><br><span class="line">设定该Key持有指定的字符串Value，如果该Key已经存在，则覆盖其原有值。返回值：总是返回&quot;OK&quot;</span><br><span class="line"></span><br><span class="line">GET key 	 </span><br><span class="line">获取指定Key的Value。如果与该Key关联的Value不是string类型，Redis将返回错误信息，因为GET命令只能用于获取string Value</span><br><span class="line">返回值：与该Key相关的Value，如果该Key不存在，则返回nil。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MSET key value [key value ...] 	 </span><br><span class="line">该命令原子性的完成参数中所有key&#x2F;value的设置操作，其具体行为可以看成是多次迭代执行SET命令。 </span><br><span class="line">返回值：该命令不会失败，始终返回OK。 </span><br><span class="line"></span><br><span class="line">MGET key [key ...]  </span><br><span class="line">返回所有指定Keys的Values，如果其中某个Key不存在，或者其值不为string类型，该Key的Value将返回nil。	</span><br><span class="line">返回值：返回一组指定Keys的Values的列表。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">SETNX key value  </span><br><span class="line">如果指定的Key不存在，则设定该Key持有指定字符串Value，此时其效果等价于SET命令。相反，如果该Key已经存在，该命令将不做任何操作并返回。</span><br><span class="line">返回值：1表示设置成功，否则0。（not exists）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MSETNX key value [key value ...] 	 </span><br><span class="line">该命令原子性的完成参数中所有key&#x2F;value的设置操作，其具体行为可以看成是多次迭代执行SETNX命令。然而这里需要明确说明的是，如果在这一批Keys中有任意一个Key已经存在了，那么该操作将全部回滚，即所有的修改都不会生效。</span><br><span class="line">返回值：1表示所有Keys都设置成功，0则表示没有任何Key被修改。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">APPEND key value  </span><br><span class="line">如果该Key已经存在，APPEND命令将参数Value的数据追加到已存在Value的末尾。如果该Key不存在，APPEND命令将会创建一个新的Key&#x2F;Value。</span><br><span class="line">返回值：追加后Value的长度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DECR key	 </span><br><span class="line">将指定Key的Value原子性的递减1。如果该Key不存在，其初始值为0，在decr之后其值为-1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。（error）</span><br><span class="line">返回值：递减后的Value值。</span><br><span class="line"></span><br><span class="line">INCR key	 </span><br><span class="line">将指定Key的Value原子性的递增1。如果该Key不存在，其初始值为0，在incr之后其值为1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。</span><br><span class="line">返回值：递增后的Value值。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">DECRBY key decrement  </span><br><span class="line">将指定Key的Value原子性的减少decrement。如果该Key不存在，其初始值为0，在decrby之后其值为-decrement。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</span><br><span class="line">返回值：减少后的Value值。</span><br><span class="line"></span><br><span class="line">INCRBY key increment   </span><br><span class="line">将指定Key的Value原子性的增加increment。如果该Key不存在，其初始值为0，在incrby之后其值为increment。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</span><br><span class="line">返回值：增加后的Value值。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">GETSET key value	 </span><br><span class="line">原子性的设置该Key为指定的Value，同时返回该Key的原有值。和GET命令一样，该命令也只能处理string Value，否则Redis将给出相关的错误信息。</span><br><span class="line">返回值：返回该Key的原有值，如果该Key之前并不存在，则返回nil。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">STRLEN key	 </span><br><span class="line"></span><br><span class="line">返回指定Key的字符值长度，如果Value不是string类型，Redis将执行失败并给出相关的错误信息。</span><br><span class="line"></span><br><span class="line">返回值：指定Key的Value字符长度，如果该Key不存在，返回0。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SETEX key seconds value	 </span><br><span class="line"></span><br><span class="line">原子性完成两个操作，一是设置该Key的值为指定字符串，同时设置该Key在Redis服务器中的存活时间(秒数)。该命令主要应用于Redis被当做Cache服务器使用时。	 （expire，到期）</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SETRANGE key offset value  </span><br><span class="line"></span><br><span class="line">替换指定Key的部分字符串值。从offset开始，替换的长度为该命令第三个参数value的字符串长度，其中如果offset的值大于该Key的原有值Value的字符串长度，Redis将会在Value的后面补齐(offset - strlen(value))数量的0x00，之后再追加新值。如果该键不存在，该命令会将其原值的长度假设为0，并在其后添补offset个0x00后再追加新值。鉴于字符串Value的最大长度为512M，因此offset的最大值为536870911。最后需要注意的是，如果该命令在执行时致使指定Key的原有值长度增加，这将会导致Redis重新分配足够的内存以容纳替换后的全部字符串，因此就会带来一定的性能折损。</span><br><span class="line"></span><br><span class="line">返回值：修改后的字符串Value长度。</span><br><span class="line"></span><br><span class="line">GETRANGE key start end	 </span><br><span class="line"></span><br><span class="line">截取字符串。该命令在截取子字符串时，将以闭区间的方式同时包含start(0表示第一个字符)和end所在的字符，如果end值超过Value的字符长度，该命令将只是截取从start开始之后所有的字符数据。当end为-1时表示是最后一位，-4 -1表示从后数4位</span><br><span class="line"></span><br><span class="line">返回值：子字符串；</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SETBIT key offset value 	 </span><br><span class="line"></span><br><span class="line">设置在指定Offset上BIT的值，该值只能为1或0，在设定后该命令返回该Offset上原有的BIT值。如果指定Key不存在，该命令将创建一个新值，并在指定的Offset上设定参数中的BIT值。如果Offset大于Value的字符长度，Redis将拉长Value值并在指定Offset上设置参数中的BIT值，中间添加的BIT值为0。最后需要说明的是Offset值必须大于0。</span><br><span class="line"></span><br><span class="line">返回值：在指定Offset上的BIT原有值。</span><br><span class="line"></span><br><span class="line">GETBIT key offset 	 </span><br><span class="line"></span><br><span class="line">返回在指定Offset上BIT的值，0或1。如果Offset超过string value的长度，该命令将返回0，所以对于空字符串始终返回0。</span><br><span class="line"></span><br><span class="line">返回值：在指定Offset上的BIT值。 </span><br><span class="line"></span><br><span class="line">(布隆过滤器)</span><br><span class="line"></span><br><span class="line">a  97  0110 0001	</span><br><span class="line"></span><br><span class="line">A  65  0100 0001  其实只用 setbit key 2 0  就将a改为了A（从0开始计数）</span><br></pre></td></tr></table></figure>

<h2 id="list类型常见操作"><a href="#list类型常见操作" class="headerlink" title="list类型常见操作"></a>list类型常见操作</h2><p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的<strong>普通链表</strong>一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。</p>
<p>从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">常见操作</span><br><span class="line">LPUSH key value [value ...] 	 </span><br><span class="line"></span><br><span class="line">在指定Key所关联的List Value的头部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的头部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。</span><br><span class="line"></span><br><span class="line">返回值：插入后链表中元素的数量。</span><br><span class="line"></span><br><span class="line">LPUSHX key value 	  （x相当于判断）</span><br><span class="line"></span><br><span class="line">仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的头部插入参数中给出的Value，否则将不会有任何操作发生。	</span><br><span class="line"></span><br><span class="line">返回值：插入后链表中元素的数量。 </span><br><span class="line"></span><br><span class="line">LRANGE key start stop 	 </span><br><span class="line"></span><br><span class="line">该命令的参数start和end都是0-based。即0表示链表头部(leftmost)的第一个元素。其中start的值也可以为负值，-1将表示链表中的最后一个元素，即尾部元素，-2表示倒数第二个并以此类推。该命令在获取元素时，start和end位置上的元素也会被取出。如果start的值大于链表中元素的数量，空链表将会被返回。如果end的值大于元素的数量，该命令则获取从start(包括start)开始，链表中剩余的所有元素。</span><br><span class="line"></span><br><span class="line">返回值：返回指定范围内元素的列表。</span><br><span class="line"></span><br><span class="line">这里的链表插入的头部插入相当于是栈：插入12345，输出时就会是54321</span><br><span class="line"></span><br><span class="line">lrange key 0 -1 表示返回这个链表的所有元素</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">LPOP key 	 （相当于把头部的那个元素移除）</span><br><span class="line"></span><br><span class="line">返回并弹出指定Key关联的链表中的第一个元素，即头部元素。如果该Key不存，返回nil。</span><br><span class="line"></span><br><span class="line">返回值：链表头部的元素。</span><br><span class="line"></span><br><span class="line">LLEN key	 </span><br><span class="line"></span><br><span class="line">返回指定Key关联的链表中元素的数量，如果该Key不存在，则返回0。如果与该Key关联的Value的类型不是链表，则返回相关的错误信息。</span><br><span class="line"></span><br><span class="line">返回值：链表中元素的数量。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">LREM key count value  </span><br><span class="line"></span><br><span class="line">在指定Key关联的链表中，删除前count个值等于value的元素。如果count大于0，从头向尾遍历并删除，如果count小于0，则从尾向头遍历并删除。</span><br><span class="line"></span><br><span class="line">如果count等于0，则删除链表中所有等于value的元素。如果指定的Key不存在，则直接返回0。	</span><br><span class="line"></span><br><span class="line">返回值：返回被删除的元素数量。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">LSET key index value </span><br><span class="line"></span><br><span class="line">设定链表中指定位置的值为新值，其中0表示第一个元素，即头部元素，-1表示尾部元素。如果索引值Index超出了链表中元素的数量范围，该命令将返回相关的错误信息。	 </span><br><span class="line"></span><br><span class="line">(对指定脚标的值进行设置)</span><br><span class="line"></span><br><span class="line">返回值：OK</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">LINDEX key index 	 </span><br><span class="line"></span><br><span class="line">该命令将返回链表中指定位置(index)的元素，index是0-based，表示头部元素，如果index为-1，表示尾部元素。如果与该Key关联的不是链表，该命令将返回相关的错误信息。	</span><br><span class="line"></span><br><span class="line">返回值：返回请求的元素，如果index超出范围，则返回nil。</span><br><span class="line"></span><br><span class="line">(读出指定脚标的值)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">LTRIM key start stop 	 </span><br><span class="line"></span><br><span class="line">该命令将仅保留指定范围内的元素，从而保证链接中的元素数量相对恒定。start和stop参数都是0-based，0表示头部元素。和其他命令一样，start和stop也可以为负值，-1表示尾部元素。如果start大于链表的尾部，或start大于stop，该命令不会报错，而是返回一个空的链表，与此同时该Key也将被删除。如果stop大于元素的数量，则保留从start开始剩余的所有元素。	 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">LINSERT key BEFORE|AFTER pivot value  </span><br><span class="line"></span><br><span class="line">该命令的功能是在pivot元素的前面或后面插入参数中的元素value。如果Key不存在，该命令将不执行任何操作。如果与Key关联的Value类型不是链表，相关的错误信息将被返回。	</span><br><span class="line"></span><br><span class="line">返回值：成功插入后链表中元素的数量，如果没有找到pivot，返回-1，如果key不存在，返回0。</span><br><span class="line"></span><br><span class="line">(在指定的某个value前或后插入一个新的value)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">RPUSH key value [value ...] 	 </span><br><span class="line"></span><br><span class="line">在指定Key所关联的List Value的尾部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的尾部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。 </span><br><span class="line"></span><br><span class="line">返回值：插入后链表中元素的数量。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">RPUSHX key value </span><br><span class="line"></span><br><span class="line">仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的尾部插入参数中给出的Value，否则将不会有任何操作发生。</span><br><span class="line"></span><br><span class="line">返回值：插入后链表中元素的数量。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">RPOP key 	 </span><br><span class="line"></span><br><span class="line">返回并弹出指定Key关联的链表中的最后一个元素，即尾部元素，。如果该Key不存，返回nil。 </span><br><span class="line"></span><br><span class="line">返回值：链表尾部的元素。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">RPOPLPUSH source destination 	 </span><br><span class="line"></span><br><span class="line">原子性的从与source键关联的链表尾部弹出一个元素，同时再将弹出的元素插入到与destination键关联的链表的头部。如果source键不存在，该命令将返回nil，同时不再做任何其它的操作了。如果source和destination是同一个键，则相当于原子性的将其关联链表中的尾部元素移到该链表的头部。	</span><br><span class="line"></span><br><span class="line">返回值：返回弹出和插入的元素</span><br></pre></td></tr></table></figure>

<h2 id="hash类型常见操作"><a href="#hash类型常见操作" class="headerlink" title="hash类型常见操作"></a>hash类型常见操作</h2><p>Redis中的Hashes类型可以看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如用户信息：Username、Password和Age等。每一个Hash可以存储4294967295个键值对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">常见操作</span><br><span class="line">HSET key field value	 </span><br><span class="line"></span><br><span class="line">为指定的Key设定Field&#x2F;Value对，如果Key不存在，该命令将创建新Key以参数中的Field&#x2F;Value对，如果参数中的Field在该Key中已经存在，则用新值覆盖其原有值。</span><br><span class="line"></span><br><span class="line">返回值：1表示新的Field被设置了新值，0表示Field已经存在，用新值覆盖原有值。 </span><br><span class="line"></span><br><span class="line">HGET key field 	 </span><br><span class="line"></span><br><span class="line">返回指定Key中指定Field的关联值。	</span><br><span class="line"></span><br><span class="line">返回值：返回参数中Field的关联值，如果参数中的Key或Field不存，返回nil。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HSETNX key field value	 </span><br><span class="line"></span><br><span class="line">只有当参数中的Key或Field不存在的情况下，为指定的Key设定Field&#x2F;Value对，否则该命令不会进行任何操作。 </span><br><span class="line"></span><br><span class="line">返回值：1表示新的Field被设置了新值，0表示Key或Field已经存在，该命令没有进行任何操作。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HEXISTS key field 	 </span><br><span class="line"></span><br><span class="line">判断指定Key中的指定Field是否存在。	</span><br><span class="line"></span><br><span class="line">返回值：1表示存在，0表示参数中的Field或Key不存在。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HLEN key 	 </span><br><span class="line"></span><br><span class="line">获取该Key所包含的Field的数量。	返回Key包含的Field数量，如果Key不存在，返回0。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HDEL key field [field ...] 	 </span><br><span class="line"></span><br><span class="line">从指定Key的Hashes Value中删除参数中指定的多个字段，如果不存在的字段将被忽略。</span><br><span class="line"></span><br><span class="line">返回值：如果Key不存在，则将其视为空Hashes，并返回0，否则返回实际删除的Field数量。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HINCRBY key field increment 	 </span><br><span class="line"></span><br><span class="line">增加指定Key中指定Field关联的Value的值。如果Key或Field不存在，该命令将会创建一个新Key或新Field，并将其关联的Value初始化为0，之后再指定数字增加的操作。该命令支持的数字是64位有符号整型，即increment可以负数。返回值：运算后的值。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HGETALL key	 </span><br><span class="line"></span><br><span class="line">获取该键包含的所有Field&#x2F;Value。其返回格式为一个Field、一个Value，并以此类推。	</span><br><span class="line"></span><br><span class="line">返回值：Field&#x2F;Value的列表。</span><br><span class="line"></span><br><span class="line">HKEYS key 	 </span><br><span class="line"></span><br><span class="line">返回指定Key的所有Fields名。	</span><br><span class="line"></span><br><span class="line">返回值：Field的列表。</span><br><span class="line"></span><br><span class="line">HVALS key 	 </span><br><span class="line"></span><br><span class="line">返回指定Key的所有Values名。 </span><br><span class="line"></span><br><span class="line">返回值：Value的列表。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HMGET key field [field ...] 	 </span><br><span class="line"></span><br><span class="line">获取和参数中指定Fields关联的一组Values。如果请求的Field不存在，其值返回nil。如果Key不存在，该命令将其视为空Hash，因此返回一组nil。	</span><br><span class="line"></span><br><span class="line">返回值：返回和请求Fields关联的一组Values，其返回顺序等同于Fields的请求顺序。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HMSET key field value [field value ...]	 </span><br><span class="line"></span><br><span class="line">逐对依次设置参数中给出的Field&#x2F;Value对。如果其中某个Field已经存在，则用新值覆盖原有值。如果Key不存在，则创建新Key，同时设定参数中的Field&#x2F;Value</span><br></pre></td></tr></table></figure>

<h2 id="set类型常见操作（不重复，可以完成交并差操作）"><a href="#set类型常见操作（不重复，可以完成交并差操作）" class="headerlink" title="set类型常见操作（不重复，可以完成交并差操作）"></a>set类型常见操作（不重复，可以完成交并差操作）</h2><p>在Redis中，我们可以将Set类型看作为没有排序的字符串集合。Set可包含的最大元素数量是4294967295。</p>
<p>Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">常见操作</span><br><span class="line"></span><br><span class="line">SADD key member [member ...]	 </span><br><span class="line"></span><br><span class="line">如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。</span><br><span class="line"></span><br><span class="line">返回值：本次操作实际插入的成员数量。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SCARD key	 </span><br><span class="line"></span><br><span class="line">获取Set中成员的数量。	</span><br><span class="line"></span><br><span class="line">返回值：返回Set中成员的数量，如果该Key并不存在，返回0。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SISMEMBER key member	 </span><br><span class="line"></span><br><span class="line">判断参数中指定成员是否已经存在于与Key相关联的Set集合中。	</span><br><span class="line"></span><br><span class="line">返回值：1表示已经存在，0表示不存在，或该Key本身并不存在。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SMEMBERS key	 </span><br><span class="line"></span><br><span class="line">获取与该Key关联的Set中所有的成员。</span><br><span class="line"></span><br><span class="line">返回值：返回Set中所有的成员。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SPOP  key 	 </span><br><span class="line"></span><br><span class="line">随机的移除并返回Set中的某一成员。 由于Set中元素的布局不受外部控制，因此无法像List那样确定哪个元素位于Set的头部或者尾部。	</span><br><span class="line"></span><br><span class="line">返回值：返回移除的成员，如果该Key并不存在，则返回nil。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SRANDMEMBER key 	 </span><br><span class="line"></span><br><span class="line">和SPOP一样，随机的返回Set中的一个成员，不同的是该命令并不会删除返回的成员。	</span><br><span class="line"></span><br><span class="line">返回值：返回随机位置的成员，如果Key不存在则返回nil。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SREM key member [member ...]	 </span><br><span class="line"></span><br><span class="line">从与Key关联的Set中删除参数中指定的成员，不存在的参数成员将被忽略，如果该Key并不存在，将视为空Set处理。	</span><br><span class="line"></span><br><span class="line">返回值：从Set中实际移除的成员数量，如果没有则返回0。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SMOVE source destination member	 </span><br><span class="line"></span><br><span class="line">原子性的将参数中的成员从source键移入到destination键所关联的Set中。如果该成员在source中并不存在，该命令将不会再执行任何操作并返回0，否则，该成员将从source移入到destination。如果此时该成员已经在destination中存在，那么该命令仅是将该成员从source中移出。</span><br><span class="line"></span><br><span class="line">返回值：1表示正常移动，0表示source中并不包含参数成员。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SDIFF key [key ...]	 </span><br><span class="line"></span><br><span class="line">返回参数中第一个Key所关联的Set和其后所有Keys所关联的Sets中成员的差异。如果Key不存在，则视为空Set。	</span><br><span class="line"></span><br><span class="line">返回值：差异结果成员的集合。</span><br><span class="line"></span><br><span class="line">SDIFFSTORE destination key [key ...] 	 </span><br><span class="line"></span><br><span class="line">该命令和SDIFF命令在功能上完全相同，两者之间唯一的差别是SDIFF返回差异的结果成员，而该命令将差异成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。	</span><br><span class="line"></span><br><span class="line">返回值：返回差异成员的数量。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SINTER key [key ...] 	 </span><br><span class="line"></span><br><span class="line">该命令将返回参数中所有Keys关联的Sets中成员的交集。因此如果参数中任何一个Key关联的Set为空，或某一Key不存在，那么该命令的结果将为空集。</span><br><span class="line"></span><br><span class="line">返回值：交集结果成员的集合。</span><br><span class="line"></span><br><span class="line">SINTERSTORE destination key [key ...]	 </span><br><span class="line"></span><br><span class="line">该命令和SINTER命令在功能上完全相同，两者之间唯一的差别是SINTER返回交集的结果成员，而该命令将交集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。	</span><br><span class="line"></span><br><span class="line">返回值：返回交集成员的数量。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SUNION key [key ...] 	 </span><br><span class="line"></span><br><span class="line">该命令将返回参数中所有Keys关联的Sets中成员的并集。	</span><br><span class="line"></span><br><span class="line">返回值：并集结果成员的集合。</span><br><span class="line"></span><br><span class="line">SUNIONSTORE destination key [key ...] 	 </span><br><span class="line"></span><br><span class="line">该命令和SUNION命令在功能上完全相同，两者之间唯一的差别是SUNION返回并集的结果成员，而该命令将并集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。 </span><br><span class="line"></span><br><span class="line">返回值：返回并集成员的数量</span><br></pre></td></tr></table></figure>

<h2 id="sortedSet类型常见操作"><a href="#sortedSet类型常见操作" class="headerlink" title="sortedSet类型常见操作"></a>sortedSet类型常见操作</h2><p>Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的<strong>成员必须是唯一</strong>的，但是<strong>分数(score)却是可以重复</strong>的。</p>
<p>在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">常见操作</span><br><span class="line"></span><br><span class="line">ZADD key score member [score] [member] 	 </span><br><span class="line"></span><br><span class="line">添加参数中指定的所有成员及其分数到指定key的Sorted-Set中，在该命令中我们可以指定多组score&#x2F;member作为参数。如果在添加时参数中的某一成员已经存在，该命令将更新此成员的分数为新值，同时再将该成员基于新值重新排序。如果键不存在，该命令将为该键创建一个新的Sorted-Sets Value，并将score&#x2F;member对插入其中。</span><br><span class="line"></span><br><span class="line">返回值：本次操作实际插入的成员数量。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ZINCRBY key increment member 	 </span><br><span class="line"></span><br><span class="line">该命令将为指定Key中的指定成员增加指定的分数。如果成员不存在，该命令将添加该成员并假设其初始分数为0，此后再将其分数加上increment。如果Key不存，该命令将创建该Key及其关联的Sorted-Sets，并包含参数指定的成员，其分数为increment参数。</span><br><span class="line"></span><br><span class="line">返回值：以字符串形式表示的新分数。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ZCARD key 	 </span><br><span class="line"></span><br><span class="line">获取与该Key相关联的Sorted-Sets中包含的成员总数量。</span><br><span class="line"></span><br><span class="line">返回值：返回Sorted-Sets中的成员数量，如果该Key不存在，返回0。</span><br><span class="line"></span><br><span class="line">ZCOUNT key min max	 </span><br><span class="line"></span><br><span class="line">该命令用于获取***\*分数\*******\*(score)\****在min和max之间的成员数量。缺省情况下，min和max表示的范围是闭区间范围，即min &lt;&#x3D; score &lt;&#x3D; max内的成员将被返回。然而我们可以通过在min和max的前面添加&quot;(&quot;字符来表示开区间，如(min max表示min &lt; score &lt;&#x3D; max，而(min (max表示min &lt; score &lt; max。</span><br><span class="line"></span><br><span class="line">返回值：分数指定范围内成员的数量。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ZRANGE key start stop [WITHSCORES] 	 </span><br><span class="line"></span><br><span class="line">该命令返回***\*排名\****在参数start和stop指定范围内的成员，这里start和stop参数都是0-based，即0表示第一个成员，-1表示最后一个成员。如果start大于该Sorted-Set中的最大索引值，或start &gt; stop，此时一个空集合将被返回。如果stop大于最大索引值，该命令将返回从start到集合的最后一个成员。如果命令中带有可选参数WITHSCORES选项，该命令在返回的结果中将包含每个成员的分数值，如value1,score1,value2,score2...。　　	</span><br><span class="line"></span><br><span class="line">返回值：返回索引在start和stop之间的成员列表。</span><br><span class="line"></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]   </span><br><span class="line"></span><br><span class="line">该命令的功能和ZRANGE基本相同，唯一的差别在于顺序相反。	</span><br><span class="line"></span><br><span class="line">返回值：返回指定的成员列表。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 	 </span><br><span class="line"></span><br><span class="line">该命令将返回***\*分数\****在min和max范围内的成员，即满足表达式min &lt;&#x3D; score &lt;&#x3D; max的成员，其中返回的成员是按照其分数从低到高的顺序返回，如果成员具有相同的分数，则按成员的字典顺序返回。可选参数LIMIT用于限制返回成员的数量范围。可选参数offset表示从符合条件的第offset个成员开始返回，同时返回count个成员。</span><br><span class="line"></span><br><span class="line">返回值：返回分数在指定范围内的成员列表。</span><br><span class="line"></span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] 	 </span><br><span class="line"></span><br><span class="line">该命令除了排序方式是基于从高到低的分数排序之外，其它功能和参数含义均与ZRANGEBYSCORE相同。	</span><br><span class="line"></span><br><span class="line">返回值：返回分数在指定范围内的成员列表。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ZRANK key member 	 </span><br><span class="line"></span><br><span class="line">该命令将返回参数中指定***\*成员的位置值\****（按分数由低到高的顺序），其中0表示第一个成员，它是Sorted-Set中分数最低的成员。</span><br><span class="line"></span><br><span class="line">返回值：如果该成员存在，则返回它的位置索引值。否则返回nil。</span><br><span class="line"></span><br><span class="line">ZREVRANK key member 	 </span><br><span class="line"></span><br><span class="line">该命令的功能和ZRANK基本相同，唯一的差别在于顺序相反	</span><br><span class="line"></span><br><span class="line">返回值：如果该成员存在，则返回它的位置索引值。否则返回nil。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ZSCORE key member	 </span><br><span class="line"></span><br><span class="line">获取指定成员的分数。	</span><br><span class="line"></span><br><span class="line">返回值：如果该成员存在，以字符串的形式返回其分数，否则返回nil。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ZREM key member [member ...]	 </span><br><span class="line"></span><br><span class="line">该命令将移除参数中指定的成员，其中不存在的成员将被忽略。如果与该Key关联的Value不是Sorted-Set，相应的错误信息将被返回。</span><br><span class="line"></span><br><span class="line">返回值：实际被删除的成员数量。</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYRANK key start stop 	 </span><br><span class="line"></span><br><span class="line">删除索引位置位于start和stop之间的成员，start和stop都是0-based，即0表示分数最低的成员，-1表示最后一个成员，即分数最高的成员。 	</span><br><span class="line"></span><br><span class="line">返回值：被删除的成员数量。</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYSCORE key min max 	 </span><br><span class="line"></span><br><span class="line">删除分数在min和max之间的所有成员，即满足表达式min &lt;&#x3D; score &lt;&#x3D; max的所有成员。对于min和max参数，可以采用开区间的方式表示，具体规则参照ZCOUNT。 </span><br><span class="line"></span><br><span class="line">返回值：被删除的成员数量</span><br></pre></td></tr></table></figure>

<h2 id="Key通用操作"><a href="#Key通用操作" class="headerlink" title="Key通用操作"></a>Key通用操作</h2><p>l KEYS pattern     </p>
<p>获取所有匹配pattern参数（正则）的Keys。需要说明的是，在我们的正常操作中应该尽量避免对该命令的调用，因为对于大型数据库而言，该命令是非常耗时的，对Redis服务器的性能打击也是比较大的。pattern支持glob-style的通配符格式，如*表示任意一个或多个字符，?表示任意字符，[abc]表示方括号中任意一个字母。    匹配模式的键列表。</p>
<p>l DEL key [key …]     </p>
<p>从数据库删除中参数中指定的keys，如果指定键不存在，则直接忽略。还需要另行指出的是，如果指定的Key关联的数据类型不是String类型，而是List、Set、Hashes和Sorted Set等容器类型，该命令删除每个键的时间复杂度为O(M)，其中M表示容器中元素的数量。而对于String类型的Key，其时间复杂度为O(1)。</p>
<p>返回值：实际被删除的Key数量。</p>
<p>l EXISTS key      </p>
<p>判断指定键是否存在。    </p>
<p>返回值：1表示存在，0表示不存在。</p>
<p>l MOVE key db      </p>
<p>将当前数据库中指定的键Key移动到参数中指定的数据库中。如果该Key在目标数据库中已经存在，或者在当前数据库中并不存在，该命令将不做任何操作并返回0。     </p>
<p>返回值：移动成功返回1，否则0。</p>
<p>在redis.conf文件中定义了redis的默认库的数量</p>
<p><img src="/15.1.Redis/image-20210906144531362.png" alt="image-20210906144531362"></p>
<p>我们可以使用select 数值 来进行库的切换: select  10.</p>
<p>l RENAME key newkey      </p>
<p>为指定的键重新命名，如果参数中的两个Keys的名字相同，或者是源Key不存在，该命令都会返回相关的错误信息。如果newKey已经存在，则直接覆盖。  </p>
<p>l RENAMENX key newkey     </p>
<p>如果新值不存在，则将参数中的原值修改为新值。其它条件和RENAME一致。</p>
<p>返回值：1表示修改成功，否则0。</p>
<p>l PERSIST key     </p>
<p>如果Key存在过期时间，该命令会将其过期时间消除，使该Key不再有超时，而是可以持久化存储。    </p>
<p>返回值：1表示Key的过期时间被移除，0表示该Key不存在或没有过期时间。</p>
<p>l EXPIRE key seconds      </p>
<p>该命令为参数中指定的Key设定超时的秒数，在超过该时间后，Key被自动的删除。如果该Key在超时之前被修改，与该键关联的超时将被移除。 </p>
<p>返回值：1表示超时被设置，0则表示Key不存在，或不能被设置。</p>
<p>l EXPIREAT key timestamp  </p>
<p>该命令的逻辑功能和EXPIRE完全相同，唯一的差别是该命令指定的超时时间是绝对时间，而不是相对时间。该时间参数是Unix timestamp格式的，即从1970年1月1日开始所流经的秒数。    </p>
<p>返回值：1表示超时被设置，0则表示Key不存在，或不能被设置。 </p>
<p>l TTL key      </p>
<p>获取该键所剩的超时描述。 </p>
<p>返回值：返回所剩描述，如果该键不存在或没有超时设置，则返回-1。</p>
<p>l RANDOMKEY     </p>
<p>从当前打开的数据库中随机的返回一个Key。    </p>
<p>返回值：返回的随机键，如果该数据库是空的则返回nil。</p>
<p>l TYPE key      </p>
<p>获取与参数中指定键关联值的类型，该命令将以字符串的格式返回。    </p>
<p>返回值：返回的字符串为string、list、set、hash和zset，如果key不存在返回none</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<p>l 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>l 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<p>开始事务。MULTI</p>
<p>命令入队。执行的redis的操作</p>
<p>执行事务。EXEC</p>
<p>事务常用命令</p>
<p>l MULTI</p>
<p>Redis Multi 命令用于标记一个事务块的开始。</p>
<p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p>
<p>返回值:总是返回OK</p>
<p>l EXEC</p>
<p>Redis Exec 命令用于执行所有事务块内的命令</p>
<p>返回值: 事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</p>
<p>l DISCARD</p>
<p>Redis Discard 命令用于取消事务，放弃执行事务块内的所有命令。</p>
<p>返回值: 总是返回 OK 。</p>
<p>l WATCH</p>
<p>Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</p>
<p>l UNWATCH</p>
<p>Redis Unwatch 命令用于取消 WATCH 命令对所有 key 的监视</p>
<p>在exec执行后所产生的错误中，即使事务中有某个/某些命令在执行时产生了错误，事务中的其他命令仍然会继续执行。Redis在<strong>事务失败时不进行回滚</strong>，而是继续执行余下的命令。</p>
<p>Redis的这种设计原则是：Redis命令只会因为错误的语法而失败(这些问题不能在入队时发现)，或是命令用在了错误类型的键上面</p>
<p>失败的命令不是Redis所致，而是由编程错误造成的，这样错误应该在开发的过程中被发现，生产环境中不应出现的错误。</p>
<p>就是在程序的运行环境中不应该出现语法的错误。而Redis能够保证正确的命令一定会被执行</p>
<p>实际做法：</p>
<p>（1）确认实际需求是否需要事务支持，如果需要则在对应方法上加上@Transaction注解</p>
<p>（2）如果不需要事务支持则将enableTransactionSupport设置为false</p>
<p>大佬推荐：</p>
<p>在 Spring 里配置两个单独的 RedisTemplate 是很好的做法：其中一个 RedisTemplates 的事务设为 false，用于大多数 Redis 操作，另一个 RedisTemplates 的事务已激活，仅用于 Redis 事务。当然必须要声明 PlatformTransactionManager 和 @Transactional，以防返回垃圾数值</p>
<h1 id="nodejs应用redis"><a href="#nodejs应用redis" class="headerlink" title="nodejs应用redis"></a>nodejs应用redis</h1><p>1.安装 redis 依赖包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redis --save</span><br></pre></td></tr></table></figure>

<p>2.连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var redis &#x3D; require(&#39;redis&#39;),</span><br><span class="line">    config &#x3D; require(&#39;..&#x2F;config&#39;),</span><br><span class="line">    dbConfig &#x3D; config.redis,</span><br><span class="line">    RDS_PORT &#x3D; dbConfig.port,     &#x2F;&#x2F;端口号</span><br><span class="line">    RDS_HOST &#x3D; dbConfig.host,     &#x2F;&#x2F;服务器IP</span><br><span class="line">    RDS_PWD &#x3D; dbConfig.pass,      &#x2F;&#x2F;密码</span><br><span class="line">    RDS_OPTS &#x3D; &#123;auth_pass: RDS_PWD&#125;,</span><br><span class="line">    client &#x3D; redis.createClient(RDS_PORT, RDS_HOST, RDS_OPTS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client.on(&#39;ready&#39;,function(res)&#123;</span><br><span class="line">    console.log(&#39;ready&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(&#39;end&#39;,function(err)&#123;</span><br><span class="line">    console.log(&#39;end&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(&#39;error&#39;, function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(&#39;connect&#39;,function()&#123;</span><br><span class="line">    console.log(&#39;redis connect success!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>3.使用</p>
<ul>
<li>字符串（string）（一个字符串类型的值最大长度为512 M） get,set,mget,mset,incr(计数器++),decr(–)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client.set(&#39;name&#39;, &#39;swx&#39;, function (err, res) &#123;</span><br><span class="line">    &#x2F;&#x2F; todo..</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.get(&#39;name&#39;, function (err, res) &#123;</span><br><span class="line">    &#x2F;&#x2F; todo...           </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>哈希（hash） 可用来存储对象,一个Redis 列表中最多可存储232-1(40亿)个元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">client.hmset(&quot;hosts&quot;, &quot;mjr&quot;, &quot;1&quot;, &quot;another&quot;, &quot;23&quot;, &quot;home&quot;, &quot;1234&quot;);</span><br><span class="line"></span><br><span class="line">client.hgetall(&quot;hosts&quot;, function (err, obj) &#123;</span><br><span class="line">    console.dir(obj);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.hmset(key2, &#123;</span><br><span class="line">    &quot;0123456789&quot;: &quot;abcdefghij&quot;, &#x2F;&#x2F; NOTE: key and value will be coerced to strings </span><br><span class="line">    &quot;some manner of key&quot;: &quot;a type of value&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>列表（lists）（一个Redis 列表中最多可存储232-1(40亿)个元素）</li>
</ul>
<p>对于lists,使用send_command进行操作;</p>
<p>队列操作</p>
<p>lpush(首位添加),rpush(末位添加),lset(修改首位值),lindex(删除首位元素),lpop(删除末位元素)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">client.send_command(&#39;lset&#39;,[&#39;mylist&#39;,0,1], function(err,data) &#123;</span><br><span class="line">    console.log(data);          &#x2F;&#x2F; OK</span><br><span class="line">&#125;)</span><br><span class="line">client.send_command(&#39;lpush&#39;,[&#39;mylist&#39;, &#39;one&#39;], function(err, data) &#123;</span><br><span class="line">    console.log(dada);          &#x2F;&#x2F;OK </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用命令行获取对应的索引下的结果</span><br><span class="line">&#x2F;&#x2F; lindex mylist 0    &#39;one&#39;</span><br><span class="line">&#x2F;&#x2F; lindex mylist 1   &#39;1&#39;</span><br><span class="line">&#x2F;&#x2F; lindex mylist 2   &#39;xxx&#39;</span><br><span class="line">&#x2F;&#x2F; lindex mylist 3   &#39;xxx&#39;</span><br></pre></td></tr></table></figure>

<p>集合（sets）</p>
<p>sets 集合处理; 业务中用lodash进行交并补也是一个不错的选择。</p>
<p>常见操作: sadd、smembers、sinter(交)、sunion(并)、sdiff(补)、smove</p>
<p>集合中不允许重复成员的存在。当多次添加一个元素时，其结果会设置单个成员多次。一个Redis 集合中最多可包含232-1(40亿)个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let db1 &#x3D; [&#39;mysql&#39;,&#39;redis&#39;];</span><br><span class="line">let db2 &#x3D; [&#39;mongo&#39;,&#39;redis&#39;];</span><br><span class="line">client.sadd(&#39;db1&#39;,db1, function(err,data) &#123;</span><br><span class="line">    client.smembers(&#39;db1&#39;, function(err,data) &#123;</span><br><span class="line">        console.log(toString.call(data));               &#x2F;&#x2F; [object Array]</span><br><span class="line">        console.log(&#39;smemers:&#39; + data);                 &#x2F;&#x2F; 获取set中的成员, [&#39;redis,mysql]  </span><br><span class="line">    &#125;)</span><br><span class="line">    client.sadd(&#39;db2&#39;, db2, function(err, data) &#123;</span><br><span class="line">        client.sinter(&#39;db1&#39;,&#39;db2&#39;, function(err,data) &#123;</span><br><span class="line">            console.log(&#39;sinter:&#39; + data)                    &#x2F;&#x2F;交集: sinter:redis</span><br><span class="line">        &#125;);</span><br><span class="line">        client.sunion(&#39;db1&#39;,&#39;db2&#39;, function(err,data) &#123;</span><br><span class="line">            console.log(&#39;sunion:&#39; + data)                    &#x2F;&#x2F; 并集: sunion:mongo,mysql,redis</span><br><span class="line">        &#125;);</span><br><span class="line">        client.sdiff(&#39;db1&#39;,&#39;db2&#39;, function(err,data) &#123;</span><br><span class="line">            console.log(&#39;SDIFF:&#39; + data)                     &#x2F;&#x2F; 补集: SDIFF:mysql</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>有序集合(SortedSets)  zadd(设置元素), zrange(获取范围内的元素),zrank(获取指定元素的排名，从0开始), zscore(获取指定元素的score，用户指定的score)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">client.zadd(table, score, id, function (err, res) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;删除单个</span><br><span class="line">client.zrem(table, id, function (err, res) &#123;</span><br><span class="line"></span><br><span class="line">));</span><br><span class="line">	&#x2F;&#x2F; 删除多个</span><br><span class="line">client.zrem(table, arr, function (err, res) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">	&#x2F;&#x2F; 从大到小 查询    </span><br><span class="line">client.zrevrange(table, 0, -1, function (err, res) &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>事务(multi命令): 批量执行所有的命令，并统一返回结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client.multi()</span><br><span class="line">    .set(&#39;xiao&#39;,&#39;xing&#39;)</span><br><span class="line">    .get(&#39;xiao&#39;)</span><br><span class="line">    .exec(function(err,replies) &#123;</span><br><span class="line">        console.log(replies);         &#x2F;&#x2F; [ &#39;OK&#39;, &#39;xing&#39; ]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>订阅发布模式</li>
</ul>
<p>redis的订阅发布模式可用来做类似kafka的消息推送;</p>
<p>使用list + redis的订阅发布模式可以构建一个不错的消息队列;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let sub &#x3D; redis.createClient(6379, &#39;127.0.0.1&#39;);   &#x2F;&#x2F; 监听消费者</span><br><span class="line">let pub &#x3D; redis.createClient(6379, &#39;127.0.0.1&#39;);   &#x2F;&#x2F; 生产者</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在sub开始监听时允许触发subscribe事件进行操作,类似连接数据库的connect事件</span><br><span class="line">sub.on(&#39;subscribe&#39;, function(channel, count) &#123;</span><br><span class="line">    console.log(&#96;$&#123;channel&#125;:$&#123;count&#125;&#96;);               &#x2F;&#x2F;  test channel:1</span><br><span class="line">    pub.publish(&#39;test channel&#39;, &#39;channel message test&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">sub.on(&#39;message&#39;, function(channel, message) &#123;</span><br><span class="line">    console.log(&#96;$&#123;channel&#125;-message:$&#123;JSON.stringify(message)&#125;&#96;)    &#x2F;&#x2F; test channel-message:&quot;channel message test&quot;</span><br><span class="line">&#125;)</span><br><span class="line">sub.subscribe(&#39;test channel&#39;);</span><br></pre></td></tr></table></figure>

<ul>
<li>对整个redis的所有客户端操作进行监听 （monitor事件可以监听到redis收到的所有客户端命令）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client.monitor(function(err, res) &#123;</span><br><span class="line">    console.log(res);   &#x2F;&#x2F; ok</span><br><span class="line">&#125;)</span><br><span class="line">client.on(&quot;monitor&quot;, function (time, args) &#123;</span><br><span class="line">    console.log(time + &quot;: &quot; + util.inspect(args));             &#x2F;&#x2F; 1556285641.395573: [ &#39;lindex&#39;, &#39;myset&#39;, &#39;2&#39; ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h1 id="java客户端jedis"><a href="#java客户端jedis" class="headerlink" title="java客户端jedis"></a>java客户端jedis</h1><p>Jedis介绍与快速入门</p>
<p>通过java来操作redis：使用jedis</p>
<p><img src="/15.1.Redis/image-20210906144617185.png" alt="image-20210906144617185"></p>
<p>搭建jedis环境：</p>
<p>新建一个javaproject，复制jar包到lib下，右键addpath构建路径</p>
<p><img src="/15.1.Redis/image-20210906144629940.png" alt="image-20210906144629940"></p>
<p>编写代码</p>
<p><img src="/15.1.Redis/image-20210906144646383.png" alt="image-20210906144646383"></p>
<p>程序执行报错：</p>
<p><img src="/15.1.Redis/image-20210906144705822.png" alt="image-20210906144705822"></p>
<p>原因:</p>
<p>1.redis服务器是否开启：linux上加载redis-server和redis.conf查看开启</p>
<p>2.linux的防火墙是否关闭：service iptables stop  关了之后在重启redis服务器</p>
<p>3.在redis.conf配置文件中 bind 127.0.0.1 代表的是外部不可以访问redis（可以把它注释掉，前面加#）</p>
<p>通过以上操作，错误信息不一样了：</p>
<p><img src="/15.1.Redis/image-20210906144737833.png" alt="image-20210906144737833"></p>
<p>原因：是我们没有设置密码</p>
<p>我们需要在redis.conf文件中设置密码admin：查找到requirepass，将前面的#删掉，然后将后面的改为admin，：wq保存退出</p>
<p><img src="/15.1.Redis/image-20210906144756360.png" alt="image-20210906144756360"></p>
<p><img src="/15.1.Redis/image-20210906144805631.png" alt="image-20210906144805631"></p>
<p>有密码的情况下，在命令行下连接redis需加上-a：</p>
<p><img src="/15.1.Redis/image-20210906144817763.png" alt="image-20210906144817763"></p>
<p>string类型常见操作</p>
<p>//string操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo2 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示 set get</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.set(“username”, “tom”);        </p>
<p>​        String value = jedis.get(“username”);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示mset mget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        jedis.mset(“password”,”123”,”age”,”20”);</p>
<p>​        </p>
<p>​        List<String> values = jedis.mget(“username”,”password”,”age”);</p>
<p>​        </p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示 append  setrange getrange</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        //jedis.append(“username”,” is boy”);</p>
<p>​        </p>
<p>​        //jedis.setrange(“username”, 7,”girl”);</p>
<p>​        System.****<em>out*</em>***.println(jedis.get(“username”));</p>
<p>​        </p>
<p>​        </p>
<p>​        System.****<em>out*</em>***.println(jedis.getrange(“username”, 7, -1));</p>
<p>​    }</p>
<p>}</p>
<p>list类型常见操作：</p>
<p>//list操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo3 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示lpush lrange</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.lpush(“names”, “tom”, “james”, “张三”, “李四”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>​    // lset</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        // jedis.lset(“names”, 1, “王五”);</p>
<p>​        // List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        // System.out.println(names);</p>
<p>​        String value = jedis.lindex(“names”, 1);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    // linsert</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3() {</p>
<p>​        jedis.linsert(“names”, LIST_POSITION.****<em>BEFORE*</em>***, “james”, “fox”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>​    </p>
<p>​    // lrem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.lrem(“names”, 1, “tom”);</p>
<p>​        List<String> names = jedis.lrange(“names”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(names);</p>
<p>​    }</p>
<p>}</p>
<p>hash类型常见操作</p>
<p>//hash操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo4 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示hset hget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        jedis.hset(“user”, “username”, “tom”);</p>
<p>​        String value = jedis.hget(“user”, “username”);</p>
<p>​        System.****<em>out*</em>***.println(value);</p>
<p>​    }</p>
<p>​    // 演示hmset hmget</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        Map&lt;String, String&gt; hash = <em><strong>*new*</strong></em> HashMap&lt;String, String&gt;();</p>
<p>​        hash.put(“password”, “123”);</p>
<p>​        hash.put(“sex”, “male”);</p>
<p>​        jedis.hmset(“user”, hash);</p>
<p>​        List<String> values = jedis.hmget(“user”, “username”, “password”, “sex”);</p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示 hgetall hkeys kvals</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        Map&lt;String, String&gt; map = jedis.hgetAll(“user”);</p>
<p>​        <em><strong>*for*</strong></em>(String key:map.keySet()){</p>
<p>​            System.****<em>out*</em>***.println(key+”  “+map.get(key));</p>
<p>​        }</p>
<p>​        </p>
<p>​        Set<String> keys = jedis.hkeys(“user”);</p>
<p>​        System.****<em>out*</em>***.println(keys);</p>
<p>​        </p>
<p>​        List<String> values = jedis.hvals(“user”);</p>
<p>​        System.****<em>out*</em>***.println(values);</p>
<p>​    }</p>
<p>​    </p>
<p>//    演示hdel</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.hdel(“user”, “username”,”password”);</p>
<p>​        Map&lt;String, String&gt; map = jedis.hgetAll(“user”);</p>
<p>​        <em><strong>*for*</strong></em>(String key:map.keySet()){</p>
<p>​            System.****<em>out*</em>***.println(key+”  “+map.get(key));</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>set类型常见操作</p>
<p>//set操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo5 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);        </p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示sadd smembers</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        </p>
<p>​        Set<String> smembers = jedis.smembers(“language1”);</p>
<p>​        System.****<em>out*</em>***.println(smembers);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //演示srem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        jedis.srem(“language1”, “java”);</p>
<p>​        Set<String> smembers = jedis.smembers(“language1”);</p>
<p>​        System.****<em>out*</em>***.println(smembers);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //差集 sdiff</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        </p>
<p>​        Set<String> sdiff = jedis.sdiff(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sdiff);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //交集</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        Set<String> sinter = jedis.sinter(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sinter);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //并集</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test5(){</p>
<p>​        jedis.sadd(“language1”,”java”,”c++”,”ruby”,”python”);</p>
<p>​        jedis.sadd(“language2”,”ios”,”c++”,”c#”,”android”);</p>
<p>​        Set<String> sunion = jedis.sunion(“language1”,”language2”);</p>
<p>​        System.****<em>out*</em>***.println(sunion);</p>
<p>​    }</p>
<p>​    </p>
<p>}</p>
<p>sortedSet类型常见操作</p>
<p>//sortedset操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo6 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // 演示zadd zrange zrangeByScore</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Set<String> set = jedis.zrange(“zkey”, 0, -1);</p>
<p>​        System.****<em>out*</em>***.println(set);</p>
<p>​        // 根据分数获取</p>
<p>​        Set<String> set1 = jedis.zrangeByScore(“zkey”, 70.0, 90.0);</p>
<p>​        System.****<em>out*</em>***.println(set1);</p>
<p>​    }</p>
<p>​    // 获取分数元素 zrangeWithScores</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Set<Tuple> zws = jedis.zrangeWithScores(“zkey”, 0, -1);</p>
<p>​        <em><strong>*for*</strong></em> (Tuple t : zws) {</p>
<p>​            System.****<em>out*</em>***.println(t.getScore() + “  “ + t.getElement());</p>
<p>​        }</p>
<p>​    }</p>
<p>​    // zrank</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Long num = jedis.zrank(“zkey”, “赵六”);</p>
<p>​        System.****<em>out*</em>***.println(num);</p>
<p>​    }</p>
<p>​    // zscore</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test4() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        Double zscore = jedis.zscore(“zkey”, “张三”);</p>
<p>​        System.****<em>out*</em>***.println(zscore);</p>
<p>​    }</p>
<p>​    // zrem</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test5() {</p>
<p>​        Map&lt;String, Double&gt; sm = <em><strong>*new*</strong></em> HashMap&lt;String, Double&gt;();</p>
<p>​        sm.put(“张三”, 70.0);</p>
<p>​        sm.put(“李四”, 80.0);</p>
<p>​        sm.put(“王五”, 90.0);</p>
<p>​        sm.put(“赵六”, 60.0);</p>
<p>​        jedis.zadd(“zkey”, sm);</p>
<p>​        jedis.zrem(“zkey”, “李四”);</p>
<p>​        </p>
<p>​        Set<Tuple> zws = jedis.zrangeWithScores(“zkey”, 0, -1);</p>
<p>​        <em><strong>*for*</strong></em> (Tuple t : zws) {</p>
<p>​            System.****<em>out*</em>***.println(t.getScore() + “  “ + t.getElement());</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>key的常见操作</p>
<p>//key的通用操作</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JedisDemo7 {</p>
<p>​    Jedis jedis;</p>
<p>​    @Before</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> createJedis() {</p>
<p>​        jedis = <em><strong>*new*</strong></em> Jedis(“192.168.19.128”);</p>
<p>​        // 设置密码</p>
<p>​        jedis.auth(“admin”);</p>
<p>​    }</p>
<p>​    // keys patten</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test1(){</p>
<p>​        Set<String> keys = jedis.keys(“*”);</p>
<p>​        System.****<em>out*</em>***.println(keys);</p>
<p>​    }</p>
<p>​    </p>
<p>​    // del key</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test2(){</p>
<p>​        Long del = jedis.del(“user”);</p>
<p>​        System.****<em>out*</em>***.println(del);</p>
<p>​    }</p>
<p>​    </p>
<p>​    //关于key时间设置</p>
<p>​    @Test</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> test3(){</p>
<p>​        //jedis.expire(“username”, 200); //设置生命周期为200秒</p>
<p>​        jedis.persist(“username”);</p>
<p>​        Long ttl = jedis.ttl(“username”); //获取生命周期值</p>
<p>​        System.****<em>out*</em>***.println(ttl);</p>
<p>​        </p>
<p>​    }</p>
<p>}</p>
<h1 id="Redis数据持久化"><a href="#Redis数据持久化" class="headerlink" title="Redis数据持久化"></a>Redis数据持久化</h1><p>Redis将内存存储和持久化存储相结合，既可提供数据访问的高效性，又可保证数据存储的安全性</p>
<p>1.Redis数据持久化机制介绍</p>
<p>1). RDB持久化：该机制是指在指定的时间间隔内将<strong>内存中的数据集快照</strong>写入磁盘。  </p>
<p>2). AOF(append only file)持久化:该机制将以<strong>日志的形式记录服务器所处理的每一个写操作</strong>，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</p>
<p>3). 同时应用AOF和RDB。 </p>
<p>4). 无持久化：可通过配置的方式禁用Redis服务器的持久化功能，这样我们就可以将Redis视为一个功能加强版的memcached了</p>
<p>2.Redis数据持久化配置与测试</p>
<p>l RDB快照方式:缺省情况下，Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开redis.conf文件之后，我们搜索save，可以看到下面的配置信息：</p>
<p>Ø save 900 1        </p>
<p>#在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。</p>
<p>Ø save 300 10       </p>
<p>#在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。</p>
<p>Ø save 60 10000     </p>
<p>#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</p>
<p>注意:关于dump.rdb文件存储的位置：它的设置是在redis.conf文件中dir ./</p>
<p>dir ./这段配置指的是服务器启动时的当前路径（在哪启动服务器时，这个rdb文件就在哪创建）。</p>
<p>l AOF日志文件方式：</p>
<p>Ø AOF日志持久化机制的开启：需要手动设置，在redis.conf文件中</p>
<p>将appendonly  no  改为 appendonly  yes</p>
<p>Ø AOF同步方式的配置：</p>
<p>在Redis的配置文件中存在三种同步方式，它们分别是：</p>
<p>appendfsync  always   #每次有数据修改发生时都会写入AOF文件。</p>
<p>appendfsync  everysec  #每秒钟同步一次，该策略为AOF的缺省策略。</p>
<p>appendfsync  no      #从不同步。高效但是数据不会被持久化。</p>
<p>3.RDB与AOF对比总结</p>
<p>l RDB存在哪些优势呢？</p>
<p>1). 数据的备份和恢复非常方便，因为一个数据库只有一个持久化文件</p>
<p>2). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p>
<p>3). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
<p>l RDB又存在哪些劣势呢？</p>
<p>1).系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
<p>2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p>l AOF的优势有哪些呢？</p>
<p>1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3种同步策略，即每秒同步、每修改同步和不同步。</p>
<p>2).对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。</p>
<p>3). 如果日志过大，Redis可以自动启用rewrite机制迅速“瘦身”(也可手动触发aof的rewrite操作，命令： bgrewriteaof)</p>
<p>4). AOF日志格式清晰、易于理解，很容易用AOF日志文件完成数据的重建。  </p>
<p>l AOF的劣势有哪些呢？</p>
<p>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。</p>
<p>2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>
<h1 id="Redis数据的备份"><a href="#Redis数据的备份" class="headerlink" title="Redis数据的备份"></a>Redis数据的备份</h1><h3 id="RDB方式-默认"><a href="#RDB方式-默认" class="headerlink" title="RDB方式(默认)"></a>RDB方式(默认)</h3><p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间和改动的键的个数。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。RDB是Redis默认采用的持久化方式，在配置文件中已经预置了3个条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1    # 900秒内有至少1个键被更改则进行快照</span><br><span class="line">save 300 10   # 300秒内有至少10个键被更改则进行快照</span><br><span class="line">save 60 10000  # 60秒内有至少10000个键被更改则进行快照</span><br></pre></td></tr></table></figure>

<p>可以存在多个条件，条件之间是“或”的关系，只要满足其中一个条件，就会进行快照。 如果想要禁用自动快照，只需要将所有的save参数删除即可。</p>
<p>Redis默认会将快照文件存储在当前目录(可CONFIG GET dir来查看)的dump.rdb文件中，可以通过配置dir和dbfilename两个参数分别指定快照文件的存储路径和文件名。</p>
<p>Redis实现快照的过程</p>
<ul>
<li>Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；</li>
<li>父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；</li>
<li>当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。</li>
</ul>
<p>在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。</p>
<p>Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实现Redis数据库备份。RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。</p>
<p>除了自动快照，还可以手动发送SAVE或BGSAVE命令让Redis执行快照，两个命令的区别在于，前者是由主进程进 行快照操作，会阻塞住其他请求，后者会通过fork子进程进行快照操作。Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串 类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。</p>
<h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p>默认情况下Redis没有开启AOF(append only file)方式的持久化，可以在redis.conf中通过appendonly参数开启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较RDB会慢一些,开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure>

<p>配置redis自动重写AOF文件的条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  # 当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据</span><br><span class="line">auto-aof-rewrite-min-size 64mb   # 允许重写的最小AOF文件大小</span><br></pre></td></tr></table></figure>

<p>配置写入AOF文件后，要求系统刷新硬盘缓存的机制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># appendfsync always   # 每次执行写入都会执行同步，最安全也最慢</span><br><span class="line">appendfsync everysec   # 每秒执行一次同步操作</span><br><span class="line"># appendfsync no       # 不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），最快也最不安全</span><br></pre></td></tr></table></figure>

<p>Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据。但是由于数据是存储在一台服务器上的，如果这台服务器的硬盘出现故障，也会导致数据丢失。为了避免单点故障，我们希望将数据库复制多个副本以部署在不同的服务器上，即使有一台服务器出现故障其他服务器依然可以继续提供服务。这就要求当一台服务器上的数据库更新后，可以自动将更新的数据同步到其他服务器上，Redis提供了复制（replication）功能可以自动 实现同步的过程。</p>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>Redis主从结构支持一主多从</p>
<p>主节点：192.168.100.200</p>
<p>从节点：192.168.100.150</p>
<p>注意：所有从节点的配置都一样</p>
<p><strong>方式1：手动修改配置文件</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">slaveof 192.168.100.200 6379 #指定master的ip和端口</span><br><span class="line"></span><br><span class="line"># If the master is password protected (using the &quot;requirepass&quot; configuration</span><br><span class="line"># directive below) it is possible to tell the slave to authenticate before</span><br><span class="line"># starting the replication synchronization process, otherwise the master will</span><br><span class="line"># refuse the slave request.</span><br><span class="line">#</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line">masterauth 123456 #这是主机的密码</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**方式2：动态设置**</span><br></pre></td></tr></table></figure>

<p>通过redis-cli 连接到从节点服务器，执行下面命令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; slaveof 192.168.100.200 6379 </span><br></pre></td></tr></table></figure>

<p>注：slaveof no one 可以使当前数据库停止接收其他数据库的同步，转成主数据库</p>
<h3 id="优点及应用场景"><a href="#优点及应用场景" class="headerlink" title="优点及应用场景"></a>优点及应用场景</h3><p>读写分离通过复制可以实现读写分离以提高服务器的负载能力。在常见的场景中，读的频率大于写，当单机的Redis无法应付大量的读请求时（尤其是较耗资源的请求，比如SORT命令等）可以通过复制功能建立多个从数据库，主数据库只进行写操作，而从数据库负责读操作。</p>
<p>从数据库持久化持久化通常相对比较耗时，为了提高性能，可以通过复制功能建立一个（或若干个）从数据库，并在从数据库中启用持久化，同时在主数据库禁用持久化。当从数据库崩溃时重启后主数据库会自动将数据同步过来，所以无需担心数据丢失。而当主数据库崩溃时，需要在从数据库中使用SLAVEOF NO ONE命令将从数据库提升成主数据库继续服务，并在原来的主数据库启动后使用SLAVEOF命令将其设置成新的主数据库的从数据库，即可将数据同步回来。</p>
<h1 id="springboot项目里使用Redis做缓存"><a href="#springboot项目里使用Redis做缓存" class="headerlink" title="springboot项目里使用Redis做缓存"></a>springboot项目里使用Redis做缓存</h1><h2 id="Spring-Cache-操作Redis"><a href="#Spring-Cache-操作Redis" class="headerlink" title="Spring Cache 操作Redis"></a>Spring Cache 操作Redis</h2><p>当Spring Boot 结合Redis来作为缓存使用时，最简单的方式就是使用Spring Cache了，使用它我们无需知道Spring中对Redis的各种操作，仅仅通过它提供的@Cacheable 、@CachePut 、@CacheEvict 、@EnableCaching等注解就可以实现缓存功能。</p>
<h3 id="EnableCaching"><a href="#EnableCaching" class="headerlink" title="@EnableCaching"></a>@EnableCaching</h3><p>开启缓存功能，一般放在启动类上。</p>
<h3 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h3><p>使用该注解的方法当缓存存在时，会从缓存中获取数据而不执行方法，当缓存不存在时，会执行方法并把返回结果存入缓存中。<strong>一般使用在查询方法上</strong>，可以设置如下属性：</p>
<ul>
<li>value：缓存名称（必填），指定缓存的命名空间；</li>
<li>key：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；</li>
<li>unless：条件符合则不缓存；</li>
<li>condition：条件符合则缓存。</li>
</ul>
<h3 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h3><p>使用该注解的方法每次执行时都会把返回结果存入缓存中。<strong>一般使用在新增方法上</strong>，可以设置如下属性：</p>
<ul>
<li>value：缓存名称（必填），指定缓存的命名空间；</li>
<li>key：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；</li>
<li>unless：条件符合则不缓存；</li>
<li>condition：条件符合则缓存。</li>
</ul>
<h3 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h3><p>使用该注解的方法执行时会清空指定的缓存。<strong>一般使用在更新或删除方法上</strong>，可以设置如下属性：</p>
<ul>
<li>value：缓存名称（必填），指定缓存的命名空间；</li>
<li>key：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；</li>
<li>condition：条件符合则缓存。</li>
</ul>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul>
<li>在pom.xml中添加项目依赖：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件application.yml，添加Redis的连接配置；</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.139</span> <span class="comment"># Redis服务器地址</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment"># Redis服务器连接端口</span></span><br><span class="line">    <span class="attr">password:</span> <span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">1000ms</span> <span class="comment"># 连接超时时间</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在启动类上添加@EnableCaching注解启动缓存功能；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallTinyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MallTinyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来在PmsBrandServiceImpl类中使用相关注解来实现缓存功能，可以发现我们获取品牌详情的方法中使用了@Cacheable注解，在修改和删除品牌的方法上使用了@CacheEvict注解；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PmsBrandService实现类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2019/4/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PmsBrandServiceImpl</span> <span class="keyword">implements</span> <span class="title">PmsBrandService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PmsBrandMapper brandMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Long id, PmsBrand brand)</span> </span>&#123;</span><br><span class="line">        brand.setId(id);</span><br><span class="line">        <span class="keyword">return</span> brandMapper.updateByPrimaryKeySelective(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brandMapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;, unless = &quot;#result==null&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PmsBrand <span class="title">getItem</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brandMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以调用获取品牌详情的接口测试下效果，此时发现Redis中存储的数据有点像乱码，并且没有设置过期时间；</li>
</ul>
<p><img src="/15.1.Redis/v2-746b4b4a1e45bb5e0bb9f25818e9b04c_720w.jpg" alt="img"></p>
<h4 id="存储JSON格式数据"><a href="#存储JSON格式数据" class="headerlink" title="存储JSON格式数据"></a>存储JSON格式数据</h4><blockquote>
<p>此时我们就会想到有没有什么办法让Redis中存储的数据变成标准的JSON格式，然后可以设置一定的过期时间，不设置过期时间容易产生很多不必要的缓存数据。</p>
</blockquote>
<ul>
<li>我们可以通过给RedisTemplate设置JSON格式的序列化器，并通过配置RedisCacheConfiguration设置超时时间来实现以上需求，此时别忘了去除启动类上的@EnableCaching注解，具体配置类RedisConfig代码如下；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis配置类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/3/2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis数据库自定义key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_KEY_DATABASE=<span class="string">&quot;mall&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;Object&gt; serializer = redisSerializer();</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(serializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(serializer);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">redisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建JSON序列化器</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(objectMapper);</span><br><span class="line">        <span class="keyword">return</span> serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">redisCacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//设置Redis缓存有效期为1天</span></span><br><span class="line">        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer())).entryTtl(Duration.ofDays(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCacheManager(redisCacheWriter, redisCacheConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此时我们再次调用获取商品详情的接口进行测试，会发现Redis中已经缓存了标准的JSON格式数据，并且超时时间被设置为了1天。</li>
</ul>
<p><img src="/15.1.Redis/v2-238e48f3a03e90c7387e3707826a3dad_720w.jpg" alt="img"></p>
<h2 id="使用Redis连接池"><a href="#使用Redis连接池" class="headerlink" title="使用Redis连接池"></a>使用Redis连接池</h2><blockquote>
<p>SpringBoot 1.5.x版本Redis客户端默认是Jedis实现的，SpringBoot 2.x版本中默认客户端是用Lettuce实现的，我们先来了解下Jedis和Lettuce客户端。</p>
</blockquote>
<h3 id="Jedis-vs-Lettuce"><a href="#Jedis-vs-Lettuce" class="headerlink" title="Jedis vs Lettuce"></a>Jedis vs Lettuce</h3><p>Jedis在实现上是直连Redis服务，多线程环境下非线程安全，除非使用连接池，为每个 RedisConnection 实例增加物理连接。</p>
<p>Lettuce是一种可伸缩，线程安全，完全非阻塞的Redis客户端，多个线程可以共享一个RedisConnection，它利用Netty NIO框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序。</p>
<h3 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul>
<li>修改application.yml添加Lettuce连接池配置，用于配置线程数量和阻塞等待时间；</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#redis数据库索引，默认为0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 连接池最大连接数 默认为8，使用负值表示没有限制</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 连接池最大空闲连接数 默认8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 连接池最小空闲连接数 默认0  为了保证一直处于连接状态，我们设置为了1</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span> <span class="comment"># 连接池最大阻塞等待时间，负值表示没有限制 默认-1</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">6000</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span>  <span class="comment">#服务器地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span>  <span class="comment">#连接端口</span></span><br><span class="line">    <span class="attr">password:</span>   <span class="comment">#连接密码，默认为空</span></span><br></pre></td></tr></table></figure>

<ul>
<li>jedis的pom文件依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Lettuce的pom文件依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>如果你没添加以上依赖的话，启动应用的时候就会产生如下错误；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: org/apache/commons/pool2/impl/GenericObjectPoolConfig</span><br><span class="line">    at org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration<span class="variable">$LettucePoolingClientConfigurationBuilder</span>.&lt;init&gt;(LettucePoolingClientConfiguration.java:84) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">    at org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration.builder(LettucePoolingClientConfiguration.java:48) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]</span><br><span class="line">    at org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration<span class="variable">$PoolBuilderFactory</span>.createBuilder(LettuceConnectionConfiguration.java:149) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]</span><br><span class="line">    at org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.createBuilder(LettuceConnectionConfiguration.java:107) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]</span><br><span class="line">    at org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.getLettuceClientConfiguration(LettuceConnectionConfiguration.java:93) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]</span><br><span class="line">    at org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.redisConnectionFactory(LettuceConnectionConfiguration.java:74) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]</span><br><span class="line">    at org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$<span class="variable">$5caa7e47</span>.CGLIB$redisConnectionFactory<span class="variable">$0</span>(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]</span><br><span class="line">    at org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47$$FastClassBySpringCGLIB$<span class="variable">$b8ae2813</span>.invoke(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]</span><br><span class="line">    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE]</span><br><span class="line">    at org.springframework.context.annotation.ConfigurationClassEnhancer<span class="variable">$BeanMethodInterceptor</span>.intercept(ConfigurationClassEnhancer.java:363) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]</span><br><span class="line">    at org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$<span class="variable">$5caa7e47</span>.redisConnectionFactory(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]</span><br><span class="line">    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]</span><br><span class="line">    ... 111 common frames omitted</span><br></pre></td></tr></table></figure>

<h2 id="自由操作Redis"><a href="#自由操作Redis" class="headerlink" title="自由操作Redis"></a>自由操作Redis</h2><blockquote>
<p>Spring Cache 给我们提供了操作Redis缓存的便捷方法，但是也有很多局限性。比如说我们想单独设置一个缓存值的有效期怎么办？我们并不想缓存方法的返回值，我们想缓存方法中产生的中间值怎么办？此时我们就需要用到RedisTemplate这个类了，接下来我们来讲下如何通过RedisTemplate来自由操作Redis中的缓存。</p>
</blockquote>
<p>默认情况下RedisTemplate模板只能支持字符串，我们自定义一个RedisTemplate，设置序列化器，这样我们可以很方便的操作实例对象。将RedisTemplate模板的设置放在RedisConfig类中</p>
<p>RedisTemplate默认为我们实现了几种操作数据类型的方法：</p>
<p><img src="/15.1.Redis/a2cc7cd98d1001e966f1ceae81048fe955e79756.jpeg" alt="img"></p>
<p>也可以自己定义：</p>
<h3 id="RedisService"><a href="#RedisService" class="headerlink" title="RedisService"></a>RedisService</h3><blockquote>
<p>定义Redis操作业务类，在Redis中有几种数据结构，比如普通结构（对象），Hash结构、Set结构、List结构，该接口中定义了大多数常用操作方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis操作Service</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/3/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">del</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">del</span><span class="params">(List&lt;String&gt; keys)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">getExpire</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有该属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">hasKey</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按delta递增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按delta递减</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Hash结构中的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">hGet</span><span class="params">(String key, String hashKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向Hash结构中放入一个属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">hSet</span><span class="params">(String key, String hashKey, Object value, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向Hash结构中放入一个属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hSet</span><span class="params">(String key, String hashKey, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接获取整个Hash结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Map&lt;Object, Object&gt; <span class="title">hGetAll</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接设置整个Hash结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">hSetAll</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接设置整个Hash结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hSetAll</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除Hash结构中的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hDel</span><span class="params">(String key, Object... hashKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断Hash结构中是否有该属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">hHasKey</span><span class="params">(String key, String hashKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash结构中属性递增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">hIncr</span><span class="params">(String key, String hashKey, Long delta)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash结构中属性递减</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">hDecr</span><span class="params">(String key, String hashKey, Long delta)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Set结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;Object&gt; <span class="title">sMembers</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向Set结构中添加属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">sAdd</span><span class="params">(String key, Object... values)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向Set结构中添加属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">sAdd</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为Set中的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">sIsMember</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Set结构的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">sSize</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除Set结构中的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">sRemove</span><span class="params">(String key, Object... values)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取List结构中的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Object&gt; <span class="title">lRange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取List结构的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">lSize</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引获取List中的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">lIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向List结构中添加属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">lPush</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向List结构中添加属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">lPush</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向List结构中批量添加属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">lPushAll</span><span class="params">(String key, Object... values)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向List结构中批量添加属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">lPushAll</span><span class="params">(String key, Long time, Object... values)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从List结构中移除属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RedisServiceImpl"><a href="#RedisServiceImpl" class="headerlink" title="RedisServiceImpl"></a>RedisServiceImpl</h3><blockquote>
<p>RedisService的实现类，使用RedisTemplate来自由操作Redis中的缓存数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis操作实现类</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/3/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisServiceImpl</span> <span class="keyword">implements</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">del</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">del</span><span class="params">(List&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hGet</span><span class="params">(String key, String hashKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, hashKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">hSet</span><span class="params">(String key, String hashKey, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, hashKey, value);</span><br><span class="line">        <span class="keyword">return</span> expire(key, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hSet</span><span class="params">(String key, String hashKey, Object value)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hGetAll</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">hSetAll</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">        <span class="keyword">return</span> expire(key, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hSetAll</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hDel</span><span class="params">(String key, Object... hashKey)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, hashKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">hHasKey</span><span class="params">(String key, String hashKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, hashKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">hIncr</span><span class="params">(String key, String hashKey, Long delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, hashKey, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">hDecr</span><span class="params">(String key, String hashKey, Long delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, hashKey, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sMembers</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">sAdd</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">sAdd</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        expire(key, time);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">sIsMember</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">sSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">sRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lRange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">lSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">lPush</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">lPush</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        Long index = redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">        expire(key, time);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">lPushAll</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPushAll(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">lPushAll</span><span class="params">(String key, Long time, Object... values)</span> </span>&#123;</span><br><span class="line">        Long count = redisTemplate.opsForList().rightPushAll(key, values);</span><br><span class="line">        expire(key, time);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RedisController"><a href="#RedisController" class="headerlink" title="RedisController"></a>RedisController</h3><blockquote>
<p>测试RedisService中缓存操作的Controller，大家可以调用测试下。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis测试Controller</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/3/3.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;RedisController&quot;, description = &quot;Redis测试&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PmsBrandService brandService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;测试简单缓存&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/simpleTest&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;PmsBrand&gt; <span class="title">simpleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;PmsBrand&gt; brandList = brandService.list(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        PmsBrand brand = brandList.get(<span class="number">0</span>);</span><br><span class="line">        String key = <span class="string">&quot;redis:simple:&quot;</span> + brand.getId();</span><br><span class="line">        redisService.set(key, brand);</span><br><span class="line">        PmsBrand cacheBrand = (PmsBrand) redisService.get(key);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(cacheBrand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;测试Hash结构的缓存&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hashTest&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;PmsBrand&gt; <span class="title">hashTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;PmsBrand&gt; brandList = brandService.list(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        PmsBrand brand = brandList.get(<span class="number">0</span>);</span><br><span class="line">        String key = <span class="string">&quot;redis:hash:&quot;</span> + brand.getId();</span><br><span class="line">        Map&lt;String, Object&gt; value = BeanUtil.beanToMap(brand);</span><br><span class="line">        redisService.hSetAll(key, value);</span><br><span class="line">        Map&lt;Object, Object&gt; cacheValue = redisService.hGetAll(key);</span><br><span class="line">        PmsBrand cacheBrand = BeanUtil.mapToBean(cacheValue, PmsBrand.class, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(cacheBrand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;测试Set结构的缓存&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/setTest&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Set&lt;Object&gt;&gt; setTest() &#123;</span><br><span class="line">        List&lt;PmsBrand&gt; brandList = brandService.list(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        String key = <span class="string">&quot;redis:set:all&quot;</span>;</span><br><span class="line">        redisService.sAdd(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));</span><br><span class="line">        redisService.sRemove(key, brandList.get(<span class="number">0</span>));</span><br><span class="line">        Set&lt;Object&gt; cachedBrandList = redisService.sMembers(key);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(cachedBrandList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;测试List结构的缓存&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/listTest&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;List&lt;Object&gt;&gt; listTest() &#123;</span><br><span class="line">        List&lt;PmsBrand&gt; brandList = brandService.list(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        String key = <span class="string">&quot;redis:list:all&quot;</span>;</span><br><span class="line">        redisService.lPushAll(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));</span><br><span class="line">        redisService.lRemove(key, <span class="number">1</span>, brandList.get(<span class="number">0</span>));</span><br><span class="line">        List&lt;Object&gt; cachedBrandList = redisService.lRange(key, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(cachedBrandList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="jedis实现缓存的实际操作："><a href="#jedis实现缓存的实际操作：" class="headerlink" title="jedis实现缓存的实际操作："></a>jedis实现缓存的实际操作：</h1><p>jedis的maven依赖（不用lettuce，因为会出现一直连接超时的情况）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;io.lettuce&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;lettuce-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>redis的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">@EnableCaching</span><br><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template &#x3D; new RedisTemplate&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F; 配置连接工厂</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        &#x2F;&#x2F;使用StringRedisSerializer来序列化和反序列化redis的key值</span><br><span class="line">        template.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        &#x2F;&#x2F; 值采用json序列化</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer());</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Primary注解指定默认缓存管理器</span><br><span class="line">     *</span><br><span class="line">     * @param template</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public CacheManager cacheManager(RedisTemplate&lt;String, Object&gt; template) &#123;</span><br><span class="line">        &#x2F;&#x2F; 基本配置</span><br><span class="line">        RedisCacheConfiguration defaultCacheConfiguration &#x3D; RedisCacheConfiguration</span><br><span class="line">                .defaultCacheConfig()</span><br><span class="line">                &#x2F;&#x2F; 设置key为String</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(template.getStringSerializer()))</span><br><span class="line">                &#x2F;&#x2F;设置value为json格式（重写了jackson2JsonRedisSerializer的配置）</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer()))</span><br><span class="line">                &#x2F;&#x2F; 不缓存null</span><br><span class="line">                .disableCachingNullValues()</span><br><span class="line">                &#x2F;&#x2F; 缓存数据保存1周</span><br><span class="line">                .entryTtl(Duration.ofDays(7));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 一个redis缓存管理器</span><br><span class="line">        RedisCacheManager redisCacheManager &#x3D;</span><br><span class="line">                RedisCacheManager.RedisCacheManagerBuilder</span><br><span class="line">                        &#x2F;&#x2F; Redis 连接工厂</span><br><span class="line">                        .fromConnectionFactory(template.getConnectionFactory())</span><br><span class="line">                        &#x2F;&#x2F; 缓存配置</span><br><span class="line">                        .cacheDefaults(defaultCacheConfiguration)</span><br><span class="line">                        &#x2F;&#x2F; 配置同步修改或删除 put&#x2F;evict</span><br><span class="line">                        .transactionAware()</span><br><span class="line">                        .build();</span><br><span class="line">        return redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager logisticsCacheManager(RedisTemplate&lt;String, Object&gt; template) &#123;</span><br><span class="line">        &#x2F;&#x2F; 基本配置</span><br><span class="line">        RedisCacheConfiguration defaultCacheConfiguration &#x3D; RedisCacheConfiguration</span><br><span class="line">                .defaultCacheConfig()</span><br><span class="line">                &#x2F;&#x2F; 设置key为String</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(template.getStringSerializer()))</span><br><span class="line">                &#x2F;&#x2F;设置value为json格式（重写了jackson2JsonRedisSerializer的配置）</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer()))</span><br><span class="line">                &#x2F;&#x2F; 不缓存null</span><br><span class="line">                .disableCachingNullValues()</span><br><span class="line">                &#x2F;&#x2F; 物流数据保存30天</span><br><span class="line">                .entryTtl(Duration.ofDays(30));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 一个redis缓存管理器</span><br><span class="line">        RedisCacheManager redisCacheManager &#x3D;</span><br><span class="line">                RedisCacheManager.RedisCacheManagerBuilder</span><br><span class="line">                        &#x2F;&#x2F; Redis 连接工厂</span><br><span class="line">                        .fromConnectionFactory(template.getConnectionFactory())</span><br><span class="line">                        &#x2F;&#x2F; 缓存配置</span><br><span class="line">                        .cacheDefaults(defaultCacheConfiguration)</span><br><span class="line">                        &#x2F;&#x2F; 配置同步修改或删除 put&#x2F;evict</span><br><span class="line">                        .transactionAware()</span><br><span class="line">                        .build();</span><br><span class="line">        return redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer() &#123;</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer &#x3D;</span><br><span class="line">                new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.configure(MapperFeature.USE_ANNOTATIONS, false);</span><br><span class="line">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</span><br><span class="line">        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);</span><br><span class="line">        &#x2F;&#x2F; 此项必须配置，否则会报java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to XXX</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        return jackson2JsonRedisSerializer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">  jedis:</span><br><span class="line">    pool:</span><br><span class="line">      #最大连接数, 不超过Redis实例的最大连接数(redis默认10000)</span><br><span class="line">      max-active: 18</span><br><span class="line">      max-wait: -1</span><br><span class="line">      max-idle: 8</span><br><span class="line">      min-idle: 1</span><br><span class="line">  timeout: 6000</span><br><span class="line">  host: 192.168.0.1</span><br><span class="line">  port: 6379</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">设置redis的缓存：</span><br><span class="line">@Cacheable(value &#x3D; &#123;&quot;userDTO&quot;&#125;, key &#x3D; &quot;#openid&quot;, sync &#x3D; true)</span><br><span class="line">public UserDTO getUserByOpenid(String openid) throws UserNotExistException &#123;</span><br><span class="line">	UserDTO userDTO &#x3D; userMapper.getUserByOpenid(openid);</span><br><span class="line">	System.out.println(userDTO);</span><br><span class="line">	if (null &#x3D;&#x3D; userDTO) &#123;</span><br><span class="line">		throw new UserNotExistException();</span><br><span class="line">	&#125;</span><br><span class="line">	return userDTO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Cacheable(value &#x3D; &#123;&quot;logistics&quot;&#125;, key &#x3D; &quot;#expressNo&quot;, cacheManager &#x3D; &quot;logisticsCacheManager&quot;, sync &#x3D; true)</span><br><span class="line"></span><br><span class="line">更改redis缓存：</span><br><span class="line">1.用注解会直接删掉缓存，下次还需要再查</span><br><span class="line">@CacheEvict(value &#x3D; &#123;&quot;userDTO&quot;&#125;, key &#x3D; &quot;#nodeRequestDTO.openid&quot;, condition &#x3D; &quot;#nodeRequestDTO.helmetColor &#x3D;&#x3D; &#39;yellow&#39;&quot;)</span><br><span class="line">@CacheEvict(value &#x3D; &#123;&quot;userDTO&quot;&#125;, key &#x3D; &quot;#companyReviewDTO.openid&quot;, condition &#x3D; &quot;#companyReviewDTO.reviewStatus &#x3D;&#x3D; &#39;2&#39;&quot;)</span><br><span class="line">2.自己写一个updateCacheInfo方法</span><br><span class="line">private void updateCacheInfo(UserDTO userDTO) &#123;</span><br><span class="line">	RedisCacheManager rcm &#x3D; (RedisCacheManager) cacheManager;</span><br><span class="line">	Cache cache &#x3D; rcm.getCache(&quot;userDTO&quot;);</span><br><span class="line">	cache.put(userDTO.getOpenid(), userDTO);</span><br><span class="line">&#125;</span><br><span class="line">在程序里将userDTO设置再更新</span><br><span class="line">userDTO.setRole(user.getRole());</span><br><span class="line">this.updateCacheInfo(userDTO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@CacheEvict(value &#x3D; &#123;&quot;userDTO&quot;&#125;, key &#x3D; &quot;#userDTO.openid&quot;)</span><br><span class="line">改为：（直接删除了缓存）</span><br><span class="line">RedisCacheManager rcm &#x3D; (RedisCacheManager) cacheManager;</span><br><span class="line">Cache cache &#x3D; rcm.getCache(&quot;userDTO&quot;);</span><br><span class="line">cache.evict(user.getOpenid());</span><br></pre></td></tr></table></figure>

<p>个人理解：CacheManager和RedisTemplate都可以操纵redis的数据，规定key和value的存入和读取格式。（CacheManager更像是装饰后的对象，RedisTemplate更像是底层的对象）</p>
<p>设置缓存：CacheManager可以在配置类里设置多个，然后在注解里指定cacheManager。 也可以直接用redisService.set直接存入redis</p>
<p>更改缓存：可以利用注解更改。也可以用配置类定义好的CacheManager，从种获取到key并更改，删除。也可以直接用redisService操作</p>
<p>指定key和value的格式：</p>
<p>JdkSerializationRedisSerializer：当需要存储java对象时使用.</p>
<p>StringRedisSerializer：当需要存储string类型的字符串时使用.</p>
<p>JacksonJsonRedisSerializer：将对象序列化成json的格式存储在redis中,需要jackson-json工具的支持</p>
<p>opsForXXX和boundXXXOps的区别：</p>
<p>前者获取到一个Opercation,但是没有指定操作的key,可以在一个连接(事务)内操作多个key以及对应的value;</p>
<p>后者会获取到一个指定了key的operation,在一个连接内只操作这个key对应的value.</p>
<h1 id="关于redis中缓存的问题"><a href="#关于redis中缓存的问题" class="headerlink" title="关于redis中缓存的问题"></a>关于redis中缓存的问题</h1><h2 id="当数据库数据需要更改，怎么操作缓存"><a href="#当数据库数据需要更改，怎么操作缓存" class="headerlink" title="当数据库数据需要更改，怎么操作缓存"></a>当数据库数据需要更改，怎么操作缓存</h2><p>以下四种更新策略通过中途失败和多线程两种情况进行考虑：</p>
<h3 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="1.先更新数据库，再更新缓存"></a>1.先更新数据库，再更新缓存</h3><p>读到旧数据：数据库更新成功，缓存更新失败，会读取到旧的缓存数据</p>
<p>读到错误数据：多线程情况下，线程A比B先进来，A更新完数据库卡住了，线程B此时顺利执行完，A又活过来才去更新缓存，就会出现读到的缓存是A的缓存不是B的缓存，导致读到错误数据（特别是写操作远大于读操作的项目场景）</p>
<h3 id="2-先更新缓存，再更新数据库"><a href="#2-先更新缓存，再更新数据库" class="headerlink" title="2.先更新缓存，再更新数据库"></a>2.先更新缓存，再更新数据库</h3><p>读到错误数据：缓存更新成功，数据库更新失败，就会读取到错误的缓存数据</p>
<p>数据库更新不成功，缓存的数据应该也是不可以成功的</p>
<p>读到错误数据：多线程情况下，类似于1（也是特别是写操作远大于读操作的项目场景）</p>
<p><strong>读多写少的场景，上面2种方式也勉强还行</strong></p>
<h3 id="3-先删除缓存，再更新数据库"><a href="#3-先删除缓存，再更新数据库" class="headerlink" title="3.先删除缓存，再更新数据库"></a>3.先删除缓存，再更新数据库</h3><p>如果删除缓存成功，但是更新数据库不成功，情况正常</p>
<p>读到错误数据：多线程情况下，A删除缓存后，停住了，B读数据库，设置缓存，A才去更新数据库，导致数据库和缓存不一致，导致读到错误数据（<strong>特别是读操作远大于写操作的项目场景</strong>）</p>
<h3 id="4-先更新数据库，再删除缓存"><a href="#4-先更新数据库，再删除缓存" class="headerlink" title="4.先更新数据库，再删除缓存"></a>4.先更新数据库，再删除缓存</h3><p>读到错误数据：更新数据库成功，删除缓存失败，导致读到错误数据</p>
<p>读到错误数据：多线程情况下，A更新数据库，也删除缓存。B去读发现没有缓存，读到了数据，准备写的时候卡住了，C来更新数据库+删除缓存后，B活过来了，把读到的A数据存入到缓存，导致读到错误数据</p>
<p>对于3：也叫延时双删除策略，<strong>可以先删除缓存 ，再更新数据库，延时后再删除缓存</strong>，就是补一刀把后续的脏缓存数据删掉，这么具体的延时时间是多少，就得根据具体项目业务时间去衡量了</p>
<p>对于4：也叫Cache-Aside pattern，读操作实际上肯定比写操作快得多，所以发生上边描述的出现脏数据的场景的概率也是比较小</p>
<p>总结：</p>
<p>并发稍微低，那么我们可以用   先删除缓存，再更新数据库  再配上延时双删除策略</p>
<p>并发稍微高，那么我们可以用 Cache-Aside pattern ，  先更新数据库 ，再删除缓存 。</p>
<p>脏数据 在不适用 分布式锁 或者 其他能保证数据顺序的方法的情况下，都是存在的。只不过是出现这种脏数据的概率以及严重性，是否是项目的业务需求可以接收。</p>
<p>上面存在的问题，都是有额外的补救方法，如加锁，重试，消息队列等等</p>
<p>1、想要提高应用的性能，可以引入「缓存」来解决</p>
<p>2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」</p>
<p>3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生</p>
<p>4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案</p>
<p>5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性</p>
<p>6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率</p>
<h1 id="缓存的名称"><a href="#缓存的名称" class="headerlink" title="缓存的名称"></a>缓存的名称</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大</p>
<p>解决方案：</p>
<p>1.接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；<br>2.从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁</li>
</ol>
<p><img src="/15.1.Redis/20180919143214879" alt="img"></p>
<pre><code>      1）缓存中有数据，直接走上述代码13行后就返回结果了

     2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。

      3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点
</code></pre>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同高的缓存数据库中。</li>
<li>设置热点数据永远不过期</li>
</ol>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>对于基本不会变的数据，为什么不选择redis存储而是要使用mysql呢？</p>
<p>答：为了应对复杂的业务逻辑，可能一个表会涉及到多个相关联的字段，需要在查询一个表的数据时候，将其他关系表的数据查询出来。而redis只能存kv值，无法应对复杂的业务场景，即使Redis的读取效率再高，我们也没法用。但对于某些没有关联少，且需要高频率读写的数据，就可以使用（比如秒杀活动，可以在redis中高速读写，当达到一定阈值之后，再更新到mysql的数据库来实现短时间内的高并发场景）。redis只能作为一个辅助工具（可以当数据库，也可以当缓存工具）存储来提高性能。</p>
<p>什么时候使用redis？</p>
<p>答：当数据多、并发量大的时候，架构中可以引入Redis，帮助提升架构的整体性能，减少Mysql(或其他数据库)的压力</p>
<p>因为Redis的性能十分优越，可以支持每秒十几万此的读/写操作，并且它还支持持久化、集群部署、分布式、主从同步等，Redis在高并发的场景下数据的安全和一致性，所以它经常用于两个场景：</p>
<p>1.缓存</p>
<p>经常会被查询，但是不经常被修改或者删除的数据；比如数据字典，业务数据中的热点数据；这样不仅提升查询效率，还可以减少数据库的压力；</p>
<p>经常被查询，实时性要求不高数据，比如网站的最新列表、排行榜之类的数据，只需要定时统计一次，然后把统计结果放到Redis中提供查询（请不要使用select top 10 from xxxx）。</p>
<p>缓存可以方便数据共享，比如我先用电脑网页打开X东，选了两件商品放到购物车里面，再登录手机APP，也是可以看到购物车里面的商品的。</p>
<p>判断数据是否适合缓存到Redis中，可以从几个方面考虑：会经常查询么？命中率如何？写操作多么？数据大小？</p>
<p>我们经常采用这样的方式将数据刷到Redis中：查询的请求过来，现在Redis中查询，如果查询不到，就查询数据库拿到数据，再放到缓存中，这样第二次相同的查询请求过来，就可以直接在Redis中拿到数据；不过要注意【缓存穿透】的问题。</p>
<p>缓存的刷新会比较复杂，通常是修改完数据库之后，还需要对Redis中的数据进行操作；代码很简单，但是需要保证这两步为同一事务，或最终的事务一致性</p>
<p>2.高速读写</p>
<p>常见的就是计数器，比如一篇文章的阅读量，不可能每一次阅读就在数据库里面update一次。</p>
<p>高并发的场景很适合使用Redis，比如双11秒杀，库存一共就一千件，到了秒杀的时间，通常会在极为短暂的时间内，有数万级的请求达到服务器，如果使用数据库的话，很可能在这一瞬间造成数据库的崩溃，所以通常会使用Redis（秒杀的场景会比较复杂，Redis只是其中之一，例如如果请求超过某个数量的时候，多余的请求就会被限流）。</p>
<p>这种高并发的场景，是当请求达到服务器的时候，直接在Redis上读写，请求不会访问到数据库；程序会在合适的时间，比如一千件库存都被秒杀，再将数据批量写到数据库中。</p>
<p>所以通常来说，在必要的时候引入Redis，可以减少MySQL（或其他）数据库的压力，两者不是替代的关系</p>
<h1 id="redis实现延迟队列"><a href="#redis实现延迟队列" class="headerlink" title="redis实现延迟队列"></a>redis实现延迟队列</h1><p>（在电商项目里有具体的实现方式）</p>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul>
<li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消。</li>
<li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单。</li>
<li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单。</li>
<li>收快递的时候，如果我们没有点确认收货，在一段时间后程序会自动完成订单。</li>
<li>在平台完成订单后，如果我们没有在规定时间评论商品，会自动默认买家不评论</li>
</ul>
<p>这类场景都可以用定时任务去轮询实现，但是当数据量过大的时候，高频轮询数据库会消耗大量的资源，此时用延迟队列来应对这类场景比较好。</p>
<p>需求功能：</p>
<ul>
<li>消息存储</li>
<li>过期延时消息实时获取</li>
<li>高可用性</li>
</ul>
<h3 id="消息延迟原理："><a href="#消息延迟原理：" class="headerlink" title="消息延迟原理："></a>消息延迟原理：</h3><p><img src="/15.1.Redis/1323607-20200702061910379-1864468139.png" alt="img"></p>
<p> 当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理，如果需要就放入到延时队列中，由延时任务检测器进行检测和处理，对于不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户</p>
<p><img src="/15.1.Redis/1323607-20200702055737295-275210721.png" alt="img"></p>
<p> 对于在延时任务检测器内部的话，有查询延迟任务和执行延时任务两个职能，任务检测器会先去延时任务队列进行队列中信息读取，判断当前队列中哪些任务已经时间到期并将已经到期的任务输出执行（设置一个定时任务）</p>
<p>在redis中，我们可以使用 zset（sortedset）这个命令，用设置好的时间戳作为score进行排序，使用 zadd score1 value1 ….命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。也可以通过 zrangebyscore key min max withscores limit 0 1 查询最早的一条任务，来进行消费。</p>
<p><img src="/15.1.Redis/1323607-20200702083502806-654371890.png" alt="img"></p>
<p>（1）使用zrangebyscore来查询当前延时队列中所有任务，找出所有需要进行处理的延时任务，在依次进行操作。</p>
<p>（2）查找当前最早的一条任务，通过score值来判断任务执行的时候是否大于了当前系统的时候，比如说：最早的任务执行时间在3点，系统时间在2点58分，表示这个应该需要立马被执行。</p>
<h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><p>1.Redis zset支持高性能的 score 排序。<br>2.Redis是在内存上进行操作的，速度非常快。<br>3.Redis可以搭建集群，当消息很多时候，我们可以用集群来提高消息处理的速度，提高可用性。<br>4.Redis具有持久化机制，当出现故障的时候，可以通过AOF和RDB方式来对数据进行恢复，保证了数据的可靠性</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>队列最重要的就是保证消息被成功消费，所以需要Redis 实现 ACK</p>
<ul>
<li>需要在业务代码中处理消息失败的情况，回滚消息到原始等待队列。</li>
<li>Consumer 挂掉，仍然需要回滚消息到等待队列中。</li>
</ul>
<h3 id="其他实现延时队列的方法"><a href="#其他实现延时队列的方法" class="headerlink" title="其他实现延时队列的方法"></a>其他实现延时队列的方法</h3><h4 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h4><p>（1）通过 RabbitMQ 来实现延时队列</p>
<p>优点：消息持久化，分布式</p>
<p>缺点：延时相同的消息必须扔在同一个队列，每一种延时就需要建立一个队列。因为当后面的消息比前面的消息先过期，还是只能等待前面的消息过期，这里的过期检测是惰性的。</p>
<p>使用: </p>
<p>​    方法一：RabbitMQ 可以针对 Queue 设置 x-expires 或者针对 Message 设置 x-message-ttl ，来控制消息的生存时间（可以根据 Queue 来设置，也可以根据 message 设置）。</p>
<p>​    方法二：Queue 还可以配置 x-dead-letter-exchange 和 x-dead-letter-routing-key（可选）两个参数，如果队列内出现了 dead letter ，则按照这两个参数重新路由转发到指定的队列，此时就可以实现延时队列了。（我们可以用RabbitMQ的插件rabbitmq-delayed-message-exchange插件来实现延时队列。达到可投递时间时并将其通过 x-delayed-type 类型标记的交换机类型投递至目标队列。）</p>
<p><img src="/15.1.Redis/1323607-20200702083119402-1566927058.png" alt="img"></p>
<p>（2）RocketMQ实现延时队列</p>
<p>rocketmq在发送延时消息时，是先把消息按照延迟时间段发送到指定的队列中（把延时时间段相同的消息放到同一个队列中，保证了消息处理的顺序性，可以让同一个队列中消息延时时间是相同的，整个RocketMQ中延时消息时按照递增顺序排序，保证信息处理的先后顺序性。）。之后，通过一个定时器来轮询处理这些队列里的信息，判断是否到期。对于到期的消息会发送到相应的处理队列中，进行处理。</p>
<p>注意 ：目前RocketMQ只支持特定的延时时间段，1s,5s,10s,…2h，不能支持任意时间段的延时设置。</p>
<h3 id="Kafka实现延时队"><a href="#Kafka实现延时队" class="headerlink" title="Kafka实现延时队"></a>Kafka实现延时队</h3><p>Kafka基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer），Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，可以进行相关的延时队列设置。</p>
<p><img src="/15.1.Redis/1323607-20200702161757716-63017960.png" alt="img"></p>
<h3 id="Netty实现延时队列"><a href="#Netty实现延时队列" class="headerlink" title="Netty实现延时队列"></a>Netty实现延时队列</h3><p>Netty也有基于时间轮算法来实现延时队列。Netty在构建延时队列主要用HashedWheelTimer，HashedWheelTimer底层数据结构是使用DelayedQueue，采用时间轮的算法来实现。</p>
<p><img src="/15.1.Redis/1323607-20200702090136855-2087712548.png" alt="img"></p>
<h3 id="DelayQueue来实现延时队列"><a href="#DelayQueue来实现延时队列" class="headerlink" title="DelayQueue来实现延时队列"></a>DelayQueue来实现延时队列</h3><p>优点：无界、延迟、阻塞队列</p>
<p>缺点：非持久化</p>
<p>介绍：JDK 自带的延时队列，没有过期元素的话，使用 poll() 方法会返回 null 值，超时判定是通过getDelay(TimeUnit.NANOSECONDS) 方法的返回值小于等于0来判断，并且不能存放空元素。</p>
<p>使用：getDelay 方法定义了剩余到期时间，compareTo 方法定义了元素排序规则。poll() 是非阻塞的获取数据，take() 是阻塞形式获取数据。实现 Delayed 接口即可使用延时队列。</p>
<p>注意：DelayQueue 实现了 Iterator 接口，但 iterator() 遍历顺序不保证是元素的实际存放顺序。</p>
<p>Java中有自带的DelayQueue数据类型，我们可以用这个来实现延时队列。DelayQueue是封装了一个PriorityQueue（优先队列），在向DelayQueue队列中添加元素时，会给元素一个Delay（延迟时间）作为排序条件，队列中最小的元素会优先放在队首，对于队列中的元素只有到了Delay时间才允许从队列中取出。这种实现方式是数据保存在内存中，可能面临数据丢失的情况，同时它是无法支持分布式系统的。</p>
<p><img src="/15.1.Redis/1323607-20200702081155517-145733708.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Delayed 定义延时队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long time;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scala-的-Await-amp-Future-（非java）"><a href="#Scala-的-Await-amp-Future-（非java）" class="headerlink" title="Scala 的 Await &amp; Future （非java）"></a>Scala 的 Await &amp; Future （非java）</h3><p>优点：消息实时性</p>
<p>缺点：非持久化</p>
<p>介绍：Scala 的 ExecutionContext 中使用Await 的 result(awaitable: Awaitable[T], atMost: Duration)方法可以根据传入的 atMost 间隔时间异步执行 awaitable。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/15.1.Redis/" data-id="ckw61se07007foswdg85eh878" data-title="Redis" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.7.内部类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:50:38.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/">内部类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>内部类：把类定义在其他类的内部，这个类就被称为内部类。</p>
<p>内部类访问特点：</p>
<p>内部类可以直接访问外部类的成员，包括私有。</p>
<p>外部类要访问内部类的成员，必须创建对象。</p>
<p>内部类的位置：</p>
<p>成员位置：成员内部类</p>
<p>成员内部类是非静态的访问方式：</p>
<p>外部类名.内部类名  对象名 = new  外部类名.new 内部类名()；</p>
<p>eg：Outer.Inner  oi = new Outer().new Inner();</p>
<p>常见修饰符：</p>
<p>1.一般内部类是不让外界直接访问的，所以用private，保证了数据的安全性。</p>
<p>2.static为了让数据访问更方便。内部类用静态修饰是因为内部类可以看作是外部类的成员。（所以static可以修饰内部类，不能修饰类）</p>
<p>被静态修饰的成员内部类只能访问外部类的静态成员（静态只能访问静态）</p>
<p>成员内部类被静态修饰后，是不能被对象访问的，只能被类访问。它下面的方法可以是静态可以是非静态。</p>
<p>成员内部类是静态的访问方式：</p>
<p> 外部类名.内部类名  对象名=new 外部类名.内部类名();</p>
<p>eg：Outer.Inner oi = new Outer.Inner();</p>
<p>oi.静态方法();   oi.非静态方法();</p>
<p>静态内部类的静态方法还可以用：Outer.Inner.静态方法名();</p>
<p>局部位置：局部内部类</p>
<p>可以直接访问外部类的成员</p>
<p>在局部位置可以创建内部类对象，通过对象调用内部类方法来使用局部内部类的功能</p>
<p>局部内部类访问局部变量的注意事项：</p>
<p>局部内部类访问的局部变量必须用final修饰。（因为局部变量是随着方法的调用而调用，随着调用完毕而消失，而堆内存的内容不会立即消失（如果不是final修饰的话，就会矛盾报错），所以加final修饰，使变为常量，即使消失了，也有数据在使用）</p>
<p>匿名内部类:就是内部类的简化写法。</p>
<p>前提：存在一个类或者接口。（这里的类可以是具体类也可以是抽象类）</p>
<p>格式： new  类名或者接口名(){</p>
<p>重写方法；</p>
<p>}</p>
<p>本质：就是具体类的子类或者抽象类的具体实现类或者接口的实现类的匿名****对象****。</p>
<p>因为本质是一个对象，所以后面可以跟调用方法。</p>
<p>new  类名或者接口名(){</p>
<p>重写方法；</p>
<p>}.方法名();</p>
<p>当有多个方法要重写时，只能调一次方法，因为这是个匿名对象。所以改进：在前面赋值给父接口或者父类、父抽象类，这就是多态。（实际上就是在{}中补了很多代码，其他格式不变），最后再通过多态的对象调用方法。</p>
<p>匿名内部类在开发中的使用：在android中常见，在ee中不常见。因为匿名内部类用完就会被回收不占内存。匿名内部类只能用一次。</p>
<p>类名调用方法，该方法就必须是静态类方法，否则应该是对象调用方法。</p>
<p>注意：内部类和外部类没有继承关系。</p>
<p>可以通过外部类名来限定this对象：new Outer().num  等价于  Outer.this.num（Outer.this其实是一个对象）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.7.%E5%86%85%E9%83%A8%E7%B1%BB/" data-id="ckw61sdvf0027oswd99u370ew" data-title="内部类" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.6.接口和抽象类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:50:31.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/">接口和抽象类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>为了体现事物功能的扩展性，java中提供了接口来定义这些额外功能，但不给出具体实现，将来有要实现的地方在添加实现。</p>
<p>特点：接口用interface关键字表示</p>
<p>格式：  interface  接口名{}</p>
<p>类实现接口用implements表示：</p>
<p>class  类名  implements  接口名{}</p>
<p>接口不能实例化。按照多态的方式，接口可以由具体的子类实例化。这也是多态的一种，接口多态。</p>
<p>所以多态有3种：</p>
<p>A. 具体类多态（几乎不用）</p>
<p>B. 抽象类多态（常用）</p>
<p>C. 接口多态（最常用）</p>
<p>接口的子类：要么是抽象类，要么重写接口中的所有抽象方法（推荐）。</p>
<p>接口成员特点：</p>
<p>成员变量：接口中的变量默认是常量，并且是静态的。默认修饰符<strong>public static final</strong> （所以建议自己手动给出）</p>
<p>构造方法：接口没有构造方法，因为接口主要是扩展功能的，没有具体存在</p>
<p>成员方法：只能是抽象方法。默认修饰符  public abstract（建议自己手动给出）</p>
<p>接口名+Impl这种格式是接口的实现类格式。</p>
<p>所有的类都默认继承自Object类。类 Object是类层次结构的根类，每个类都使用Object作为超类。因为Objec类只有无参构造，所以默认每个子类都会调用其父类的无参构造super();</p>
<p>类与类关系：继承关系，可以单继承，也可以多层继承</p>
<p>类与接口关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
<p>接口与接口的关系：继承关系，可以单继承，也可以多继承（java中有多继承，只有接口有）</p>
<p>抽象类和接口的区别：</p>
<p>A. 成员区别：抽象类有变量、常量，有构造方法，有抽象方法和非抽象方法</p>
<p>接口中只有常量，抽象方法</p>
<p>B. 关系区别：类与类关系、类与接口关系、接口与接口的关系</p>
<p>C. 设计理念区别：</p>
<p>抽象类被继承体现的是“is  a”的关系。共性功能</p>
<p>接口被实现体现的是“hava a”的关系。扩展功能（也有说like a的关系 谁像啥）</p>
<p>形式参数是引用类型：</p>
<p>类：类作为形参，其实需要的是该类的对象（匿名对象可以作为对象，只使用一次）</p>
<p>抽象类：需要的是该抽象类的子类对象。（因为它本身不能实例化，只有子类的对象）</p>
<p>接口：需要的是该接口的实现类对象。</p>
<p>返回值是引用类型：</p>
<p>类：返回的是该类的对象。</p>
<p>抽象类：返回的是该抽象类的子类对象。</p>
<p>接口：返回的是该接口的实现类对象。</p>
<p>链式编程：每次调用完毕方法后，返回的是一个对象。（适用于中间调用的返回值是类、接口、抽象类）</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在java中，一个没有方法体的方法应该定义为抽象方法。而类中如果有抽象方法，该类必须定义为抽象类。</p>
<p>抽象类和抽象方法必须使用abstract关键字修饰。</p>
<p>格式：抽象类：  abstract class 类名{…}</p>
<p> 抽象方法：    public abstract void eat（）；</p>
<p>空方法体用  ｛｝   没有方法体用  ;  </p>
<p>抽象类不一定有抽象方法（没有抽象方法的抽象类的意义就是不让外界创建对象，只能通过子类访问），但是有抽象方法的类一定是抽象类。</p>
<p>抽象类有构造方法（这个构造方法的作用是用于子类访问父类数据的初始化），但是不能实例化。按照多态的方式，抽象类可以由具体的子类实例化，和多态的声明一样: 父 f=new 子();  抽象类多态</p>
<p>抽象类的子类要么是抽象类，要么重写抽象类中的所有抽象方法成为一个具体的类。</p>
<p>抽象类的成员特点：</p>
<p>成员变量：既可以是变量，也可以是常量。</p>
<p>构造方法：有。用于子类访问父类数据的初始化。</p>
<p>成员方法：既可以是抽象的（强制要求子类做的事情），也可以是非抽象的（子类继承的事情，提高代码的复用性）。</p>
<p>如果测试的东西父类中都包含，可以使用多态。但如果要测试子类中特有的内容，我们无法用多态继续测试，所以要创建子类的对象来测试。</p>
<p>abstract不能共存的关键字：</p>
<p>private：冲突。加了就不让重写了。</p>
<p>final：冲突。不能被重写。</p>
<p>static：无意义。因为静态可以直接通过类名访问，而abstract没有方法体，访问一个没有方法体的方法是无意义的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/" data-id="ckw61sdve0025oswdb9thd2u5" data-title="接口和抽象类" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.8.程序控制流程if" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:49:57.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/">程序控制流程if</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>想了想还是单独给程序控制流程部分开了一个文章。因为业务逻辑部分，最主要的用的还是if语句。通过对不同情形的判断，来进行情况分类，可以帮助我们实现功能，学会if是写逻辑层代码重要的一环。</p>
<p>流程控制语句：可以控制程序的执行流程。</p>
<h1 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h1><p>是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p>
<p>从上往下，依次执行。</p>
<h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><p>也被称为分支结构。有特定的语法规则，代码要执行具体的逻辑运算进行判断，逻辑运算的结果有两个，所以产生选择，按照不同的选择执行不同的代码。</p>
<p>两种：</p>
<p>if语句的使用场景：</p>
<p>a.针对表达式是一个boolean类型的判断</p>
<p>b.针对一个范围的判断</p>
<p>c.针对几个常量值的判断</p>
<p>switch语句使用场景：针对几个常量值的判断</p>
<p>1.if语句</p>
<p>if语句的使用格式：</p>
<p>a. 适合做单个判断</p>
<p> if(关系表达式){</p>
<p>语句体</p>
<p>}</p>
<p>if语句控制的语句体如果是一条语句，大括号可以省略，如果是多条语句，就不能省略。建议永远不要省略。</p>
<p>一般来说，有左大括号就没有分号，有分号就没有左大括号。if();或if(){}</p>
<p>b.适合做两个判断</p>
<p>if(关系表达式){</p>
<p>语句体1；</p>
<p>}else{</p>
<p>语句体2；</p>
<p>}</p>
<p>else后面是没有表达式的，只有if后面有。</p>
<p>三元运算符实现的都可以用if语句实现。反之不成立（因为当if语句控制的操作是一个输出语句时候就不能，三元运算符是一个运算符，操作完毕是会有一个结果而不是一个输出语句）</p>
<p>c.适合做多个判断</p>
<p>if(比较表达式1){</p>
<p>语句体1；</p>
<p>}else if(比较表达式2){</p>
<p>语句体2；</p>
<p>}else if(比较表达式3){</p>
<p>语句体3；</p>
<p>}</p>
<p>…</p>
<p>else{</p>
<p>语句体n+1；</p>
<p>}</p>
<p>注意事项：比较表达式无论简单还是复杂，结果必须是boolean类型。</p>
<p>if语句是可以任意嵌套使用的，把语句体n改为if语句即可实现（无论使用if三种格式那种都行）。</p>
<p>\2. switch语句</p>
<p>switch(表达式){</p>
<p>case  值1:</p>
<p>语句体1；</p>
<p>break；</p>
<p>case  值2:</p>
<p>语句体2；</p>
<p>break；</p>
<p>…</p>
<p>default：</p>
<p>语句体n+1；</p>
<p>break；</p>
<p>}</p>
<p>switch:表示这是switch选择结构。</p>
<p>表达式：表达式取值有限定，byte，short，char，int。JDK5以后可以是枚举，JDK7以后可以是字符串。</p>
<p>case后面跟的是要和表达式比较的值。</p>
<p>语句体部分可以是一条或者多条语句</p>
<p>break表示中断，结束的意思，可以结束switch语句。</p>
<p>注意事项：</p>
<p>\1. case后面只能是常量，不能是变量，而且多个case后面的值不能出现相同的。</p>
<p>\2. default可以省略。一般不建议，除非判断的case值是固定的（可以穷举完）。他的作用是对不正确的情况给出提示。</p>
<p>\3. break可以省略。一般不建议，会出现case穿透(可以利用case穿透来实现多个输出结果相同时整合到一起)。最后一个break可以省略。</p>
<p>\4. default位置可以出现在switch语句的任意位置。建议在最后。</p>
<p>\5. switch语句的结束条件：遇到break或者执行到程序的末尾。</p>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>循环语句的组成：</p>
<p>初始化语句：一条或者多条语句，这些语句完成一些初始化操作</p>
<p>判断条件语句：这是一个boolean表达式，这个表达式决定是否执行循环体</p>
<p>循环体语句：要多次循环的语句</p>
<p>控制条件语句：在一次循环结束后，下次循环判断条件执行前执行，通过用于控制循环条件中的变量，使得循环再合适的时候结束</p>
<h2 id="for循环："><a href="#for循环：" class="headerlink" title="for循环："></a>for循环：</h2><p>for(初始化语句；判断条件语句；控制条件语句)｛</p>
<p>循环体语句；</p>
<p>｝</p>
<p>注意事项：判断条件语句的结果是一个boolean类型</p>
<p>循环语句如果是一条语句，大括号可以省略，如果是多条语句，大括号不能省略，建议永远不要省略。</p>
<p>一般来说，有左大括号就没有分号，有分号就没有左大括号。</p>
<p>for循环：求和思想：初始化值为0。</p>
<p>求阶乘思想：初始化值为1。</p>
<p>水仙花数：就是指一个三位数，其各位数字的立方和等于该数本身。eg：153</p>
<h2 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h2><p>基本格式：</p>
<p>while(判断条件语句){</p>
<p>循环体语句；</p>
<p>}</p>
<p>扩展格式：</p>
<p>初始化语句；</p>
<p>while（判断条件语句）｛</p>
<p>循环体语句；</p>
<p>控制条件语句；</p>
<p>｝</p>
<p> for循环和while循环语句可以等价转换，但也存在区别：</p>
<p>使用区别：控制条件语句所控制的那个变量，在for循环结束后，就不能在被访问到了，而while循环结束还可以继续使用。若不使用推荐使用for循环，因为这个变量会从内存中消失，能够提高内存的使用效率。</p>
<p>场景区别：for循环适合针对一个范围判断进行操作，while循环适合判断次数不明确的操作。</p>
<h2 id="do-…-while-循环语句："><a href="#do-…-while-循环语句：" class="headerlink" title="do … while 循环语句："></a>do … while 循环语句：</h2><p>至少执行一次</p>
<p>基本格式：</p>
<p>do{</p>
<p>循环体语句；</p>
<p>}while（判断条件语句）;</p>
<p>扩展格式：</p>
<p>初始化语句；</p>
<p>do｛</p>
<p>循环体语句；</p>
<p>控制条件语句；</p>
<p>｝while（判断条件语句）;</p>
<p>优先考虑for循环，其次是while循环，最后考虑do… while循环。</p>
<p>注意死循环：ctrl+c中断循环</p>
<p>A：注意控制条件语句控制的那个变量的问题，不要丢了，否则会死循环。</p>
<p>B：两种最简单的死循环格式</p>
<p>while（true）｛</p>
<p>｝</p>
<p>for（；；）｛</p>
<p>｝</p>
<p>循环嵌套：循环语句的循环体本身是一个循环语句。</p>
<p>外循环控制行数，内循环控制列数。</p>
<h1 id="控制跳转语句"><a href="#控制跳转语句" class="headerlink" title="控制跳转语句"></a>控制跳转语句</h1><p>****break****：中断</p>
<p>使用场景：离开下面2个场景使用，无意义。</p>
<p>A：switch语句中</p>
<p>B：循环语句中（加入了if判断的情况）</p>
<p>使用：A：跳出单层循环</p>
<p>B：跳出多层循环，必须借助标签。</p>
<p>格式：</p>
<p>标签名： 语句</p>
<p>****continue****：继续</p>
<p>使用场景：循环语句中。（离开此场景无意义）</p>
<p>break和continue的区别：break是跳出单层循环。continue是跳出一次循环，进行下一次的判断执行。</p>
<p>****return****：返回</p>
<p>renturn关键字不是为了跳转出循环体，更常用的功能是结束一个方法，也就是推出一个方法，跳转到上层调用的方法。</p>
<p>一旦遇到return，程序就不会在继续往后执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/" data-id="ckw61sdvg0029oswd66s523v9" data-title="程序控制流程if" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-1.5.编程规范" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T02:57:13.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/">编程规范</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><p>遇到左大括号缩进一个tab的位置。</p>
<p>关联不是很大的语句间空行。</p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><p>1.不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</p>
<p>2.严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。（有些国际通用的可以用拼音：renminbi，taobao）</p>
<p>3.驼峰命名。</p>
<p>4.杜绝完全不规范的缩写，避免望文不知义</p>
<p>5.为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。</p>
<p>6.如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p>
<h3 id="类名命名"><a href="#类名命名" class="headerlink" title="类名命名"></a>类名命名</h3><p>1.大写开头（DO / BO / DTO / VO / AO/ PO / UID除外 ）</p>
<p>2.抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾</p>
<p>3.POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p>
<p>4.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。<strong>包名统一使用单数形式</strong>，但是类名如果有复数含义，类名可以使用复数形式。</p>
<p>5.避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低</p>
<p>6.接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。</p>
<p>7.接口和实现类的命名：</p>
<ul>
<li><p>对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用Impl 的后缀与接口区别。CacheServiceImpl 实现 CacheService 接口。</p>
</li>
<li><p>如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）AbstractTranslator 实现 Translatable 接口</p>
</li>
</ul>
<p>8.<strong>枚举类</strong>名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。</p>
<p>9.Service/DAO 层方法命名规约</p>
<p>1） 获取单个对象的方法用 get 做前缀。</p>
<p>2） 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。 </p>
<p>3） 获取统计值的方法用 count 做前缀。 </p>
<p>4） 插入的方法用 save/insert 做前缀。</p>
<p>5） 删除的方法用 remove/delete 做前缀。</p>
<p>6） 修改的方法用 update 做前缀。</p>
<p>10.领域模型命名规约</p>
<p>1） 数据对象：xxxDO，xxx 即为数据表名。</p>
<p>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</p>
<p>3） 展示对象：xxxVO，xxx 一般为网页名称。</p>
<p>4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO</p>
<h3 id="方法名，参数名，变量名"><a href="#方法名，参数名，变量名" class="headerlink" title="方法名，参数名，变量名"></a>方法名，参数名，变量名</h3><p>1.小写开头。</p>
<p>2.类型与中括号紧挨相连来表示数组</p>
<p>3.在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度（startTime / workQueue / nameList / TERMINATED_THREAD_COUNT）</p>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>1.常量命名全部大写，单词间用下划线隔开，不要嫌弃太长，一定见名知意。</p>
<p>2.不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</p>
<p>3.在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解</p>
<p>4.不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。（缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。）</p>
<p>5.常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</p>
<p>1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。</p>
<p>2） 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。</p>
<p>3） 子工程内部共享常量：即在当前子工程的 constant 目录下。</p>
<p>4） 包内共享常量：即在当前包下单独的 constant 目录下。</p>
<p>5） 类内共享常量：直接在类内部 private static final 定义。</p>
<p>6.如果变量值仅在一个固定范围内变化用 enum 类型来定义。</p>
<p>7.常量类</p>
<p>static final修饰的字段在javac编译时生成constantValue属性，在类加载的准备阶段直接把constantValue的值赋给该字段。可以理解为在编译期即把结果放入了常量池中。即在类未被加载时static final字段就有了值，这个值不需要对类进行初始化就可以读取，不像static变量，需要类加载后才会有值(类未加载进内存时值为默认值0或null)。</p>
<p>注：1.ConstantValue修饰的字段<strong>只限于基本类型和string</strong>。</p>
<p>   2.ConstantValue修饰的字段若为String类型，必须要是编译期可以进行优化得到的即编译期常量才能满足不需要对类进行初始化就可以读取(例如：String s = “a”+“bc”；)，否则这个值需要对类进行初始化才可以读取(例如：String s = new String(“abc”)；)。</p>
<p>   3.对于满足上两个条件的constantValue变量，在访问该变量时，无需初始化类即可访问(即访问时在常量池中寻找，不会执行类的静态成员和静态代码块)。</p>
<h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p>1.如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块则： </p>
<p>1） 左大括号前不换行。<br>2） 左大括号后换行。<br>3） 右大括号前换行。<br>4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行</p>
<p>2.左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左大括号前需要空格。</p>
<p>3.if/for/while/switch/do 等保留字与括号之间都必须加空格。</p>
<p>4.任何二目、三目运算符的左右两边都需要加一个空格。</p>
<p>5.采用 4 个空格缩进，禁止使用 tab 字符</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 缩进 4 个空格 </span></span><br><span class="line">    String say = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line">    <span class="comment">// 运算符的左右必须有一个空格 </span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 </span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123; </span><br><span class="line">        System.out.println(say); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 左大括号前加空格且不换行；左大括号后换行 </span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;world&quot;</span>); </span><br><span class="line">    <span class="comment">// 右大括号前换行，右大括号后有 else，不用换行 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>); </span><br><span class="line">    <span class="comment">// 在右大括号后直接结束，则必须换行 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.注释的双斜线与注释内容之间有且仅有一个空格</p>
<p>7.在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。</p>
<p>8.单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：<br>1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进。<br>2）运算符与下文一起换行。<br>3）方法调用的点符号与下文一起换行。<br>4）方法调用中的多个参数需要换行时，在逗号后进行。 </p>
<p>5）在括号前不要换行，在逗号前不要换行</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(); </span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行</span></span><br><span class="line">sb.append(<span class="string">&quot;Jack&quot;</span>).append(<span class="string">&quot;Ma&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>9.方法参数在定义和传入时，多个参数逗号后边必须加空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method(args1, args2, args3);</span><br></pre></td></tr></table></figure>

<p>10.IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式。</p>
<p>11.单个方法的总行数不超过 80 行（除注释之外的所有行数）</p>
<p>代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护</p>
<p>12.没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐</p>
<p>13.不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性（任何情形，没有必要插入多个空行进行隔开）</p>
<h2 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h2><p>1.避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可</p>
<p>2.所有的覆写方法，必须加@Override 注解</p>
<p>3.相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。（提倡同学们尽量不用可变参数编程）</p>
<p>4.外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</p>
<p>5.不能使用过时的类或方法（接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么）</p>
<p>6.Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。推荐使用 java.util.Objects#equals（JDK7 引入的工具类）。</p>
<p>7.所有整型包装类对象之间值的比较，全部使用 equals 方法比较</p>
<p>对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。</p>
<p>8.浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals 来判断。</p>
<p>浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line"> <span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"> <span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line"> <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line"> <span class="comment">// 预期进入此代码快，执行其它业务逻辑</span></span><br><span class="line"> <span class="comment">// 但事实上 a==b 的结果为 false</span></span><br><span class="line"> &#125;</span><br><span class="line"> Float x = Float.valueOf(a);</span><br><span class="line"> Float y = Float.valueOf(b);</span><br><span class="line"> <span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line"> <span class="comment">// 预期进入此代码快，执行其它业务逻辑</span></span><br><span class="line"> <span class="comment">// 但事实上 equals 的结果为 false</span></span><br><span class="line"> &#125; </span><br><span class="line">正例：</span><br><span class="line">(<span class="number">1</span>) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。</span><br><span class="line"> <span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"> <span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line"> <span class="keyword">float</span> diff = <span class="number">1e-6f</span>;</span><br><span class="line"> <span class="keyword">if</span> (Math.abs(a - b) &lt; diff) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">(<span class="number">2</span>) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。</span><br><span class="line"> BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"> BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"> BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"> BigDecimal x = a.subtract(b);</span><br><span class="line"> BigDecimal y = b.subtract(c);</span><br><span class="line"> <span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>9.定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。</p>
<p>数据库字段的 bigint 必须与类属性的 Long 类型相对应。</p>
<p>10.为了防止精度损失，禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常</p>
<p>如：BigDecimal g = new BigDecimal(0.1f); 实际的存储值为：0.10000000149  </p>
<p>需使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal recommend1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">BigDecimal recommend2 = BigDecimal.valueOf(<span class="number">0.1</span>);</span><br></pre></td></tr></table></figure>

<p>11.关于基本数据类型与包装数据类型的使用标准：</p>
<ul>
<li><p>所有的 POJO 类属性必须使用包装数据类型。</p>
</li>
<li><p>RPC 方法的返回值和参数必须使用包装数据类型。</p>
</li>
<li><p>所有的局部变量使用基本数据类型。</p>
</li>
</ul>
<p>POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p>
<h2 id="Java代码的规范"><a href="#Java代码的规范" class="headerlink" title="Java代码的规范"></a>Java代码的规范</h2><p>1.尽量在合适的场合使用单例</p>
<p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，单例主要适用于以下三个方面：</p>
<ul>
<li><p>控制资源的使用，通过线程同步来控制资源的并发访问</p>
</li>
<li><p>控制实例的产生，以达到节约资源的目的</p>
</li>
<li><p>控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p>
</li>
</ul>
<p>2.尽量避免随意使用静态变量</p>
<p>要知道，当某个对象被定义为stataic变量所引用，那么gc通常是不会回收这个对象所占有的内存，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">static B b &#x3D; new B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p>
<p>3.尽量避免过多过常的创建java对象</p>
<p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。</p>
<p>4.尽量使用final修饰符</p>
<p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指 定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。java编译器会寻找机会内联 (inline)所有的final方法(这和具体的编译器实现有关)。此举能够使性能平均提高50%。</p>
<p>5.尽量使用局部变量</p>
<p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈(Stack)中，速度较快。其他变量，如静态变量，实例变量等，都在堆(Heap)中创建，速度较慢。</p>
<p>6.尽量处理好包装类型和基本类型两者的使用场所</p>
<p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。</p>
<p>在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p>
<p>7.慎用synchronized，尽量减小synchronize的方法</p>
<p>都 知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。</p>
<p>8.尽量使用StringBuilder和StringBuffer进行字符串连接</p>
<p>字符串缓冲区</p>
<p>9.尽量不要使用finalize方法</p>
<p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p>
<p>10.尽量使用基本数据类型代替对象</p>
<p>String str = “hello”;</p>
<p>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；</p>
<p>String str = new String(“hello”);</p>
<p>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p>
<p>11.单线程应尽量使用HashMap, ArrayList</p>
<p>HashTable,Vector等使用了同步机制，降低了性能。</p>
<p>12.尽量合理的创建HashMap</p>
<p>当你要创建一个比较大的hashMap时，充分利用另一个构造函数</p>
<p>public HashMap(int initialCapacity, float loadFactor)</p>
<p>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p>
<p>13.尽量减少对变量的重复计算</p>
<p>如</p>
<p>for(int i=0;i&lt;list.size();i++)</p>
<p>应该改为</p>
<p>for(int i = 0,len = list.size();i&lt; len;i++)</p>
<p>并且在循环中应该避免使用复杂的表达式。在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。</p>
<p>14.尽量避免不必要的创建</p>
<p>如</p>
<p>A a = new A();</p>
<p>if(i==1){list.add(a);}</p>
<p>应该改为</p>
<p>if(i==1){<br>A a = new A();</p>
<p>list.add(a);}</p>
<p>15.尽量在finally块中释放资源</p>
<p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。</p>
<p>16.尽量使用移位来代替’a/b’的操作</p>
<p>“/“是一个代价很高的操作，使用移位的操作将会更快和更有效</p>
<p>如</p>
<p>int num = a / 4;</p>
<p>int num = a / 8;</p>
<p>应该改为</p>
<p>int num = a &gt;&gt; 2;</p>
<p>int num = a &gt;&gt; 3;</p>
<p>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解</p>
<p>17.尽量使用移位来代替’a*b’的操作</p>
<p>同样的，对于’*’操作，使用移位的操作将会更快和更有效</p>
<p>如</p>
<p>int num = a * 4;</p>
<p>int num = a * 8;</p>
<p>应该改为</p>
<p>int num = a &lt;&lt; 2;</p>
<p>int num = a &lt;&lt; 3;</p>
<p>18.尽量确定StringBuffer的容器</p>
<p>StringBuffer 的构造器会创建一个默认大小(通常是16)的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。</p>
<p>如：StringBuffer buffer = new StringBuffer(1000);</p>
<p>19.尽量早释放无用对象的引用</p>
<p>大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。</p>
<p>例如：</p>
<p>Public void test(){<br>Object obj = new Object();</p>
<p>……</p>
<p>//执行耗时，耗内存操作；或调用耗时，耗内存的方法</p>
<p>}</p>
<p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p>
<p>Public void test(){<br>Object obj = new Object();</p>
<p>……</p>
<p>Obj=null;</p>
<p>……</p>
<p>}</p>
<p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p>
<p>20.尽量避免使用二维数组</p>
<p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p>
<p>21.尽量避免使用split</p>
<p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p>
<p>22.ArrayList &amp; LinkedList</p>
<p>一 个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。</p>
<p>23.尽量使用System.arraycopy ()代替通过来循环复制数组</p>
<p>System.arraycopy() 要比通过循环来复制数组快的多</p>
<p>24.尽量缓存经常使用的对象</p>
<p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p>
<p>25.尽量避免非常大的内存分配</p>
<p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p>
<p>26.慎用异常</p>
<p>当 创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。</p>
<p>如果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就 抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p>
<h2 id="MySQL-数据库规范"><a href="#MySQL-数据库规范" class="headerlink" title="MySQL 数据库规范"></a>MySQL 数据库规范</h2><h3 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h3><p>1.表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。任何字段如果为非负数，必须是 unsigned。</p>
<p>POJO 类中的任何布尔类型的变量，都不要加 is 前缀。</p>
<p>2.表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。不允许出现任何大写字母（因为MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写）</p>
<p>3.表名不使用复数名词。DO 类名也是单数形式</p>
<p>4.禁用保留字，如 desc、range、match、delayed 等</p>
<p>5.主键索引名（primary key）为 <code>pk_字段名</code>；唯一索引名（unique key）为 <code>uk_字段名</code>；普通索引名（ index）则为 <code>idx_字段名</code></p>
<p>6.小数类型为 decimal，禁止使用 float 和 double（在存储的时候，float 和 double 都存在精度损失的问题）。存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储</p>
<p>7.如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
<p>8.varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
<p>9.表必备三字段：id（必为主键，类型为 bigint unsigned、单表时自增、步长为 1）, create_time, update_time（类型均为 datetime 类型）。</p>
<p>10.表的命名最好是遵循“业务名称_表的作用”</p>
<p>11.库名与应用名称尽量一致</p>
<p>12.如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释</p>
<p>13.字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p>
<p>1） 不是频繁修改的字段。</p>
<p>2） 不是 varchar 超长字段，更不能是 text 字段。</p>
<p> 3） 不是唯一索引的字段。</p>
<p>14.单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表（预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表）</p>
<p>15.合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。无符号值（unsigned）可以避免误存负数，且扩大了表示范围。</p>
<p>对象 年龄区间 类型 字节 表示范围</p>
<p>人 150 岁之内 tinyint unsigned 1 无符号值：0 到 255</p>
<p>龟 数百岁 smallint unsigned 2 无符号值：0 到 65535</p>
<p>恐龙化石 数千万年 int unsigned 4 无符号值：0 到约 42.9 亿</p>
<p>太阳 约 50 亿年 bigint unsigned 8 无符号值：0 到约 10 的 19 次方</p>
<p>16.尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。在设置默认值的时候，尽量不要用Null来当默认值，如果字段是int类型，默认为0，如果是varchar类型，默认值用空字符串（’’）会更好一些</p>
<p>17.习惯是任何数据表的任何列都是非空（NOT NULL），在此基础上将数字默认设为0，文本默认设为’’（在PHPMyAdmin中留空）</p>
<h3 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h3><p>1.业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。（唯一索引影响 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。没有唯一索引的话，必然有脏数据产生）</p>
<p>2.超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引（双表join时也要注意表索引、SQL性能）</p>
<p>3.在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定</p>
<p>4.页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决（索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。）</p>
<p>5.order by：注意利用索引的有序性（order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能）</p>
<p>6.利用覆盖索引来进行查询操作，避免回表（覆盖索引只是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index）</p>
<p>7.利用延迟关联或者子查询优化超多分页场景</p>
<p>8.SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。</p>
<p>1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</p>
<p>2） ref 指的是使用普通的索引（normal index）。 </p>
<p>3） range 对索引进行范围检索。</p>
<p>type=index,索引物理文件全扫描，速度非常慢，这个 index 级别比较 range还低，与全表扫描是小巫见大巫</p>
<p>9.建组合索引的时候，区分度最高的在最左边</p>
<p>10.防止因字段类型不同造成的隐式转换，导致索引失效</p>
<p>11.创建索引时,注意避免:</p>
<p>1） 宁滥勿缺。认为一个查询就需要建一个索引。</p>
<p>2） 宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</p>
<p>3） 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p>
<h3 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><p>1.不要使用 count(列名)或 count(常量)来替代 <code>count(*)</code>，<code>count(*)</code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<p>2.count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p>
<p>3.当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。</p>
<p>使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table;</p>
<p>4.使用 ISNULL()来判断是否为 NULL 值。NULL 与任何值的直接比较都为 NULL</p>
<p>5.代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p>
<p>6.不得使用外键与级联，一切外键概念必须在应用层解决</p>
<p>7.禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
<p>8.数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p>
<p>9.in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</p>
<p>10.所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。当需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别</p>
<p>11.TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。</p>
<p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
<h3 id="ORM-映射"><a href="#ORM-映射" class="headerlink" title="ORM 映射"></a>ORM 映射</h3><p>1.在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明</p>
<p>1）增加查询分析器解析成本。</p>
<p>2）增减字段容易与 resultMap 配置不一致。</p>
<p>3）无用字段增加网络消耗，尤其是 text 类型的字段。</p>
<p>2.POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。</p>
<p>3.不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个 POJO 类与之对应。</p>
<p>配置映射关系，使字段与 DO 类解耦，方便维护。</p>
<p>4.sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入</p>
<p>5.iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。（因为它的实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取start,size 的子集合）</p>
<p>6.不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p>
<p>resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控</p>
<p>7.更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p>
<p>8.不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p>
<p>9.@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p>
<p>10.<code>&lt;isEqual&gt;</code>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；&lt;isNotEmpty&gt;表示不为空且不为 null 时执行；<code>&lt;isNotNull&gt;</code>表示不为 null 值时执行。 </p>
<h2 id="自己的项目规范："><a href="#自己的项目规范：" class="headerlink" title="自己的项目规范："></a>自己的项目规范：</h2><p>1.同级之间不要互相调用，上层只能调用下层，避免混乱。</p>
<p>2.swagger注解</p>
<ul>
<li><p>controller类上： </p>
<p>@Api(value=””,tags=””)</p>
</li>
<li><p>controller类里的方法：<br>@ApiOperation(value=””,notes=””)</p>
<p>@ApiParam(value = “”)</p>
<p>@ApiImplicitParams(</p>
<pre><code>        @ApiImplicitParam(name = &quot;&quot;, value = &quot;&quot;,paramType = &quot;&quot;,required = true, dataType = &quot;&quot;)
)
</code></pre>
<p>​    @ApiResponses({<br>​            @ApiResponse(code = 0, message = “”,class=””)<br>​<br>​    })</p>
</li>
<li><p>类上：<br>@ApiModel(value = “”,description=””)</p>
</li>
<li><p>类的字段上：<br>@ApiModelProperty(value=””)</p>
</li>
</ul>
<p>3.查数据用get，删，改，增数据用post</p>
<p>4.<strong>改东西前，加个备份,改东西后，加个记录</strong></p>
<p>5.</p>
<h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h2><p>前后端接口规范：解耦接口，尽量不要用大接口。可以用公共的接口，但是尽量是前端需要什么信息，传递什么信息，不要查到所有信息再返回给前端。因为尽量避免暴露数据库表结构，避免传递不必要的信息。</p>
<p>前端传过来的数据也要做数据校验（即使前端已经做过校验），因为可能是通过接口发送的参数，绕过了前端页面</p>
<h2 id="RESTful-架构"><a href="#RESTful-架构" class="headerlink" title="RESTful 架构"></a>RESTful 架构</h2><p>RESTful 只是一种指导风格，就像我们 Java 要用驼峰命名法。</p>
<p>REST 不是一个单词，是 Representational State Transfer 的缩写。直译过来就是表述性状态转移。其实它还有个主语 Resource ，所以是资源的表述性状态转移。</p>
<p><strong>核心</strong>就是资源，用 URL 定位资源，用 HTTP 动词来描述所要做的操作。</p>
<p>HTTP的提供了很多动词：GET、PUT、POST、DELETE……这些动词都是有含义的。</p>
<p>比如：</p>
<p>GET 就是获取资源，是查询请求。</p>
<p>PUT 指的是修改资源，是幂等的。</p>
<p>POST 也是修改(新增也是一种修改)，指的是不幂等的操作。</p>
<p>所以根据这些规范我们都能得知这次交互的一些动作，所以 RESTful 风格正确的使用姿势如下：</p>
<p>比如获取一个 user：</p>
<p>​    错误姿势：<code>GET /getUserById?userId=1</code>。</p>
<p>​    正确姿势：<code>GET /users/1</code>。</p>
<p>再比如新增 user：</p>
<p>​    错误姿势：<code>POST /addUser</code> （省略body）。</p>
<p>​    正确姿势：<code>POST /users</code> （省略body）。</p>
<p>可以看到 HTTP 的动词其实就能指代你要对资源做的操作，所以不需要在 URL 上做一些东西，就把 URL 表明的东西看作一个资源即可。</p>
<p>这里注意要用对 HTTP 动词，比如一个获取资源的请求用 PUT，用了也能获取资源但是这不合适。</p>
<p>其实更深一步的理解是  HTTP 是一个协议。</p>
<p>协议其实就是约定好的一个东西，协议就规定 GET 是获取资源，那你非得在 URL 上再重复一遍或者所有请求不论增删改都用 GET 这个动作，这其实就是没有完全遵循这个协议。</p>
<p>可以说只是把 HTTP 当成一个传输管道，而不是约定好的协议。</p>
<p>这其实是对 HTTP 更深一层的认识，我认为也是 RESTful 被推出的原因。</p>
<p>当然理想很丰满，现实很骨感，还是有很多人就 <code>getUserById</code>。</p>
<p>不过我个人觉得问题不大，公司统一就行。</p>
<h2 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h2><p>即 Hypermedia as the Engine of Application State 的缩写，翻译过来就是作为应用状态引擎的超媒体。</p>
<p>这也是 REST 提出的设计。</p>
<p>比如你请求获取用户列表：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /users</span><br><span class="line">Accept: application/json+userdb</span><br></pre></td></tr></table></figure>

<p>此时的返回应该是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Content-Type: application/json+userdb</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;users&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 1,</span><br><span class="line">            &quot;name&quot;: &quot;Emil&quot;,</span><br><span class="line">            &quot;country: &quot;Sweden&quot;,</span><br><span class="line">            &quot;links&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/user/1&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;self&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;GET&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/user/1&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;PUT&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/user/1&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;delete&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 2,</span><br><span class="line">           ....省略.....</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;links&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;/user&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;create&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;POST&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点就是这个 links，结果会返回你能对这个资源所做的操作。</p>
<p>比如对于 userId 是 1 的，你调用<code>PUT /user/1</code>就是做修改这个用户，<code>DELETE /user/1</code>就是删除这个用户。</p>
<p>最外层的 links 告诉你用 <code>POST /user</code> 就能再创建一个用户。</p>
<p>这里还有个隐藏信息，可以看到外层的 links 没有返回 DELETE 的信息，说明此时客户端无法删除用户！</p>
<p>所以说 RESTful API 还需要再返回此时能对资源做的操作，这样客户端就知道它能做什么。</p>
<p>它也不需要管具体怎么做，反正返回里面会告诉它 DELETE 就这样这样，POST 就这样这样。</p>
<p>没告诉它的就是不能做的。</p>
<p>然后这个时候再去理解下资源的表述性状态转移，是不是感觉来了？</p>
<p>如果说上一 part 提到用 HTTP 的动词来指代动作， URL 仅表示资源的现实是骨感的。</p>
<p>那么 HATEOAS 的现实就是骨灰。</p>
<p>基本上没几家公司会这么做。</p>
<p>就我个人而言这玩意没啥用。</p>
<p>它的出发点是让客户端从响应就能得知对资源操作的入口，并且通过响应得知哪些动作能执行。</p>
<p>听起来好像有点用，但是就我目前的功力，我只能看到响应变得十分冗余。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章关于 RESTful API 具体的写法我就提到一些，还有挺多的就自己查资料吧。</p>
<p>文章的目的是为了让你理解 RESTful API，我再总结一下重点。</p>
<p>HTTP 是协议，不是传输通道。（对协议不理解的看我之前的 HTTP 分析）</p>
<p>所以协议约定了很多东西，推荐我们按照协议的用法进行客户端和服务端的交互。</p>
<p>也就是 RESTful 表明的面向资源，通过 HTTP 动作 + URL 上的资源。</p>
<p>RESTful 还提到了 HATEOAS，虽说基本上没什么公司会这样使用，但是它能让你更好的理解 REST 这个名字的含义。</p>
<p>RESTful 是一种风格，你是否采用这种风格对你的程序运行没有影响，类比驼峰命名来思考。</p>
<p>简而言之，RESTful 就是不要在 URL 上表现出动作，用 HTTP 动词代表动作，URL 上只做资源。</p>
<p>仅此而已。</p>
<p>至于要不要严格遵循 RESTful 风格，我个人的看法是公司内部保持一致就行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" data-id="ckw61sdw0003zoswd2hh9cvgx" data-title="编程规范" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/9/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>