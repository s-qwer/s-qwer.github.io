<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/8/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-4.6.接口和抽象类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:50:31.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/">接口和抽象类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>为了体现事物功能的扩展性，java中提供了接口来定义这些额外功能，但不给出具体实现，将来有要实现的地方在添加实现。</p>
<p>特点：接口用interface关键字表示</p>
<p>格式：  interface  接口名{}</p>
<p>类实现接口用implements表示：</p>
<p>class  类名  implements  接口名{}</p>
<p>接口不能实例化。按照多态的方式，接口可以由具体的子类实例化。这也是多态的一种，接口多态。</p>
<p>所以多态有3种：</p>
<p>A. 具体类多态（几乎不用）</p>
<p>B. 抽象类多态（常用）</p>
<p>C. 接口多态（最常用）</p>
<p>接口的子类：要么是抽象类，要么重写接口中的所有抽象方法（推荐）。</p>
<p>接口成员特点：</p>
<p>成员变量：接口中的变量默认是常量，并且是静态的。默认修饰符public static final （所以建议自己手动给出）</p>
<p>构造方法：接口没有构造方法，因为接口主要是扩展功能的，没有具体存在</p>
<p>成员方法：只能是抽象方法。默认修饰符  public abstract（建议自己手动给出）</p>
<p>接口名+Impl这种格式是接口的实现类格式。</p>
<p>所有的类都默认继承自Object类。类 Object是类层次结构的根类，每个类都使用Object作为超类。因为Objec类只有无参构造，所以默认每个子类都会调用其父类的无参构造super();</p>
<p>类与类关系：继承关系，可以单继承，也可以多层继承</p>
<p>类与接口关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
<p>接口与接口的关系：继承关系，可以单继承，也可以多继承（java中有多继承，只有接口有）</p>
<p>抽象类和接口的区别：</p>
<p>A. 成员区别：抽象类有变量、常量，有构造方法，有抽象方法和非抽象方法</p>
<p>接口中只有常量，抽象方法</p>
<p>B. 关系区别：类与类关系、类与接口关系、接口与接口的关系</p>
<p>C. 设计理念区别：</p>
<p>抽象类被继承体现的是“is  a”的关系。共性功能</p>
<p>接口被实现体现的是“hava a”的关系。扩展功能（也有说like a的关系 谁像啥）</p>
<p>形式参数是引用类型：</p>
<p>类：类作为形参，其实需要的是该类的对象（匿名对象可以作为对象，只使用一次）</p>
<p>抽象类：需要的是该抽象类的子类对象。（因为它本身不能实例化，只有子类的对象）</p>
<p>接口：需要的是该接口的实现类对象。</p>
<p>返回值是引用类型：</p>
<p>类：返回的是该类的对象。</p>
<p>抽象类：返回的是该抽象类的子类对象。</p>
<p>接口：返回的是该接口的实现类对象。</p>
<p>链式编程：每次调用完毕方法后，返回的是一个对象。（适用于中间调用的返回值是类、接口、抽象类）</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在java中，一个没有方法体的方法应该定义为抽象方法。而类中如果有抽象方法，该类必须定义为抽象类。</p>
<p>抽象类和抽象方法必须使用abstract关键字修饰。</p>
<p>格式：抽象类：  abstract class 类名{…}</p>
<p> 抽象方法：    public abstract void eat（）；</p>
<p>空方法体用  ｛｝   没有方法体用  ;  </p>
<p>抽象类不一定有抽象方法（没有抽象方法的抽象类的意义就是不让外界创建对象，只能通过子类访问），但是有抽象方法的类一定是抽象类。</p>
<p>抽象类有构造方法（这个构造方法的作用是用于子类访问父类数据的初始化），但是不能实例化。按照多态的方式，抽象类可以由具体的子类实例化，和多态的声明一样: 父 f=new 子();  抽象类多态</p>
<p>抽象类的子类要么是抽象类，要么重写抽象类中的所有抽象方法成为一个具体的类。</p>
<p>抽象类的成员特点：</p>
<p>成员变量：既可以是变量，也可以是常量。</p>
<p>构造方法：有。用于子类访问父类数据的初始化。</p>
<p>成员方法：既可以是抽象的（强制要求子类做的事情），也可以是非抽象的（子类继承的事情，提高代码的复用性）。</p>
<p>如果测试的东西父类中都包含，可以使用多态。但如果要测试子类中特有的内容，我们无法用多态继续测试，所以要创建子类的对象来测试。</p>
<p>abstract不能共存的关键字：</p>
<p>private：冲突。加了就不让重写了。</p>
<p>final：冲突。不能被重写。</p>
<p>static：无意义。因为静态可以直接通过类名访问，而abstract没有方法体，访问一个没有方法体的方法是无意义的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.6.%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/" data-id="ckqk8k3dj002e2wwd98tnhc6p" data-title="接口和抽象类" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.8.程序控制流程if" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T03:49:57.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/">程序控制流程if</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>想了想还是单独给程序控制流程部分开了一个文章。因为业务逻辑部分，最主要的用的还是if语句。通过对不同情形的判断，来进行情况分类，可以帮助我们实现功能，学会if是写逻辑层代码重要的一环。</p>
<p>流程控制语句：可以控制程序的执行流程。</p>
<h1 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h1><p>是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p>
<p>从上往下，依次执行。</p>
<h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><p>也被称为分支结构。有特定的语法规则，代码要执行具体的逻辑运算进行判断，逻辑运算的结果有两个，所以产生选择，按照不同的选择执行不同的代码。</p>
<p>两种：</p>
<p>if语句的使用场景：</p>
<p>a.针对表达式是一个boolean类型的判断</p>
<p>b.针对一个范围的判断</p>
<p>c.针对几个常量值的判断</p>
<p>switch语句使用场景：针对几个常量值的判断</p>
<p>1.if语句</p>
<p>if语句的使用格式：</p>
<p>a. 适合做单个判断</p>
<p> if(关系表达式){</p>
<p>语句体</p>
<p>}</p>
<p>if语句控制的语句体如果是一条语句，大括号可以省略，如果是多条语句，就不能省略。建议永远不要省略。</p>
<p>一般来说，有左大括号就没有分号，有分号就没有左大括号。if();或if(){}</p>
<p>b.适合做两个判断</p>
<p>if(关系表达式){</p>
<p>语句体1；</p>
<p>}else{</p>
<p>语句体2；</p>
<p>}</p>
<p>else后面是没有表达式的，只有if后面有。</p>
<p>三元运算符实现的都可以用if语句实现。反之不成立（因为当if语句控制的操作是一个输出语句时候就不能，三元运算符是一个运算符，操作完毕是会有一个结果而不是一个输出语句）</p>
<p>c.适合做多个判断</p>
<p>if(比较表达式1){</p>
<p>语句体1；</p>
<p>}else if(比较表达式2){</p>
<p>语句体2；</p>
<p>}else if(比较表达式3){</p>
<p>语句体3；</p>
<p>}</p>
<p>…</p>
<p>else{</p>
<p>语句体n+1；</p>
<p>}</p>
<p>注意事项：比较表达式无论简单还是复杂，结果必须是boolean类型。</p>
<p>if语句是可以任意嵌套使用的，把语句体n改为if语句即可实现（无论使用if三种格式那种都行）。</p>
<p>\2. switch语句</p>
<p>switch(表达式){</p>
<p>case  值1:</p>
<p>语句体1；</p>
<p>break；</p>
<p>case  值2:</p>
<p>语句体2；</p>
<p>break；</p>
<p>…</p>
<p>default：</p>
<p>语句体n+1；</p>
<p>break；</p>
<p>}</p>
<p>switch:表示这是switch选择结构。</p>
<p>表达式：表达式取值有限定，byte，short，char，int。JDK5以后可以是枚举，JDK7以后可以是字符串。</p>
<p>case后面跟的是要和表达式比较的值。</p>
<p>语句体部分可以是一条或者多条语句</p>
<p>break表示中断，结束的意思，可以结束switch语句。</p>
<p>注意事项：</p>
<p>\1. case后面只能是常量，不能是变量，而且多个case后面的值不能出现相同的。</p>
<p>\2. default可以省略。一般不建议，除非判断的case值是固定的（可以穷举完）。他的作用是对不正确的情况给出提示。</p>
<p>\3. break可以省略。一般不建议，会出现case穿透(可以利用case穿透来实现多个输出结果相同时整合到一起)。最后一个break可以省略。</p>
<p>\4. default位置可以出现在switch语句的任意位置。建议在最后。</p>
<p>\5. switch语句的结束条件：遇到break或者执行到程序的末尾。</p>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>循环语句的组成：</p>
<p>初始化语句：一条或者多条语句，这些语句完成一些初始化操作</p>
<p>判断条件语句：这是一个boolean表达式，这个表达式决定是否执行循环体</p>
<p>循环体语句：要多次循环的语句</p>
<p>控制条件语句：在一次循环结束后，下次循环判断条件执行前执行，通过用于控制循环条件中的变量，使得循环再合适的时候结束</p>
<h2 id="for循环："><a href="#for循环：" class="headerlink" title="for循环："></a>for循环：</h2><p>for(初始化语句；判断条件语句；控制条件语句)｛</p>
<p>循环体语句；</p>
<p>｝</p>
<p>注意事项：判断条件语句的结果是一个boolean类型</p>
<p>循环语句如果是一条语句，大括号可以省略，如果是多条语句，大括号不能省略，建议永远不要省略。</p>
<p>一般来说，有左大括号就没有分号，有分号就没有左大括号。</p>
<p>for循环：求和思想：初始化值为0。</p>
<p>求阶乘思想：初始化值为1。</p>
<p>水仙花数：就是指一个三位数，其各位数字的立方和等于该数本身。eg：153</p>
<h2 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h2><p>基本格式：</p>
<p>while(判断条件语句){</p>
<p>循环体语句；</p>
<p>}</p>
<p>扩展格式：</p>
<p>初始化语句；</p>
<p>while（判断条件语句）｛</p>
<p>循环体语句；</p>
<p>控制条件语句；</p>
<p>｝</p>
<p> for循环和while循环语句可以等价转换，但也存在区别：</p>
<p>使用区别：控制条件语句所控制的那个变量，在for循环结束后，就不能在被访问到了，而while循环结束还可以继续使用。若不使用推荐使用for循环，因为这个变量会从内存中消失，能够提高内存的使用效率。</p>
<p>场景区别：for循环适合针对一个范围判断进行操作，while循环适合判断次数不明确的操作。</p>
<h2 id="do-…-while-循环语句："><a href="#do-…-while-循环语句：" class="headerlink" title="do … while 循环语句："></a>do … while 循环语句：</h2><p>至少执行一次</p>
<p>基本格式：</p>
<p>do{</p>
<p>循环体语句；</p>
<p>}while（判断条件语句）;</p>
<p>扩展格式：</p>
<p>初始化语句；</p>
<p>do｛</p>
<p>循环体语句；</p>
<p>控制条件语句；</p>
<p>｝while（判断条件语句）;</p>
<p>优先考虑for循环，其次是while循环，最后考虑do… while循环。</p>
<p>注意死循环：ctrl+c中断循环</p>
<p>A：注意控制条件语句控制的那个变量的问题，不要丢了，否则会死循环。</p>
<p>B：两种最简单的死循环格式</p>
<p>while（true）｛</p>
<p>｝</p>
<p>for（；；）｛</p>
<p>｝</p>
<p>循环嵌套：循环语句的循环体本身是一个循环语句。</p>
<p>外循环控制行数，内循环控制列数。</p>
<h1 id="控制跳转语句"><a href="#控制跳转语句" class="headerlink" title="控制跳转语句"></a>控制跳转语句</h1><p>****break****：中断</p>
<p>使用场景：离开下面2个场景使用，无意义。</p>
<p>A：switch语句中</p>
<p>B：循环语句中（加入了if判断的情况）</p>
<p>使用：A：跳出单层循环</p>
<p>B：跳出多层循环，必须借助标签。</p>
<p>格式：</p>
<p>标签名： 语句</p>
<p>****continue****：继续</p>
<p>使用场景：循环语句中。（离开此场景无意义）</p>
<p>break和continue的区别：break是跳出单层循环。continue是跳出一次循环，进行下一次的判断执行。</p>
<p>****return****：返回</p>
<p>renturn关键字不是为了跳转出循环体，更常用的功能是结束一个方法，也就是推出一个方法，跳转到上层调用的方法。</p>
<p>一旦遇到return，程序就不会在继续往后执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/4.8.%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8Bif/" data-id="ckqk8k3dk002g2wwd38jk02q5" data-title="程序控制流程if" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-1.5.编程规范" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T02:57:13.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/">编程规范</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><p>遇到左大括号缩进一个tab的位置。</p>
<p>关联不是很大的语句间空行。</p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><p>1.不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</p>
<p>2.严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。（有些国际通用的可以用拼音：renminbi，taobao）</p>
<p>3.驼峰命名。</p>
<p>4.杜绝完全不规范的缩写，避免望文不知义</p>
<p>5.为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。</p>
<p>6.如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p>
<h3 id="类名命名"><a href="#类名命名" class="headerlink" title="类名命名"></a>类名命名</h3><p>1.大写开头（DO / BO / DTO / VO / AO/ PO / UID除外 ）</p>
<p>2.抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾</p>
<p>3.POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p>
<p>4.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。<strong>包名统一使用单数形式</strong>，但是类名如果有复数含义，类名可以使用复数形式。</p>
<p>5.避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低</p>
<p>6.接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。</p>
<p>7.接口和实现类的命名：</p>
<ul>
<li><p>对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用Impl 的后缀与接口区别。CacheServiceImpl 实现 CacheService 接口。</p>
</li>
<li><p>如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）AbstractTranslator 实现 Translatable 接口</p>
</li>
</ul>
<p>8.<strong>枚举类</strong>名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。</p>
<ol start="9">
<li>Service/DAO 层方法命名规约</li>
</ol>
<p>1） 获取单个对象的方法用 get 做前缀。</p>
<p>2） 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。 </p>
<p>3） 获取统计值的方法用 count 做前缀。 </p>
<p>4） 插入的方法用 save/insert 做前缀。</p>
<p>5） 删除的方法用 remove/delete 做前缀。</p>
<p>6） 修改的方法用 update 做前缀。</p>
<p>10.领域模型命名规约</p>
<p>1） 数据对象：xxxDO，xxx 即为数据表名。</p>
<p>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</p>
<p>3） 展示对象：xxxVO，xxx 一般为网页名称。</p>
<p>4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO</p>
<h3 id="方法名，参数名，变量名"><a href="#方法名，参数名，变量名" class="headerlink" title="方法名，参数名，变量名"></a>方法名，参数名，变量名</h3><p>1.小写开头。</p>
<p>2.类型与中括号紧挨相连来表示数组</p>
<p>3.在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度（startTime / workQueue / nameList / TERMINATED_THREAD_COUNT）</p>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>1.常量命名全部大写，单词间用下划线隔开，不要嫌弃太长，一定见名知意。</p>
<p>2.不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</p>
<p>3.在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解</p>
<p>4.不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。（缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。）</p>
<p>5.常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</p>
<p>1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。</p>
<p>2） 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。</p>
<p>3） 子工程内部共享常量：即在当前子工程的 constant 目录下。</p>
<p>4） 包内共享常量：即在当前包下单独的 constant 目录下。</p>
<p>5） 类内共享常量：直接在类内部 private static final 定义。</p>
<p>6.如果变量值仅在一个固定范围内变化用 enum 类型来定义。</p>
<p>7.常量类</p>
<p>static final修饰的字段在javac编译时生成constantValue属性，在类加载的准备阶段直接把constantValue的值赋给该字段。可以理解为在编译期即把结果放入了常量池中。即在类未被加载时static final字段就有了值，这个值不需要对类进行初始化就可以读取，不像static变量，需要类加载后才会有值(类未加载进内存时值为默认值0或null)。</p>
<p>注：1.ConstantValue修饰的字段<strong>只限于基本类型和string</strong>。</p>
<p>   2.ConstantValue修饰的字段若为String类型，必须要是编译期可以进行优化得到的即编译期常量才能满足不需要对类进行初始化就可以读取(例如：String s = “a”+“bc”；)，否则这个值需要对类进行初始化才可以读取(例如：String s = new String(“abc”)；)。</p>
<p>   3.对于满足上两个条件的constantValue变量，在访问该变量时，无需初始化类即可访问(即访问时在常量池中寻找，不会执行类的静态成员和静态代码块)。</p>
<h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p>1.如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块则： </p>
<p>1） 左大括号前不换行。<br>2） 左大括号后换行。<br>3） 右大括号前换行。<br>4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行</p>
<p>2.左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左大括号前需要空格。</p>
<p>3.if/for/while/switch/do 等保留字与括号之间都必须加空格。</p>
<p>4.任何二目、三目运算符的左右两边都需要加一个空格。</p>
<p>5.采用 4 个空格缩进，禁止使用 tab 字符</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 缩进 4 个空格 </span></span><br><span class="line">    String say = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line">    <span class="comment">// 运算符的左右必须有一个空格 </span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 </span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123; </span><br><span class="line">        System.out.println(say); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 左大括号前加空格且不换行；左大括号后换行 </span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;world&quot;</span>); </span><br><span class="line">    <span class="comment">// 右大括号前换行，右大括号后有 else，不用换行 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>); </span><br><span class="line">    <span class="comment">// 在右大括号后直接结束，则必须换行 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.注释的双斜线与注释内容之间有且仅有一个空格</p>
<p>7.在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。</p>
<p>8.单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：<br>1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进。<br>2）运算符与下文一起换行。<br>3）方法调用的点符号与下文一起换行。<br>4）方法调用中的多个参数需要换行时，在逗号后进行。 </p>
<p>5）在括号前不要换行，在逗号前不要换行</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(); </span><br><span class="line"><span class="comment">// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行</span></span><br><span class="line">sb.append(<span class="string">&quot;Jack&quot;</span>).append(<span class="string">&quot;Ma&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>)... </span><br><span class="line">.append(<span class="string">&quot;alibaba&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>9.方法参数在定义和传入时，多个参数逗号后边必须加空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method(args1, args2, args3);</span><br></pre></td></tr></table></figure>

<p>10.IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式。</p>
<p>11.单个方法的总行数不超过 80 行（除注释之外的所有行数）</p>
<p>代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护</p>
<p>12.没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐</p>
<p>13.不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性（任何情形，没有必要插入多个空行进行隔开）</p>
<h2 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h2><p>1.避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可</p>
<p>2.所有的覆写方法，必须加@Override 注解</p>
<p>3.相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。（提倡同学们尽量不用可变参数编程）</p>
<p>4.外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</p>
<p>5.不能使用过时的类或方法（接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么）</p>
<p>6.Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。推荐使用 java.util.Objects#equals（JDK7 引入的工具类）。</p>
<p>7.所有整型包装类对象之间值的比较，全部使用 equals 方法比较</p>
<p>对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。</p>
<p>8.浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals 来判断。</p>
<p>浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line"> <span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"> <span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line"> <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line"> <span class="comment">// 预期进入此代码快，执行其它业务逻辑</span></span><br><span class="line"> <span class="comment">// 但事实上 a==b 的结果为 false</span></span><br><span class="line"> &#125;</span><br><span class="line"> Float x = Float.valueOf(a);</span><br><span class="line"> Float y = Float.valueOf(b);</span><br><span class="line"> <span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line"> <span class="comment">// 预期进入此代码快，执行其它业务逻辑</span></span><br><span class="line"> <span class="comment">// 但事实上 equals 的结果为 false</span></span><br><span class="line"> &#125; </span><br><span class="line">正例：</span><br><span class="line">(<span class="number">1</span>) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。</span><br><span class="line"> <span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"> <span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line"> <span class="keyword">float</span> diff = <span class="number">1e-6f</span>;</span><br><span class="line"> <span class="keyword">if</span> (Math.abs(a - b) &lt; diff) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">(<span class="number">2</span>) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。</span><br><span class="line"> BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"> BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"> BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"> BigDecimal x = a.subtract(b);</span><br><span class="line"> BigDecimal y = b.subtract(c);</span><br><span class="line"> <span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>9.定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。</p>
<p>数据库字段的 bigint 必须与类属性的 Long 类型相对应。</p>
<p>10.为了防止精度损失，禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常</p>
<p>如：BigDecimal g = new BigDecimal(0.1f); 实际的存储值为：0.10000000149  </p>
<p>需使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal recommend1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">BigDecimal recommend2 = BigDecimal.valueOf(<span class="number">0.1</span>);</span><br></pre></td></tr></table></figure>

<p>11.关于基本数据类型与包装数据类型的使用标准：</p>
<ul>
<li><p>所有的 POJO 类属性必须使用包装数据类型。</p>
</li>
<li><p>RPC 方法的返回值和参数必须使用包装数据类型。</p>
</li>
<li><p>所有的局部变量使用基本数据类型。</p>
</li>
</ul>
<p>POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p>
<h2 id="MySQL-数据库-规范"><a href="#MySQL-数据库-规范" class="headerlink" title="MySQL 数据库 规范"></a>MySQL 数据库 规范</h2><h3 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h3><p>1.表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。任何字段如果为非负数，必须是 unsigned。</p>
<p>POJO 类中的任何布尔类型的变量，都不要加 is 前缀。</p>
<p>2.表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。不允许出现任何大写字母（因为MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写）</p>
<p>3.表名不使用复数名词。DO 类名也是单数形式</p>
<p>4.禁用保留字，如 desc、range、match、delayed 等</p>
<p>5.主键索引名（primary key）为 <code>pk_字段名</code>；唯一索引名（unique key）为 <code>uk_字段名</code>；普通索引名（ index）则为 <code>idx_字段名</code></p>
<p>6.小数类型为 decimal，禁止使用 float 和 double（在存储的时候，float 和 double 都存在精度损失的问题）。存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储</p>
<p>7.如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
<p>8.varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
<p>9.表必备三字段：id（必为主键，类型为 bigint unsigned、单表时自增、步长为 1）, create_time, update_time（类型均为 datetime 类型）。</p>
<p>10.表的命名最好是遵循“业务名称_表的作用”</p>
<p>11.库名与应用名称尽量一致</p>
<p>12.如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释</p>
<p>13.字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p>
<p>1） 不是频繁修改的字段。</p>
<p>2） 不是 varchar 超长字段，更不能是 text 字段。</p>
<p> 3） 不是唯一索引的字段。</p>
<p>14.单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表（预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表）</p>
<p>15.合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。无符号值（unsigned）可以避免误存负数，且扩大了表示范围。</p>
<p>对象 年龄区间 类型 字节 表示范围</p>
<p>人 150 岁之内 tinyint unsigned 1 无符号值：0 到 255</p>
<p>龟 数百岁 smallint unsigned 2 无符号值：0 到 65535</p>
<p>恐龙化石 数千万年 int unsigned 4 无符号值：0 到约 42.9 亿</p>
<p>太阳 约 50 亿年 bigint unsigned 8 无符号值：0 到约 10 的 19 次方</p>
<p>16.尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。在设置默认值的时候，尽量不要用Null来当默认值，如果字段是int类型，默认为0，如果是varchar类型，默认值用空字符串（’’）会更好一些</p>
<p>17.习惯是任何数据表的任何列都是非空（NOT NULL），在此基础上将数字默认设为0，文本默认设为’’（在PHPMyAdmin中留空）</p>
<h3 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h3><p>1.业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。（唯一索引影响 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。没有唯一索引的话，必然有脏数据产生）</p>
<p>2.超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引（双表join时也要注意表索引、SQL性能）</p>
<p>3.在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定</p>
<p>4.页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决（索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。）</p>
<p>5.order by：注意利用索引的有序性（order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能）</p>
<p>6.利用覆盖索引来进行查询操作，避免回表（覆盖索引只是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index）</p>
<p>7.利用延迟关联或者子查询优化超多分页场景</p>
<p>8.SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。</p>
<p>1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</p>
<p>2） ref 指的是使用普通的索引（normal index）。 </p>
<p>3） range 对索引进行范围检索。</p>
<p>type=index,索引物理文件全扫描，速度非常慢，这个 index 级别比较 range还低，与全表扫描是小巫见大巫</p>
<p>9.建组合索引的时候，区分度最高的在最左边</p>
<p>10.防止因字段类型不同造成的隐式转换，导致索引失效</p>
<p>11.创建索引时,注意避免:</p>
<p>1） 宁滥勿缺。认为一个查询就需要建一个索引。</p>
<p>2） 宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</p>
<p>3） 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p>
<h3 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><p>1.不要使用 count(列名)或 count(常量)来替代 <code>count(*)</code>，<code>count(*)</code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
<p>2.count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p>
<p>3.当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。</p>
<p>使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table;</p>
<p>4.使用 ISNULL()来判断是否为 NULL 值。NULL 与任何值的直接比较都为 NULL</p>
<p>5.代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p>
<p>6.不得使用外键与级联，一切外键概念必须在应用层解决</p>
<p>7.禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
<p>8.数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p>
<p>9.in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</p>
<p>10.所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。当需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别</p>
<p>11.TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。</p>
<p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
<h3 id="ORM-映射"><a href="#ORM-映射" class="headerlink" title="ORM 映射"></a>ORM 映射</h3><p>1.在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明</p>
<p>1）增加查询分析器解析成本。</p>
<p>2）增减字段容易与 resultMap 配置不一致。</p>
<p>3）无用字段增加网络消耗，尤其是 text 类型的字段。</p>
<p>2.POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。</p>
<p>3.不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个 POJO 类与之对应。</p>
<p>配置映射关系，使字段与 DO 类解耦，方便维护。</p>
<p>4.sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入</p>
<p>5.iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。（因为它的实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取start,size 的子集合）</p>
<p>6.不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p>
<p>resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控</p>
<p>7.更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p>
<p>8.不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p>
<p>9.@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p>
<p>10.<code>&lt;isEqual&gt;</code>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；&lt;isNotEmpty&gt;表示不为空且不为 null 时执行；<code>&lt;isNotNull&gt;</code>表示不为 null 值时执行。 </p>
<h2 id="自己的项目规范："><a href="#自己的项目规范：" class="headerlink" title="自己的项目规范："></a>自己的项目规范：</h2><p>1.同级之间不要互相调用，上层只能调用下层，避免混乱。</p>
<p>2.swagger注解</p>
<ul>
<li><p>controller类上： </p>
<p>@Api(value=””,tags=””)</p>
</li>
<li><p>controller类里的方法：<br>@ApiOperation(value=””,notes=””)</p>
<p>@ApiParam(value = “”)</p>
<p>@ApiImplicitParams(</p>
<pre><code>        @ApiImplicitParam(name = &quot;&quot;, value = &quot;&quot;,paramType = &quot;&quot;,required = true, dataType = &quot;&quot;)
)
</code></pre>
<p>​    @ApiResponses({<br>​            @ApiResponse(code = 0, message = “”,class=””)<br>​<br>​    })</p>
</li>
<li><p>类上：<br>@ApiModel(value = “”,description=””)</p>
</li>
<li><p>类的字段上：<br>@ApiModelProperty(value=””)</p>
</li>
</ul>
<p>3.查数据用get，删，改，增数据用post</p>
<p>4.<strong>改东西前，加个备份,改东西后，加个记录</strong></p>
<p>5.</p>
<h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h2><p>前后端接口规范：解耦接口，尽量不要用大接口。可以用公共的接口，但是尽量是前端需要什么信息，传递什么信息，不要查到所有信息再返回给前端。因为尽量避免暴露数据库表结构，避免传递不必要的信息。</p>
<p>前端传过来的数据也要做数据校验（即使前端已经做过校验），因为可能是通过接口发送的参数，绕过了前端页面</p>
<h2 id="RESTful-架构"><a href="#RESTful-架构" class="headerlink" title="RESTful 架构"></a>RESTful 架构</h2><p>RESTful 只是一种指导风格，就像我们 Java 要用驼峰命名法。</p>
<p>REST 不是一个单词，是 Representational State Transfer 的缩写。直译过来就是表述性状态转移。其实它还有个主语 Resource ，所以是资源的表述性状态转移。</p>
<p><strong>核心</strong>就是资源，用 URL 定位资源，用 HTTP 动词来描述所要做的操作。</p>
<p>HTTP的提供了很多动词：GET、PUT、POST、DELETE……这些动词都是有含义的。</p>
<p>比如：</p>
<p>GET 就是获取资源，是查询请求。</p>
<p>PUT 指的是修改资源，是幂等的。</p>
<p>POST 也是修改(新增也是一种修改)，指的是不幂等的操作。</p>
<p>所以根据这些规范我们都能得知这次交互的一些动作，所以 RESTful 风格正确的使用姿势如下：</p>
<p>比如获取一个 user：</p>
<p>​    错误姿势：<code>GET /getUserById?userId=1</code>。</p>
<p>​    正确姿势：<code>GET /users/1</code>。</p>
<p>再比如新增 user：</p>
<p>​    错误姿势：<code>POST /addUser</code> （省略body）。</p>
<p>​    正确姿势：<code>POST /users</code> （省略body）。</p>
<p>可以看到 HTTP 的动词其实就能指代你要对资源做的操作，所以不需要在 URL 上做一些东西，就把 URL 表明的东西看作一个资源即可。</p>
<p>这里注意要用对 HTTP 动词，比如一个获取资源的请求用 PUT，用了也能获取资源但是这不合适。</p>
<p>其实更深一步的理解是  HTTP 是一个协议。</p>
<p>协议其实就是约定好的一个东西，协议就规定 GET 是获取资源，那你非得在 URL 上再重复一遍或者所有请求不论增删改都用 GET 这个动作，这其实就是没有完全遵循这个协议。</p>
<p>可以说只是把 HTTP 当成一个传输管道，而不是约定好的协议。</p>
<p>这其实是对 HTTP 更深一层的认识，我认为也是 RESTful 被推出的原因。</p>
<p>当然理想很丰满，现实很骨感，还是有很多人就 <code>getUserById</code>。</p>
<p>不过我个人觉得问题不大，公司统一就行。</p>
<h2 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h2><p>即 Hypermedia as the Engine of Application State 的缩写，翻译过来就是作为应用状态引擎的超媒体。</p>
<p>这也是 REST 提出的设计。</p>
<p>比如你请求获取用户列表：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /users</span><br><span class="line">Accept: application/json+userdb</span><br></pre></td></tr></table></figure>

<p>此时的返回应该是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Content-Type: application/json+userdb</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;users&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 1,</span><br><span class="line">            &quot;name&quot;: &quot;Emil&quot;,</span><br><span class="line">            &quot;country: &quot;Sweden&quot;,</span><br><span class="line">            &quot;links&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/user/1&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;self&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;GET&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/user/1&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;edit&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;PUT&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;href&quot;: &quot;/user/1&quot;,</span><br><span class="line">                    &quot;rel&quot;: &quot;delete&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 2,</span><br><span class="line">           ....省略.....</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;links&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;href&quot;: &quot;/user&quot;,</span><br><span class="line">            &quot;rel&quot;: &quot;create&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;POST&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点就是这个 links，结果会返回你能对这个资源所做的操作。</p>
<p>比如对于 userId 是 1 的，你调用<code>PUT /user/1</code>就是做修改这个用户，<code>DELETE /user/1</code>就是删除这个用户。</p>
<p>最外层的 links 告诉你用 <code>POST /user</code> 就能再创建一个用户。</p>
<p>这里还有个隐藏信息，可以看到外层的 links 没有返回 DELETE 的信息，说明此时客户端无法删除用户！</p>
<p>所以说 RESTful API 还需要再返回此时能对资源做的操作，这样客户端就知道它能做什么。</p>
<p>它也不需要管具体怎么做，反正返回里面会告诉它 DELETE 就这样这样，POST 就这样这样。</p>
<p>没告诉它的就是不能做的。</p>
<p>然后这个时候再去理解下资源的表述性状态转移，是不是感觉来了？</p>
<p>如果说上一 part 提到用 HTTP 的动词来指代动作， URL 仅表示资源的现实是骨感的。</p>
<p>那么 HATEOAS 的现实就是骨灰。</p>
<p>基本上没几家公司会这么做。</p>
<p>就我个人而言这玩意没啥用。</p>
<p>它的出发点是让客户端从响应就能得知对资源操作的入口，并且通过响应得知哪些动作能执行。</p>
<p>听起来好像有点用，但是就我目前的功力，我只能看到响应变得十分冗余。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章关于 RESTful API 具体的写法我就提到一些，还有挺多的就自己查资料吧。</p>
<p>文章的目的是为了让你理解 RESTful API，我再总结一下重点。</p>
<p>HTTP 是协议，不是传输通道。（对协议不理解的看我之前的 HTTP 分析）</p>
<p>所以协议约定了很多东西，推荐我们按照协议的用法进行客户端和服务端的交互。</p>
<p>也就是 RESTful 表明的面向资源，通过 HTTP 动作 + URL 上的资源。</p>
<p>RESTful 还提到了 HATEOAS，虽说基本上没什么公司会这样使用，但是它能让你更好的理解 REST 这个名字的含义。</p>
<p>RESTful 是一种风格，你是否采用这种风格对你的程序运行没有影响，类比驼峰命名来思考。</p>
<p>简而言之，RESTful 就是不要在 URL 上表现出动作，用 HTTP 动词代表动作，URL 上只做资源。</p>
<p>仅此而已。</p>
<p>至于要不要严格遵循 RESTful 风格，我个人的看法是公司内部保持一致就行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/15/1.5.%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" data-id="ckqk8k3e1003v2wwd43s46yp9" data-title="编程规范" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-5.3.MySQL踩坑" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/13/5.3.MySQL%E8%B8%A9%E5%9D%91/" class="article-date">
  <time class="dt-published" datetime="2021-04-12T16:40:08.000Z" itemprop="datePublished">2021-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/13/5.3.MySQL%E8%B8%A9%E5%9D%91/">MySQL踩坑</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="关于数据库时区说明"><a href="#关于数据库时区说明" class="headerlink" title="关于数据库时区说明"></a>关于数据库时区说明</h2><p>2016-12-07T03:13:25.808Z:T是代表后面跟着“时间”。Z代表0时区，<br>这是UTC统一时间</p>
<p>时间的描述：</p>
<p>mysql数据库拥有时区设置，默认使用系统时区</p>
<p>可通过如下语句查询当前时区</p>
<p><code>show variables like &#39;%time_zone%&#39;;</code></p>
<p>数据库使用系统时间CST——China Standard Time UTC+8:00 中国沿海时间(北京时间)</p>
<p>​     UTC:国际时间</p>
<p>​    UTC-8:伦敦时间</p>
<p>​    UTC+8就是国际时加八小时,是东八区时间,也就是北京时间</p>
<p>GMT，即格林尼治标准时间，也就是世界时。GMT的正午是指当太阳横穿格林尼治子午线（本初子午线）时的时间。但由于地球自转不均匀不规则，导致GMT不精确，现在已经不再作为世界标准时间使用。</p>
<p>UTC，即协调世界时。UTC是以原子时秒长为基础，在时刻上尽量接近于GMT的一种时间计量系统。为确保UTC与GMT相差不会超过0.9秒，在有需要的情况下会在UTC内加上正或负闰秒。UTC现在作为世界标准时间使用。</p>
<p>所以，UTC与GMT基本上等同，误差不超过0.9秒</p>
<p>RTC，硬件时间，主板上面bios的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String dateTime = <span class="string">&quot;2019-06-27T16:00:00.000Z&quot;</span>;</span><br><span class="line"></span><br><span class="line">dateTime = dateTime .replace(<span class="string">&quot;Z&quot;</span>, <span class="string">&quot; UTC&quot;</span>); <span class="comment">//2019-06-27T16:00:00.000 UTC</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat format1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS Z&quot;</span>);<span class="comment">//转换时区格式</span></span><br><span class="line">SimpleDateFormat format2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"></span><br><span class="line">Date date = format1.parse(dateTime ) || <span class="keyword">long</span> ldate = format1.parse(dateTime ).getTime();<span class="comment">//将Z时间格式转换成Date类型格式或换成毫秒</span></span><br><span class="line">String time= format2.format(date);<span class="comment">//2019-06-28</span></span><br><span class="line"></span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2019</span>-<span class="number">06</span>-<span class="number">28</span></span><br></pre></td></tr></table></figure>

<p>时间类型说明</p>
<p>datetime</p>
<p>实际格式储存（Just stores what you have stored and retrieves the same thing which you have stored.）</p>
<p>与时区无关（It has nothing to deal with the TIMEZONE and Conversion.）</p>
<p>timestamp</p>
<p>值以UTC毫秒数保存（ it stores the number of milliseconds）</p>
<p>存储及检索时根据当前时区设置，对时间数值做转换</p>
<p>由于timestamp与时区相关，且线上数据库时区设置为北京时间（即UTC+8:00）。因此，当数据库中使用了timestamp列，若使用不当，统一UTC格式时间改造将很可能会引入错误！</p>
<h2 id="关于时间查询的sql语句"><a href="#关于时间查询的sql语句" class="headerlink" title="关于时间查询的sql语句"></a>关于时间查询的sql语句</h2><p>在项目开发过程中，自己需要查询出一定时间段内的交易。故需要在sql查询语句中加入日期时间要素，sql语句如何实现?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM lmapp.lm_bill where tx_time Between &#39;2015-12-20&#39; And &#39;2015-12-31&#39;;</span><br></pre></td></tr></table></figure>

<p>查询每一天某个时间段的所有记录(例:9:00:00到21:00:00)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 </span><br><span class="line">WHERE DATE_FORMAT(create_time,&#39;%H:%i:%S&#39;)&gt;&#x3D;&#39;09:00:00&#39;</span><br><span class="line">and DATE_FORMAT(create_time,&#39;%H:%i:%S&#39;)&lt;&#x3D;&#39;21:00:00&#39; </span><br><span class="line">ORDER BY 排序字段 ASC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mysql 查询当天、最近一天、最近一周，本月，上一个月的数据</p>
<p>今天<br><code>select * from 表名 where to_days(时间字段名) = to_days(now());</code></p>
<p>昨天</p>
<p><code>SELECT * FROM 表名 WHERE TO_DAYS( NOW( ) ) - TO_DAYS( 时间字段名) &lt;= 1</code><br>7天</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;&#x3D; date(时间字段名)</span><br></pre></td></tr></table></figure>

<p>近30天</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;&#x3D; date(时间字段名)</span><br></pre></td></tr></table></figure>

<p>本月</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE DATE_FORMAT( 时间字段名, &#39;%Y%m&#39; ) &#x3D; DATE_FORMAT( CURDATE( ) , &#39;%Y%m&#39; )</span><br></pre></td></tr></table></figure>

<p>上一月</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE PERIOD_DIFF( date_format( now( ) , &#39;%Y%m&#39; ) , date_format( 时间字段名, &#39;%Y%m&#39; ) ) &#x3D;1</span><br></pre></td></tr></table></figure>



<p>SELECT id FROM m_question WHERE cratedate BETWEEN<br>‘2018-05-31 12:00:00’ and ‘2018-06-26 14:59:59’ ORDER BY id DESC<br>或者<br>SELECT id FROM m_question WHERE cratedate &gt;<br>‘2018-05-31 12:00:00’ and cratedate &lt; ‘2018-06-26 14:59:59’ ORDER BY id DESC<br>但是between and 包含时间界限，也相当于&gt;= &lt;=，而&gt; &lt;不包含</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Select  *  from mytable where  DateField1&lt;&#x3D;&#39;2010-1-31&#39;</span><br><span class="line"></span><br><span class="line">Select  *  from mytable where  DateField1&lt;&#x3D;&#39;2010-1-31 0:0:0&#39;</span><br><span class="line"></span><br><span class="line">Select  *  from mytable where  DateField1&lt; &#39;2010-2-1&#39;</span><br><span class="line"></span><br><span class="line">Select  *  from mytable where  DateField1&lt;&#39;2010-2-1 0:0:0&#39;</span><br></pre></td></tr></table></figure>

<p>如果DateField1 里面有 值为 2010-1-31 ，我们不建议用 语句1 或者 语句 2，因为由于数据库的数据精度和编程语言的数据精度不一致，</p>
<p>使用&lt;= 会导致无法取得 2010-1-31 的数据</p>
<h2 id="关于数据库enum类型"><a href="#关于数据库enum类型" class="headerlink" title="关于数据库enum类型"></a>关于数据库enum类型</h2><p>避免使用ENUM数据类型（修改ENUM值需要使用ALTER语句，ENUM类型的ORDER BY操作效率低，需要额外操作，禁止使用书值作为ENUM的枚举值</p>
<p>不要拿mysql的enum类型取存一些数字；如果你一定要使用这个字段去存数字，请把这个字段定义为int，然后在java代码中使用枚举类做一个对于这个字段值范围的一个限定</p>
<h2 id="关于数据库字符集utf8和utf8mb4的区别"><a href="#关于数据库字符集utf8和utf8mb4的区别" class="headerlink" title="关于数据库字符集utf8和utf8mb4的区别"></a>关于数据库字符集utf8和utf8mb4的区别</h2><p>MySQL 的“utf8mb4”是真正的“UTF-8”</p>
<p>MySQL 的“utf8”是一种“专属的编码”，它能够编码的 Unicode 字符并不多</p>
<p>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode</p>
<p>好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就够了</p>
<p>为了获取更好的兼容性，应该总是使用 utf8mb4 而非 utf8. 对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，根据 Mysql 官方建议，使用 VARCHAR 替代 CHAR。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/13/5.3.MySQL%E8%B8%A9%E5%9D%91/" data-id="ckqk8k3dk002j2wwd1t6qeymv" data-title="MySQL踩坑" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-5.1.MySQL初级" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/13/5.1.MySQL%E5%88%9D%E7%BA%A7/" class="article-date">
  <time class="dt-published" datetime="2021-04-12T16:39:03.000Z" itemprop="datePublished">2021-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/13/5.1.MySQL%E5%88%9D%E7%BA%A7/">MySQL初级</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>关系型数据库</p>
<p>服务器：</p>
<p>​    硬件：指的就是一台计算机</p>
<p>​    软件：指的是需要在这台电脑上安装数据库服务器</p>
<p>一台电脑如果安装了MySQL，这台电脑称为是MySQL数据库服务器</p>
<p>MySQL数据库服务器存储的方式：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml5948\wps1.jpg" alt="img"> </p>
<p>一台数据库服务器中会创建很多数据库（一个项目，会创建一个数据库）。在数据库中会创建很多张表（一个实体会创建一个表）。在表中会有很多记录（一个对象的实例会添加一条新的记录）。</p>
<p>SQL：结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=51720422&ss_c=ssc.citiao.link">数据库查询和程序设计语言</a>，用于存取数据以及查询、更新和管理关系数据库系统；同时也是<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=71639443&ss_c=ssc.citiao.link">数据库脚本文件</a>的<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=190718&ss_c=ssc.citiao.link">扩展名</a>。</p>
<p>分类：</p>
<p>​    DDL：数据定义语言：create，drop，alter..</p>
<p>​    DCL：数据控制语言：grant，if…</p>
<p>​    DML：数据操纵语言：insert，update，delete…</p>
<p>​    DQL：数据查询语言：select   （不区分大小写）</p>
<h2 id="对数据库进行CRUD的操作"><a href="#对数据库进行CRUD的操作" class="headerlink" title="对数据库进行CRUD的操作"></a>对数据库进行CRUD的操作</h2><h3 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h3><p>语法：</p>
<p><code>create database 数据库名称 [character set 字符集 collate 字符集校对规则]; </code>  </p>
<p>utf-8的字符集写的时候是utf8</p>
<p>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode，比如emoji表情</p>
<p>为了获取更好的兼容性，应该总是使用 utf8mb4 而非 utf8.  对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，根据 Mysql 官方建议，使用 VARCHAR  替代 CHAR</p>
<p>字符集校对规则可以在查询手册中查到，用来数据库排序展示</p>
<h3 id="查看数据库："><a href="#查看数据库：" class="headerlink" title="查看数据库："></a>查看数据库：</h3><p>语法：</p>
<p>查看数据库服务器中所有的数据库：<code>show databases;</code></p>
<p>查看某个数据库的定义信息： <code>show create database 数据库名称;</code></p>
<h3 id="修改数据库："><a href="#修改数据库：" class="headerlink" title="修改数据库："></a>修改数据库：</h3><p>语法：</p>
<p><code>alter database 数据库名称 character set 字符集 collate 校对规则;</code></p>
<h3 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h3><p>语法:</p>
<p><code>drop database 数据库名称;</code></p>
<h3 id="其他数据库操作："><a href="#其他数据库操作：" class="headerlink" title="其他数据库操作："></a>其他数据库操作：</h3><p>切换数据库：<code>use 数据库名称;</code></p>
<p>查看当前正在使用的数据库：<code>select database();</code></p>
<h2 id="对数据库表进行操作"><a href="#对数据库表进行操作" class="headerlink" title="对数据库表进行操作"></a>对数据库表进行操作</h2><table>
<thead>
<tr>
<th>Java中的类型</th>
<th>MySQL中的类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte/short/int/long</td>
<td>tinyint/smallint/int/bigint</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>double</td>
<td>double</td>
</tr>
<tr>
<td>boolean</td>
<td>bit</td>
</tr>
<tr>
<td>char/String</td>
<td>char和varchar类型</td>
</tr>
<tr>
<td>Date</td>
<td>date/time/datetime/timestamp</td>
</tr>
<tr>
<td>File</td>
<td>BLOB/TEXT</td>
</tr>
</tbody></table>
<p><img src="/5.1.MySQL%E5%88%9D%E7%BA%A7/830738-20191225205655031-1448819652.png" alt="img"></p>
<p>tinyint 型的字段如果设置为unsigned类型，只能存储从0到255的整数,不能用来储存负数。<br>tinyint 型的字段如果不设置unsigned类型,存储-128到127的整数。<br>1个tinyint型数据只占用一个字节;一个INT型数据占用四个字节。<br>这看起来似乎差别不大，但是在比较大的表中，字节数的增长是很快的。<br>    tinyint(1)与tinyint(2)的区别可以从下面看出来:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (                                  </span><br><span class="line">   `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,                </span><br><span class="line">   `str` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                                     </span><br><span class="line">   `state`  tinyint(<span class="number">1</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,   </span><br><span class="line">   `state2` tinyint(<span class="number">2</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">   `state3` tinyint(<span class="number">3</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">   `state4` tinyint(<span class="number">4</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY (`id`)                                   </span><br><span class="line"> ) ENGINE<span class="operator">=</span>MyISAM AUTO_INCREMENT<span class="operator">=</span><span class="number">6</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8  </span><br><span class="line">         </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test (str,state,state2,state3,state4) <span class="keyword">values</span>(<span class="string">&#x27;csdn&#x27;</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">id   str   state   state2   state3   state4 </span><br><span class="line"><span class="number">1</span>    csdn  <span class="number">4</span>        <span class="number">04</span>       <span class="number">004</span>     <span class="number">0004</span> </span><br><span class="line"></span><br><span class="line">于是在dll里面channel` tinyint(<span class="number">2</span>) unsigned zerofill <span class="keyword">DEFAULT</span> ‘<span class="number">00</span>’</span><br></pre></td></tr></table></figure>

<p>问题来了，2指的是存储宽度，不表示存储长度。如果列制定了zerofill 就会用0填充显示，例如tinyint(2)指定后2就会显示为02，自动左边补零</p>
<p>char和varchar的区别：</p>
<p>​    char代表是固定长度的字符或字符串。定义类型char(8),向这个字段存入字符串hello，那么数据库使用三个空格将其补全。</p>
<p>​    varchar代表的是可变长度的字符串。定义类型varchar(8), 向这个字段存入字符串hello,那么存入到数据库的就是hello。</p>
<p>datetime和timestamp区别：</p>
<p>​    datetime就是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库使用null存入到数据库中。</p>
<p>​    timestamp也是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库使用当前的系统时间存入到数据库中。</p>
<p>BLOB是二进制的文件，TEXT是文本类型的文件（都很少使用）</p>
<h2 id="约束："><a href="#约束：" class="headerlink" title="约束："></a>约束：</h2><p>约束作用：保证数据的完整性</p>
<p>单表约束分类：</p>
<p>​    主键约束：primary key 主键约束默认就是唯一 非空的</p>
<p>​    唯一约束：unique</p>
<p>​    非空约束：not null</p>
<h3 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a>创建表：</h3><p>语法：<code>create table 表名称(字段名称 字段类型(长度) 约束,字段名称 字段类型(长度) 约束…);</code></p>
<p>字段类型：一个实体对应一个表，一个实体属性对应表的一个字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database web_test1;</span><br><span class="line"></span><br><span class="line">use web_test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line"></span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line"></span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span>,</span><br><span class="line"></span><br><span class="line">	password <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"></span><br><span class="line">	age <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line">	birthday <span class="type">date</span></span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="查看表："><a href="#查看表：" class="headerlink" title="查看表："></a>查看表：</h3><p>查看某个数据库下的所有的表： （必须先切换到这个数据库）</p>
<p>语法：<code>show tables;</code></p>
<p>查看某个表的结构信息：</p>
<p>语法：<code>desc 表名; </code>（只是结构信息）</p>
<h3 id="删除表："><a href="#删除表：" class="headerlink" title="删除表："></a>删除表：</h3><p>语法：<code>drop table 表名;</code></p>
<h3 id="修改表："><a href="#修改表：" class="headerlink" title="修改表："></a>修改表：</h3><p>​    添加列：<code>alter table 表名 add 列名 类型(长度) 约束;</code></p>
<p>​    修改列类型，长度和约束：<code>alter table 表名 modify 列名 类型(长度) 约束;</code></p>
<p>​    删除列：<code>alter table 表名 drop 列名;</code></p>
<p>​    修改列名称：<code>alter table 表名 change 旧列名 新列名 类型(长度) 约束;</code></p>
<p>​    修改表名：<code>rename table 表名 to 新的表名;</code></p>
<p>​    修改表的字符集：<code>alter table 表名 character set 字符集;</code></p>
<h2 id="对数据库表的记录进行操作"><a href="#对数据库表的记录进行操作" class="headerlink" title="对数据库表的记录进行操作"></a>对数据库表的记录进行操作</h2><h3 id="添加表的记录："><a href="#添加表的记录：" class="headerlink" title="添加表的记录："></a>添加表的记录：</h3><p>语法：</p>
<p>​    向表中插入某些列：<code>insert into 表名 (列名1,列名2,列名3…) values (值1,值2,值3…)</code></p>
<p>​    向表中插入所有列：<code>insert into 表名 values (值1,值2,值3…);</code></p>
<p>//id一般是自动增长的，所以可以把值写为null</p>
<p>注意事项</p>
<p>1.值的类型与数据库中表列的类型一致。</p>
<p>2.值的顺序与数据库中表列的顺序一致。</p>
<p>3.值的最大长度不能超过列设置最大长度。</p>
<p>4.值的类型是字符串或者是日期类型，使用单引号引起来。</p>
<p>直接向数据库中插入中文记录会出现错误！ </p>
<p>解决方法：</p>
<ol>
<li><code>show variables like &#39;%character%&#39;; </code> –查看数据库中与字符集相关参数（数据库中都是utf8，而命令行中的是gbk）所以需要将MySQL数据库服务器中的客户端部分的字符集改为gbk。MySQL数据库服务器中的服务端还是utf8，但是MySQL数据库服务器已经可以识别了。</li>
</ol>
<p>​    2.找到MySQL的安装路径：my.ini文件，修改文件中[client]下的字符集，重新启动MySQL数据库服务器（在搜索程序和文件中输入 services.msc 打开服务 界面，找到MySQL停止，再启动），再<code>show variables like &#39;%character%&#39;; </code> 就可以看到改成功了。</p>
<h3 id="修改表的记录："><a href="#修改表的记录：" class="headerlink" title="修改表的记录："></a>修改表的记录：</h3><p>语法:<code>update 表名 set 列名=值,列名=值 [where 条件];</code></p>
<p>注意事项</p>
<p>1.值的类型与列的类型一致。</p>
<p>2.值的最大长度不能超过列设置的最大长度。</p>
<p>3.字符串类型和日期类型添加单引号。</p>
<h3 id="删除表的记录："><a href="#删除表的记录：" class="headerlink" title="删除表的记录："></a>删除表的记录：</h3><p>语法：<code>delete from 表名 [where 条件];</code></p>
<p>注意事项</p>
<p>1.删除表的记录，指的是删除表中的一行记录。</p>
<p>2.删除如果没有条件，默认是删除表中的所有记录。</p>
<p>删除表中的记录有两种做法:</p>
<p><code>delete from user;</code> 删除所有记录，属于DML语句，一条记录一条记录删除。事务可以作用在DML语句上的（可以回滚）</p>
<p><code>truncate table user;</code>删除所有记录，属于DDL语句，将表删除，然后重新创建一个结构一样的表。事务不能控制DDL的（真的删除掉了）</p>
<h3 id="查看表的记录："><a href="#查看表的记录：" class="headerlink" title="查看表的记录："></a>查看表的记录：</h3><p>基本查询：</p>
<p>语法:</p>
<p><code>select  [distinct]  *|列名 from 表 [条件];</code></p>
<p>[]代表可选，就是可加可不加。distinct表示不重复的</p>
<p>*|列名 中的列名可以进行运算的。select name,english+chinese+math from exam;</p>
<p>也可以取个别名进行查询：</p>
<p>select name,english+chinese+math as sum from exam; （as有没有都可以）</p>
<p>条件查询：使用where子句：</p>
<p>&gt; , &lt; , &gt;= , &lt;= , &lt;&gt;（不等于） ,=</p>
<p>like:模糊查询（like可以进行模糊查询,在like子句中可以使用_或者%作为占位符。_只能代表一个字符，而%可以代表任意个字符。）</p>
<p>in:范围查询  （in后面跟的是范围）</p>
<p>条件关联:and , or ,not  （多个条件时可以使用）</p>
<p>排序查询：</p>
<p>使用order by 字段名称 asc/desc;</p>
<p>asc 升序   desc  降序  （不写的话，默认是asc升序）</p>
<p>查询学生信息，先按照语文成绩进行倒序排序，如果成绩相同再按照英语成绩升序排序：select * from exam order by chinese desc,english asc;</p>
<p>分组统计查询：</p>
<p>聚合函数使用：（）括号中加对象</p>
<p>sum();</p>
<p>select sum(english)+sum(chinese)+sum(math) from exam;和select sum(english+chinese+math) from exam;的区别：</p>
<p>第一个语句是按照列的方式统计，英语成绩总和+语文成绩总和+数学成绩总和。</p>
<p>第二个语句先计算英语+数学+语文然后再求和。</p>
<p>//如果其中有一个值为null时，select sum(english+chinese+math) from exam;语句不会把那一行数据加上（null加上任意数还是null），select sum(english)+sum(chinese)+sum(math) from exam;语句就会正确相加。</p>
<p>如果某一列有null值，可以使用ifnull的函数：</p>
<p><code>select sum(ifnull(english,0)+chinese+math) from exam;</code>如果english是null，赋值为0</p>
<p>count();  统计个数 select count(*) from exam where name like ‘李%’;</p>
<p>max();</p>
<p>min();</p>
<p>avg();</p>
<p>分组查询：</p>
<p>语法：使用group by 字段名称;</p>
<p>where的子句后面不能跟着聚合函数。如果现在使用带有聚合函数的条件过滤（分组后条件过滤）需要使用一个关键字having</p>
<p>select product,sum(price) from orderitem  group by product having sum(price) &gt; 5000;</p>
<p>总结</p>
<p>S(select)… F(from)…W(where)…G(group by)…H(having)…O(order by);</p>
<p>顺序不能颠倒，可以省略</p>
<h2 id="MySQL的密码重置-不成功"><a href="#MySQL的密码重置-不成功" class="headerlink" title="MySQL的密码重置(不成功)"></a>MySQL的密码重置(不成功)</h2><p>\1. 停止MySQL的服务：在搜索程序和文件中输入 services.msc 打开服务 界面，找到MySQL停止</p>
<p>\2. 在cmd下启动服务：mysqld –skip-grant-tables</p>
<p>\3. 重新开启cmd的命令行（前面那个不要关掉）：mysql -u root -p 直接登入，不需要密码</p>
<p>\4. 修改root密码：use mysql；  update user set password = password (‘xinmima’) where user =’root’;</p>
<p>update user set password =password(‘sunweixuan’) where user =’root’;</p>
<p>\5. 结束mysqld的进程:在任务管理器中的进程结束mysqld.exe</p>
<p>\6. 重新启动mysql的服务：在搜索程序和文件中输入 services.msc 打开服务 界面，找到MySQL启动</p>
<h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><p>数据库的备份：</p>
<p>1.打开cmd的命令行窗口（以管理员身份运行）</p>
<p>2.输入mysqldump -u root -p web_test1 &gt;C:/web_test1.sql （这样c盘中就有了web_test1.sql ）  （&gt;和&lt;是数据流向）</p>
<p>数据库的还原：</p>
<p>第一种：</p>
<p>1.在数据库服务器内部创建数据库：creat</p>
<p>2.在命令行窗口输入：mysql -u root -p web_test1 &lt; C:/web_test1.sql</p>
<p>第二种：</p>
<p>1.在数据库服务器内部创建数据库：creat</p>
<p>2.切换到该数据库：use</p>
<p>3.使用source命令还原：source C:/web_test1.sql</p>
<h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><p>SQLyog、navicat等</p>
<p>MySQL的可视化工具有很多，基本上功能和内容都一样。</p>
<p>可以增删查改，可以执行SQL语句。</p>
<h2 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h2><p>约束是用来保证数据的完整性。</p>
<p>单表：主键约束、非空约束、唯一约束。</p>
<p>多表：外键约束：用来保证数据完整性（多表之间）</p>
<p>让两个表之间产生联系：</p>
<p>在员工表上添加外键：alter table employee add foreign key (dno) references dept(did);  （添加外键dno指向dept表中的did列）</p>
<p>对外键进行操作类似于对表进行修改：设置外键为非空：alter table employee modify dno int not null;</p>
<p>表与表之间的关系：</p>
<p>\1. 一对多的关系（员工和部门）：</p>
<p>建表原则：在多的一方创建外键指向一的一方的主键</p>
<p>\2. 多对多的关系（学生和课程）：</p>
<p>建表原则：需要创建中间表，中间表中至少两个字段，分别作为外键指向多对多双方的主键</p>
<p>\3. 一对一的关系（公司和注册地址）：（很少见）</p>
<p>两种方式：</p>
<p>（1）唯一外键对应：假设是一对多，在多的一方创建外键指向一的一方的主键，将外键设置为unique。</p>
<p>（2）主键对应：将两个表的主键建立对应关系即可。</p>
<p>多表设计：</p>
<p>\1. 多表分析： 分析每个类之间的关系</p>
<p>\2. 多表创建：创建各个表，添加外键使其建立关系，对于多对多的关系，需要再建立中间表。</p>
<p>\3. 多表查询：2类</p>
<p>（1）连接查询</p>
<p>l 交叉连接（了解）：查询到的是两个表的笛卡尔积（表1*表2=总记录条数）</p>
<p>语法：<code>select * from 表1 cross join 表2;</code></p>
<p><code>select * from 表1,表2;</code></p>
<p>l 内连接：inner join （inner可以省略）</p>
<p>显示内连接：在SQL中显示的调用inner join关键字</p>
<p>语法：<code>select * from 表1 inner join 表2 on 关联条件;</code></p>
<p>（select * from classes c inner join student s on c.cid = s.cno;）</p>
<p>隐式内连接：在SQL中没有调用inner join关键字</p>
<p>语法：<code>select * from 表1,表2 where 关联条件;</code></p>
<p>（SELECT * FROM classes c,student s WHERE c.cid = s.cno;）</p>
<p>l 外连接：outer join  （outer可以省略）</p>
<p>左外连接：语法：select * from 表1 left outer join 表2 on 关联条件; </p>
<p>左边表的全部和左右边共有的部分（左边表为基准）</p>
<p>右外连接：语法：select * from 表1 right outer join 表2 on 关联条件;</p>
<p>左边表的全部和左右边共有的部分（右边表为基准）</p>
<p>（2）子查询：一个查询语句条件需要依赖另一个查询语句的结果。（查询可以嵌套）</p>
<p>带in的子查询：select * from classes where cid in (SELECT cno FROM student WHERE birthday &gt; ‘1991-01-01’); （先查询出后面的范围，再在后面的范围中查找前面的信息并输出）</p>
<p>带exists的子查询：select * from classes where exists (SELECT cno FROM student WHERE birthday &gt; ‘1991-01-01’); （先查询后面的范围，如果存在，就对前面的语句进行查询；如果不存在，不执行前面的查询语句）</p>
<p>带any的子查询：SELECT * FROM classes WHERE cid &gt; ANY (SELECT cno FROM student )； （大于后面中最小值的）</p>
<p>带all的子查询：SELECT * FROM classes WHERE cid &gt; ALL (SELECT cno FROM student)； （大于后面中最大值的）</p>
<p>内连接与外连接的区别：左外连接和右外连接的交集就是内连接。</p>
<p>IFNULL() 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值</p>
<p>Case具有两种格式。</p>
<p>简单Case函数</p>
<p>​    格式说明   </p>
<p>　　　　case 列名</p>
<p>　　　　when  条件值1  then  选项1</p>
<p>　　　　when  条件值2   then  选项2…….</p>
<p>　　　　else   默认值    end</p>
<p>Case搜索函数</p>
<p>​    格式说明   </p>
<p>　　　　case  </p>
<p>　　　　when  列名= 条件值1  then  选项1</p>
<p>　　　　when  列名=条件值2   then  选项2…….</p>
<p>　　　　else   默认值 end</p>
<p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同</p>
<p>not in</p>
<p>对于第二个表中的某个字段不想要，只想取第一个表中这个字段值时，可以在查询时利用where条件限定id字段not in 第一个表的id字段。这样第二个表的查询结果会自动把第一个表中已经存在的id字段自动去除。</p>
<h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><h3 id="级联动作"><a href="#级联动作" class="headerlink" title="级联动作"></a>级联动作</h3><p> 1、cascade </p>
<p>   数据级联删除、更新(参考字段)</p>
<p>  2、restrict(默认)</p>
<p>   从表有相关联记录,不允许主表操作</p>
<p>  3、set null</p>
<p>   主表删除、更新,从表相关联记录字段值为NULL</p>
<p>  4、no action</p>
<p>​    无事发生</p>
<h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><p>数据字典存储有关数据的来源、说明、与其他数据的关系、用途和格式等信息，它本身就是一个数据库，存储“关于数据项的数据”</p>
<p>数据字典通常是指数据库中数据定义的一种记录，类似一个数据库的数据结构，但其内容要比数据库的数据结构描述丰富得多。在收集有关数据信息，建立数据库的初始阶段，必须建立数据项的<strong>命名约定</strong>，必须统一不同部门、不同个人之间对共同关心的数据的内涵、来源和命名的观念。这个过程要涉及数据监管人、用户和数据库开发人员，是一个需要反复多次的过程。这个统一的命名约定，及其附带的说明，就是数据字典。</p>
<p>数据库的重要部分是数据字典。它存放有数据库所用的有关信息，对用户来说是一组只读的表。</p>
<p>数据库数据字典是一组表和视图结构。它们存放在SYSTEM表空间中。</p>
<p>目的：</p>
<p>1)提高开发效率，降低研制成本。数据字典是数据库开发者、数据监管人和用户之间的共同约定，是系统说明书的一个重要组成部分。一个统一的数据字典有助于开发者建立数据模型以及程序和数据库之间的数据转换接口，为规范化设计和实施数据管理系统铺平了道路。<br>2)促进数据共享，提高数据的使用效率。通过数据字典，用户可以方便地知道每项数据的意义，了解数据的来源和使用方法，从而帮助用户迅速地找到所需的信息，并按照正确的方法使用数据。<br>3)控制数据的使用。在某些特定的场合，可以通过对数据字典的控制达到控制数据使用的目的。</p>
<p>数据字典（Data dictionary）是一种用户可以访问的记录数据库和应用程序元数据的目录</p>
<p>主动数据字典是指在对数据库或应用程序结构进行修改时，其内容可以由数据库管理系统自动更新的数据字典。被动数据字典是指修改时必须手工更新其内容的数据字典</p>
<p>两种形式：</p>
<p>第一种：《主体表》里包含主体和属性代码，《属性表》里包含属性代码和属性Value,不同属性分别建表</p>
<p>由于属性id是存储在主体表里的，属性的数量是不变的，而属性取值的数量可以是变化的。但是如果该主体的属性非常多的话，就需要建很多的属性表，在开发中还要设计很多属性类，那当想要取得一条主体的完全数据时，那将进行几十个表的联接（join）操作。性能耗损严重。当属性的数量不多时，用第一种数据字典即可</p>
<p>第二种：《主体表》里仅包含主体，《系统代码分类表》里存储属性标识和属性名称，《系统代码表》里包含所有属性代码、属性标识和属性Value，《属性表》是《主体》和《系统代码表》的关系表，包含属性id，主体id,属性代码</p>
<p>由于这种设计方式属性和主题表是分开的，所以属性的数量是可变的，而属性取值的数量可以是变化的。引入《系统代码分类表》和《系统代码表》，也解决了第一种设计方式的局限性</p>
<p>优点：</p>
<p>一、在一定程度上，通过系统维护人员即可改变系统的行为（功能），不需要开发人员的介入。使得系统的变化更快，能及时响应客户和市场的需求。</p>
<p>二、提高了系统的灵活性、通用性，减少了主体和属性的耦合度</p>
<p>三、简化了主体类的业务逻辑</p>
<p>四、能减少对系统程序的改动，使数据库、程序和页面更稳定。特别是数据量大的时候，能大幅减少开发工作量</p>
<p>五、使数据库表结构和程序结构条理上更清楚，更容易理解，在可开发性、可扩展性、可维护性、系统强壮性上都有优势。</p>
<p>缺点：</p>
<p>一、数据字典是通用的设计，在系统效率上会低一些。</p>
<p>二、程序算法相对复杂一些。</p>
<p>三、对于开发人员，需要具备一定抽象思维能力，所以对开发人员的要求较高</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/13/5.1.MySQL%E5%88%9D%E7%BA%A7/" data-id="ckqk8k3ed004p2wwd2rjr604o" data-title="MySQL初级" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-19.2.Gitee" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/12/19.2.Gitee/" class="article-date">
  <time class="dt-published" datetime="2021-04-12T02:59:11.000Z" itemprop="datePublished">2021-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/12/19.2.Gitee/">Gitee</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="码云教程"><a href="#码云教程" class="headerlink" title="码云教程"></a>码云教程</h2><p>gitee是开源中国（<a target="_blank" rel="noopener" href="https://www.oschina.net/%EF%BC%89%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8Egit%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%EF%BC%8C%E8%83%BD%E5%A4%9F%E7%94%A8%E7%A0%81%E4%BA%91%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E3%80%81%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E3%80%81%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%98%AF%E5%9B%BD%E5%86%85%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BB%A3%E7%A0%81%E7%B3%BB%E7%BB%9F%EF%BC%8Cgitee%E5%92%8Cgithub%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E6%80%A7%E8%B4%A8%E6%98%AF%E7%B1%BB%E4%BC%BC%E7%9A%84%EF%BC%8C%E7%A0%81%E4%BA%91%E6%98%AF%E5%9F%BA%E4%BA%8Egitlab%EF%BC%8C%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E4%B8%8Egithub%E7%B1%BB%E4%BC%BC%EF%BC%8C%E4%BD%86%E6%98%AF%E7%9B%B8%E6%AF%94%E4%BA%8Egithub%E8%80%8C%E8%A8%80%EF%BC%8Cgitee%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%98%BE%E8%91%97%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A%E4%B8%80%E6%98%AF%E9%80%9F%E5%BA%A6%E5%BF%AB%EF%BC%8C%E4%BA%8C%E6%98%AF%E6%94%AF%E6%8C%81%E5%85%8D%E8%B4%B9%E7%9A%84%E7%A7%81%E5%AF%86%E9%A1%B9%E7%9B%AE%E3%80%82">https://www.oschina.net/）开发的一款基于git的代码托管平台，能够用码云实现代码托管、项目管理、协作开发，目前是国内最大的代码系统，gitee和github的作用和性质是类似的，码云是基于gitlab，操作方式与github类似，但是相比于github而言，gitee有两个显著的优势：一是速度快，二是支持免费的私密项目。</a></p>
<h3 id="对于网上的项目"><a href="#对于网上的项目" class="headerlink" title="对于网上的项目"></a>对于网上的项目</h3><h4 id="一、fork源项目"><a href="#一、fork源项目" class="headerlink" title="一、fork源项目"></a>一、fork源项目</h4><p>码云的协作是基于fork（分支）源项目的基础上，才能进行pull request。对要进行协作开发或者学习的项目，fork一份到自己的远程仓库。</p>
<p>这样我们自己的远程仓库就会有一份源工程的副本。熟悉git版本工具开发的朋友，可以把一份fork下来的副本当成一个开发分支。</p>
<p>只有fork下来的副本你才拥有修改的权限，等同于一个拥有开发权限的分支。在这个开发分支中，你可以进行代码学习或者开发，提交修改到远程仓库的副本工程。</p>
<h4 id="二、协同修改操作pull-request"><a href="#二、协同修改操作pull-request" class="headerlink" title="二、协同修改操作pull request"></a>二、协同修改操作pull request</h4><p>这样可以将自己仓库的修改过的分支，提交合并请求到源项目，完成远程协作。</p>
<h4 id="三、拉取源项目最新内容"><a href="#三、拉取源项目最新内容" class="headerlink" title="三、拉取源项目最新内容"></a>三、拉取源项目最新内容</h4><p>点击项目标题下源项目旁边的 刷新按钮，便可以拉取最新的源项目数据。</p>
<p>便于及时获取原作者最新的项目更新。</p>
<p>也可以通过给fork下来的副本添加上游仓库地址<br>使用git 命令更新</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://gitee.com/xxxxxxxx.git</span><br><span class="line">git pull upstream develop</span><br></pre></td></tr></table></figure>

<p>注意： 更新上游仓库 会覆盖本地修改，所以请pr项目评审(Project Review) 接受之后 在更新</p>
<h3 id="对于工作的项目"><a href="#对于工作的项目" class="headerlink" title="对于工作的项目"></a>对于工作的项目</h3><h4 id="创建本地代码仓库"><a href="#创建本地代码仓库" class="headerlink" title="创建本地代码仓库"></a>创建本地代码仓库</h4><ol>
<li><p>在本地一个盘下新建一个文件夹，当作本地代码仓库，也就是说希望之后这个文件夹里的文件的改动都能被git进行管理。<br>例如在F盘内新建一个名为XXX的文件夹</p>
</li>
<li><p>在该文件内： 点击鼠标右键，选择执行git命令，执行代码：<code>git init</code></p>
</li>
</ol>
<p>这句话的意思是初始一个本地仓库，之后可以看到在该文件夹下多了一个.git文件夹，用于记录所有与管理本仓库相关的文件，<br>所以请小心改动。</p>
<p>也可以：<code>git clone 项目的url</code></p>
<p>然后就会发现在该盘下面就有了一个同名文件夹，并且.git目录和README.md文件都有，这两个代码仓库都已经同步好了</p>
<h4 id="进行代码托管"><a href="#进行代码托管" class="headerlink" title="进行代码托管"></a>进行代码托管</h4><p>本地代码仓库和远程代码仓库都创建好之后，需要把它们进行同步才能在gitee上进行代码托管。</p>
<p>1.本地代码仓库与远程代码仓库进行同步，执行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;xxxxxxx.git</span><br></pre></td></tr></table></figure>

<p>其中远程库的名字就是origin，这是git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>origin可以改为项目名，或者和项目名不同也都是可以的，因为重要的是后面的url，每个远程代码库都有一个自己的url，所以本地仓库本质上是和这个url所指代的远程仓库进行关联的。</p>
<p>2.拉取远程代码库<br>由于在创建远程仓库时会初始化一个README.md文件，而本地仓库里没有，所以需要先执行pull操作将远程仓库拉取合并到本地仓库，否则会出错。执行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p>【注1：由于在本地创建了代码仓库，git默认关联的库在本地，所以直接执行git pull命令是无效的，需要执行<code>git pull origin master</code>命令才行，这句话的意思是推送到远程库master分支，此外，也可以根据提示执行一下<code>git branch --set-upstream origin master</code>命令，以后就可以直接使用git pull了】</p>
<p>此时可以看到在本地代码仓库中多了一个README.md文件。</p>
<p>【注2：如果遇到错误提示“fatal: refusing to merge unrelated histories”，出现这种错误是因为git会以为这两个仓库不同所以进行无法合并，在执行pull操作时添加–allow-unrelated-histories，即执行<code>git pull origin master --allow-unrelated-histories</code>就可以了】</p>
<p>3.向远程代码仓库推送文件（例如在本地代码仓库中新建了test1.txt和test2.txt文件，现把它们同步到远程代码仓库），执行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;对该操作的相关描述&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到，git追踪到了仓库中文件的变化，所以说git起到了作用。现在执行push操作将它推送到远程代码库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure>

<p>【注3：这里使用git push命令会和上面使用git pull时出现同样的问题，根据提示<code>git push --set-upstream origin master</code>，以后就可以直接使用git push命令了】<br>刷新远程代码仓库，可以看到文件被成功的同步到了远程仓库：</p>
<p>当然，同步一个文件夹到远程仓库与同步单个文件相同，只不过无法同步空文件夹到远程仓库，因为git会认为没有改动</p>
<p>【注4：这以直接使用git push命令，因为远程创建了代码仓库，git默认关联的库在远程，git push是默认推送到远程库master分支】</p>
<h3 id="关于删除"><a href="#关于删除" class="headerlink" title="关于删除"></a>关于删除</h3><h4 id="一、删除文件、文件夹"><a href="#一、删除文件、文件夹" class="headerlink" title="一、删除文件、文件夹"></a>一、删除文件、文件夹</h4><p>1.删除文件，执行命令：<code>git rm 想要删除的文件的名字及其后缀</code></p>
<p>如果在本地代码仓库testGit1中有三个文件，README.md、test1.txt和test2.txt，删除文件test1.txt，<br>但是如果不加文件后缀的话，会发现提示匹配不到文件，所以必须给全名。<br>之后可以发现本地仓库已经没有这个文件了，但是刷新远程仓库会发现，这个文件依然存在，<br>这是因为在本地仓库改动过后，没有将现在的状态同步到远程仓库，所以需要执行一下commit和push命令：</p>
<p><code>git commit -m &quot;对本次提交的描述信息&quot;</code><br><code>git push</code></p>
<p>现在刷新远程代码仓库，可以看到文件test1.txt被成功的删除了。</p>
<p>2.删除文件夹，执行命令：<code>git rm 想要删除的文件夹的名字 -r</code></p>
<p>如果在本地代码仓库testGit1中有一个名为test的文件夹，直接使用删除文件的命令无法删除文件夹，会提示错误“not removing ‘test’ recursively without -r”，可以先执行一下git rm -help命令查看rm命令的使用详情，其中添加-r表示允许迭代移除，所以git rm test -r可以删除test文件夹，之后执行commit和push操作即可。</p>
<h4 id="二、找回误删文件、文件夹"><a href="#二、找回误删文件、文件夹" class="headerlink" title="二、找回误删文件、文件夹"></a>二、找回误删文件、文件夹</h4><p>git对于版本的管理本质是对提交的管理，所以在每个操作后最好提交一下，便于之后需要回退，例如要找回上面操作中误删的文件test1.txt。</p>
<p>1.如果你现在正在进行某些更改，需要先推送远程仓库，否则回退之后，最新状态的内容就没有了。</p>
<p>2.执行命令：<code>git log</code></p>
<p>这个命令会显示出提交日志，可以看到有一个增加了2个文件（test1.txt和test2.txt）的提交和删除test1.txt的提交：</p>
<p>每个提交都有自己的唯一标识，所以想要找回文件test1.txt，需要回退到提交删除操作的前一个状态，所以这里是回退到添加文件状态，执行命令：</p>
<p><code>git reset --hard 需要回退到的状态的commit标识号</code></p>
<p>该命令的原理：git有个指向当前版本的HEAD指针，执行回退操作本质上是git把HEAD指针从当前状态指向想要回退到的状态，所以回退的速度很快，需要回退到哪里，就让HEAD指向哪里就行。</p>
<p>如果看到提示说HEAD已经处于添加文件的状态了，此时查看文件也可以看到test1.txt文件。</p>
<p>3.如果在这个状态和最新状态之间又提交过很多文件，需要手动把这个找回的test1.txt文件拷贝出去一份，再执行reset命令回到最新的状态：</p>
<p><code>git reset --hard 最新状态的commit标识号</code><br>4.最新状态是没有刚刚找回的这个文件的，把test1.txt文件拷贝进本地仓库中，然后推送到远程仓库即可，执行命令：</p>
<p>git add .<br>git commit -m “对本次提交的描述”<br>git push</p>
<p>这样就可以既找回了之前误删的文件，又没有丢掉中间状态的很多文件。<br>找回误删的文件夹和找回误删的文件操作完全相同，因为git不会识别你找回的是什么，只是回退到相应的状态而已。</p>
<p>过程示意图：</p>
<p>commit:1——&gt;commit:2——&gt;commit:3——&gt;commit:4——&gt;commit：5<br>                           误删                    最新状态</p>
<p>当你想要找回删除的文件的时候，先保存现在的状态即最新状态commit：5，然后回退到误删的前一个状态也就是commit：2，<br>这时候可以获取到已经删除的文件，把它拷贝出去保存一份，然后回到最新状态commit：5，<br>该状态下是没有已经删除的文件的，但是刚刚我们找到了它并拷贝了一份，现在把这个文件再拷贝进来到本地仓库中，<br>然后执行提交推送操作，会产生一个新的commit状态，这个就是在commit：5的基础上找回已删除文件后产生的最最新的状态。</p>
<h2 id="常见名词"><a href="#常见名词" class="headerlink" title="常见名词"></a>常见名词</h2><ol>
<li>分支（git branch命令）</li>
</ol>
<p>git默认分支一般是master，当然，这是可以修改的，我们在master完成一次开发，生成了一个稳定版本，那么当需要添加新功能或者做修改时，只需要新建一个分支，然后在该分支上开发，完成后合并到主分支即可，分支功能解决了正在开发的版本与上线版本稳定性冲突的问题。</p>
<ol start="2">
<li>提交（git commit命令）</li>
</ol>
<p>git对于版本的管理其实是对提交的管理，git使用40个字节长度的16进制字符串来标识每一个提交，每一个提交具有唯一的标识，根据这个标识可以任意回退。</p>
<ol start="3">
<li>拉取（git pull命令）</li>
</ol>
<p>用于取回远程仓库某个分支的更新，再与本地仓库合并。</p>
<ol start="4">
<li>推送（git push命令）</li>
</ol>
<p>用于把本地的代码更新到远程仓库。</p>
<h2 id="常见操作指令"><a href="#常见操作指令" class="headerlink" title="常见操作指令"></a>常见操作指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git init  &#x2F;&#x2F;初始化一个Git仓库，Git的很多命令都需要在Git的仓库中运行，所以 git init 是使用Git的第一个命令</span><br><span class="line">git clone  &#x2F;&#x2F;拷贝一份远程仓库，也就是下载一个项目</span><br><span class="line">git config --list &#x2F;&#x2F;查看配置信息</span><br><span class="line">git config --global user.name &quot;runoob&quot;  &#x2F;&#x2F;配置个人的用户名称</span><br><span class="line">git config --global user.email test@runoob.com  &#x2F;&#x2F;配置个人的电子邮件地址    去掉 --global 参数只对当前仓库有效</span><br><span class="line"></span><br><span class="line">git status  &#x2F;&#x2F;查看仓库当前的状态，显示有变更的文件</span><br><span class="line">git diff  &#x2F;&#x2F;比较文件的不同，即暂存区和工作区的差异</span><br><span class="line">git reset &#x2F;&#x2F;回退版本</span><br><span class="line">git rm  &#x2F;&#x2F;删除工作区文件</span><br><span class="line">git mv  &#x2F;&#x2F;移动或重命名工作区文件</span><br><span class="line"></span><br><span class="line">git remote  &#x2F;&#x2F;远程仓库操作    （remote 远程）</span><br><span class="line">git fetch  &#x2F;&#x2F;从远程获取代码库   （fetch 取来）</span><br><span class="line"></span><br><span class="line">分支管理</span><br><span class="line">git branch (branchname)  &#x2F;&#x2F;创建分支  git branch -分支名</span><br><span class="line">git checkout (branchname) &#x2F;&#x2F;切换分支  git checkout -   分支名</span><br><span class="line">git merge  &#x2F;&#x2F;合并分支   git merg --no-ff 分支名</span><br><span class="line">git log  &#x2F;&#x2F;查看历史提交记录   git log --graph</span><br><span class="line">git blame &lt;file&gt;  &#x2F;&#x2F;以列表形式查看指定文件的历史修改记录  （blame 责备）</span><br><span class="line"></span><br><span class="line"> git tag -a v1.0 &#x2F;&#x2F;git标签</span><br></pre></td></tr></table></figure>



<h2 id="IDEA集成gitee"><a href="#IDEA集成gitee" class="headerlink" title="IDEA集成gitee"></a>IDEA集成gitee</h2><h3 id="1、安装gitee插件"><a href="#1、安装gitee插件" class="headerlink" title="1、安装gitee插件"></a>1、安装gitee插件</h3><p>【File】-【Settings】-【Plugins】，查看gitee插件并安装</p>
<p>IDEA 码云插件已由 gitosc 更名为 gitee。</p>
<p>安装完成后，重启IDEA</p>
<h3 id="2、使用码云托管项目"><a href="#2、使用码云托管项目" class="headerlink" title="2、使用码云托管项目"></a>2、使用码云托管项目</h3><h5 id="添加Gitee账户"><a href="#添加Gitee账户" class="headerlink" title="添加Gitee账户"></a>添加Gitee账户</h5><p>【File】-【Settings】-【Version Control】-【Gitee】，点击【Add account】添加账户</p>
<p>输入账号和密码，点击【Log In】</p>
<p>登录成功后会显示账户信息。</p>
<h5 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h5><p><strong>将IDEA项目分享至Gitee（这个会推送到个人的项目里，不是多人合作的项目）（用于个人练习的项目存到码云上）</strong></p>
<p>选中要同步的项目，点击菜单【VCS】-【Import into Version Control】-【Share Project on Gitee】</p>
<p>点击【Share】按钮</p>
<p>（如果文件有很多更改）将不必要的文件去除对勾，点击【Add】</p>
<p>提示项目成功分享至Gitee</p>
<p>登录Gitee可看到项目</p>
<p><strong>Gitee项目克隆至IDEA（用于将码云上的项目下载到本地）</strong></p>
<p>【VCS】-【Git】</p>
<p>输入Gitee项目的URL，点击【Clone】，开始克隆</p>
<p>点击【Yes】</p>
<p>点击【This Window】</p>
<p>克隆成功，可看到项目代码</p>
<p><strong>Gitee团队协作（用于正式项目的开发合作）</strong></p>
<p>拉取代码<br>【VCS】-【Update Project】</p>
<p>点击【OK】</p>
<p>提示更新多少个文件，可以点击【View】查看更新的文件列表</p>
<p>更新文件列表</p>
<h6 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h6><p>注：提交代码前，应先拉取。若拉取时出现代码冲突，应先解决冲突后再提交</p>
<p>【VCS】-【Commit】</p>
<p>可选择哪些代码提交，默认全选，输入提交信息，点击【Commit and Push】。或者先点击【Commit】，再从菜单中点击【Push】</p>
<p>选择默认分支，点击【Push】</p>
<p>提交成功</p>
<h3 id="idea里颜色含义"><a href="#idea里颜色含义" class="headerlink" title="idea里颜色含义"></a>idea里颜色含义</h3><p>绿色，已经加入控制暂未提交<br>红色，未加入版本控制<br>蓝色，加入，已提交，有改动<br>白色，加入，已提交，无改动<br>灰色：版本控制已忽略文件</p>
<h2 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h2><h3 id="发生的场景"><a href="#发生的场景" class="headerlink" title="发生的场景"></a>发生的场景</h3><ul>
<li>情景一：多个分支代码合并到一个分支时</li>
<li>情景二：多个分支向同一个远端分支推送代码时</li>
</ul>
<p>实际上，push操作即是将本地代码merge到远端库分支上。</p>
<p>关于push和pull其实就分别是用本地分支合并到远程分支 和 将远程分支合并到本地分支</p>
<p>所以这两个过程中也可能存在冲突。git的合并中产生冲突的具体情况：<br>　　&lt;1&gt;两个分支中修改了同一个文件（不管什么地方）<br>　　&lt;2&gt;两个分支中修改了同一个文件的名称<br>两个分支中分别修改了不同文件中的部分，不会产生冲突，可以直接将两部分合并。</p>
<h3 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h3><ul>
<li>情景一：在当前分支上，直接修改冲突代码—&gt;add—&gt;commit</li>
<li>情景二：在本地当前分支上，修改冲突代码—&gt;add—&gt;commit—&gt;push</li>
</ul>
<p>注：借用vim或者IDE或者直接找到冲突文件，修改</p>
<h4 id="idea里："><a href="#idea里：" class="headerlink" title="idea里："></a>idea里：</h4><p>当在提交或拉取代码时，出现冲突会弹出对话框，选中冲突的文件，点击【Merge】</p>
<p>对话框中出现三个框，分别为：</p>
<p>左边框为本地待提交的代码<br>右边框为Gitee中代码<br>中间框为解决冲突后的结果代码<br>解决代码冲突：我们修改中间的代码，可根据情况选择【Accept Left】或【Accept Right】；亦或者手动修改冲突代码后点击【Apply】</p>
<p>点击【Yes】</p>
<p>当所有冲突文件解决后，重新提交即可</p>
<p>还有一种解决冲突的方式：</p>
<p>1.将本地代码进行stash 即保存到git栈中，并命名”333 conflict” （<code>git - repository - stash changes</code>） 此后所有的修改已经不存在了，恢复到上一次的代码内容</p>
<p>2.<code>pull master</code>  代码内容变为远程仓库master分支的内容</p>
<p>3.将本地修改取出 （<code>git - repository - unstash changes</code>）选中之前创建的”333 conflict” 恢复</p>
<p>4.此时会提示有冲突 点击解决冲突 中间的result为解决结果 可以直接选择左或右或修改结果</p>
<p>5.冲突修改完成，commit and push</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>本地新建立一个文件夹，然后git命令拉取到本地：</p>
<p><code>git clone url地址</code></p>
<p>提交代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;提交的备注信息&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>



<h3 id="分支："><a href="#分支：" class="headerlink" title="分支："></a>分支：</h3><p>gitee是国内的代码托管平台，相比较于github拉取仓库和推送的速度更快，这里主要讲述一下通过git bash将代码推送到gitee的某个branch的流程。</p>
<h5 id="推送流程简述："><a href="#推送流程简述：" class="headerlink" title="推送流程简述："></a>推送流程简述：</h5><p>推送的流程其实归纳起来可以总结出四步：</p>
<ol>
<li>将Gitee的仓库/某个具体的分支拉取到本地</li>
<li>将自己写好的代码放到本地仓库中</li>
<li>将代码提交到本地仓库</li>
<li>将代码推送到Gitee远端仓库</li>
</ol>
<h5 id="具体过程详解："><a href="#具体过程详解：" class="headerlink" title="具体过程详解："></a>具体过程详解：</h5><p>首先是将Gitee的仓库/分支拉取到本地：</p>
<p>首先进入任意文件夹，选择git bash（在这里运行的前提是本地已经安装并配置好git，安装配置的过程在这里不多赘述），然后输入命令：</p>
<p><code>git clone -b【分支名】SSH（这里的ssh是码云仓库的SSH）</code></p>
<p>这里强调一下，如果是要拉取master分支就可以直接使用git clone，如果要拉取子分支需要加 -b 【分支名】，否则默认拉取的是master分支！</p>
<p>拉取成功之后会看到本地多了一个文件夹，这就是我们远端拉取到的git仓库</p>
<p>将代码提交到本地git仓库<br>在成功拉取之后我们进入到拉取来的文件夹，可以看到里面的结构与我们码云上的结构是完全相同的</p>
<p>然后直接从本地将我们的代码拷贝到该文件夹中，打开git bash，执行</p>
<p><code>git add 【文件】</code></p>
<p>的操作（！！这里要重点强调，一定要在远端仓库中打开git bash，会在路径中看到有我们的分支名称）</p>
<p>当 git add完成之后我们需要执行</p>
<p><code>git commit -m &quot;&quot;</code> </p>
<p>操作，来表明我们对这个事务进行提交（可以类比数据库的事务）<br>在这里使用 <code>-m</code>  目的是对提交的项目进行描述（message）</p>
<p>当commit成功后我们就成功将我们的项目添加到了本地的git仓库中，使用</p>
<p><code>git push origin 【分支名】</code></p>
<p>就可以成功把本地git仓库的代码推送到码云远端仓库中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/12/19.2.Gitee/" data-id="ckqk8k3e400462wwd5qk5f4w5" data-title="Gitee" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-10.5.项目提交" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/11/10.5.%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4/" class="article-date">
  <time class="dt-published" datetime="2021-04-11T06:03:11.000Z" itemprop="datePublished">2021-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/11/10.5.%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4/">项目提交</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>后端项目打包：</p>
<p>maven的lifecycle提供了一个package，点击后打的jar包会出现在target文件下。</p>
<p>或者控制台输入命令：</p>
<p><code>mvn clean package -Dmaven.test.skip=true</code></p>
<p>前端项目打包：</p>
<p>1.先运行依赖包：<code>npm install</code></p>
<p>2.控制台输入打包命令：</p>
<p><code>cnpm run build</code>   </p>
<p>3.将生成的dist文件，直接放到服务器上</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/11/10.5.%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4/" data-id="ckqk8k3cw000c2wwd4u5o360d" data-title="项目提交" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-10.6.项目外包" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/10.6.%E9%A1%B9%E7%9B%AE%E5%A4%96%E5%8C%85/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T12:03:47.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/10.6.%E9%A1%B9%E7%9B%AE%E5%A4%96%E5%8C%85/">项目外包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>项目外包一般包括：项目文档、项目外包合同</p>
<p><em><strong>*分为*</strong>***</em>*项目立项*<em><strong>、</strong></em>*项目规划*<em><strong>、</strong></em>*需求分析*<em><strong>、</strong></em>*项目验收****<em><strong>*阶段*</strong></em></p>
<p><em><strong>*1.明确项目干系人*</strong>***</em>*<br>****    在项目规划阶段明确干系人的人员组成、优先级、期望点，是保障项目定位、需求来源的准确性的必要途径，是进入项目需求阶段的基础</p>
<p><em><strong>*2.合理的项目团队组织*</strong></em></p>
<p>包括人员安排、任务划分、沟通协作项目确认</p>
<p>· 安排专业人员作为项目对接人</p>
<p>· 建立项目进度跟踪机制</p>
<p>3.不可忽视项目的非功能需求：包括性能需求、安全需求、集成需求、可靠性需求、兼容性需求、易用性需求等</p>
<p><strong>l</strong> <em><strong>*性能需求*</strong></em></p>
<p>对于前台的系统而言，通常以“响应时间”上进行定义，并具体到的某个业务场景。需求描述举例如下：</p>
<p>定位系统从点击到第一个界面显示出来所需要的时间不得超过300毫秒。</p>
<p>在非高峰时间根据编号和名称特定条件进行搜索，可以在3秒内得到搜索结果。</p>
<p>对于后台的业务管理系统来说，通常以“整体能力上来定义”，并具体到某个业务场景。常见的业务指标包括“并发量、资源使用率、业务量、系统容量”等等。需求描述举例如下：</p>
<p>系统可以同时满足10,000个用户请求，并为25,000个并发用户提供浏览功能。</p>
<p>CPU占用率&lt;=50%，内存占用率&lt;=50%。</p>
<p>数据库表行数不超过100万行，数据库最大容量不超过1000GB，磁盘空间至少需要40G以上。</p>
<p><strong>l</strong> <em><strong>*可扩展需求*</strong></em></p>
<p>系统可扩展可以从系统性能、系统功能两个方面进行考虑，其基本要求是功能扩展时不需要对系统的基础架构进行改动，性能扩展不通过任何代码的更改。在描述系统性能的可扩展需求时应结合性能需求，举例如下：</p>
<p>系统可以在未来需要的情况下，不通过任何代码的更改，对系统性能进行提升，使之中心系统每秒钟能记录25个以上的考勤记录。</p>
<p>从业务设计的角度来说，模块化、可复用、较少依赖或耦合是可扩展的原则。</p>
<p>l 集成需求</p>
<p>集成需求主要包括数据对接（系统之间的数据交换和信息传递）、单点登录（多个独立系统统一账号和登录认证）、系统融合（ 将多个系统融合在一个系统中，统一账号、权限、应用的管理，最终以一个独立的软件系统存在）。需求描述举例如下：</p>
<p>某某图书管理系统采集##库存管理系统的数据包括库存数据、订单数据。</p>
<p>某某课程管理系统通过与EHR系统实施集成，实现相关基础数据（组织机构、用户数据等）的共享，实施统一身份认证和统一登录界面。</p>
<p>内训管理后台融合到社区管理后台中，统一账号、权限、功能的管理。</p>
<p>l 兼容性需求<br>一般对于前台系统而言，都需要考虑其兼容性。目前最为广泛的前台系统是手机客户端、web端，在考虑系统的兼容性时主要前台的适用平台有哪些，需求描述举例如下。</p>
<p>· 系统仅支持chrome浏览器，不考虑移动端适配。</p>
<p>· 移动端需要兼容的操作系统IOS6以上、Andriod6.0以上</p>
<p>l 易用性需求</p>
<p>易用性和产品的用户体验相关，是一组规定或者潜在的用户为使用其软件所需做的努力和对这样的使用所作的评价有关的一组属性。衡量易用性的标准是用户对于系统功能是否容易理解、是否容易学习、是否容易操作，需求描述举例如下：</p>
<p>80%的用户经过培训后，可在5分钟内完成课程创建。</p>
<p>90％的用户完成建课后，需要在5s内知道下一步需要进行什么操作，如课程上线、编辑、查看详情等。</p>
<p>接口测试也是属于****功能测试*<em><strong>，所以跟我们以往的功能测试流程并没有太大区别，测试流程依旧是：1.测试接口文档（需求文档） 2.根据接口文档编写</strong></em>*测试用例****（用例编写完全可以按照以往规则来编写，例如等价类划分，边界值等设计方法） 3. 执行测试，查看不同的参数请求，接口的返回的数据是否达到预期</p>
<p>HTTP抓包工具：Fiddler、Charles、Firebug、开发者工具等等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/10.6.%E9%A1%B9%E7%9B%AE%E5%A4%96%E5%8C%85/" data-id="ckqk8k3cx000f2wwdbqnj1ck7" data-title="项目外包" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-7.Tomcat" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/7.Tomcat/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:47:13.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/7.Tomcat/">Tomcat</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Apache/6265">Apache</a>、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>
<p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTML">HTML</a>（<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073">标准通用标记语言</a>下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。</p>
<p>诀窍是，当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。另外，Tomcat和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/IIS">IIS</a>等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTML">HTML</a>的能力不如Apache服务器。</p>
<p>Tomcat就是一个web的服务器，用来发布web项目。</p>
<p>下载：<a target="_blank" rel="noopener" href="http://tomcat.apache.org/download-70.cgi">http://tomcat.apache.org/download-70.cgi</a></p>
<p>解压文件之后，bin目录下的startup.bat，会出现一个dos命令界面，不要关闭的情况下，在浏览器中输入localhost:8080/会跳转到一个页面,这样就表示安装成功了。</p>
<p>安装注意事项：</p>
<p>Tomcat运行需要依赖Java环境，也就是说需要在电脑上安装了JDK之后才可以安装和启动Tomcat。因为Tomcat启动的时候需要使用JRE的环境。必须要配置JAVA_HOME环境变量（这个必须要在系统变量中才行），如果没有配置JAVA_HOME环境变量，那么服务器在启动的时候就会一闪然后关闭。（可以将startup.bat用记事本打开，在最后的end后面的最后一行写上pause，令它停止一下，再打开就会显示错误信息）</p>
<p>如果电脑上安装了一个应用之后，有可能会占用Tomcat的端口，如果将Tomcat端口占用了，同样这个Tomcat启动不了的。Tomcat默认的端口号是8080（很少会有程序占用，除非你启动了两个Tomcat，但是一般80端口容易被其他程序所占用）。因为80端口是HTTP协议的默认端口（一般在http协议下的输入网址字母后面都可以跟：80，无影响，所以可以省略）。</p>
<p>解决端口号冲突导致Tomcat的startup.bat打开不了的方法：</p>
<p>1.将占用端口的程序结束掉。</p>
<p>在cmd命令符中输入命令查看端口号：netstat -ano</p>
<p>假如出现了这个：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps1.jpg" alt="img"> </p>
<p>8080的端口是PID为9428的占用了，可以在任务管理器中结束这个9428的进程</p>
<p>\2. 改变自身程序的端口。</p>
<p>修改Tomcat的端口号：进入tomcat/conf/server.xml</p>
<p>将配置文件中的</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps2.jpg" alt="img"> </p>
<p>改为其他的即可。</p>
<p>查看日志：</p>
<p>C:\Users\vcc\Desktop\apache-tomcat-9.0.41-windows-x64\apache-tomcat-9.0.41\logs</p>
<p>Tomcat的目录结构：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps3.jpg" alt="img"> </p>
<p>bin        :二进制文件（命令文件：开启和关闭）</p>
<p>conf    :配置文件</p>
<p>lib        :tomcat所需要的jar包</p>
<p>logs        :tomcat服务器日志文件</p>
<p>temp    :tomcat运行产生临时文件</p>
<p>webapps    :需要发布的项目需要放在webapps下，这样就相当于发布出去了（ROOT中的index.jsp就是发布项目的首页）</p>
<p>work    :JSP翻译（编译）成Servlet产生的代码</p>
<p>发布一个Tomcat项目：</p>
<p>可以发布静态，动态项目</p>
<p>如果是静态的项目，只需要有静态页面就够了</p>
<p>动态WEB资源目录结构：</p>
<p>website</p>
<p>​    |——静态页面（HTML、CSS、JS、图片）</p>
<p>​    |——JSP页面</p>
<p>​    |——<em><strong>*WEB-INF*</strong></em></p>
<p>​            |—–<em><strong>*web.xml*</strong></em>    （必须的，有配置、servlet）</p>
<p>​            |—–classes    （可选的，java类，servlet被编译）</p>
<p>​            |—–lib        （可选的，第三方的jar包）</p>
<p>项目的发布方式：</p>
<p>\1. 直接将项目复制到tomcat/webapps下</p>
<p>将项目复制到tomcat/webapps中，启动服务器：bin/startup.bat</p>
<p>访问项目（本机访问）：<a target="_blank" rel="noopener" href="http://localhost:8080/aaa/index.html%EF%BC%88index.html%E6%98%AF%E4%B8%BB%E9%A1%B5%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%86%99%EF%BC%89%EF%BC%88%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%B0%86localhost%E6%94%B9%E4%B8%BAip%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BE%9B%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91%E8%AE%BF%E9%97%AE%EF%BC%89">http://localhost:8080/aaa/index.html（index.html是主页，也可以不写）（也可以将localhost改为ip地址，供其他电脑访问）</a></p>
<p>\2. 在tomcat/conf/server.xml配置tomcat的虚拟路径</p>
<p>虚拟路径：配置一个名称与一个真实的路径进行绑定，然后访问这个名称从而找到真实路径。</p>
<p>在tomcat/conf/server.xml中进行配置（配置的相关变量属性可以在tomcat的文档中找到，tomcat的文档可以在localhost:8080/下找到）。</p>
<p>要添加<Context></Context>表示配置虚拟路径</p>
<p>docBase：项目路径（文档的根路径）</p>
<p>path：虚拟路径</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps4.jpg" alt="img"> </p>
<p>启动服务器访问：<a target="_blank" rel="noopener" href="http://localhost:8080/itheima/index.html">http://localhost:8080/虚拟路径/index.html</a></p>
<p>3.在tomcat/conf/Catalina/localhost/下配置tomcat的虚拟路径</p>
<p>第三种方式也需要配置虚拟路径，第二种需要修改server.xml。server.xml是tomcat的核心配置文件，一旦修改错了，那么tomcat服务器就会出现问题。推荐使用第三种配置方式。</p>
<p>在tomcat/conf/Catalina/localhost下创建一个xml文件：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps5.jpg" alt="img"> </p>
<p>文件的名称就是虚拟路径，只需要访问虚拟路径就可以访问C:\ccc这个路径</p>
<p>启动服务器访问：<a target="_blank" rel="noopener" href="http://localhost:8080/itheima/index.html">http://localhost:8080/虚拟路径/index.html</a></p>
<p>在Eclipse中集成Tomcat</p>
<p>1.选择Eclipse的服务的配置：</p>
<p>打开Eclipse–选择window下的preferences–选择Server下的runtimeenvironment–add添加服务选择ApacheTomcat你的版本，选择安装路径，finish</p>
<p>2.配置服务</p>
<p>切换到javaee视图–在控制台位置找到servers，点击下面的添加–选择ApacheTomcat你的版本，finish–添加好的服务右击open，修改其中的两步</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps6.jpg" alt="img"> </p>
<p>\3. 在eclipse中发布项目</p>
<p>空白处new一个DynamicWebProject，设置项目名称名字，设置模块版本为2.5，finish</p>
<p>（java的代码写到JavaResources的src下，静态页面、jsp写到WebContent下）</p>
<p>创建一个html页面（在WebContent下new），写完之后在下面的Servers右击AddAndRemove，将项目add到右边，finish</p>
<p>在Servers右击start表示开启服务器（现在可以在Tomcat的WebApps下看到项目已经配置了）</p>
<p>\4. 访问项目</p>
<p>浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8080/web_test/">http://localhost:8080/项目名字/</a>就可以访问了。</p>
<p>网站访问的过程：BS模式下</p>
<p><a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a></p>
<p>http是协议</p>
<p>www是万维网的主机名</p>
<p>baidu.com是域名</p>
<p>访问域名的时候，会先去本地的host文件中查找这个域名是否有匹配的ip地址，如果有，会直接返回，如果没有就会去网络上的DNS服务器查找域名所匹配的ip地址，如果找到了就会直接返回这个ip地址，然后根据80端口去访问相应的ip服务器，如果没有就会出错（404）</p>
<p>DNS服务器：DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。</p>
<p>Tomcat虚拟主机的配置：</p>
<p>虚拟主机：在电脑上设置一个目录，使用一个名称与该目录进行绑定。这个路径称为是虚拟主机。主机是可以发布web项目的。</p>
<p>1.抓取一个页面（以百度为例）</p>
<p>2.创建一个路径（虚拟主机的目录）：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps7.jpg" alt="img"> </p>
<p>baidu是虚拟主机的目录，website是项目名称，将抓取的页面放入到项目中</p>
<p>3.配置tomcat的虚拟主机：conf下的server.xml配置。appBase是虚拟主机的目录，name是虚拟主机的名称</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps8.jpg" alt="img"> </p>
<p>4.修改本地的hosts文件：找到C:\Windows\System32\drivers\etc\hosts，修改hosts文件</p>
<p>首先需要知道本机的ip地址：cmd中输入ipconfig /all 找到ip地址</p>
<p>在最下面添加：<img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps9.jpg" alt="img"></p>
<p>5.启动服务器访问项目：在bin下启动服务器：startup.bat</p>
<p>在浏览器输入：<a target="_blank" rel="noopener" href="http://www.baidu.com:8080/website/baidu.htm">http://www.baidu.com:8080/website/baidu.htm</a></p>
<p>但是一般输入的时候不用输入这么多，所以需要修改一些配置，在conf下的server.xml配置</p>
<p>修改端口号：8080改为80</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps10.jpg" alt="img"> </p>
<p>将路径中的website去掉：在自己的虚拟主机中再配置一个虚拟路径</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps11.jpg" alt="img"> </p>
<p>（只要输入一个/就会去website下查找）上述因为添加了注释的汉字，所以格式需要另存一下，改为utf-8（不然会报错）</p>
<p>配置默认的首页（将baidu.htm去掉）：在conf/web.xml下添加baidu.htm为默认页面</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml4240\wps12.jpg" alt="img"> </p>
<p>注意：修改conf的配置文件后，需要重启服务器</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/7.Tomcat/" data-id="ckqk8k3dl002l2wwdgfjm5cpm" data-title="Tomcat" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-14.1.linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/14.1.linux/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:42:46.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/14.1.linux/">linux</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>学习Linux目标:掌握linux常用命令，会安装开发中使用软件，例如mysql,jdk…</p>
<p>开发人员掌握就好，更多的是运维人员需要掌握</p>
<h1 id="Linux介绍"><a href="#Linux介绍" class="headerlink" title="Linux介绍"></a>Linux介绍</h1><p>Linux是基于Unix开发的，Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核</p>
<p>Unix是一个强大的多用户、多任务操作系统。    于1969年在AT&amp;T的贝尔实验室开发。    UNIX的商标权由国际开放标准组织（The Open Group）所拥有。    UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些</p>
<p>Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机</p>
<p>Linux系统的应用</p>
<p>服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； </p>
<p>嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，</p>
<p>高性能运算、计算密集型应用Linux有强大的运算能力。</p>
<p>桌面应用系统 ubuntu</p>
<p>移动手持系统</p>
<p>Linux版本：<em><strong>*内核版本和发行版本*</strong></em></p>
<p>内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号，非常小，只有几M</p>
<p>​    常用的ubuntu  centos  fedora  redhat</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps1.jpg" alt="img"> </p>
<h1 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="*Linux*****安装****"></a><em><strong>*Linux*</strong>***</em>*安装****</h1><p>我们在虚拟机上来安装Linux</p>
<p>虚拟机：一台虚拟的电脑</p>
<p>虚拟机软件：</p>
<p>VMWare它是一个收费虚拟软件，密钥</p>
<p>VirtualBox    :免费的</p>
<p>怎样安装linux系统(centos6.5)：</p>
<p>参考《虚拟软件vmware安装.doc》，安装VmWare</p>
<p>参考《CentOS6详细安装文档.doc》，安装CentOS</p>
<p>前提需要一个.iso的镜像文件</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps2.jpg" alt="img"> </p>
<p>典型安装就可以</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps3.jpg" alt="img"><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps4.jpg" alt="img"><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps5.jpg" alt="img"><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps6.jpg" alt="img"> </p>
<p>需要指定iso文件的位置</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps7.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps8.jpg" alt="img"> </p>
<p>进入安装，选择skip（ctrl+alt可以将鼠标的光标跳出虚拟机）</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps9.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps10.jpg" alt="img"> </p>
<p>时区，亚洲上海</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps11.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps12.jpg" alt="img"> </p>
<p>选择basic server是安装为服务，只有dos命令，便于远程连接访问。如果是desktop桌面版的话不灵活且安装的内容会很多</p>
<p>慢慢等待安装完成，重新引导（重启）</p>
<p>登录时，使用的用户是root,录入密码时不会显示（其实已经输入了），显示第三行的内容为登录成功</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps13.jpg" alt="img"> </p>
<p>很少会直接登录，一般都是远程访问</p>
<h1 id="Linux远程访问"><a href="#Linux远程访问" class="headerlink" title="*Linux远程访问*"></a><em><strong>*Linux远程访问*</strong></em></h1><p>使用CRT软件打开</p>
<p>新建一个连接，快速连接</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps14.jpg" alt="img"> </p>
<p>需要录入linux的ip地址及用户名密码，连接成功后可以在选项中设置窗口颜色方案，变为黑白的这种经典窗口</p>
<p>在虚拟机中查看ip地址 ，输入命令 ifconfig</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps15.jpg" alt="img"> </p>
<p>注意事项:</p>
<p>1.关于linux安装时失败问题，有可能是硬件虚拟化没有打开，需要在bios中开启虚拟化。通过 <img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps16.jpg" alt="img">可以查看</p>
<p>2.关于CRT安装与破解(参考图片)</p>
<h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="*Linux目录结构*"></a><em><strong>*Linux目录结构*</strong></em></h1><p>Linux系统它是文件系统</p>
<p>它的根目录 是”/”,是以树型结构来管理</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps17.jpg" alt="img"> </p>
<p>Root用户登录后，显示时有一个~,它其实代表的就是root目录</p>
<p>通过命令cd..  就会放回上层的根目录 /]#</p>
<p>通过命令ls  可以查看所有的文件名 </p>
<p>bin  boot  cgroup  dev  etc  home  lib  lost  found  media  misc  mnt  net  opt  proc  root  sbin  selinux  srv  sys  tmp  usr  var</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps18.jpg" alt="img"> </p>
<p>root管理员的home目录root</p>
<p>其他用户的home目录home目录中</p>
<p>我们可以将我们自己的文件安装在任意位置</p>
<h1 id="Linux常用命令-重点"><a href="#Linux常用命令-重点" class="headerlink" title="*Linux常用命令(重点)*"></a><em><strong>*Linux常用命令(重点)*</strong></em></h1><p>1.切换目录命令 <em><strong>*cd*</strong></em> （这个命令非常重要）</p>
<p>cd app    切换到app目录    cd ..      切换到上一层目录    cd /        切换到系统根目录    cd ~        切换到用户主目录 root    cd -        切换到上一次执行时所在的目录</p>
<p>2.列出文件列表 <em><strong>*ls ll*</strong></em> （这个命令非常重要）</p>
<p>ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。</p>
<p>dir命令很少用</p>
<p> 格式：ls [参数]  [路径或文件名]        ls –help 可以帮助我们查看帮助信息，都有哪些命令可以执行</p>
<p>可能会出现中文乱码的问题，可以在选项中选择编码为UTF-8</p>
<p>ls -a  显示所有文件或目录（包含隐藏的文件）</p>
<p>ls -l  使用较长格式列出信息（详细信息），缩写成ll</p>
<p>TIPS:在linux中以 . 开头的文件都是隐藏的文件</p>
<p>3.创建与删除目录（注意权限）</p>
<p>可以mkdir –help查看可用命令</p>
<p>mkdir(make directory)命令可用来创建子目录：mkdir app  è  在当前目录下创建app目录mkdir –p app2/test  è 级联创建aap2以及test目录</p>
<p>rmdir(remove directory)命令可用来删除“空”的子目录：    rmdir app  è  删除app目录</p>
<p>当用rmdir 删除非空目录时会显示失败</p>
<p>4.浏览文件</p>
<p>cat操作：cat用于显示文件的内容。</p>
<p>格式：cat [参数] &lt;文件名&gt;</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps19.jpg" alt="img"> </p>
<p>more操作：more一般用于要显示的内容会超过一个画面长度的情况。</p>
<p>按空格键显示下一个画面，按回车键显示下一行内容，按 q 键退出查看</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps20.jpg" alt="img"> </p>
<p>less操作：用法和more类似，不同的是less可以通过PgUp、PgDn键来控制</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps21.jpg" alt="img"> </p>
<p>tail操作：tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容</p>
<p>用法:</p>
<p>tail -10 /etc/passwd  è 查看后10行数据</p>
<p>tail -f catalina.log  è <em><strong>*动态查看日志*</strong></em>(非常重要)</p>
<p>ctrl+c 结束查看</p>
<p>5.文件操作</p>
<p>cp操作：是copy操作</p>
<p>cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</p>
<p>cp a.txt b.txt  è 将a.txt复制为b.txt文件</p>
<p>cp  a.txt  ../  è 将a.txt文件复制到上一层目录中</p>
<p>cp  a.txt  /a/b.txt  将a.txt文件复制到a目录下的b.txt文件中（如果没有这个文件会创建）</p>
<p>mv操作：是move相当于剪切</p>
<p>mv 移动或者重命名</p>
<p>mv a.txt ../  è 将a.txt文件移动到上一层目录中</p>
<p>mv a.txt b.txt  è 将a.txt文件重命名为b.txt</p>
<p>rm操作：它可以帮助我们删除文件与目录</p>
<p>rm  删除文件</p>
<p>用法：rm  [选项]  文件</p>
<p>rm a.txt  è 删除a.txt文件 （删除需要用户确认，y/n）</p>
<p>rm 删除不需要询问</p>
<p>rm -f a.txt  è 不询问，直接删除</p>
<p>rm 删除目录</p>
<p>rm -r a  è 递归删除 （删除需要用户递归确认，y/n）</p>
<p>不询问递归删除（慎用）</p>
<p>rm -rf  a  è 不询问递归删除</p>
<p>rm -rf *  è  删除所有文件</p>
<p>rm -rf /*  è  自杀</p>
<p>****tar操作****：打包压缩与解压（打包或解压操作时常用）</p>
<p>ls或者ll命令下查看：d开头的一般是一个目录，r开头的是一个文件</p>
<p>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件（所以一般.gz或者.tgz文件就是linux系统的文件，.zip就是windows系统的文件）</p>
<p>常用参数：</p>
<p>-c：创建一个新tar文件</p>
<p>-v：显示运行过程的信息</p>
<p>-f：指定文件名</p>
<p>-z：调用gzip压缩命令进行压缩</p>
<p>-t：查看压缩文件的内容</p>
<p>-x：解开tar文件</p>
<p>打包：</p>
<p>tar –cvf xxx.tar ./*  将./*（./*可以是多个文件）的文件打包成xxx.tar文件</p>
<p>打包并且压缩：</p>
<p>tar –zcvf xxx.tar.gz ./* </p>
<p>解压 </p>
<p> tar –xvf xxx.tar   就会解压到当前路径</p>
<p>tar -xvf xxx.tar.gz -C /usr/aaa 注意：C要大写，必须在xxx.tar.gz的目录下执行这个命令</p>
<p>find操作：文件查找，用于查找符合条件的文件</p>
<p>示例：</p>
<p>find / -name “ins*” 查找文件名称是以ins开头的文件</p>
<p>find / -name “ins*” –ls  查找文件名称是以ins开头的文件并列出来详细信息</p>
<p>find / –user itcast –ls 查找用户itcast的文件并列出详细信息（user是权限符）</p>
<p>find / –user itcast –type d –ls 查找用户itcast的目录</p>
<p>find /-perm -777 –type d-ls 查找权限是777的文件</p>
<p>grep操作：字符串查找，用于查找文件中符合条件的字符串</p>
<p>用法: grep  [选项]   PATTERN [FILE]</p>
<p>示例：</p>
<p>grep lang anaconda-ks.cfg  在文件中查找lang</p>
<p>grep lang anaconda-ks.cfg –color 高亮显示</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps22.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps23.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps24.jpg" alt="img"> </p>
<p>A是after，B是before的意思，A5 B5就是前五行和后五行</p>
<p>6.其它常用命令</p>
<p>clear：清屏命令</p>
<p>pwd：显示当前所在目录</p>
<p>touch：创建一个空文件  touch a.txt</p>
<p>ll -h：友好显示文件大小，k表示</p>
<p>wget：下载资料   wget <a target="_blank" rel="noopener" href="http://nginx.org/download/nginx-1.9.12.tar.gz">http://nginx.org/download/nginx-1.9.12.tar.gz</a>  下载的东西会保存再当前目录</p>
<p>LSB是Linux Standard Base的缩写，lsb_release命令用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。</p>
<p>-v, –version<br>显示版本信息<br>-i, –id<br>显示发行版的ID<br>-d, –description<br>显示该发行版的描述信息<br>-r, –release<br>显示当前系统是发行版的具体版本号<br>-c, –codename<br>发行版代号<br>-a, –all<br>显示上面的所有信息<br>-h, –help<br>显示帮助信息</p>
<p> netstat -anp  查看当前进程</p>
<p>netstat -lnp|grep 80 查看80端口  tcp和linux的进程</p>
<p>netstat -ntpl|grep 80 查看80端口   只有tcp</p>
<p>netstat -tunlp|grep 80 查看80端口  只有tcp</p>
<p>ps -aux |grep 80  查看80端口  最全</p>
<p>lsof -i:80   查看80端口  最少</p>
<p>kill -9 进程名字  杀死进程</p>
<p>CentOS7 的防火墙配置跟以前版本有很大区别，CentOS7这个版本的防火墙默认使用的是firewall，与之前的版本Centos 6.x使用iptables不一样</p>
<p>一、iptables防火墙<br>1、基本操作</p>
<p>查看防火墙状态</p>
<p>service iptables status  </p>
<p>停止防火墙</p>
<p>service iptables stop  </p>
<p>启动防火墙</p>
<p>service iptables start  </p>
<p>重启防火墙</p>
<p>service iptables restart  </p>
<p>永久关闭防火墙</p>
<p>chkconfig iptables off  </p>
<p>永久关闭后重启</p>
<p>chkconfig iptables on　　</p>
<p>2、开启80端口</p>
<p>vim /etc/sysconfig/iptables</p>
<p>加入如下代码</p>
<p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT<br>保存退出后重启防火墙</p>
<p>service iptables restart<br>二、firewall防火墙<br>1、查看firewall服务状态</p>
<p>systemctl status firewalld</p>
<p>出现Active: active (running)切高亮显示则表示是启动状态。</p>
<p>出现 Active: inactive (dead)灰色表示停止，看单词也行。<br>2、查看firewall的状态</p>
<p>firewall-cmd –state<br>3、开启、重启、关闭、firewalld.service服务</p>
<p>开启</p>
<p>service firewalld start</p>
<p>重启</p>
<p>service firewalld restart</p>
<p>关闭</p>
<p>service firewalld stop<br>4、查看防火墙规则</p>
<p>firewall-cmd –list-all<br>5、查询、开放、关闭端口</p>
<p>查询端口是否开放</p>
<p>firewall-cmd –query-port=8080/tcp</p>
<p>开放80端口</p>
<p>firewall-cmd –permanent –add-port=80/tcp</p>
<p>移除端口</p>
<p>firewall-cmd –permanent –remove-port=8080/tcp<br>#重启防火墙(修改配置后要重启防火墙)<br>firewall-cmd –reload</p>
<p>参数解释</p>
<p>1、firwall-cmd：是Linux提供的操作firewall的一个工具；<br>2、–permanent：表示设置为持久；<br>3、–add-port：标识添加的端口；</p>
<p>CentOS7 默认使用firewalld防火墙，如果想换回iptables防火墙，可关闭firewalld并安装iptables。</p>
<h1 id="VI与VIM编辑器"><a href="#VI与VIM编辑器" class="headerlink" title="*VI与VIM编辑器*"></a><em><strong>*VI与VIM编辑器*</strong></em></h1><p>vim是vi的升级。</p>
<p>在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。有三种模式： 命令行、 插入  、底行 模式</p>
<p>通过vi（vim）文件名，就可以对文件进行操作。 </p>
<p>当操作时，开始是命令行模式，按i o  a 切换到插入模式</p>
<p>i 在当前位置前插入</p>
<p>  I 在当前行首插入</p>
<p>  a 在当前位置后插入</p>
<p>  A 在当前行尾插入</p>
<p>  o 在当前行之后插入一行</p>
<p>  O 在当前行之前插入一行</p>
<p>再按esc 可以重新切换到命令行模式 </p>
<p>在命令行模式下按 “:” 就可以切换到底行模式，更多详细用法，可以查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》</p>
<p>在命令行模式下可以使用一些快捷键：</p>
<p>打开文件：vim file</p>
<p>退出：esc à :q （切换到底行模式，再按q就是退出）</p>
<p>修改文件：输入i进入插入模式</p>
<p>保存并退出：escà:wq</p>
<p>不保存退出：escà:q!</p>
<p>三种进入插入模式：</p>
<p>i:在当前的光标所在处插入</p>
<p>o:在当前光标所在的行的下一行插入</p>
<p>a:在光标所在的下一个字符插入</p>
<p>快捷键：</p>
<p>dd – 快速删除一行</p>
<p>yy - 复制当前行</p>
<p>nyy - 从当前行向后复制几行</p>
<p>p - 粘贴</p>
<p>R – 替换</p>
<p>重定向</p>
<p>echo  “sdahufha”  命令就是直接打印出“”内容</p>
<p>&gt;  重定向输出，覆盖原有内容；    &gt;&gt; 重定向输出，换行+追加功能；    示例：</p>
<p>cat /etc/passwd &gt; a.txt  将输出定向到a.txt中</p>
<p>cat /etc/passwd &gt;&gt; a.txt  输出并且追加</p>
<p>ifconfig &gt; ifconfig.txt</p>
<p>管道</p>
<p>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例</p>
<p>ls –help | more  分页查询帮助信息</p>
<p>ps –ef | grep java  查询名称中包含java的进程 （ps -ef 查看当前的进程）</p>
<p>ifconfig | more</p>
<p>cat index.html | more</p>
<p>ps –ef | grep aio</p>
<p>&amp;&amp;命令执行控制</p>
<p>命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。  </p>
<p>只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 </p>
<p>只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。</p>
<p>mkdir test &amp;&amp; cd test</p>
<p>系统管理常用命令</p>
<p>date 可以显示或设置系统时间</p>
<p>date  显示当前系统时间</p>
<p>date -s “2014-01-01 10:10:10“  设置系统时间df 显示磁盘信息</p>
<p>df –h  友好显示大小free 显示内存状态</p>
<p>free –m 以mb单位显示内存组昂头top 显示，管理执行中的程序</p>
<p>clear 清屏幕 </p>
<p>ps 正在运行的某个进程的状态</p>
<p>ps –ef  查看所有进程</p>
<p>ps –ef | grep ssh 查找某一进程kill 杀掉某一进程kill + pid</p>
<p>kill 2868  杀掉2868编号的进程</p>
<p>kill -9 2868  强制杀死进程</p>
<p>du 显示目录或文件的大小。</p>
<p>du –h 显示当前目录的大小</p>
<p> who 显示目前登入系统的用户信息。 </p>
<p>uname 显示系统信息。</p>
<p>uname -a 显示本机详细信息。依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称</p>
<h1 id="Linux下用户与组管理"><a href="#Linux下用户与组管理" class="headerlink" title="*Linux下用户与组管理*"></a><em><strong>*Linux下用户与组管理*</strong></em></h1><p>用户管理</p>
<p>useradd 添加一个用户</p>
<p>useradd test 添加test用户 （会出现在home目录下）</p>
<p>useradd test -d /home/t1  指定用户home目录 </p>
<p>passwd  设置、修改密码</p>
<p>passwd test  为test用户设置密码</p>
<p>切换登录：</p>
<p>ssh -l test -p 22 192.168.19.128  （ssh协议默认22端口）</p>
<p>su – 用户名 切换到这个用户</p>
<p> userdel 删除一个用户</p>
<p>userdel test 删除test用户(不会删除home目录)</p>
<p>userdel –r test  删除用户以及home目录</p>
<p>组管理</p>
<p>当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组 </p>
<p>创建用户时也可以指定所在组 </p>
<p>groupadd  创建组</p>
<p>groupadd public  创建一个名为public的组</p>
<p>useradd u1 –g public  创建用户指定组groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。</p>
<p>groupdel public</p>
<p>id命令：查看一个用户的UID和GID用法：id  [选项] [用户名]</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps25.jpg" alt="img"> </p>
<p>直接使用id，直接使用id 用户名</p>
<p>su命令：切换用户。用法：su   [选项]  [-] [用户   [参数]  ]示例：</p>
<p>su u1  切换到u1用户</p>
<p>su - u1 切换到u1用户，并且将环境也切换到u1用户的环境（推荐使用）</p>
<p>账户文件</p>
<p>/etc/passwd  用户文件    /etc/shadow  密码文件    /etc/group  组信息文件</p>
<p>【用户文件】</p>
<p>root:x:0:0:root:/root:/bin/bash账号名称：        在系统中是唯一的用户密码：        此字段存放加密口令用户标识码(User ID)：  系统内部用它来标示用户组标识码(Group ID)：  系统内部用它来标识用户属性用户相关信息：        例如用户全名等用户目录：        用户登录系统后所进入的目录用户环境:        用户工作的环境</p>
<p>【密码文件】</p>
<p>shadow文件中每条记录用冒号间隔的9个字段组成.用户名：用户登录到系统时使用的名字，而且是惟一的口令：  存放加密的口令最后一次修改时间:  标识从某一时刻起到用户最后一次修改时间最大时间间隔:  口令保持有效的最大天数，即多少天后必须修改口令最小时间间隔：    再次修改口令之间的最小天数警告时间：从系统开始警告到口令正式失效的天数不活动时间：    口令过期少天后，该账号被禁用失效时间：指示口令失效的绝对天数(从1970年1月1日开始计算)标志：未使用 </p>
<p>【组文件】</p>
<p>root:x:0:组名：用户所属组组口令：一般不用GID：组ID用户列表：属于该组的所有用户</p>
<h1 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="*文件权限管理*"></a><em><strong>*文件权限管理*</strong></em></h1><p>文件权限</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps26.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps27.jpg" alt="img"> </p>
<p>r:对文件是指可读取内容 对目录是可以ls</p>
<p>w:对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件)</p>
<p>x:对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录</p>
<p>Linux三种文件类型：</p>
<p>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 </p>
<p> 目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。  </p>
<p>设备文件： Linux系统把每一个设备都看成是一个文件</p>
<p>文件类型标识：</p>
<p>普通文件（-）目录（d）符号链接（l） 进入etc可以查看，相当于快捷方式字符设备文件（c）块设备文件（s）套接字（s）命名管道（p）</p>
<p>文件权限管理：</p>
<p>chmod 变更文件或目录的权限。</p>
<p>chmod 755 a.txt </p>
<p>chmod u=rwx,g=rx,o=rx a.txt</p>
<p>chmod 000 a.txt  / chmod 777 a.txt</p>
<p>chmod u-r a.txt  /  chmod g+x a.txtchown 变更文件或目录改文件所属用户和组</p>
<p>chown u1:public a.txt：变更当前的目录或文件的所属用户和组(用户为u1，组为public)</p>
<p>chown -R u1:public dir：变更目录中的所有的子目录及子文件的所属用户和组</p>
<h1 id="常用网络操作"><a href="#常用网络操作" class="headerlink" title="*常用网络操作*"></a><em><strong>*常用网络操作*</strong></em></h1><p>主机名配置</p>
<p>hostname 查看主机名</p>
<p>hostname xxx 修改主机名，临时性修改 重启后无效</p>
<p>如果想要永久生效，可以修改/etc/sysconfig/network文件（vi 进入文件后编辑）</p>
<p>IP地址配置</p>
<p>Setup设置ip地址</p>
<p>ifconfig 查看(修改)ip地址(重启后无效)</p>
<p>ifconfig eth0 192.168.12.22 修改ip地址</p>
<p>如果想要永久生效</p>
<p>修改 /etc/sysconfig/network-scripts/ifcfg-eth0文件</p>
<p>可以直接输入setup进入网络配置设置（DHCP是自动分配，自己设置的话就是静态ip，空格，tab键）</p>
<p>域名映射</p>
<p>在windows中，System下的drivers下的etc下的hosts文件是域名映射文件</p>
<p>/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps28.jpg" alt="img"> </p>
<p>网络服务管理</p>
<p>service network status 查看指定服务的状态</p>
<p>service network stop 停止指定服务</p>
<p>service network start 启动指定服务</p>
<p>service network restart 重启指定服务</p>
<p>service —status–all 查看系统中所有后台服务</p>
<p>netstat –nltp 查看系统中网络进程的端口监听情况</p>
<p>防火墙设置</p>
<p>防火墙根据配置文件/etc/sysconfig/iptables来控制本机的”出”、”入”网络访问行为。</p>
<p>service iptables status 查看防火墙状态</p>
<p><em><strong>*service iptables stop 关闭防火墙*</strong></em> （需要关闭以访问一些服务和下载）</p>
<p>service iptables start 启动防火墙</p>
<p>chkconfig  iptables off 禁止防火墙自启</p>
<h1 id="Linux上软件安装介绍"><a href="#Linux上软件安装介绍" class="headerlink" title="*Linux上软件安装介绍*"></a><em><strong>*Linux上软件安装介绍*</strong></em></h1><p>Linux上的软件安装有以下几种常见方式介绍</p>
<p>1.二进制发布包</p>
<p>软件已经针对具体平台编译打包发布，只要解压，修改配置即可（可能对linux的某个版本可以，其他版本不可用）</p>
<p>2.RPM包</p>
<p>软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装（可能依赖其他包，需要下载其他包，但是可能没有打包依赖包）</p>
<p>3.Yum在线安装</p>
<p>软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题</p>
<p>4.源码编译安装</p>
<p>软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署。</p>
<p>上传与下载工具介绍：就是windows和linux的文件交互</p>
<p>1.FileZilla：在windows上下载好</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps29.jpg" alt="img"> </p>
<p>解压后，运行exe文件：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps30.jpg" alt="img"> </p>
<p>左边是windows的文件，右边是linux的文件，可以直接把左边的安装包拖拽到右边进行上传</p>
<p>2.lrzsz</p>
<p>我们可以在linux上使用yum安装方式安装 yum install lrzsz</p>
<p>注意：必须有网络</p>
<p>直接输入命令：yum install lrzsz 就会提示下载成功</p>
<p>可以在crt中设置上传与下载目录：在crt上面有个选项，会话选择</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps31.jpg" alt="img"> </p>
<p>上传：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps32.jpg" alt="img"> </p>
<p>下载：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps33.jpg" alt="img"> </p>
<p>在Linux上安装JDK:</p>
<p>1.上传JDK到Linux的服务器</p>
<p>通过rz命令上传JDK，然后java –version发现可以查到版本号，所以卸载自带的open-JDK</p>
<p>rpm -qa | grep java 查找自带的java版本。然后复制，再通过rpm -e –nodeps 复制的内容卸载</p>
<p>rpm -e –nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686</p>
<p>rpm -e –nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.i686</p>
<p>2.在Linux服务器上安装JDK</p>
<p>通常将软件安装到/usr/local</p>
<p>直接解压就可以： tar –xvf  jdk.tar.gz  -C 目标路径  </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps34.jpg" alt="img">./就是当前</p>
<p>3.配置JDK的环境变量</p>
<p>ll查看jdk下的文件获得版本号</p>
<p>配置环境变量：</p>
<p>① vi /etc/profile</p>
<p>② 在末尾行添加</p>
<p>​    #set java environment</p>
<p>​    JAVA_HOME=/usr/local/jdk/jdk1.7.0_71</p>
<p>​    CLASSPATH=.:$JAVA_HOME/lib.tools.jar</p>
<p>​    PATH=$JAVA_HOME/bin:$PATH</p>
<p>​    export JAVA_HOME CLASSPATH PATH</p>
<p>保存退出 ：wq</p>
<p>③source /etc/profile  使更改的配置立即生效</p>
<p>在Linux上安装Mysql:</p>
<p>1.将mysql的安装文件上传到Linux的服务器.（也可以通过wget 网址下载Mysql的安装包）</p>
<p>rz上传</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps35.jpg" alt="img"> </p>
<p>将mysql的tar解压：创建一个新的mysql目录</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps36.jpg" alt="img"> </p>
<p>将系统自带的mysql卸载</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps37.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps38.jpg" alt="img"> </p>
<p>–nodeps是忽略相关依赖包</p>
<p>2.安装MYSQL服务端</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps39.jpg" alt="img"> </p>
<p>如果安装显示出错，需要导入相关的依赖包</p>
<p>下面的提示是告诉我们root用户的密码第一次是随机生成的，它保存在/root/.mysql_secret中，第一次登录需要修改root密码</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps40.jpg" alt="img"> </p>
<p>3.安装MYSQL客户端</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps41.jpg" alt="img"> </p>
<p>查看生成的root密码</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps42.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps43.jpg" alt="img"> </p>
<p>报错:原因是没有启动mysql服务</p>
<p>需要开启mysql服务</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps44.jpg" alt="img"> </p>
<p>可以通过netstat -nltp 查看现在的服务，找到3306的端口证明启动了mysql</p>
<p>然后进行登录，操作mysql时会报错，原因是第一次操作mysql必须修改root用户的密码</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps45.jpg" alt="img"> </p>
<p>设置root用户的密码为root</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps46.jpg" alt="img"> </p>
<p><em><strong>*M*</strong>***</em>*ysql服务加入到系统服务并自动启动操作********：****chkconfig –add mysql</p>
<p>自动启动：chkconfig mysql on</p>
<p>查询列表：chkconfig</p>
<p>关于mysql远程访问设置：</p>
<p>先登录到mysql，然后输入下面命令进行设置</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml2932\wps47.jpg" alt="img"> </p>
<p>在linux中很多软件的端口都被”防火墙”限止，我们需要将防火墙关闭，也可以将防火墙打开3306端口</p>
<p>/sbin/iptables -I INPUT -p tcp –dport 3306 -j ACCEPT</p>
<p>/etc/rc.d/init.d/iptables save</p>
<p>/etc/init.d/iptables status</p>
<p>学习阶段我们也可以直接将防火墙关闭（不推荐，因为服务器需要防火墙）：service iptables stop</p>
<p>在Linux上安装tomcat:</p>
<p>1.Tomcat上传到linux上：rz，上传文件。ll查看是否上传成功</p>
<p>2.将上传的tomcat解压：建目录mkdir tomcat7  ，然后tar -xvf 安装包名字 -C ./tomacat7</p>
<p>3.在tomcat/bin目录下执行 startup.sh（注意防火墙需要关闭）： ./startup.sh </p>
<p>4.查看日志 tomcat/logs/catalina.out：cat ./catalina.out</p>
<p>也可以查看cat ./catalina.日期.log</p>
<p>以后的文件工程可以放到webapp下进行发布</p>
<p><strong>Linux系统一般有4个主要部分：</strong></p>
<p>内核、shell、文件系统和应用程序。内核、shell和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统。部分层次结构如图1-1所示。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lEDBbOe0FuicSPxypcgPoeL9uibcHTFXGQibX74k5ffhwscOY6zyhhZgH1w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iblTYUnF9yPPAFqPibv6Siadtw5kYIvianGuggAAZcL0nicTqibicKG1MUJG8Nvic9BVDaXuJSlRZquoQJjNkNgglBRAxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>一、linux内核</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OKdYEbfJSc6gicBpKXLM0OehXMoaLEVciciaZtGq2EVOCnYxayTAq4iat0n7tpp67RLQyAwnJ704cic8UPyaYhQicRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。</p>
<p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。如图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lETUWYmjOW4badfSmqjQhYuGiaxO1ZmiaiayfKJslK7oJBD2qZN4t5IHicuA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">图1</p>
<p> 系统调用接口：SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。</p>
<h3 id="1、内存管理"><a href="#1、内存管理" class="headerlink" title="1、内存管理"></a><strong>1、内存管理</strong></h3><p>对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux  采用了称为“虚拟内存”的内存管理方式。Linux  将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。</p>
<p>不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。</p>
<p>为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。</p>
<h3 id="2、进程管理"><a href="#2、进程管理" class="headerlink" title="2、进程管理"></a><strong>2、进程管理</strong></h3><p>进程实际是某特定应用程序的一个运行实体。在 Linux  系统中，能够同时运行多个进程，Linux  通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。</p>
<p>进程调度控制进程对CPU的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待CPU资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux使用了比较简单的基于优先级的进程调度算法选择新的进程。</p>
<p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。</p>
<p>内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSⅨ] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSⅨ 机制）。</p>
<h3 id="3、-文件系统"><a href="#3、-文件系统" class="headerlink" title="3、 文件系统"></a><strong>3、 文件系统</strong></h3><p>和 DOS 等操作系统不同，Linux 操作系统中单独的文件系统并不是由驱动器号或驱动器名称（如 A:  或 C:  等）来标识的。相反，和 UNIX  操作系统一样，Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux  将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。Linux  操作系统的一个重要特点是它支持许多不同类型的文件系统。Linux 中最普遍使用的文件系统是 Ext2，它也是 Linux  土生土长的文件系统。但 Linux  也能够支持 FAT、VFAT、FAT32、MINIX 等不同类型的文件系统，从而可以方便地和其它操作系统交换数据。由于 Linux  支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统.</p>
<p>虚拟文件系统（VirtualFileSystem,VFS）:隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。虚拟文件系统可以分为逻辑文件系统和设备驱动程序。逻辑文件系统指Linux所支持的文件系统，如ext2,fat等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。</p>
<p>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层。即VFS 在用户和文件系统之间提供了一个交换层。</p>
<h5 id="VFS在用户和文件系统之间提供了一个交换层"><a href="#VFS在用户和文件系统之间提供了一个交换层" class="headerlink" title="VFS在用户和文件系统之间提供了一个交换层:"></a>VFS在用户和文件系统之间提供了一个交换层:</h5><p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lEQqkMREF3lmAGBkIon8Nm1VNjPdYz1KxFnV2oEVdLjNU9AnJzPRDVuw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。</p>
<p>文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p>
<p>因此，用户和进程不需要知道文件所在的文件系统类型，而只需要象使用 Ext2  文件系统中的文件一样使用它们。</p>
<h3 id="4、设备驱动程序"><a href="#4、设备驱动程序" class="headerlink" title="4、设备驱动程序"></a><strong>4、设备驱动程序</strong></h3><p>设备驱动程序是 Linux  内核的主要部分。和操作系统的其它部分类似，设备驱动程序运行在高特权级的处理器环境中，从而可以直接对硬件进行操作，但正因为如此，任何一个设备驱动程序的错误都可能导致操作系统的崩溃。设备驱动程序实际控制操作系统和硬件设备之间的交互。</p>
<p>设备驱动程序提供一组操作系统可理解的抽象接口完成和操作系统之间的交互，而与硬件相关的具体操作细节由设备驱动程序完成。一般而言，设备驱动程序和设备的控制芯片有关，例如，如果计算机硬盘是 SCSI  硬盘，则需要使用 SCSI  驱动程序，而不是 IDE 驱动程序。</p>
<h3 id="5、网络接口（NET）"><a href="#5、网络接口（NET）" class="headerlink" title="5、网络接口（NET）"></a><strong>5、网络接口（NET）</strong></h3><p>提供了对各种网络标准的存取和各种网络硬件的支持。网络接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。众所周知，TCP/IP  协议是 Internet  的标准协议，同时也是事实上的工业标准。</p>
<p>Linux  的网络实现支持 BSD 套接字，支持全部的TCP/IP协议。Linux内核的网络部分由BSD套接字、网络协议层和网络设备驱动程序组成。网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iblTYUnF9yPPAFqPibv6Siadtw5kYIvianGuggAAZcL0nicTqibicKG1MUJG8Nvic9BVDaXuJSlRZquoQJjNkNgglBRAxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>二、linux shell</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OKdYEbfJSc6gicBpKXLM0OehXMoaLEVciciaZtGq2EVOCnYxayTAq4iat0n7tpp67RLQyAwnJ704cic8UPyaYhQicRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。</p>
<p><strong>目前主要有下列版本的shell。</strong></p>
<p>1、Bourne Shell：是贝尔实验室开发的。<br>2、BASH：是GNU的Bourne Again Shell，是GNU操作系统上默认的shell,大部分linux的发行套件使用的都是这种shell。<br>3、Korn Shell：是对Bourne SHell的发展，在大部分内容上与Bourne Shell兼容。<br>4、C Shell：是SUN公司Shell的BSD版本。</p>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iblTYUnF9yPPAFqPibv6Siadtw5kYIvianGuggAAZcL0nicTqibicKG1MUJG8Nvic9BVDaXuJSlRZquoQJjNkNgglBRAxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>三、****linux 文件系统</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OKdYEbfJSc6gicBpKXLM0OehXMoaLEVciciaZtGq2EVOCnYxayTAq4iat0n7tpp67RLQyAwnJ704cic8UPyaYhQicRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、 EXT3、 FAT、 FAT32、 VFAT和ISO9660。</p>
<h3 id="3-1-文件类型"><a href="#3-1-文件类型" class="headerlink" title="3.1 文件类型"></a><strong>3.1 文件类型</strong></h3><p>Linux下面的文件类型主要有：</p>
<p><strong>1) 普通文件：</strong>C语言元代码、SHELL脚本、二进制的可执行文件等。分为纯文本和二进制。<br><strong>2) 目录文件：</strong>目录，存储文件的唯一地方。<br><strong>3) 链接文件：</strong>指向同一个文件或目录的的文件。<br><strong>4) 设备文件：</strong>与系统外设相关的，通常在/dev下面。分为块设备和字符设备。</p>
<p><strong>5）管道(FIFO)文件 :</strong> 提供进程建通信的一种方式<br><strong>6）套接字(socket) 文件：</strong> 该文件类型与网络通信有关</p>
<p>可以通过ls –l, file, stat几个命令来查看文件的类型等相关信息。</p>
<h3 id="3-2-Linux目录"><a href="#3-2-Linux目录" class="headerlink" title="3.2  Linux目录"></a><strong>3.2  Linux目录</strong></h3><p>文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上。</p>
<p>目录提供了管理文件的一个方便而有效的途径。</p>
<p>Linux使用标准的目录结构，在安装的时候，安装程序就已经为用户创建了文件系统和完整而固定的目录组成形式，并指定了每个目录的作用和其中的文件类型。</p>
<p>完整的目录树可划分为小的部分，这些小部分又可以单独存放在自己的磁盘或分区上。这样，相对稳定的部分和经常变化的部分可单独存放在不同的分区中，从而方便备份或系统管理。目录树的主要部分有 root、/usr、/var、/home  等（图2） 。这样的布局可方便在 Linux 计算机之间共享文件系统的某些部分。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lEs5lJ5fZtO0ibWSopT8HNxrGISkXhdWxKwicwodAHXdLluic9ibuQszIGOA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图2</p>
<p>Linux采用的是树型结构。最上层是根目录，其他的所有目录都是从根目录出发而生成的。</p>
<p>微软的DOS和windows也是采用树型结构，但是在DOS和 windows中这样的树型结构的根是磁盘分区的盘符，有几个分区就有几个树型结构，他们之间的关系是并列的。最顶部的是不同的磁盘（分区），如：C，D，E，F等。</p>
<p>但是在linux中，无论操作系统管理几个磁盘分区，这样的目录树只有一个。从结构上讲，各个磁盘分区上的树型目录不一定是并列的。</p>
<h3 id="3-3-Linux磁盘分区"><a href="#3-3-Linux磁盘分区" class="headerlink" title="3.3 Linux磁盘分区"></a><strong>3.3 Linux磁盘分区</strong></h3><h4 id="一、主分区，扩展分区和逻辑分区："><a href="#一、主分区，扩展分区和逻辑分区：" class="headerlink" title="一、主分区，扩展分区和逻辑分区："></a><strong>一、主分区，扩展分区和逻辑分区：</strong></h4><p>linux分区不同于windows,硬盘和硬盘分区在Linux都表示为设备.</p>
<p><strong>硬盘分区一共有三种：</strong>主分区，扩展分区和逻辑分区。</p>
<p>硬盘的分区主要分为主分区(Primary Partion)和扩展分区(Extension Partion)两种，主分区和扩展分区的数目之和不能大于四个。</p>
<blockquote>
<p><strong>主分区(Primary Partion)：</strong>可以马上被使用但不能再分区。</p>
<p><strong>扩展分区(Extension Partion)：</strong>必须再进行分区后才能使用，也就是说它必须还要进行二次分区。</p>
<p><strong>逻辑分区（(Logical Partion)）：</strong>由扩展分区建立起来的分区。逻辑分区没有数量上限制。</p>
</blockquote>
<p>扩展分区只不过是逻辑分区的“容器”，实际上只有主分区和逻辑分区进行数据存储。</p>
<h4 id="二、Linux下硬盘分区的标识"><a href="#二、Linux下硬盘分区的标识" class="headerlink" title="二、Linux下硬盘分区的标识"></a><strong>二、Linux下硬盘分区的标识</strong></h4><p>硬盘分区的标识一般使用/dev/hd[a-z]X或者/dev/sd[a-z]X来标识，其中[a-z]代表硬盘号，X代表硬盘内的分区号。</p>
<p>整块硬盘分区的块号标识:Linux下用hda、hdb、sda、sdb 等来标识不同的硬盘;</p>
<p><strong>其中：</strong></p>
<p><strong>IDE接口硬盘：</strong>表示为/dev/hda1、/dev/hdb …；</p>
<p>SCSI 接口的硬盘、SATA接口的硬盘表示为/dev/sda、/dev/sdb … … ；</p>
<p><strong>硬盘内的分区：</strong>如果X的值是1到4,表示硬盘的主分区（包含扩展分区）；逻辑分区从是从5开始的，比如/dev/hda5肯定是逻辑分区了；</p>
<p><strong>例如：</strong></p>
<p>用hda1、hda2、 hda5、hda6 来标识不同的分区。其中，字母a 代表第一块硬盘，b代表第二块硬盘，依次类推。而数字1 代表一块硬盘的第一个分区、2 代表第二个分区，依次类推。1 到4 对应的是主分区(Primary Partition)或扩展分区(Extension Partition)。从5开始，对应的都是硬盘的逻辑分区(Logical Partition)。一块硬盘即使只有一个主分区，逻辑分区也是从5开始编号的，这点应特别注意。</p>
<p><strong>总结：</strong>一个硬盘分区首先要大确认在哪个硬盘，然后再确认它所在硬盘内的哪个分区。</p>
<p>对于/dev/hda 类似的表示方法，也并不寞生吧；我们在Linux通过fdisk -l 就可以查到硬盘是/dev/hda还是/dev/hdb；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  　[root@localhost ~]# fdisk -l      　　</span><br><span class="line">   　Disk &#x2F;dev&#x2F;hda: 80.0 GB, 80026361856 bytes   　　255 heads, 63 sectors&#x2F;track, 9729 cylinders   　　Units &#x3D; cylinders of 16065 * 512 &#x3D; 8225280 bytes   　　 Device Boot Start End Blocks Id System   　　&#x2F;dev&#x2F;hda1 * 1 970 7791493+ 7 HPFS&#x2F;NTFS   　　&#x2F;dev&#x2F;hda2 971 9729 70356667+ 5 Extended   　　&#x2F;dev&#x2F;hda5 971 2915 15623181 b W95 FAT32   　　&#x2F;dev&#x2F;hda6 2916 4131 9767488+ 83 linux   　　&#x2F;dev&#x2F;hda7 4132 5590 11719386 83 linux   　　&#x2F;dev&#x2F;hda8 5591 6806 9767488+ 83 linux   　　&#x2F;dev&#x2F;hda9 6807 9657 22900626 83 linux   　　&#x2F;dev&#x2F;hda10 9658 9729 578308+ 82 linux swap &#x2F; Solaris</span><br></pre></td></tr></table></figure>

<p>请注意第一行， Disk /dev/hda: 80.0 GB, 80026361856 bytes ，这个就是表示机器中只有一个硬盘设备/dev/hda ，体积大小为 80.0G；下面的就是硬盘的分区，每个分区都有详细的信息，在这里不详细说了；</p>
<p><strong>Linux下磁盘分区和目录的关系如下：</strong></p>
<p>– 任何一个分区都必须挂载到某个目录上。</p>
<p>– 目录是逻辑上的区分。分区是物理上的区分。</p>
<p>– 磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作。</p>
<p>– 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。</p>
<h3 id="3-4-linux主要目录的功用。"><a href="#3-4-linux主要目录的功用。" class="headerlink" title="3.4 linux主要目录的功用。"></a><strong>3.4 linux主要目录的功用。</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin 二进制可执行命令   　　</span><br><span class="line"> &#x2F;dev 设备特殊文件   　　&#x2F;etc 系统管理和配置文件   　　&#x2F;etc&#x2F;rc.d 启动的配置文件和脚本   　　&#x2F;home 用户主目录的基点，比如用户user的主目录就是&#x2F;home&#x2F;user，可以用~user表示   　　&#x2F;lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件   　　&#x2F;sbin 系统管理命令，这里存放的是系统管理员使用的管理程序   　　&#x2F;tmp 公用的临时文件存储点   　　&#x2F;root 系统管理员的主目录（呵呵，特权阶级）   　　&#x2F;mnt 系统提供这个目录是让用户临时挂载其他的文件系统。  　　&#x2F;lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里   　　&#x2F;proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。  　　&#x2F;var 某些大文件的溢出区，比方说各种服务的日志文件   　　&#x2F;usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：  　　      &#x2F;usr&#x2F;X11R6 存放X window的目录   　　      &#x2F;usr&#x2F;bin 众多的应用程序   　　      &#x2F;usr&#x2F;sbin 超级用户的一些管理程序   　　      &#x2F;usr&#x2F;doc linux文档   　　      &#x2F;usr&#x2F;include linux下开发和编译应用程序所需要的头文件   　　      &#x2F;usr&#x2F;lib 常用的动态链接库和软件包的配置文件   　　      &#x2F;usr&#x2F;man 帮助文档   　　      &#x2F;usr&#x2F;src 源代码，linux内核的源代码就放在&#x2F;usr&#x2F;src&#x2F;linux里   　　      &#x2F;usr&#x2F;local&#x2F;bin 本地增加的命令   　　      &#x2F;usr&#x2F;local&#x2F;lib 本地增加的库</span><br></pre></td></tr></table></figure>

<h3 id="3-5-linux文件系统"><a href="#3-5-linux文件系统" class="headerlink" title="3.5  linux文件系统"></a><strong>3.5  linux文件系统</strong></h3><p>文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。</p>
<p><strong>1、文件系统类型：</strong></p>
<h4 id="ext2-：-早期linux中常用的文件系统-ext3-：-ext2的升级版，带日志功能-RAMFS-：-内存文件系统，速度很快-NFS-：-网络文件系统，由SUN发明，主要用于远程文件共享-MS-DOS-：-MS-DOS文件系统-VFAT-：-Windows-95-98-操作系统采用的文件系统-FAT-：-Windows-XP-操作系统采用的文件系统-NTFS：-Windows-NT-XP-操作系统采用的文件系统-HPFS-：-OS-2-操作系统采用的文件系统-PROC-虚拟的进程文件系统-ISO9660-：-大部分光盘所采用的文件系统-ufsSun-OS-所采用的文件系统-NCPFS-：-Novell-服务器所采用的文件系统-SMBFS-：-Samba-的共享文件系统-XFS-：-由SGI开发的先进的日志文件系统，支持超大容量文件-JFS-：IBM的AIX使用的日志文件系统-ReiserFS-基于平衡树结构的文件系统-udf-可擦写的数据光盘文件系统"><a href="#ext2-：-早期linux中常用的文件系统-ext3-：-ext2的升级版，带日志功能-RAMFS-：-内存文件系统，速度很快-NFS-：-网络文件系统，由SUN发明，主要用于远程文件共享-MS-DOS-：-MS-DOS文件系统-VFAT-：-Windows-95-98-操作系统采用的文件系统-FAT-：-Windows-XP-操作系统采用的文件系统-NTFS：-Windows-NT-XP-操作系统采用的文件系统-HPFS-：-OS-2-操作系统采用的文件系统-PROC-虚拟的进程文件系统-ISO9660-：-大部分光盘所采用的文件系统-ufsSun-OS-所采用的文件系统-NCPFS-：-Novell-服务器所采用的文件系统-SMBFS-：-Samba-的共享文件系统-XFS-：-由SGI开发的先进的日志文件系统，支持超大容量文件-JFS-：IBM的AIX使用的日志文件系统-ReiserFS-基于平衡树结构的文件系统-udf-可擦写的数据光盘文件系统" class="headerlink" title="ext2 ： 早期linux中常用的文件系统 ext3 ： ext2的升级版，带日志功能 RAMFS ： 内存文件系统，速度很快 NFS ： 网络文件系统，由SUN发明，主要用于远程文件共享 MS-DOS ： MS-DOS文件系统 VFAT ： Windows 95/98 操作系统采用的文件系统 FAT ： Windows XP 操作系统采用的文件系统 NTFS： Windows NT/XP 操作系统采用的文件系统 HPFS ： OS/2 操作系统采用的文件系统 PROC : 虚拟的进程文件系统 ISO9660 ： 大部分光盘所采用的文件系统 ufsSun : OS 所采用的文件系统 NCPFS ： Novell 服务器所采用的文件系统 SMBFS ： Samba 的共享文件系统 XFS ： 由SGI开发的先进的日志文件系统，支持超大容量文件 JFS ：IBM的AIX使用的日志文件系统 ReiserFS : 基于平衡树结构的文件系统 udf: 可擦写的数据光盘文件系统"></a><strong>ext2 ：</strong> 早期linux中常用的文件系统 <strong>ext3 ：</strong> ext2的升级版，带日志功能 <strong>RAMFS ：</strong> 内存文件系统，速度很快 <strong>NFS ：</strong> 网络文件系统，由SUN发明，主要用于远程文件共享 <strong>MS-DOS ：</strong> MS-DOS文件系统 <strong>VFAT ：</strong> Windows 95/98 操作系统采用的文件系统 <strong>FAT ：</strong> Windows XP 操作系统采用的文件系统 <strong>NTFS：</strong> Windows NT/XP 操作系统采用的文件系统 <strong>HPFS ：</strong> OS/2 操作系统采用的文件系统 <strong>PROC :</strong> 虚拟的进程文件系统 <strong>ISO9660 ：</strong> 大部分光盘所采用的文件系统 <strong>ufsSun :</strong> OS 所采用的文件系统 <strong>NCPFS ：</strong> Novell 服务器所采用的文件系统 <strong>SMBFS ：</strong> Samba 的共享文件系统 <strong>XFS ：</strong> 由SGI开发的先进的日志文件系统，支持超大容量文件 <strong>JFS ：</strong>IBM的AIX使用的日志文件系统 ReiserFS : 基于平衡树结构的文件系统 udf: 可擦写的数据光盘文件系统</h4><h4 id="2、文件系统特性："><a href="#2、文件系统特性：" class="headerlink" title="2、文件系统特性："></a><strong>2、文件系统特性：</strong></h4><p>磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个分区。格式化的目的是能使操作系统可以使用的文件系统格式（即我们上面提到文件系统类型）.</p>
<p>每种操作系统能够使用的文件系统并不相同. 如windows 98 以前的微软操作系统主要利用的文件系统是 FAT (或 FAT16)，windows 2000 以后的版本有所谓的 NTFS 文件系统，至于 Linux 的正统文件系统则为 Ext2 (Linux second extended file system, ext2fs)这一个。此外，在默认的情况下，windows 操作系统是不会认识 Linux 的 Ext2 的。</p>
<p>传统的磁盘与文件系统之应用中，一个分区就是只能够被格式化成为一个文件系统，所以我们可以说一个 filesystem 就是一个 partition。但是由于新技术的利用，例如我们常听到的LVM与软件磁盘阵列(software raid)， 这些技术可以将一个分区格式化为多个文件系统(例如LVM)，也能够将多个分区合成一个文件系统(LVM, RAID)！所以说，目前我们在格式化时已经不再说成针对 partition 来格式化了， 通常我们可以称呼一个可被挂载的数据为一个文件系统而不是一个分区喔！</p>
<p>那么文件系统是如何运行的呢？这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外， 通常含有非常多的属性，例如 Linux 操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中。另外，还有一个超级区块 (superblock) 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。</p>
<p>对于一个磁盘分区来说，在被指定为相应的文件系统后，整个分区被分为 1024，2048 和 4096 字节大小的块。根据块使用的不同，可分为：</p>
<p>1、超级块(Superblock): 这是整个文件系统的第一块空间。包括整个文件系统的基本信息，如块大小，inode/block的总量、使用量、剩余量，指向空间 inode 和数据块的指针等相关信息。</p>
<p>2、inode块(文件索引节点) : 文件系统索引,记录文件的属性。它是文件系统的最基本单元，是文件系统连接任何子目录、任何文件的桥梁。每个子目录和文件只有唯一的一个 inode 块。它包含了文件系统中文件的基本属性(文件的长度、创建及修改时间、权限、所属关系)、存放数据的位置等相关信息. 在 Linux 下可以通过 “ls -li” 命令查看文件的 inode 信息。硬连接和源文件具有相同的 inode 。</p>
<p>3、数据块(Block) :实际记录文件的内容，若文件太大时，会占用多个 block。为了提高目录访问效率，Linux 还提供了表达路径与 inode 对应关系的 dentry 结构。它描述了路径信息并连接到节点 inode，它包括各种目录信息，还指向了 inode 和超级块。</p>
<p>就像一本书有封面、目录和正文一样。在文件系统中，超级块就相当于封面，从封面可以得知这本书的基本信息；inode 块相当于目录，从目录可以得知各章节内容的位置；而数据块则相当于书的正文，记录着具体内容。</p>
<p>Linux正统的文件系统(如ext2、3等)将硬盘分区时会划分出超级块、inode Table区块和data block数据区域。一个文件由一个超级块、inode和数据区域块组成。Inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lEG57fUxgGiagsu2Ty4hUoPaKBu81GmhwLPJAc4nAc6icE8VfOZdgZdDpA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>ext2文件系统示意图</p>
<p>我们将 inode 与 block 区块用图解来说明一下，如下图所示，文件系统先格式化出 inode 与 block 的区块，假设某一个文件的属性与权限数据是放置到 inode 4 号(下图较小方格内)，而这个 inode 记录了文件数据的实际放置点为 2, 7, 13, 15 这四个 block 号码，此时我们的操作系统就能够据此来排列磁盘的阅读顺序，可以一口气将四个 block 内容读出来！那么数据的读取就如同下图中的箭头所指定的模样了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lExkXOIu9JicNV1EibibQSEcLezMzcicbQZ2d6mBa0NefDIKXth0rUGouuEg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图 inode/block 数据存取示意图</p>
<p>这种数据存取的方法我们称为索引式文件系统(indexed allocation)。那有没有其他的惯用文件系统可以比较一下啊？有的，那就是我们惯用的闪盘(闪存)，闪盘使用的文件系统一般为 FAT 格式。FAT 这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中， 其读取方式有点像下图所示:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lEicTYERpYiaUcHTbIntEic8A1lgZXX3YiaEpI8L5nBAv8ozsicHSv5xDly2g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图、FAT文件系统数据存取示意图</p>
<p>上图中我们假设文件的数据依序写入1-&gt;7-&gt;4-&gt;15号这四个 block 号码中， 但这个文件系统没有办法一口气就知道四个 block 的号码，他得要一个一个的将 block 读出后，才会知道下一个 block 在何处。如果同一个文件数据写入的 block 分散的太过厉害时，则我们的磁盘读取头将无法在磁盘转一圈就读到所有的数据， 因此磁盘就会多转好几圈才能完整的读取到这个文件的内容！</p>
<p>常常会听到所谓的“碎片整理”吧？ 需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能将会变的很差所致。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整在一起，这样数据的读取会比较容易啊！ 想当然尔，FAT 的文件系统需要经常的碎片整理一下，那么 Ext2 是否需要磁盘重整呢？</p>
<p>由于 Ext2 是索引式文件系统，基本上不太需要常常进行碎片整理的。但是如果文件系统使用太久， 常常删除/编辑/新增文件时，那么还是可能会造成文件数据太过于离散的问题，此时或许会需要进行重整一下的。不过，老实说，鸟哥倒是没有在 Linux 操作系统上面进行过 Ext2/Ext3 文件系统的碎片整理说！似乎不太需要啦！^_^</p>
<p>可以用ln命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：</p>
<p>硬连接：原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；</p>
<p>由于删除文件要在同一个索引节点属于唯一的连接时才能成功，因此可以防止不必要的误删除。</p>
<p>符号连接：用ln -s命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。</p>
<p>可以删除原有的文件而保存连接文件，没有防止误删除功能。</p>
<p>这一段的的内容过于抽象，又是节点又是数组的，我已经尽量通俗再通俗了，又不好加例子作演示。大家如果还是云里雾里的话，我也没有什么办法了，只有先记住，日后在实际应用中慢慢体会、理解了。这也是我学习的一个方法吧。</p>
<h3 id="3-6-文件系统在内核中的表示"><a href="#3-6-文件系统在内核中的表示" class="headerlink" title="3.6 文件系统在内核中的表示"></a><strong>3.6 文件系统在内核中的表示</strong></h3><p><strong>内核数据结构</strong></p>
<p>Linux内核的VFS子系统可以图示如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lE0SomiaP6IeXYX7pyspBiaMgmHCf0lOhM5PKm0PtBbecPfZd190KG5CiaA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>文件与IO: 每个进程在PCB（Process Control Block）中都保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，现在我们明确一下：已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体。</p>
<p>在file结构体中维护File Status Flag（file结构体的成员f_flags）和当前读写位置（file结构体的成员f_pos）。在上图中，进程1和进程2都打开同一文件，但是对应不同的file结构体，因此可以有不同的File Status Flag和读写位置。file结构体中比较重要的成员还有f_count，表示引用计数（Reference Count），后面我们会讲到，dup、fork等系统调用会导致多个文件描述符指向同一个file结构体，例如有fd1和fd2都引用同一个file结构体，那么它的引用计数就是2，当close(fd1)时并不会释放file结构体，而只是把引用计数减到1，如果再close(fd2)，引用计数就会减到0同时释放file结构体，这才真的关闭了文件。</p>
<p>每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。</p>
<p>file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说，read、write等文件操作的步骤和方法应该是一样的，调用的函数应该是相同的，所以图中的三个打开文件的file结构体指向同一个file_operations结构体。如果打开一个字符设备文件，那么它的read、write操作肯定和常规文件不一样，不是读写磁盘的数据块而是读写硬件设备，所以file结构体应该指向不同的file_operations结构体，其中的各种文件操作函数由该设备的驱动程序实现。</p>
<p>每个file结构体都有一个指向dentry结构体的指针，“dentry”是directory entry（目录项）的缩写。我们传给open、stat等函数的参数的是一个路径，例如/home/akaedu/a，需要根据路径找到文件的inode。为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache，其中每个节点是一个dentry结构体，只要沿着路径各部分的dentry搜索即可，从根目录/找到home目录，然后找到akaedu目录，然后找到文件a。dentry cache只保存最近访问过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。</p>
<p>每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示/home/akaedu/a和/home/akaedu/b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。每个inode结构体都有一个指向inode_operations结构体的指针，后者也是一组函数指针指向一些完成文件目录操作的内核函数。</p>
<p>和file_operations不同，inode_operations所指向的不是针对某一个文件进行操作的函数，而是影响文件和目录布局的函数，例如添加删除文件和目录、跟踪符号链接等等，属于同一文件系统的各inode结构体可以指向同一个inode_operations结构体。</p>
<p>inode结构体有一个指向super_block结构体的指针。super_block结构体保存着从磁盘分区的超级块读上来的信息，例如文件系统类型、块大小等。super_block结构体的s_root成员是一个指向dentry的指针，表示这个文件系统的根目录被mount到哪里，在上图的例子中这个分区被mount到/home目录下。</p>
<p>file、dentry、inode、super_block这几个结构体组成了VFS的核心概念。对于ext2文件系统来说，在磁盘存储布局上也有inode和超级块的概念，所以很容易和VFS中的概念建立对应关系。而另外一些文件系统格式来自非UNIX系统（例如Windows的FAT32、NTFS），可能没有inode或超级块这样的概念，但为了能mount到Linux系统，也只好在驱动程序中硬凑一下，在Linux下看FAT32和NTFS分区会发现权限位是错的，所有文件都是rwxrwxrwx，因为它们本来就没有inode和权限位的概念，这是硬凑出来的。</p>
<h3 id="3-6-挂载文件系统"><a href="#3-6-挂载文件系统" class="headerlink" title="3.6  挂载文件系统"></a><strong>3.6  挂载文件系统</strong></h3><p>linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。这里所说的“按一定方式”就是指的挂载。</p>
<p>将一个文件系统的顶层目录挂到另一个文件系统的子目录上，使它们成为一个整体，称为挂载。把该子目录称为挂载点.</p>
<p>例如要读取硬盘中的一个格式化好的分区、光盘或软件等设备时，必须先把这些设备对应到某个目录上，而这个目录就称为“挂载点（mount point）”，这样才可以读取这些设备。挂载后将物理分区细节屏蔽掉，用户只有统一的逻辑概念。所有的东西都是文件。</p>
<p><strong>注意：</strong>1、挂载点必须是一个目录。</p>
<p>2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。</p>
<p>对于其他操作系统建立的文件系统的挂载也是这样。但是需要理解的是：光盘、软盘、其他操作系统使用的文件系统的格式与linux使用的文件系统格式是不一样的。光盘是ISO9660；软盘是fat16或ext2；windows NT是fat16、NTFS；windows98是fat16、fat32；windows2000和windowsXP是fat16、fat32、 NTFS。挂载前要了解linux是否支持所要挂载的文件系统格式。</p>
<p>挂载时使用mount命令，其格式：mount [-参数] [设备名称] [挂载点]<br>其中常用的参数有</p>
<p>-t 指定设备的文件系统类型（什么提到的文件类型）<br>-o 指定挂载文件系统时的选项。有些也可用在/etc/fstab中。常用的有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">codepage&#x3D;XXX 代码页  </span><br><span class="line">iocharset&#x3D;XXX 字符集   ro 以只读方式挂载   rw 以读写方式挂载   nouser 使一般用户无法挂载   user 可以让一般用户挂载设备</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<p><strong>1、挂载windows的文件系统：</strong></p>
<p>1）首先我们使用sudo fdisk -l查看挂载的设备，例如最下面有：/dev/hda5<br>2）mkdir创建一个目录，这里的目录是作为挂在目录，就是你要把E盘挂到这个目录下：mk /mnt/winc<br>3）windows和linux使用的不是一个文件系统，一般情况下linux不挂载windows文件系统，所以要你手动mount：<br># mount -t vfat /dev/hda5 /mnt/winc  （ -t vfat指出这里的文件系统fat32）<br>现在就可以进入/mnt/winc等目录读写这些文件了。</p>
<p><strong>2、挂载光盘：# mk /mnt/cdrom</strong></p>
<p># mount -t iso9660 /dev/cdrom /mnt/cdrom (关盘的名字一般都是cdrom，这条命令一般都通用)</p>
<p>3、虚拟机共享文件夹：例如在VirtualBox下，主机是Windows，Ubuntu是Guest。共分三步：</p>
<p>1). 首先要安装虚拟电脑工具包：在VirtualBox的菜单里选择”设备”-&gt;”安装虚拟电脑工具包”，你会发现在Ubuntu桌面上多出一个光盘图标，这张光盘默认被自动加载到了文件夹/media/cdom0，而且/cdrom自动指向这个文件夹。默认设置下文件管理器会自动打开这张光盘，可以看到里面有个”VBoxLinuxAdditions.run”文件。打开一个命令行终端，依次输入”cd /cdrom”和”sudo sh ./VBoxLinuxAdditions.run”，不含双引号，开始安装工具包。安装完毕，会用英文提示要重启Ubuntu，建议立刻重启。重启后，比较明显的变化是鼠标是共享模式，并且剪贴板也和Windows共享了。如果有这些变化，说明虚拟电脑工具包已经装成功。</p>
<p>2). 下一步设置共享文件夹。</p>
<p>在共享文件夹设置窗口中，单击右侧的”添加一个共享文件夹”，路径选择你想要共享的Windows文件夹，共享名任取一个自己喜欢的，比如”myshare”，选项read-only是指是否只允许ubuntu读这个文件夹，请根据需要选择这个选项。</p>
<p>3). 在ubuntu下挂载这个共享文件夹:sudo mount -t vboxsf myshare /media/share<br>其中”myshare”是之前取的共享文件夹的名字，”/media/share”是要挂载到的目标文件.</p>
<h3 id="3-7-自动挂载windows分区"><a href="#3-7-自动挂载windows分区" class="headerlink" title="3.7  自动挂载windows分区"></a><strong>3.7  自动挂载windows分区</strong></h3><p>每次开机访问windows分区都要运行mount命令显然太烦琐，为什么访问其他的linux分区不用使用mount命令呢？</p>
<p>其实，每次开机时，linux自动将需要挂载的linux分区挂载上了。那么我们是不是可以设定让linux在启动的时候也挂载我们希望挂载的分区，如windows分区，以实现文件系统的自动挂载呢？</p>
<p>这是完全可以的。在/etc目录下有个fstab文件，它里面列出了linux开机时自动挂载的文件系统的列表。我的/etc/fstab文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 　&#x2F;dev&#x2F;hda2 &#x2F; ext3 defaults 1 1      　　</span><br><span class="line">  　&#x2F;dev&#x2F;hda1 &#x2F;boot ext3 defaults 1 2      　　</span><br><span class="line">  　none &#x2F;dev&#x2F;pts devpts gid&#x3D;5,mode&#x3D;620 0 0      　　</span><br><span class="line">  　none &#x2F;proc proc defaults 0 0      　　</span><br><span class="line">  　none &#x2F;dev&#x2F;shm tmpfs defaults 0 0      　　</span><br><span class="line">  　&#x2F;dev&#x2F;hda3 swap swap defaults 0 0      　　</span><br><span class="line">  　&#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom iso9660 noauto,codepage&#x3D;936,iocharset&#x3D;gb2312 0 0      　　</span><br><span class="line">  　&#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy auto noauto,owner,kudzu 0 0      　　</span><br><span class="line">  　&#x2F;dev&#x2F;hdb1 &#x2F;mnt&#x2F;winc vfat defaults,codepage&#x3D;936,iocharset&#x3D;cp936 0 0      　　</span><br><span class="line">  　&#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;wind vfat defaults,codepage&#x3D;936,iocharset&#x3D;cp936 0 0</span><br></pre></td></tr></table></figure>

<p>在/etc/fstab文件里，第一列是挂载的文件系统的设备名，第二列是挂载点，第三列是挂载的文件系统类型，第四列是挂载的选项，选项间用逗号分隔。第五六列不知道是什么意思，还望高手指点。</p>
<p>在最后两行是我手工添加的windows下的C；D盘，加了codepage=936和iocharset=cp936参数以支持中文文件名。参数defaults实际上包含了一组默认参数：</p>
<p>rw 以可读写模式挂载<br>suid 开启用户ID和群组ID设置位<br>dev 可解读文件系统上的字符或区块设备<br>exec 可执行二进制文件<br>auto 自动挂载<br>nouser 使一般用户无法挂载<br>async 以非同步方式执行文件系统的输入输出操作</p>
<p>大家可以看到在这个列表里，光驱和软驱是不自动挂载的，参数设置为noauto。（如果你非要设成自动挂载，你要确保每次开机时你的光驱和软驱里都要有盘，呵呵。)</p>
<h3 id="3-8-软连接、硬链接"><a href="#3-8-软连接、硬链接" class="headerlink" title="3.8 .软连接、硬链接"></a><strong>3.8 .软连接、硬链接</strong></h3><p>可以用ln命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：</p>
<p>硬连接：是给文件一个副本，原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；</p>
<p>修改其中一个，与其连接的文件同时被修改。如果删除其中任意一个其余的文件将不受影响。</p>
<p>由于删除文件要在同一个索引节点属于唯一的连接时才能成功，因此可以防止不必要的误删除。</p>
<p>符号连接（软连接）：用ln -s命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。</p>
<p>当然删除这个连接，也不会影响到源文件，但对连接文件的使用、引用都是直接调用源文件的。</p>
<p>具体关系可以看下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb3DzFFWFib9rGhGy7kGA70lESwS1gbZe2qh6ZHTNxCZOUxJ0sfniaYcPpsJCicWdxOL44FibCvjAcwoDw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图5：软链接和硬链接</p>
<p>从图上可以看出硬链接和软链接的区别：</p>
<blockquote>
<p>1：硬链接原文件和新文件的inode编号一致。而软链接不一样。</p>
<p>2：对原文件删除，会导致软链接不可用，而硬链接不受影响。</p>
<p>3：对原文件的修改，软、硬链接文件内容也一样的修改，因为都是指向同一个文件内容的。</p>
</blockquote>
<h3 id="3-9-文件目录管理命令"><a href="#3-9-文件目录管理命令" class="headerlink" title="3.9.文件目录管理命令"></a><strong>3.9.文件目录管理命令</strong></h3><p>磁盘和文件空间 ：fdisk df du</p>
<p>文件目录与管理：cd pwd mkdir rmdir ls cp rm mv</p>
<p>查看文件内容 cat、tac、more、less、head 、tail</p>
<p>文件目录与权限 ：chmod chown chgrp umask</p>
<p>文件查找：which、whereis、locate、find、find</p>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iblTYUnF9yPPAFqPibv6Siadtw5kYIvianGuggAAZcL0nicTqibicKG1MUJG8Nvic9BVDaXuJSlRZquoQJjNkNgglBRAxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>四、linux 应用</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OKdYEbfJSc6gicBpKXLM0OehXMoaLEVciciaZtGq2EVOCnYxayTAq4iat0n7tpp67RLQyAwnJ704cic8UPyaYhQicRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>标准的Linux系统一般都有一套都有称为应用程序的程序集，它包括文本编辑器、编程语言、X Window、办公套件、Internet工具和数据库等。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iblTYUnF9yPPAFqPibv6Siadtw5kYIvianGuggAAZcL0nicTqibicKG1MUJG8Nvic9BVDaXuJSlRZquoQJjNkNgglBRAxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>五、linux内核参数优化</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OKdYEbfJSc6gicBpKXLM0OehXMoaLEVciciaZtGq2EVOCnYxayTAq4iat0n7tpp67RLQyAwnJ704cic8UPyaYhQicRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>内核参数是用户和系统内核之间交互的一个接口，通过这个接口，用户可以在系统运行的同时动态更新内核配置，而这些内核参数是通过Linux Proc文件系统存在的。因此，可以通过调整Proc文件系统达到优化Linux性能的目的。</p>
<h1 id="VMware安装centos"><a href="#VMware安装centos" class="headerlink" title="VMware安装centos"></a>VMware安装centos</h1><p><a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/">http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/</a></p>
<p>DVD是基本版本（推荐使用这个）</p>
<p>Everything是所有</p>
<p>minial是最小的。后面那个数字是大小。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/14.1.linux/" data-id="ckqk8k3gi006k2wwdfhj73m09" data-title="linux" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/30/4.27.%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">序列化与反序列化</a>
          </li>
        
          <li>
            <a href="/2021/06/28/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/">电商项目</a>
          </li>
        
          <li>
            <a href="/2021/06/24/4.26.JSR/">JSR</a>
          </li>
        
          <li>
            <a href="/2021/06/24/31.3.%E8%85%BE%E8%AE%AF%E4%BA%91%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9A%84%E5%BC%80%E5%8F%91/">腾讯云音视频的开发</a>
          </li>
        
          <li>
            <a href="/2021/06/23/%E7%94%B3%E8%AF%B7%E8%BD%AF%E8%91%97/">申请软著</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>