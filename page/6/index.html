<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/6/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-4.14.异常处理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.14.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:34:57.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.14.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">异常处理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>异常就是Java程序出现了不正常的情况。</p>
<p>程序的异常：Throwable</p>
<p>严重问题：Error 我们不处理，一般这种问题都是很严重的，比如内存溢出</p>
<p>问题：Exception</p>
<p>编译期问题：不是RuntimeException的异常 必须进行处理的，因为不处理，编译就不能通过</p>
<p>运行期问题：RuntimeException 这种问题我们也不处理，因为是代码不严谨的问题，需要修正代码。</p>
<p>如果程序出现了问题，我们没有做任何处理，最终jvm会做出默认的处理：把异常的名称，原因及出现的问题等信息输出在控制台；同时会结束程序。</p>
<p>我们可以自己进行异常处理方案：</p>
<p>A：try…catch…finally处理格式：</p>
<p>try{</p>
<p>可能出现问题的代码；</p>
<p>}catch(异常类名 变量名){</p>
<p>针对问题的处理；</p>
<p>}finally{</p>
<p>释放资源；</p>
<p>}</p>
<p>变形格式：</p>
<p>try{</p>
<p>可能出现问题的代码；</p>
<p>}catch(异常类名 变量名){</p>
<p>针对问题的处理；</p>
<p>}</p>
<p>注意：try里面的代码越少越好。catch里面必须有内容，哪怕是给出一个简单的提示</p>
<p>两个异常的处理：</p>
<p>（1）每一个都写一个try…catch…</p>
<p>（2）写一个try，多个catch：</p>
<p>try{</p>
<p>可能出现问题的代码；</p>
<p>}catch(异常类名 变量名){</p>
<p>针对问题的处理；</p>
<p>}catch(异常类名 变量名){</p>
<p>针对问题的处理；</p>
<p>}</p>
<p>一旦try里面出了问题，就会在这里把问题给抛出去，然后和catch里面的问题进行匹配，一旦有匹配的，就执行catch里面的处理，然后结束try…catch…，继续执行后面的语句（碰到第一个问题就会抛出并查找并输出，然后执行后面的。）</p>
<p>注意：</p>
<p>1.能明确的尽量明确，不要用大的来处理（Exception e）</p>
<p>2.平级关系的异常谁前谁后无所谓，如果出现了子父关系，父必须在后面。（如果父在前面的话，父后面的异常处理就多余了）</p>
<p>finally的特点：</p>
<p>被finally控制的语句体一定会执行，但是特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))就不会执行</p>
<p>finally的作用：用于释放资源，在IO流操作和数据库操作中会见到</p>
<p>1.final,finally和finalize的区别：</p>
<p>final：最终的意思，可以修饰类，成员变量，成员方法。</p>
<p>修饰类，类不能被继承。</p>
<p>修饰成员变量，变量是常量。</p>
<p>修饰成员方法，方法不能被重写。</p>
<p>finally：是异常处理的一部分，用来释放资源。</p>
<p>一般来说代码肯定会执行，特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))就不会执行</p>
<p>finalize：是Object类的一个方法，用于垃圾回收。</p>
<p>2.如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后。</p>
<p>会。前。准确的说应该是在中间。（这里的return语句返回路径已经形成，但还是会执行finally语句）</p>
<p>\3. try…catch…finally的格式变形：</p>
<p>（1）try…catch…finally</p>
<p>（2）try…catch</p>
<p>（3）try…catch…catch</p>
<p>（4）try…catch…catch…finally</p>
<p>（5）try…finally  这种格式的做法目前是为了释放资源</p>
<p>必须要有try</p>
<p>B：throws</p>
<p>定义功能方法时，需要把出现的问题暴露出来让调用者去处理。那么就通过throws在方法上标识。（有些时候我们没有权限去处理某个异常，有可能处理不了，所以java提供了另一种处理方案：抛出）</p>
<p>格式：throws 异常类名 可以跟多个，用逗号隔开</p>
<p>注意：这个格式必须跟在方法的括号后面。（在方法声明上抛出是为了告诉调用者我有问题） 调用者的处理方式：1.在方法上继续抛异常 2.用try…catch…</p>
<p>尽量不要再main方法上抛出异常</p>
<p>throw：程序不能继续运行，需要进行跳转时，如果出现了异常情况，我们可以把异常抛出，这个时候抛出的应该是异常的对象而不是异常的类名。</p>
<p>throws和throw的区别：</p>
<p>throws：用在方法声明后面，跟的是异常类名；可以跟多个异常类名，用逗号隔开；表示抛出异常，由该方法的调用者来处理；throws表示出现异常的一种可能性，并不一定会发生这些异常</p>
<p>throw：用在方法体内，跟的是异常对象名；只能抛出一个异常对象名；表示抛出异常，由方法体内的语句处理；throw则是抛出了异常，执行throw则一定抛出了某种异常</p>
<p>处理异常的原则:如果该功能内部可以将问题处理,用try；如果处理不了,交由调用者处理,这是用throws。后续程序需要继续运行就try；后续程序不需要继续运行就throws</p>
<p>编译时异常和运行时异常的区别：</p>
<p>编译时异常：Java程序必须显示处理，否则程序就会发生错误，无法通过编译</p>
<p>运行时异常：无需显示处理，也可以和编译时异常一样处理</p>
<p>在try里面发现问题后，jvm会帮我们生成一个异常对象，然后把这个对象抛出，和catch里面的类进行匹配。如果对象是某个类型的，就会执行该catch里面的处理信息。</p>
<p>Throwable中的方法：</p>
<p>public String getMessage() 获取异常信息，返回字符串。</p>
<p>public String toString() 获取异常类名和异常信息，返回字符串:此对象的类的name（全路径名）  </p>
<p>+  “: ” (冒号和一个空格)  </p>
<p>+  调用此对象getLocalizedMessage()方法的结果（这里默认返回的是getMessage()的内容）</p>
<p>printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。把信息输出在控制台</p>
<p>printStackTrace(PrintStream s) 通常用该方法将异常内容保存在日志文件中，以便查阅。 </p>
<p>自定义异常：当java中没有对应的异常，需要我们自己来定义一个异常要想自己写的类是一个异常类，就必须继承自Exception（非运行时异常，再调用时需要处理异常）或者继承自RuntimeException（运行时异常，再调用时不用处理异常）</p>
<p>自定义异常不用写方法体（有时候需要写构造方法:无参，带参：super(message);）</p>
<p>注意事项：子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)</p>
<p>如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常</p>
<p>如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws</p>
<p>运行时异常：RuntimeException类及其子类的异常，是非受检异常，如NullPointerException、IndexOutOfBoundsException等。由于这类异常要么是系统异常，无法处理，如网络问题；要么是程序逻辑错误，如空指针异常；JVM<strong>必须</strong>停止运行以改正这种错误，所以运行时异常可以不进行处理（捕获或向上抛出，当然也可以处理），而由JVM自行处理。Java Runtime会自动catch到程序throw的RuntimeException，然后停止线程，打印异常</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ArithmeticException</td>
<td>算术错误，如被0除</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundsException</td>
<td>数组下标越界</td>
</tr>
<tr>
<td><strong>ArrayStoreException</strong></td>
<td>数组元素赋值类型不兼容</td>
</tr>
<tr>
<td><strong>ClassCastException</strong></td>
<td>非法强制转换类型</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>非法参数类型</td>
</tr>
<tr>
<td>IllegalMonitorStateException</td>
<td>非法监控操作，如等待一个未锁定的线程</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>环境或应用状态不正确</td>
</tr>
<tr>
<td>IllegalThreadStateException</td>
<td>请求操作与当前线程状态不兼容</td>
</tr>
<tr>
<td><strong>IndexOutOfBoundsException</strong></td>
<td>某些类型索引越界</td>
</tr>
<tr>
<td><strong>NullPointerException</strong></td>
<td>非法使用空引用</td>
</tr>
<tr>
<td>NumberFormatException</td>
<td>字符串到数字格式非法转换</td>
</tr>
<tr>
<td>SecurityException</td>
<td>试图违反安全性</td>
</tr>
<tr>
<td>StringIndexOutOfBounds</td>
<td>试图在字符串边界之外索引</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>遇到不支持的操作</td>
</tr>
<tr>
<td><strong>BufferOverflowException</strong></td>
<td>IO操作的</td>
</tr>
</tbody></table>
<p>非运行时异常，受检异常(checked exception)：RuntimeException以外的异常，类型上都属于Exception类及其子类，是受检异常。非运行时异常<strong>必须</strong>进行处理（捕获或向上抛出），如果不处理，程序将出现编译错误。一般情况下，API中写了throws的Exception都不是RuntimeException</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IOException</strong></td>
<td></td>
</tr>
<tr>
<td><strong>SQLException</strong></td>
<td></td>
</tr>
<tr>
<td><strong>FileNotFoundException</strong></td>
<td></td>
</tr>
<tr>
<td><strong>NoSuchFileException</strong></td>
<td></td>
</tr>
<tr>
<td><strong>NoSuchMethodException</strong></td>
<td></td>
</tr>
<tr>
<td>InterruptedException</td>
<td>一个线程被另一个线程中断</td>
</tr>
<tr>
<td>InstantiationException</td>
<td>试图创建一个抽象类或抽象接口的对象</td>
</tr>
<tr>
<td>IllegalAccessException</td>
<td>对一个类的访问被拒绝</td>
</tr>
<tr>
<td>CloneNotSupportedException</td>
<td>试图克隆一个不能实现Cloneable接口的对象</td>
</tr>
<tr>
<td>ClassNotFoundException</td>
<td>找不到类</td>
</tr>
</tbody></table>
<p>打印异常</p>
<p>1 e.getMessage() ;    只会获得异常的名称。比如说NullPoint 空指针,就告诉你说是空指针</p>
<p>2.e.toString()：  获得异常种类和错误信息</p>
<p>3.e.printStackTrace();    在控制台打印打印出详细的异常信息，异常名称。便于调试</p>
<p>e.printStackTrace()是打印整个Exception轨迹栈，相当于System.out.print(e.getStackTrace().toString())</p>
<p>4.e初始化，也就是实例化Exception类型的对象，e是此对象引用名称。然后e（引用）会自动调用Exception类中指定的方法，也就出现了e.printStackTrace()</p>
<p>如果异常是用无参构造器构造，后续又没有设置message的话一般就是null，如果用带String参数的构造器构造的话，返回的就是那个参数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.14.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" data-id="ckvc2kucx001k9kwd45h1ef16" data-title="异常处理" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-19.3.github" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/19.3.github/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T10:24:12.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/19.3.github/">github</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/19.3.github/" data-id="ckvc2kucl000j9kwd4qlib9q8" data-title="github" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-代理和反向代理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T10:16:03.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">代理和反向代理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="正向代理-Forward-Proxy"><a href="#正向代理-Forward-Proxy" class="headerlink" title="正向代理(Forward Proxy)"></a>正向代理(Forward Proxy)</h1><p>一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术</p>
<p>正向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p><img src="/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/image-20211007121537363.png" alt="image-20211007121537363"></p>
<p>正向代理就是代理服务器替代访问方【用户A】去访问目标服务器【服务器B】，这就是正向代理的意义所在</p>
<p>使用正向代理服务器作用：</p>
<p>1.访问本无法访问的服务器B</p>
<p>我们抛除复杂的网络路由情节来看，假设图中路由器从左到右命名为R1,R2 假设最初用户A要访问服务器B需要经过R1和R2路由器这样一个路由节点，如果路由器R1或者路由器R2发生故障，那么就无法访问服务器B了。但是如果用户 A让代理服务器Z去代替自己访问服务器B，由于代理服务器Z没有在路由器R1或R2节点中，而是通过其它的路由节点访问服务器B，那么用户A就可以得到服务器B的数据了。</p>
<p>现实中的例子就是“翻墙”。不过自从VPN技术被广泛应用外，“翻墙”不但使用了传统的正向代理技术，有的还使用了VPN技术。</p>
<p><img src="/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/image-20211007121650270.png" alt="image-20211007121650270"></p>
<p>2.加速访问服务器B</p>
<p>这种说法目前不像以前那么流行了，主要是带宽流量的飞速发展。早期的正向代理中，很多人使用正向代理就是提速。假设用户A到服务器B，经过R1路由器和R2路由器，而R1到R2路由器的链路是一个低带宽链路。而用户A到代理服务器Z，从代理服务器Z到服务器B都是高带宽链路。那么很显然就可以加速访问服务器B了</p>
<p>3.Cache作用</p>
<p>Cache（缓存）技术和代理服务技术是紧密联系的（不光是正向代理，反向代理也使用了Cache（缓存）技术。如果在用户A访问服务器B某数据J之前，已经有人通过代理服务器Z访问过服务器B上得数据J，那么代理服务器Z会把数据J保存一段时间，如果有人正好取该数据J，那么代理服务器Z不再访问服务器B，而把缓存的数据J直接发给用户A。这一技术在Cache中术语就叫<strong>Cache命中</strong>。如果有更多的像用户A的用户来访问代理服务器Z，那么这些用户都可以直接从代理服务器Z中取得数据J，而不用千里迢迢的去服务器B下载数据了。</p>
<p>4.客户端访问授权</p>
<p>这方面的内容现今使用的还是比较多的，例如一些公司采用ISA SERVER做为正向代理服务器来授权用户是否有权限访问互联网。</p>
<p>防火墙作为网关，用来过滤外网对其的访问。假设用户A和用户B都设置了代理服务器，用户A允许访问互联网，而用户B不允许访问互联网（这个在代理服务器Z上做限制）这样用户A因为授权，可以通过代理服务器访问到服务器B，而用户B因为没有被代理服务器Z授权，所以访问服务器B时，数据包会被直接丢 弃。</p>
<p><img src="/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/wps1.png" alt="img"></p>
<p>5.隐藏访问者的行踪</p>
<p>服务器B并不知道访问自己的实际是用户A，因为代理服务器Z代替用户A去直接与服务器B进行交互。如果代理服务器Z被用户A完全控制（或不完全控制），会惯以“肉鸡”术语称呼</p>
<p><img src="/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/wps2.png" alt="img"></p>
<p>总结：正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。</p>
<h1 id="反向代理（reverse-proxy）"><a href="#反向代理（reverse-proxy）" class="headerlink" title="反向代理（reverse proxy）"></a>反向代理（reverse proxy）</h1><p>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。</p>
<p>使用反向代理服务器的作用：</p>
<p>1.保护和隐藏原始资源服务器</p>
<p>用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。</p>
<p><img src="/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/wps3.png" alt="img"></p>
<p>2.负载均衡</p>
<p>当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。</p>
<p><img src="/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/wps4.png" alt="img"></p>
<p>当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是<strong>CDN技术</strong>的核心。当然，CDN最关键的核心技术智能DNS。只是展示CDN技术实际上利用的正是反向代理原理这块。</p>
<p><img src="/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/image-20211007122345566.png" alt="image-20211007122345566"></p>
<p>总结：</p>
<p>反向代理结论与正向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p>
<p>基本上，网上做正反向代理的程序很多，能做正向代理的软件大部分也可以做反向代理。开源软件中最流行的就是<strong>squid</strong>，既可以做正向代理，也有很多人用来做反向代理的前端服务器。另外<strong>MS ISA</strong>也可以用来在WINDOWS平台下做正向代理。反向代理中最主要的实践就是WEB服务，近些年来最火的就是<strong>Nginx</strong>了。网上有人说NGINX不能做正向代理，其实是不对的。NGINX也可以做正向代理，不过用的人比较少了</p>
<h1 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h1><p>透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。</p>
<p>透明代理实践的例子就是时下很多公司使用的行为管理软件。</p>
<p><img src="/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/wps5.png" alt="img"></p>
<p>用户A和用户B并不知道行为管理设备充当透明代理行为，当用户A或用户B向服务器A或服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，并作为实际的请求方，向服务器A或B发送请求，当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户A或B，如上图，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据。</p>
<h1 id="java的代理"><a href="#java的代理" class="headerlink" title="java的代理"></a>java的代理</h1><p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能</p>
<p><strong>一个比方：在租房的时候，有的人会通过房东直租，有的人会通过中介租房。</strong></p>
<p>这两种情况哪种比较方便呢？当然是通过中介更加方便。</p>
<p>这里的中介就相当于代理，用户通过中介完成租房的一系列操作（看房、交押金、租房、清扫卫生）代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/hC3oNAJqSRwGHhK1oR8QrPgPBKlklWfKShzZuLnafc2NFwHR7PODd4beGiaQBaXhKo1J9iavkDWsU83jFqBDbebg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>分类：</strong></p>
<p><strong>静态代理：</strong> 在编译时就已经实现，编译完成后代理类是一个实际的class文件</p>
<p><strong>动态代理：</strong> 在运行时动态生成的，即编译完成后没有实际的class文件，而是<strong>在运行时动态生成类字节码，并加载到JVM中</strong></p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>使用方式</strong></p>
<p>创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;    </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在保存用户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionHandler</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//目标代理对象</span></span><br><span class="line">    <span class="keyword">private</span> UserDao target;</span><br><span class="line">    <span class="comment">//构造代理对象时传入目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransactionHandler</span><span class="params">(UserDao target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用目标方法前的处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务控制...&quot;</span>);</span><br><span class="line">        <span class="comment">//调用目标对象的方法</span></span><br><span class="line">        target.save();</span><br><span class="line">        <span class="comment">//调用目标方法后的处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事务控制...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建目标对象</span></span><br><span class="line">        UserDaoImpl target = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        <span class="comment">//创建代理对象, 并使用接口对其进行引用</span></span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> TransactionHandler(target);</span><br><span class="line">        <span class="comment">//针对接口进行调用</span></span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用JDK静态代理很容易就完成了对一个类的代理操作。但是<code>JDK</code>静态代理的<strong>缺点</strong>也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐</p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p><strong>使用JDK动态代理的五大步骤：</strong></p>
<ol>
<li>通过实现InvocationHandler接口来自定义自己的InvocationHandler；</li>
<li>通过<code>Proxy.getProxyClass</code>获得动态代理类；</li>
<li>通过反射机制获得代理类的构造方法，方法签名为<code>getConstructor(InvocationHandler.class)</code>；</li>
<li>通过构造函数获得代理对象并将自定义的<code>InvocationHandler</code>实例对象传为参数传入；</li>
<li>通过代理对象调用目标方法；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** 目标对象 */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------插入前置通知代码-------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行相应的目标方法</span></span><br><span class="line">        Object rs = method.invoke(target,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;------插入后置处理代码-------------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">// =========================第一种==========================</span></span><br><span class="line">        <span class="comment">// 1、生成$Proxy0的class文件</span></span><br><span class="line">        System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、获取动态代理类</span></span><br><span class="line">        Class proxyClazz = Proxy.getProxyClass(IHello.class.getClassLoader(),IHello.class);</span><br><span class="line">        <span class="comment">// 3、获得代理类的构造函数，并传入参数类型InvocationHandler.class</span></span><br><span class="line">        Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);</span><br><span class="line">        <span class="comment">// 4、通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入</span></span><br><span class="line">        IHello iHello1 = (IHello) constructor.newInstance(<span class="keyword">new</span> MyInvocationHandler(<span class="keyword">new</span> HelloImpl()));</span><br><span class="line">        <span class="comment">// 5、通过代理对象调用目标方法</span></span><br><span class="line">        iHello1.sayHello();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ==========================第二种=============================</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Proxy类中还有个将2~4步骤封装好的简便方法来创建动态代理对象，</span></span><br><span class="line"><span class="comment">         *其方法签名为：newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] instance, InvocationHandler h)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        IHello  iHello2 = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), <span class="comment">// 加载接口的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;IHello.class&#125;, <span class="comment">// 一组接口</span></span><br><span class="line">                <span class="keyword">new</span> MyInvocationHandler(<span class="keyword">new</span> HelloImpl())); <span class="comment">// 自定义的InvocationHandler</span></span><br><span class="line">        iHello2.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK静态代理与JDK动态代理之间有些许相似，比如说都要创建代理类，以及代理类都要实现接口等。</p>
<p><strong>不同之处：</strong> 在静态代理中我们需要对哪个接口和哪个被代理类创建代理类，所以我们在编译前就需要代理类实现与被代理类相同的接口，并且直接在实现的方法中调用被代理类相应的方法；但是动态代理则不同，我们不知道要针对哪个接口、哪个被代理类创建代理类，因为它是在运行时被创建的。</p>
<p><strong>一句话来总结一下JDK静态代理和JDK动态代理的区别：</strong></p>
<p>JDK静态代理是通过直接编码创建的，而<code>JDK</code>动态代理是利用反射机制在运行时创建代理类的。</p>
<p>其实在动态代理中，核心是<code>InvocationHandler</code>。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的<code>invoke</code>方法</p>
<p>对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。</p>
<h2 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h2><p>CGLIB包的底层是通过使用一个小而快的字节码处理框架<code>ASM</code>，来转换字节码并生成新的类</p>
<p><strong>CGLIB代理实现如下：</strong></p>
<ol>
<li>首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</li>
<li>然后在需要使用的时候，通过CGLIB动态代理获取代理对象。</li>
</ol>
<p><strong>使用案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloService构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法不能被子类覆盖,Cglib是无法代理final修饰的方法的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> String <span class="title">sayOthers</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloService:sayOthers&gt;&gt;&quot;</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloService:sayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy; </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sub：cglib生成的代理对象</span></span><br><span class="line"><span class="comment">     * method：被代理对象方法</span></span><br><span class="line"><span class="comment">     * objects：方法入参</span></span><br><span class="line"><span class="comment">     * methodProxy: 代理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object sub, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======插入前置通知======&quot;</span>);</span><br><span class="line">        Object object = methodProxy.invokeSuper(sub, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;======插入后者通知======&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.DebuggingClassWriter;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代理类class文件存入本地磁盘方便我们反编译查看源码</span></span><br><span class="line">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;D:\\code&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过CGLIB动态代理获取代理对象的过程</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置enhancer对象的父类</span></span><br><span class="line">        enhancer.setSuperclass(HelloService.class);</span><br><span class="line">        <span class="comment">// 设置enhancer的回调对象</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        HelloService proxy= (HelloService)enhancer.create();</span><br><span class="line">        <span class="comment">// 通过代理对象调用目标方法</span></span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK代理要求被代理的类必须实现接口，有很强的局限性。</p>
<p>而CGLIB动态代理则没有此类强制性要求。简单的说，<code>CGLIB</code>会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。</p>
<p><strong>总结一下CGLIB在进行代理的时候都进行了哪些工作</strong></p>
<ul>
<li>生成的代理类继承被代理类。在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理</li>
<li>代理类会为委托方法生成两个方法，一个是与委托方法签名相同的方法，它在方法中会通过<code>super</code>调用委托方法；另一个是代理类独有的方法</li>
<li>当执行代理对象的方法时，会首先判断一下是否存在实现了<code>MethodInterceptor</code>接口的<code>CGLIB$CALLBACK_0</code>;，如果存在，则将调用<code>MethodInterceptor</code>中的<code>intercept</code>方法</li>
</ul>
<p>在<code>intercept</code>方法中，我们除了会调用委托方法，还会进行一些增强操作。在Spring AOP中，典型的应用场景就是在某些敏感方法执行前后进行操作日志记录</p>
<p>在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：通过<strong>FastClass机制</strong>对Class对象进行特别的处理，比如将会用数组保存method的引用，每次调用方法的时候都是通过一个index下标来保持对方法的引用</p>
<h3 id="Fastclass机制"><a href="#Fastclass机制" class="headerlink" title="Fastclass机制"></a>Fastclass机制</h3><p>CGLIB采用了FastClass的机制来实现对被拦截方法的调用。</p>
<p>FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test10</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里，tt可以看作目标对象，fc可以看作是代理对象；首先根据代理对象的getIndex方法获取目标方法的索引，</span></span><br><span class="line">  <span class="comment">//然后再调用代理对象的invoke方法就可以直接调用目标类的方法，避免了反射</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test tt = <span class="keyword">new</span> Test();</span><br><span class="line">        Test2 fc = <span class="keyword">new</span> Test2();</span><br><span class="line">        <span class="keyword">int</span> index = fc.getIndex(<span class="string">&quot;f()V&quot;</span>);</span><br><span class="line">        fc.invoke(index, tt, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;g method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">int</span> index, Object o, Object[] ol)</span></span>&#123;</span><br><span class="line">        Test t = (Test) o;</span><br><span class="line">        <span class="keyword">switch</span>(index)&#123;<span class="number">0</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            t.f();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            t.g();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个方法对Test类中的方法建立索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(String signature)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(signature.hashCode())&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3078479</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3108270</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，Test2是Test的Fastclass，在Test2中有两个方法getIndex和invoke。</p>
<p>在getIndex方法中对Test的每个方法建立索引，并根据入参（方法名+方法的描述符）来返回相应的索引。</p>
<p>Invoke根据指定的索引，以ol为入参调用对象O的方法。这样就避免了反射调用，提高了效率</p>
<h2 id="三种代理方式之间对比"><a href="#三种代理方式之间对比" class="headerlink" title="三种代理方式之间对比"></a><strong>三种代理方式之间对比</strong></h2><table>
<thead>
<tr>
<th align="left">代理方式</th>
<th align="left">实现</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">JDK静态代理</td>
<td align="left">代理类与委托类实现同一接口，并且在代理类中需要硬编码接口</td>
<td align="left">实现简单，容易理解</td>
<td align="left">代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">JDK动态代理</td>
<td align="left">代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写<code>invoke</code>方法来进行动态代理的，在invoke方法中将对方法进行增强处理</td>
<td align="left">不需要硬编码接口，代码复用率高</td>
<td align="left">只能够代理实现了接口的委托类</td>
<td align="left">底层使用反射机制进行方法的调用</td>
</tr>
<tr>
<td align="left">CGLIB动态代理</td>
<td align="left">代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过<code>super</code>调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了<code>MethodInterceptor</code>接口的对象，若存在则将调用intercept方法对委托方法进行代理</td>
<td align="left">可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口</td>
<td align="left">不能对<code>final</code>类以及final方法进行代理</td>
<td align="left">底层将方法全部存入一个数组中，通过数组索引直接进行方法调用</td>
</tr>
</tbody></table>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>CGlib比JDK快？</strong></p>
<ul>
<li>使用CGLiB实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类， 在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理， 因为CGLib原理是动态生成被代理类的子类。</li>
<li>在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率。只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，<strong>jdk代理效率高于CGLIB代理</strong>，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。</li>
</ul>
<p><strong>Spring如何选择用JDK还是CGLIB？</strong></p>
<ul>
<li>当Bean实现接口时，Spring就会用JDK的动态代理。</li>
<li>当Bean没有实现接口时，Spring使用CGlib实现。</li>
<li>可以强制使用CGlib</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" data-id="ckvc2kue6005e9kwdbsawhkwq" data-title="代理和反向代理" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-24.算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/24.%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T10:12:44.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/24.%E7%AE%97%E6%B3%95/">算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>照片压缩完的格式一般是JPEG。</p>
<p>文件存储</p>
<p>文件是将数据存储在磁盘等存储媒介的一种形式。程序文件中最基本的存储数据单位是字节B=byte。文件就是字节数据的集合。在任何情况下，文件中的字节数都是连续存储的。</p>
<p>压缩算法：数据压缩的算法，包括压缩和还原（解压缩）的两个步骤。在不改变原有文件属性的前提下，降低文件字节空间和占用空间的一种算法。</p>
<p>1.有损和无损</p>
<p>有损压缩：有失真，不能完全准确的恢复原始数据。多媒体数据的压缩。该方法压缩比较大。Eg：预测编码、音感编码、分形压缩、小波压缩、JPEG/MPEG。</p>
<p>无损压缩：无失真。可执行文件和普通文件、磁盘的压缩，多媒体数据的压缩。该方法的压缩比较小。Eg：差分编码、RLE、Huffman编码、LZW编码、算术编码。</p>
<p>\2. .对称性</p>
<p>\3. 帧间与帧内（MPEG和JPEG）</p>
<p>\4. 实时性（需要简单快速高效的算法和高速复杂的CPU/DSP芯片）</p>
<p>\5. 分级处理</p>
<p>\6. 可逆压缩和非可逆压缩</p>
<p>RLE（Run Length Encoding，行程长度编码）算法的机制：相同字符去重化，字符*重复次数。针对连续的字节序列压缩效果比较好。</p>
<p>哈夫曼算法：多次出现的数据用小于8位的字节数来表示，不常用的数据则可以用超过8位的字节数表示。用二叉树实现。</p>
<p>图像文件的格式一般有：</p>
<p>BMP：使用windows自带的画笔来做成的一种图像形式</p>
<p>JPEG：数码相机等常用的一种。非可逆压缩</p>
<p>TIFF：一种通过在文件中包含“标签”就能快速显示出数据性质的图像形式。</p>
<p>GIF：美国开发的一种数据形式，要求色数不超过256个。可逆压缩</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/24.%E7%AE%97%E6%B3%95/" data-id="ckvc2kucq00109kwdg5xj084o" data-title="算法" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-23.数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/23.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T10:12:39.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/23.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数据结构：数据的存储（组织）方式。</p>
<p>一、数组。需要指定元素的地址</p>
<p>指多个相同的数据类型在内存中连续排列的一种形式。作为数组元素的各个数据会通过下标编号来区分，这个编号也叫索引。</p>
<p>存储同一种类型的多个元素的容器，有索引，方便我们获取。</p>
<p>特点：查询快，增删慢。</p>
<p>二、栈（stack）。不需要指定元素的地址</p>
<p>采用LIFO（last in first out）即后入先出的方式对内存进行操作。（像收纳箱）数据在存储时从内存的下层（大的地址编号）逐渐往上层（晓得地址编号）累积，读出时则是按照从上往下进行读取的。</p>
<p>位于后面的数据先入栈。</p>
<p>****压*<em><strong>入（push）入</strong></em>*栈****：向栈中存储数据。</p>
<p>****弹*<em><strong>出（pop）出</strong></em>*栈****：从栈中读出数据。</p>
<p>三、队列。不需要指定元素的地址</p>
<p>和栈相似，但先入先出（first in first out）</p>
<p>入列（EnQueue）入队</p>
<p>出列（DeQueue）出队</p>
<p>队列实现有两种：顺序队列和循环队列。</p>
<p>循环队列一般以环状缓冲区的方式实现，适合缓存数据流。</p>
<p>四、链表。不用考虑索引的顺序</p>
<p>高效的对数据元素进行添加和删除操作。</p>
<p>在实现数组的基础上，除了数据的值之外，通过为其附带下个元素的索引，即可实现链表。数据的值和下一个元素的地址（索引）就构成了一个链表元素。</p>
<p>由一个链子把多个结点连接起来组成的数据。结点：有数据和地址组成。（数据域和指针域组成）</p>
<p>链表的添加和删除不涉及数据的移动。</p>
<p>单向链表最后一个结点的地址是null。如果把头元素的地址给了最后一个元素的地址位置，就是循环链表。如果每个结点由3部分（地址、数据、地址）组成，就可以组成双向链表。如果再把前后的对应也连接起来，就成了双向循环链表。</p>
<p>特点：查询慢，增删快。</p>
<p>五、二叉树。不用考虑索引的顺序</p>
<p>高效的对数据元素进行检索操作</p>
<p>在链表的基础上往数组追加元素时，考虑数组的大小关系，将其分为左右两个方向的表现形式。</p>
<p>红黑树：是一种自平衡的二叉树</p>
<p>六、哈希表。是一个元素为链表的数组。综合了链表和数组的好处。</p>
<p>哈希值和什么值有关：和对象的成员变量值有关（有可能直接相加会出现相同的哈希值，所以可以适当的乘一个系数）</p>
<p>桶结构（相当于是链表的同一个索引下放了很多个元素）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/23.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="ckvc2kucp000x9kwd3jl539ht" data-title="数据结构" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-22.3.常见cmd命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/22.3.%E5%B8%B8%E8%A7%81cmd%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T10:09:29.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/22.3.%E5%B8%B8%E8%A7%81cmd%E5%91%BD%E4%BB%A4/">常见cmd命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Windows+R键可以打开运行行，打cmd进入命令提示符。</p>
<p>盘名： ：盘符切换</p>
<p>cd    ：（change directory）改变指定目录（进入指定的目录）</p>
<p>cd..   :退回到上一级目录</p>
<p>cd\   ：退回到根目录</p>
<p>dir   ：（directory）列出当前目录下的文件以及文件夹</p>
<p>↑↓键  ：查找敲过的命令</p>
<p>Tab键  ：命令自动补齐</p>
<p>md   ：（make directory）创建目录</p>
<p>rd：（remove directory）删除目录（带有内容的文件夹无法删除）</p>
<p>rd /s 文件夹名 询问是否删除文件夹</p>
<p>rd /s /q文件夹名 直接删除文件夹（安静模式）</p>
<p>del  ：（delete）只能删除<em><strong>*文件*</strong></em></p>
<p>删除一堆后缀名一样的文件del *.txt</p>
<p>exit：退出dos命令行</p>
<p>cls：（clear screen）清屏</p>
<p> 不能ctrl+V时候，可以右击粘贴</p>
<p>HOME键 使鼠标光标移动到最开始。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/22.3.%E5%B8%B8%E8%A7%81cmd%E5%91%BD%E4%BB%A4/" data-id="ckvc2kucp000v9kwd27lj95o5" data-title="常见cmd命令" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-22.2.计算机语言" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/22.2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T10:09:18.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/22.2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/">计算机语言</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>人机交互方式：</p>
<p>\1. 图形化界面</p>
<p>\2. 命令行方式</p>
<p>一、机器语言</p>
<p>机器语言的程序称为本地代码（native code）。</p>
<p>计算机是由****二进制****构成的。通过寄存器来处理。</p>
<p>二进制由来：因为IC元件的引脚只有两种电压：0或5V，决定了计算机的信息处理只有0和1。</p>
<p>计算机最小集成单位为位，也就是比特（bite），8位二进制为一个字节（因为8位能涵盖所有的字符编码）。字节是最基本的计量单位，位是最小单位。32位计算机指一次可以表示4字节的二进制数。</p>
<p>二进制转为十进制：直接将各个位置上的值*位权（次幂）即可。从2^0开始。（位权的值是数的位数-1）</p>
<p>十进制到其他进制：除基取余，直到商为0，余数反转。</p>
<p>小数部分：乘基，直到乘位为0，进位顺序取。</p>
<p>二进制的运算</p>
<p>移位运算：左移一位，低位补齐0，相当于是乘2。</p>
<p>右移：涉及到便于计算机处理的补数。相当于除2。</p>
<p>二进制表示负数时：最高位当作为符号位，0表示正数，1表示负数。</p>
<p>计算机内没有减法，做减法运算时实际上是加法运算，加负数。表示负数时涉及到二进制补数（用正数来表示负数）：将二进制各位数全部取反，然后将结果+1。</p>
<p>逻辑右移：当二进制的数值表示图形模式而非数值时，移位后需要在最高位补0.</p>
<p>算数右移：当二进制作为带符号的数值进行右移时，需要在最高位补移位前符号的值（0或1）。</p>
<p>符号扩展：将8位变为16位或32位的时候，将0或1填满高位即可。</p>
<p>算数运算是指加减乘除的四则运算。</p>
<p>逻辑运算是指对二进制的各个数位的0和1分别进行处理的运算。</p>
<p>逻辑非（NOT运算）：取反操作。</p>
<p>逻辑与（AND运算）：两个都是1的时候才是1，其他皆为0.</p>
<p>逻辑或（OR运算）：两个为0才为0，其余皆为1.</p>
<p>逻辑异或（XOR运算）：相同为0，不同为1</p>
<p>二、汇编语言（也被称为符号语言）</p>
<p>晦涩难懂，需经过****汇编器****才能转换为机器语言，与机器语言是一一对应的关系。</p>
<p>采用助记符（memonic）来代替机器指令的操作码。mov,add</p>
<p>采用地址符号或标号来代替指令或操作数的地址。</p>
<p>汇编语言的语法是操作码（指令动作）+操作数（指令对象）。</p>
<p>汇编语言转机器语言称汇编，机器语言转汇编语言称反汇编。</p>
<p>汇编语言的源代码是由转换成本地代码的指令（操作码）和针对汇编器的伪指令构成的。伪指令负责把程序的构造以及汇编的方法指示给汇编器（转换程序），伪指令是无法汇编成本地代码的。</p>
<p>段定义：是用来区分或者划分范围内区域的意思。汇编语言的segment伪指令表示段定义的起始，ends表示段定义的结束。是命令和数据等程序的集合体，是一段连续的内存空间。一个程序由多个段定义构成。</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>操作数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>mov</td>
<td>A,B</td>
<td>把B的值赋给A</td>
</tr>
<tr>
<td>add</td>
<td>A,B</td>
<td>把A和B同时相加，并把结果赋给A</td>
</tr>
<tr>
<td>push</td>
<td>A</td>
<td>把A的值存储在栈中</td>
</tr>
<tr>
<td>pop</td>
<td>A</td>
<td>从栈中读出值，并将其赋值给A</td>
</tr>
<tr>
<td>call</td>
<td>A</td>
<td>调用函数A</td>
</tr>
<tr>
<td>ret</td>
<td>无</td>
<td>处理返回给调用源函数</td>
</tr>
<tr>
<td>cmp</td>
<td>A,B</td>
<td>对A和B进行比较，比较结果会自动存入标志寄存器中</td>
</tr>
<tr>
<td>inc</td>
<td>A</td>
<td>对A的值+1，相当于i++</td>
</tr>
<tr>
<td>xor</td>
<td>A,B</td>
<td>A和B的位进行异或比较，将结果存入A中</td>
</tr>
</tbody></table>
<p>i++：先赋值后+1</p>
<p>++i：先+1在赋值</p>
<p>三、高级语言</p>
<p>需经过****编译****转换成机器语言才能运行，与机器语言不是一一对应关系。</p>
<p>高级语言编写的程序仅仅是文本文件（排除文字编码的问题），在任何环境下都能显示和编辑，称之为源代码。对源代码编译就可以得到本地代码。</p>
<p>移植性：指的是同样的程序在不同操作系统下运行时所花费的时间，时间越少证明移植性越好。</p>
<p>全局变量：在函数外部定义的变量，在任意函数中使用。</p>
<p>局部变量：在函数内部定义的变量，只能在函数定义局部变量的内部使用。</p>
<p>局部变量只是函数在处理期间临时存储在寄存器和栈中的。（寄存器空闲时使用寄存器，寄存器空间不足时使用栈）局部变量使用寄存器，是Borland C++编译器最优化的运行结果。</p>
<p>条件控制流程分为三种：顺序执行，条件分支，循环判断。</p>
<p>条件分支：使用cmp指令和跳转指令。</p>
<p>jle：jump on less or equal,比较结果小时跳转</p>
<p>jge:jump on greater or equal,比较结果大时跳转</p>
<p>jmp：不管结果怎样都进行跳转</p>
<p>for循环：通过在括号中指定循环计数器的初始值、循环的继续条件、循环计数器的更新这三种形式来进行循环处理，对应的汇编代码就是通过比较指令（cmp）和跳转指令（jl：jump on less than，小于的话就跳转）来实现的。</p>
<p>面向过程语言</p>
<p>\1. C</p>
<p>C语言编写的源代码也能通过编译器编译成汇编代码，用 Borland C++ 5.5编译器即可。C语言源文件的扩展名用.c，汇编语言的文件的扩展名用.asm。</p>
<p>Borland C++中，编译后的函数名和变量名前面会加一个_，dd指的是define double word，db指的是define byte。</p>
<p>在调用函数后，需认人为执行栈清理指令，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。</p>
<p>Windows提供的TextOut函数API可以向窗口和打印机输出字符，C语言提供的printf函数，是用来在命令提示符中显示字符串的函数，使用printf函数是无法向打印机输出字符的。</p>
<p>在C语言中，只要使用 _asm{}就可以在其中计述助记符，实现C和汇编语言混合的源代码。</p>
<p>\2. Fortran</p>
<p>\3. COBOL</p>
<p>\4. PASCAL</p>
<p>\5. ADA</p>
<p>面向对象语言</p>
<p>\6. C++</p>
<p>\7. C#</p>
<p>\8. Java</p>
<p>Java中的native关键字修饰的变量，这个变量的底层就是用C语言编写的。</p>
<p>\9. Python</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/22.2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/" data-id="ckvc2kuco000t9kwd98vwf57o" data-title="计算机语言" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-8.5.网页前端框架之bootstrap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/8.5.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8Bbootstrap/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T09:50:10.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/8.5.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8Bbootstrap/">网页前端框架之bootstrap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>bootstrap是一个基于HTML、CSS、JavaScript的前端框架</p>
<p>这个框架已经预定了一套CSS样式和与样式对应的JS代码（对应的样式有对应的特效）</p>
<p>开发人员只需要编写HTML结构，添加bootstrap固定的class样式，就可以轻松完成指定效果的实现（使用现成的样式和特效）</p>
<p>作用：bootstrap使得WEB开发更加快捷，高效</p>
<p>bootstrap支持响应式开发，解决了移动互联网前端开发问题</p>
<p>问题：不同分辨率需要不同的样式（移动手机，电脑，pad等屏幕大小都不一样）</p>
<p>响应式布局：一个网站的展示能够兼容多个终端（手机、ipad、PC等，而不需要为每个终端单独做一个展示版本）  此概念为解决移动互联网浏览而诞生的。</p>
<p>响应式布局能够使得网站仅适用一套样式，就可以在不同分辨率下展示出不同的舒适效果，大大降低了网站开发维护成本，并且能够给用户更好的体验性。</p>
<h1 id="bootstrap环境搭建"><a href="#bootstrap环境搭建" class="headerlink" title="*bootstrap环境搭建*"></a><em><strong>*bootstrap环境搭建*</strong></em></h1><p>javaee关注的是dist文件。dist中有css、fonts、js需要我们复制到项目中（css中有个bootstrap.css和bootstrap.min.css，js中也有个bootstrap.js和bootstrap.min.js），jquery-1.11.3-min.js也需要复制到js文件下，这样就算环境搭建完成了。</p>
<p>完整版bootstrap.css，bootstrap.js：完整版用于源码学习，但因为文件大小问题，不适合网络间传递。</p>
<p>压缩版bootstrap.min.css，bootstrap.min.js：压缩版用于网络发布，相比于完整版就是把源码的空格和换行删除掉了，节约了大量空间，功能是完全相同的，适用于网络间的快速传递，但是不适合源码阅读。</p>
<p>基本模版创建：可以从帮助文档中复制一个模版过来然后新建一个html文件放到其中，里面的bootstrap.min.css，bootstrap.min.js，jquery-1.11.3-min.js这三个东西要重新设置href和src</p>
<!DOCTYPE html>

<html lang="zh-CN">  <!--html页面使用的是中文简体-->

<head>

<meta charset="UTF-8">  <!--设置html页面的字符集是utf-8-->

<meta http-equiv="X-UA-Compatible" content=”IE=edge”>  <!--使用IE最新的渲染模式 展示页面-->

<meta name="viewport" content=”width=device-width,initial-scale=1”>  <!--上述3个meat变迁必须放在最前面，任何其他内容都必须跟随其后-->

<!--viewport：视口 （浏览器上网页内容的可视区域）-->

<title> Bootstrap 101 Template</title>

<link href=”../css/bootstrap.min.css” rel=”stylesheet”>

<script src=”../js/jquery-1.11.3-min.js”></script>

<script src=”../js/bootstrap.min.js”></script>

<!--这三个是bootstrap依赖的样式和脚本-->

</head>

<body>

<h1>helloworld</h1>

</body>

</html>

<p>这几个设置，仅在移动设备上生效：</p>
<p>width=device-width  设置视口的宽度为设备的宽度（大多数手机浏览器视口的宽度是980）</p>
<p>initial-scale=1  初始化缩放设置（1~5）1代表就是100%</p>
<p>minimum-scale=1  移动设备上，页面可以最小缩放的级别</p>
<p>maximum-scale=1  移动设备上，页面可以最大缩放的级别</p>
<p>user-scalable=no  移动设备上，页面禁止缩放</p>
<h1 id="布局容器"><a href="#布局容器" class="headerlink" title="*布局容器*"></a><em><strong>*布局容器*</strong></em></h1><p>bootstrap必须需要至少一个布局容器，才能为页面内容进行封装和方便的样式控制  相当于一个画板</p>
<p>帮助手册位置：全局CSS样式–概览–布局容器</p>
<p>任意元素使用了布局容器的样式都会成为一个布局容器，建议使用div作为布局容器。</p>
<p>.container  ：类用于固定宽度并支持响应式布局的容器  特点：居中，两端留白</p>
<div  class=”container”>...</div>

<p>.container-fluid  :类用于100%宽度，占据全部视口的容器  特点：占据视口100%宽度</p>
<div  class=”container-fluid”>...</div>

<h1 id="栅格系统"><a href="#栅格系统" class="headerlink" title="*栅格系统*"></a><em><strong>*栅格系统*</strong></em></h1><p>为了方便在布局容器中进行网页的布局操作，bootstrap提供了一套专门用于响应式开发布局的栅格系统。</p>
<p>栅格系统将一行分为12列，通过设定元素占用的列数来布局元素在页面上的展示位置。</p>
<p>作用：可以让开发人员更加轻松进行网页布局，并且轻松进行响应式开发</p>
<p>特点：行必须包含在container或container-fluid中；</p>
<p>行使用的样式row，列使用样式col-*-*，元素内容应当放置于列内；</p>
<p>基本的书写方式必须是：容器–行–列</p>
<p>栅格参数：col-屏幕尺寸-占用列数  (屏幕尺寸现在都写成lg)</p>
<p>为了方便显示元素大小，我们为展示元素都赋予了相同样式</p>
<div  class=”container”>

<div class=”row”>

<div class=”col-lg-2” style=”border:1px solid:red;”>

<p>11111</p>
</div>

<div class=”col-lg-4” style=”border:1px solid:red;”>

<p>222222222</p>
</div>

</div>

</div>

<p>列元素的书写顺序，决定布局顺序，先写的列元素会先被布局到行上</p>
<p>列元素的占用列数定义了列元素的大小。</p>
<p>一个row下，如果列元素总和小于等于12，都在一行上。如果大于12，那么超出的元素会另起一行排列</p>
<p>行和列可以无限嵌套，嵌套方式必须为列-行-列-行…（相当于是把当前的列当作行，这个行row又分为12列，可以继续设置）</p>
<p>一个row元素下，都会有12列。</p>
<p>屏幕尺寸设置：</p>
<p>large：lg  大屏幕，一般pc尺寸</p>
<p>medium：md  中等屏幕，小pc尺寸</p>
<p>small：sm  小屏幕，ipad尺寸</p>
<p>x small：  xs  超小屏幕，智能手机尺寸</p>
<p>如果没有设置当前屏幕尺寸的样式，默认一个元素占一行。（比如你设置了lg尺寸，但是当你缩小为md尺寸的时候，就会变为一个元素占一行，因为你没有设置md的相应样式）</p>
<p>多个屏幕尺寸共同设置：只需要在后面加即可</p>
<div class=”col-lg-4 col-md-3 col-sm-2” style=”border:1px solid:red;”>

<p>如果设置了一个屏幕尺寸，比这个尺寸大的屏幕，继承了当前的设置；比这个尺寸小的屏幕，默认一个元素占一行</p>
<p>列偏移：将列元素向右侧进行推移</p>
<p>col-屏幕尺寸-offset-*  在指定屏幕尺寸下，向右偏移*个列</p>
<div class=”col-lg-4 col-lg-offset-3” style=”border:1px solid:red;”>

<h1 id="响应式工具"><a href="#响应式工具" class="headerlink" title="*响应式工具*"></a><em><strong>*响应式工具*</strong></em></h1><p>为针对性地在移动页面上展示和隐藏不同的内容，bootstrap提供响应式工具</p>
<p>可以让开发人员通过该工具决定，在何种屏幕尺寸下，隐藏或者显示某些元素</p>
<p>visible-屏幕尺寸  可见</p>
<p>hidden-屏幕尺寸  隐藏</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="*列表*"></a><em><strong>*列表*</strong></em></h1><p>bootstrap提供了实用的列表样式供开发人员使用</p>
<p>帮助手册–全局CSS样式–排版–列表</p>
<p>无序列表、有序列表、无样式列表、内联列表。</p>
<p>内联列表：可以在标签内进行设置：class=“list-inline”就可以使列表变为在一行上。</p>
<h1 id="按钮"><a href="#按钮" class="headerlink" title="*按钮*"></a><em><strong>*按钮*</strong></em></h1><p>任何HTML元素加上以下样式都会变成对应按钮：class属性设置为</p>
<p>btn btn-default  默认按钮</p>
<p>btn btn-primary  首选按钮</p>
<p>btn btn-success  成功按钮</p>
<p>btn btn-info  一般信息按钮</p>
<p>btn btn-warning  警告按钮</p>
<p>btn btn-danger  危险按钮</p>
<p>btn btn-link  链接按钮</p>
<p>尺寸：在按钮的属性后面添加即可</p>
<p>btn-lg  大按钮</p>
<p>btn-sm  小按钮</p>
<p>btn-xs  超小按钮</p>
<p>默认按钮不用写</p>
<p>块级元素：btn-block  使按钮变为块级元素</p>
<p>激活状态：active  直接在后面添加即可（不用写btn-）</p>
<p>禁用状态：让鼠标无法点击的禁用状态：disabled 用法和active一样</p>
<p>让鼠标指上去是个禁止的禁用状态：设置disabled=“disabled”</p>
<h1 id="导航条"><a href="#导航条" class="headerlink" title="*导航条*"></a><em><strong>*导航条*</strong></em></h1><p>可以复制代码，然后修改我们需要的内容即可。nav标签</p>
<p>汉堡按钮：缩小时，会将项目合并成一个图标</p>
<p>sr-only  阅读器专用的样式（盲人设备，当鼠标指针放到这的时候，阅读器会读出相应设置的内容）</p>
<h1 id="轮播图"><a href="#轮播图" class="headerlink" title="*轮播图*"></a><em><strong>*轮播图*</strong></em></h1><p>帮助手册位置–javascript插件–Carousel</p>
<p>轮播图DIV的定时换图属性：data-interval=“毫秒值”  放在标签中</p>
<p>注意：多个轮播图，必须修改轮播图的id，使id唯一，当改了id之后，后续的代码中的相应部分也要修改</p>
<h1 id="排版方式"><a href="#排版方式" class="headerlink" title="*排版方式*"></a><em><strong>*排版方式*</strong></em></h1><p>class=“”</p>
<p>将元素内所有的内容进行排版：</p>
<p>text-left  使元素内容靠左显示</p>
<p>text-center  使元素内容居中显示</p>
<p>text-right  使元素内容靠右显示</p>
<h1 id="表单元素"><a href="#表单元素" class="headerlink" title="*表单元素*"></a><em><strong>*表单元素*</strong></em></h1><p>复制相关代码，修改其中的一些部分，完成自己的需求。</p>
<p>内联表单，水平排列的表单。</p>
<p>校验状态：has-success  has-error  has-warning</p>
<h1 id="分页条"><a href="#分页条" class="headerlink" title="*分页条*"></a><em><strong>*分页条*</strong></em></h1><p>默认分页  </p>
<p>禁用和激活状态（可以显示当前在第几页，第一页的前一页不可用等情况）： disabled  active  即使设置了不可用，如果存在href标签的话，仍能点击跳转到相应地方，保险起见，建议删除href标签。</p>
<p>翻页</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/8.5.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8Bbootstrap/" data-id="ckvc2kud9002g9kwd69zddout" data-title="网页前端框架之bootstrap" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-8.4.网页前端之JS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/8.4.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BJS/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T05:24:00.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/8.4.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BJS/">网页前端之JS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>HTML是用来写网页的</p>
<p>CSS是美化页面的</p>
<p>JavaScript是WEB上强大的脚本语言</p>
<p>JAVA编程语言：独立写程序，独立运行。编译–运行</p>
<p>脚本语言：无法独立执行。必须嵌入到其他语言中结合使用。直接被浏览器解析执行</p>
<p>作用：控制页面特效展示</p>
<p>语言特征：JavaScript无需编译，直接被浏览器解释并执行</p>
<p>JavaScript无法单独执行，必须嵌入到HTML代码中执行</p>
<p>JavaScript的执行过程由上到下依次执行</p>
<p>注意：JavaScript没有访问系统文件的权限</p>
<p>JavaScript无需编译，由上到下依次解释执行，所以在保证可读性的情况下，允许使用链式编程</p>
<p>JavaScript和java没有任何直接关系</p>
<p>组成</p>
<p>ECMAScript（核心）：规定了JS的语法和基本对象</p>
<p>DOM 文档对象模型（标记型文档。HTML）：处理网页内容的方法和接口</p>
<p>BOM  浏览器对象模型：与浏览器交互的方法和接口</p>
<p>引入方式：</p>
<p>\1. 内部脚本：在当前页面内部写script标签，script内部即可书写JavaScript代码。</p>
<p>格式：</p>
<script type=”text/javascript”>

JavaScript的代码

</sctipt>

注意：script标签理论上可以书写在HTML文件的任意位置

\2. 外部引入：在HTML文档中，通过<script src=””>标签引入.js文件

格式：

<script type=”text/javascript” src=”demo.js”></script>

<p>注意：外部引用时，script标签内不能有script代码，即使写了也不会执行</p>
<p>开发规范规定，script标签的放置位置为：在结束标签</body>前</p>
<p>(在学习时，可以先放在head标签之中，最后在放到结束标签</body>前)</p>
<p>优点：保证html展示内容优先加载，最后加载脚本，增强用户体验性</p>
<p>JavaScript的语法及规则：alert相当于是System.out.println()</p>
<p>\1. 注释：<br>单行注释： //  Hbuilder快捷键：ctrl+/</p>
<p>多行注释：/**/  Hbuilder快捷键：ctrl+shift+/</p>
<p>\2. 变量：标示内存中的一块空间，用于存储数据，且数据是可变的。<br>声明：var 变量名；  变量赋予默认值，默认值为undefined</p>
<p>var 变量名=值；</p>
<p>注意：必须以字母或下划线开头，中间可以使数字，字符或下划线。</p>
<p>变量名不能包含空格等符号</p>
<p>不能使用JavaScript的关键字作为变量名，如：function、this、class</p>
<p>JavaScript严格区分大小写</p>
<p>基本数据类型：5类</p>
<p>string：字符串类型  “” ‘’ 都是字符串，JavaScript中没有单个字符</p>
<p>boolean：布尔类型  固定值为false和true</p>
<p>number：数字类型 任意数字</p>
<p>null：空 一个占位符</p>
<p>undefined：未定义类型  该类型只有一个固定值，即undefined，表示变量声明却未定义具体的值</p>
<p>注意：因为undefined是从null中派生出来的，所以undefined==null</p>
<p>JavaScript区别于java，是弱类型语言，变量的使用不用严格遵循规范，所以一个变量声明好之后，还可以赋予任意类型的值。</p>
<p>typeof() 可以分辨变量值属于哪种基本数据类型：undefined、string、boolean、number。 如果一个变量是引用类型或者null类型的话，会返回object。</p>
<p>ECMAScript实现之初的一个bug：null属于基本数据类型，然而typeof(null)返回的却是object</p>
<p>引用数据类型:引用数据类型通常叫做类（class），但在JavaScript中，因为不存在编译过程，所以没有类的概念，所处理的引用数据类型都是对象。</p>
<p>标准创建方式： var str= new String();  //和java相同</p>
<p>var str= new String;  //js独有的方式</p>
<p>\3. 运算符：与java基本一致<br>比较运算符：== 逻辑等。 仅仅对比值<br>                === 全等。对比值并且对比类型<br>逻辑运算符：没有&amp; |  只有三个</p>
<p>&amp;&amp;：and</p>
<p>||：  or</p>
<p>!：  not</p>
<p>\4. 正则对象<br>RegExp对象的创建方式：</p>
<p>var reg= new RegExp(“表达式”);  （开发中基本不用）</p>
<p>var reg=/^表达式$/；  直接量（开发中常用）</p>
<p>直接量中存在边界，即^代表开始，$代表结束</p>
<p>直接量方式的正则是对象，不是字符串，别用引号</p>
<p>使用正则对象：方法：compile：编译正则表达式  （不咋用）</p>
<p>exec：检索字符串中指定的值，返回找到的值，并确定其位置 （不咋用）</p>
<p>test方法： 正则对象.test(string);  用来校验字符串是否匹配正则，全部字符匹配返回true，有一个字符不匹配返回false</p>
<p>注意：/表达式/ 普通方式，只要有成立正则的字符存在，就返回true，除非全部字符不符合正则，返回false（检查不严格，适合字符串查找、替换）</p>
<p>/^表达式$/ 直接量方式，只要有无法成立正则表达式的字符存在，就返回false（检查严格，适合表单校验）</p>
<p>\5. JS数组对象<br>特性：JS数组可以看作java中的ArrayList集合。</p>
<p>数组中的每一个成员都没有类型限制，即可以存放任意类型。</p>
<p>数组的长度可以自动修改</p>
<p>四种创建方式：</p>
<p>（1）var arr=[1,2,3,”a”,true];  常用的js数组  （常用）</p>
<p>（2）var arr=new Array();  创建一个数组对象，数组长度默认为0 （常用）</p>
<p>（3）var arr= new Array(4);  数组长度是4，相当于开辟了长度为4的空间，每个元素是undefined。</p>
<p>（4）var arr =new Array(“a”,1,true);创建了一个数组，长度为3，元素是“a”,1,true<br>常用属性：length  设置或返回数组中元素的数目</p>
<p>常用方法： join（string）  把数组的所有元素放入一个字符串。元素通过指定的分隔符string进行分隔 （对原来的数组无影响）</p>
<p>pop（） 删除并返回数组的最后一个元素（原先数组无了）</p>
<p>push（新元素） 向数组的末尾添加一个或更多的元素，并返回新的长度（原先数组无了）</p>
<p>reverse（） 颠倒数组中元素的顺序（物理翻转，就是把元素下标进行互换）该方法的返回值就是翻转成功的新数组。（会对当前的数组进行操作，原来的数组无了）</p>
<p>\6. 全局函数(global)</p>
<p>undefined属于全局函数的属性，但是我们在使用的时候不用加global.undefined<br>（1）执行： eval（string）  计算JavaScript字符串，并把它作为脚本代码来执行</p>
<p>作用：增强程序的扩展性</p>
<p>注意：只可以传递原始数据类型string，传递string对象无作用。</p>
<p>（2）编码和解码</p>
<p>URL/URI编码：中文和特殊符号  %十六进制</p>
<p>作用：保证数据传递的完整性</p>
<p>encodeURI（string）  把字符串进行URI编码，返回值就是编码后的结果</p>
<p>decodeURI（string）  解码某个编码的URI</p>
<p>（3）URI和URL的区别</p>
<p>URI是统一资源标识符  标识资源详细名称  必须包含资源名</p>
<p>URL是统一资源定位器  定位资源的网络位置  必须包含http：//</p>
<p>资源：就是可以通过浏览器访问的信息统称为资源（图片、文本、HTML、CSS等等）</p>
<p>（4）字符串转数字</p>
<p>parseInt(string)  解析一个字符串并返回一个整数  小数点后面部分直接去掉</p>
<p>parseFloat(string)  解析一个字符串并返回一个浮点数</p>
<p>注意：如果字符串的某个字符从字面值上无法转为数字，那么从该字符开始停止转换，仅返回前面正确的转换值。</p>
<p>如果字符串的第一个字符就无法从字面值上转为数字，那么停止转换，返回NaN（Not A Number，一个数字类型的标识，表示不是一个正确的数字）</p>
<p>\7. 自定义函数/自定义方法</p>
<p>函数：如果一段代码需要被重复编写使用，那么我们为了方便统一编写使用，可以将其封装进一个函数（方法）中</p>
<p>作用：增强代码的复用性</p>
<p>格式： function 方法名(参数列表){</p>
<p>函数体</p>
<p>}</p>
<p>注意：JavaScript函数定义必须用小写的function</p>
<p>无需定义返回值类型，在function后面直接写方法名</p>
<p>参数的定义无需使用var关键字，否则会报错</p>
<p>函数体中，return可以不写，也可以return具体值，也可以仅仅写return</p>
<p>JavaScript函数调用执行完毕一定有返回值，值及类型根据return决定，如果未return具体值，则返回值为undefined</p>
<p>函数如果同名，JavaScript中不存在方法重载，只有方法相互覆盖，所以最后定义的函数覆盖之前的定义。</p>
<p>再调用时仅仅根据方法名来调用函数，即使实际参与函数与形参不匹配，也不会影响正常调用。</p>
<p>如果实参未赋值，就使用默认值undefined</p>
<p>\8. 自定义对象</p>
<p>①function构造函数：JavaScript中的引用数据类型都是对象，而对象在JavaScript中可以用函数来表示。（相当于java中创建某个class类）</p>
<p>无形参格式：function 对象名(){</p>
<p>函数体</p>
<p>}</p>
<p>例如：</p>
<p>声明一个Person对象：</p>
<p>function Person(){</p>
<p>this.name=”swx”;  // this 就是当前的Person对象</p>
<p>this.age=”23”;   //name  age是对象的属性</p>
<p>}</p>
<p>var p=new Person();  //创建了一个Person对象</p>
<p>alert(p.name);</p>
<p>为属性赋值：</p>
<p>（1）构造参数赋值：function Person(n,a){</p>
<p>this.name=n;  </p>
<p>this.age=a;  </p>
<p>}</p>
<p>var p=new Person(“swx”,”23”);</p>
<p>（2）创建对象后，调用属性进行赋值</p>
<p>p.name=”sss”;</p>
<p>属性定义方式：</p>
<p>（1）this关键字，在对象声明定义阶段，定义一个属性</p>
<p>（2）创建对象后，使用对象.属性 方式来动态定义属性</p>
<p>p.sex=”男”;  //为Person对象声明了一个新的属性sex并赋值为男</p>
<p>应用场景：适用于对象构建及代码复用</p>
<p>②对象直接量</p>
<p>开发中可以用一种简单的方式直接创建自定义的JavaScript对象，这种方式称为“对象直接量”</p>
<p>格式： var 对象名 = {属性名1：“属性值1”，属性名2：“属性值2”，属性名3：“属性值3”……};  //  不一定非要字符串了 可以直接数字18</p>
<p>该方式直接创建出实例对象，无需构建函数，无需再new创建实例对象，直接使用即可。</p>
<p>适用场景：适用于快速创建实例对象及数据封装</p>
<p>BOM对象 </p>
<p>BOM（Browser Object Model）浏览器对象模型</p>
<p>浏览器：IE、火狐、谷歌、360等任意浏览器</p>
<p>作用：用来执行浏览器的相关操作（例如：浏览器的地址，弹出消息等）</p>
<p>一般情况下，window代表了BOM对象</p>
<p>window对象是JavaScript的内置对象，使用window对象调用方法时可以省略window不写</p>
<p>（1）消息框</p>
<p>alert()  警告框，用来弹出警告消息 </p>
<p>注意：不同浏览器显示的组件样式不同，我们无需关注</p>
<p>confirm() 确认框 用于告知用户信息并收集用户的选择</p>
<p>有一个返回值，boolean类型</p>
<p>（2）定时器</p>
<p>循环定时器：调用一次就会创建并循环执行一个定时器</p>
<p>格式：setInterval(调用的方法名()，毫秒值);  </p>
<p>会有一个返回值，返回值就是这个定时器的id</p>
<p>取消：clearInterval(id);  取消id的定时器</p>
<p>一次性定时器：调用一次就会创建并执行一个计时器一次</p>
<p>格式：setTimeout(调用的方法名()，毫秒值);</p>
<p>也会有一个返回值，返回值就是这个定时器的id</p>
<p>取消：clearTimeout(定时器ID);  这个id在当前页面要求是唯一的。</p>
<p>（3）location对象</p>
<p>包含浏览器地址栏的信息</p>
<p>常用属性：href  设置或返回完整的URL  （直接调用会返回当前页面的URL，设置href属性=””;浏览器就会跳转到对应的路径，这里可以是html页面，也可以是外网路径，但必须要加https：//）</p>
<p>DOM对象</p>
<p>DOM（Document Object Model）文档对象模型</p>
<p>文档：标记型文档（HTML等）</p>
<p>DOM是将标记型文档中所有内容（标签、文本、属性）都封装成对象</p>
<p>通过操作对象的属性或者方法，来达到操作或者改变HTML展示效果的目的</p>
<p>HTML文件会加载并解析到内存中，会生成一张DOM树</p>
<p>DOM树：</p>
<p>每个标签都会被加载成DOM树上的一个元素节点对象</p>
<p>每个标签的属性会被加载成DOM树上的一个属性节点对象</p>
<p>每个标签的内容体会被加载成DOM树上的一个文本节点对象</p>
<p>整个DOM树，是一个文档节点对象，即DOM对象</p>
<p><em><strong>*一个HTML文档加载到内存中就会形成一个DOM对象*</strong></em></p>
<p>特点：必定会有一个根节点</p>
<p>每个节点都是节点对象</p>
<p>常见的节点关系：父子节点关系</p>
<p>文本节点对象没有子节点（叶子节点）</p>
<p>每个节点都有一个父节点，零到多个子节点</p>
<p>只有根节点没有父节点</p>
<p>获取元素对象的四种方式： document的相关方法，所以要用document调用</p>
<p>getElementById();  通过元素id获取对应元素对象 （可以通过id获取对应的元素对象，如果找不到，返回null）</p>
<p>getElementsByName();  通过元素的****name属性****获取符合要求的所有元素</p>
<p>getElementsByTagName();  通过元素的****元素名属性（标签名）****获取符合要求的所有元素</p>
<p>getElementsByClassName();  通过元素的****class属性****获取符合要求的所有元素</p>
<p>注意事项：</p>
<p>获取某个或某些元素节点对象，必须保证元素节点对象先被加载到内存中。（这就是为什么script标签为什么推荐放在</body>之前的原因，这就可以保证元素都被加载完了，再运行script标签时就能找到相应的标签）</p>
<p>元素对象常见属性：</p>
<p>value: 可以修改元素的值</p>
<p>元素对象.value  获取元素对象的value属性值</p>
<p>元素对象.value=属性值  设置元素对象的value属性值</p>
<p>className： 可以修改元素的样式</p>
<p> //本来是class，但是class是关键字，所以要用className</p>
<p>元素对象.className  获取元素对象的class属性值</p>
<p>元素对象.className=属性值  设置元素对象的class属性值</p>
<p>checked：  可以修改单选/复选的选中与否</p>
<p>元素对象.checked  获取元素对象的checked属性值</p>
<p>元素对象.checked=属性值  设置元素对象的checked属性值</p>
<p>HTML中checked=”checked”,JavaScript中返回true，false</p>
<p>innerHTML：  可以操作元素的内容体</p>
<p>元素对象.innerHTML  获取元素对象的内容体</p>
<p>元素对象.innerHTML=值  设置元素对象的内容体</p>
<p>追加内容体信息：  元素对象.innerHTML+=值</p>
<p>JS事件</p>
<p>通常鼠标或热键的动作称之为事件（Event）。</p>
<p>作用：通过JS事件，我们可以完成页面的指定特效</p>
<p>JS事件驱动机制：</p>
<p>事件源：专门产生事件的组件 </p>
<p>事件：由事件源所产生的动作或者事情 </p>
<p>监听器：专门处理事件源所产生的事件</p>
<p>注册/绑定监听器：让监听器时刻监听事件源是否有指定事件产生，如果事件源产生指定事件，则调用监听器处理</p>
<p>JS常见事件：  一般都是放在标签中，事件=“方法()”</p>
<p>\1. 点击事件（onclick）：由鼠标或热键点击元素组件时触发</p>
<p>\2. 焦点事件</p>
<p>焦点：即整个页面的注意力。  默认一个正常页面最多仅有一个焦点 （例如：文本框中闪烁的小竖线）</p>
<p>通常焦点也能反映出用户目前的关注点，或者正在操作的组件。</p>
<p>获取焦点事件（onfocus）：当元素组件获取焦点时触发</p>
<p>失去焦点事件（onblur）：元素组件失去焦点时触发</p>
<p>\3. 域内容改变事件（onchange）：元素组件的值发生改变时触发</p>
<p>\4. 加载完毕事件（onload）：元素组件加载完毕时触发</p>
<p>//以前有推荐script代码放在最后是因为要元素标签加载完在调取，现在有了这个方法，也可以让元素组件加载完再调取。</p>
<p>\5. 表单提交事件（onsubmit）：表单的提交按钮被点击时触发</p>
<p>注意：该事件需要返回boolean类型的值来执行  提交/阻止表单数据的操作</p>
<p>事件得到true，提交表单数据</p>
<p>事件得到false，阻止表单数据提交</p>
<p>在form标签处写。</p>
<p>用于表单的校验，也可以控制表单的提交  onsubmit=”return run1()” run1方法中必须要有返回值（可以进行表单校验，符合返回true，会提交表单；不符合返回false，表单提交会被阻止）</p>
<p>\6. 键位弹起事件（onkeyup）：在组件中输入某些内容时，键盘键位弹起时触发该事件（可以进行校验）</p>
<p>\7. 常用鼠标事件</p>
<p>鼠标移入事件（onmouseover）：鼠标移入某个元素组件时触发</p>
<p>鼠标移出事件（onmouseout）：鼠标移出某个元素组件时触发</p>
<p>JS事件的两种绑定方式：</p>
<p>\1. 元素事件句柄绑定：将事件以元素属性的方式写到标签内部，进而绑定对应函数</p>
<p>//可以绑定一个或者多个 无参、带参函数，如果是带参的话，外面是“”里面是’’。多个函数时，函数之间用“ ， ”隔开，顺序就是执行顺序。</p>
<p>优点：开发快捷；传参方便；可以绑定多个函数</p>
<p>缺点：JS和HTML代码高度糅合在一起，不利于多部门的项目开发维护</p>
<p>\2. DOM绑定方式：使用DOM的属性方式绑定事件</p>
<p>两种：（1）对象.事件属性  一次只能绑定一个函数，不能传递参数</p>
<p>window.onload=run1；</p>
<p>（2）匿名函数  可以绑定多个函数，可以传递参数</p>
<p>window.onload=function(){</p>
<p>//这个方法是页面加载的方法，可以在这里调取此页面的所有元素，获得元素后就可以继续使用匿名函数调取方法</p>
<p>run1();</p>
<p>run2();</p>
<p>}</p>
<p>优点：使得HTML代码和JS代码完全分离</p>
<p>缺点：不能传递参数；一个事件只能绑定一个函数。解决：匿名函数就可以，匿名函数内部就可以绑定多个函数</p>
<h3 id="Window-setInterval-方法"><a href="#Window-setInterval-方法" class="headerlink" title="Window setInterval() 方法"></a>Window setInterval() 方法</h3><p>setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。</p>
<p>setInterval() 方法会不停地调用函数，直到 <a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/met-win-clearinterval.html">clearInterval()</a> 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数</p>
<p>如果你只想执行一次可以使用 <a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/met-win-settimeout.html">setTimeout()</a> 方法</p>
<h3 id="Window-clearInterval-方法"><a href="#Window-clearInterval-方法" class="headerlink" title="Window clearInterval() 方法"></a>Window clearInterval() 方法</h3><p>显示当前时间 ( setInterval() 函数会每秒执行一次函数，类似手表)。使用 clearInterval() 来停止执行:</p>
<p>clearInterval() 方法可取消由 setInterval() 函数设定的定时执行操作。</p>
<p>clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值。</p>
<p><strong>注意:</strong> 要使用 clearInterval() 方法, 在创建执行定时操作时要使用全局变量：</p>
<h3 id="if问题"><a href="#if问题" class="headerlink" title="if问题"></a>if问题</h3><p>在 JavaScript 里，不为空 “” 的字符串、不为 0 的数字、不为 null 的对象、不为 undefined 的对象属性、布尔型 true，单独作为判断式里的一个表达式时 JavaScript 通通认定为真（true），反之则为假（false）</p>
<p>原型和原型链</p>
<p>一、原型<br>①所有引用类型都有一个<code>__proto__</code>(隐式原型)属性，属性值是一个普通的对象<br>②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象<br>③所有引用类型的<code>__proto__</code>属性指向它构造函数的prototype</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1,2,3];</span><br><span class="line">a.__proto__ &#x3D;&#x3D;&#x3D; Array.prototype; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>


<p>二、原型链<br>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<code>__proto__</code>隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p>
<p>二、原型链<br>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p>
<p>举例，有以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Parent(month)&#123;</span><br><span class="line">    this.month &#x3D; month;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child &#x3D; new Parent(&#39;Ann&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child.month); &#x2F;&#x2F; Ann</span><br><span class="line"></span><br><span class="line">console.log(child.father); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>在child中查找某个属性时，会执行下面步骤：</p>
<p><img src="/8.4.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BJS/20180620134143385" alt="这里写图片描述"></p>
<p>访问链路为：</p>
<p><img src="/8.4.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BJS/20180620155400807" alt="这里写图片描述"></p>
<p>①一直往上层查找，直到到null还没有找到，则返回undefined<br>②<code>Object.prototype.__proto__</code> === null<br>③所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象</p>
<p>js的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify()   &#x2F;&#x2F;将数组转为字符串</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.indexOf(searchvalue,fromindex) &#x2F;&#x2F;从stringObject中检索searchvalue，对大小写敏感，没找到返回-1，找到返回stringObject中的index值</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/8.4.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BJS/" data-id="ckvc2kue300569kwdcycudxvx" data-title="网页前端之JS" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-10.7.关于重构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T05:16:25.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/">关于重构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="什么是重构？"><a href="#什么是重构？" class="headerlink" title="什么是重构？"></a><strong>什么是重构？</strong></h1><p>Martin Fowler曾出版了两本有关重构的书籍，他认为：</p>
<p>重构指的是，在不改变代码的外部行为，只改善其内部结构的方式下，修改软件系统的过程。重构是一种有条理的清理代码的方式，可以最大程度地减少引入bug的机会。本质上，重构意味着在代码编写完成后，改进代码的设计。</p>
<h1 id="重构有什么好处？"><a href="#重构有什么好处？" class="headerlink" title="重构有什么好处？"></a><strong>重构有什么好处？</strong></h1><p>首先，重构可以将混乱、不正确和/或重复的代码转换成整洁的代码。它可以解决多位开发人员协同工作时可能引发的代码标准化问题。重构可以提高可读性，改善源代码的可维护性以及整体结构和功能。重构可以使代码更易于扩展和添加新功能。删除不必要的代码（比如重复代码）可以减少代码所使用的内存，并加快执行速度。 </p>
<p>例如，在2014年，Kickstarter的工程师面临着一个巨大的挑战：由于用户数量呈指迅速增长，导致查询性能下降。为此，他们将MySQL查询重构为Redis，减少了100毫秒的加载时间，从而减少了加载时间的差异并提高了网站的整体速度。</p>
<h1 id="技术负债与重构"><a href="#技术负债与重构" class="headerlink" title="技术负债与重构"></a><strong>技术负债与重构</strong></h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAughAuEz9WJKmOEboib3KY1y335WhibibfKKEic84Md2OlBMT0UxxICJs15MOBWP5zulrkg2x6icPO3ZqtA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>简而言之，重构是消除或减少技术负债的一种方式。</p>
<p>重构对于长期维持的代码质量、安全性和性能至关重要。如果没有定期的重构，开发人员就会承受巨大的技术负债。重构代码的机会越少，技术负债就会越多，开发新功能也会变得越来越难。</p>
<h1 id="重构的指标"><a href="#重构的指标" class="headerlink" title="重构的指标"></a><strong>重构的指标</strong></h1><p>我们可以通过各种指标，衡量重构代码的优先级。在指标的帮助下，我们可以有条不紊地计划重构，每一次都专心完成最重要的任务。</p>
<p>此外，你需要通过指标来衡量重构的效果。我们不仅需要重构低效的代码，而且还可以通过修改低效代码增加价值。为了获得真正的价值，你需要进行测试，包括单元测试和功能测试。除此之外，还有一些其他方面的指标，比如发现的bug数减少，以及降低循环复杂性（重构的目标是降低复杂性）。高度复杂的方法或功能（比如超过350行的方法或功能）就是良好的重构对象。</p>
<p>此外，我们还需要考虑，如何将重构融合到更广泛的团队目标或有关工作流和任务的里程碑中。</p>
<h1 id="代码重构示例"><a href="#代码重构示例" class="headerlink" title="代码重构示例"></a><strong>代码重构示例</strong></h1><p>代码重构的示例非常多，为了简洁起见，我们介绍以下几种：</p>
<p><strong>红色，绿色和重构</strong></p>
<p>重构与单元测试息息相关。最常见的形式之一就是敏捷方法固有的测试驱动开发（Test-Driven Development，即TDD）。你可以在编写代码之前先编写测试。从本质上来说，应该由测试来驱动程序，说明代码应该执行的操作。</p>
<p>红色，绿色和重构是测试驱动开发的一个示例：</p>
<ul>
<li>红色：编写没有实现代码的测试套件，必然会失败。</li>
<li>绿色：编写实现代码，刚刚好可以通过测试套件。</li>
<li>重构：寻找优化和改进代码的方法。</li>
</ul>
<p><strong>提取方法（又名提取函数）</strong></p>
<p>将代码片段从现有方法移到新方法中，而新方法的名称明确说明了其功能。这种技术有助于降低复杂性并提高代码的可读性。</p>
<p><strong>提取变量</strong> </p>
<p>如果遇到难以理解的表达式，或者该表达式在整个代码中重复了多次，则可以通过提取变量重构，将表达式或其中一部分放入一个复杂度较低且更易于理解的变量中。这样可以减少复杂性和代码重复。</p>
<p><strong>按抽象建立分支</strong></p>
<p>按抽象建立分支可以逐步对软件系统进行大规模地修改，而你则可以一边修改代码，一边定期发布系统。这种方法可以降低在分支上重构代码的复杂性，避免在合并代码时出现问题。</p>
<p><strong>方法组合</strong></p>
<p>代码过长不便于理解，而且也不方便修改。方法组合指的是一系列的操作，将方法改成顺序结构并删除重复的代码。这些操作包括内联方法、内联模板、用查询代替模板、拆分临时变量以及删除对参数的赋值等。</p>
<h1 id="重构代码的工具"><a href="#重构代码的工具" class="headerlink" title="重构代码的工具"></a><strong>重构代码的工具</strong></h1><p>你需要专业的重构工具吗？Martin Fowler表示，自动化的工具有帮助但不是必需的。他指出：</p>
<p>“许多语言都有IDE，可以自动执行许多常见的重构。这些是非常有价值的工具，可以帮助我更快地重构代码。但是，这些工具不是必不可少的，我经常在没有工具支持的情况下编写程序，每次只迈出一小步，并通过频繁的测试来发现错误。”</p>
<p>许多开发环境都可以自动化重构，一些常见的重构工具包括：</p>
<ul>
<li>Visual studio intellicode</li>
<li>Eclipse IDE</li>
<li>Spring Tool Suite 4</li>
<li>Rider</li>
<li>IntelliJ IDEA</li>
<li>SonarQube</li>
</ul>
<h1 id="重构与工程经理的难题"><a href="#重构与工程经理的难题" class="headerlink" title="重构与工程经理的难题"></a><strong>重构与工程经理的难题</strong></h1><p>为了解决引发重构需求的问题，首先我们需要弄清楚公司的运营方式。在着手重构之前，请先回答下列几个问题：</p>
<ul>
<li>哪些任务最优先？</li>
<li>开发的速度如何？</li>
<li>开发人员是否感觉到了快速交付代码的压力？</li>
<li>解决技术负债的流程都有哪些？</li>
<li>实施了哪些类型的代码审核？</li>
<li>团队成员是否具备适当的重构技能？</li>
<li>公司的文档标准是什么？</li>
</ul>
<p>如果不解决引发重构需求的根本问题，那么问题只会愈演愈糟。</p>
<h1 id="高级管理层对重构的支持"><a href="#高级管理层对重构的支持" class="headerlink" title="高级管理层对重构的支持"></a><strong>高级管理层对重构的支持</strong></h1><p>你们公司可能并没有在基础设施和维护上投入太多资金。</p>
<p>可能会有人说，应该将花费在重构上的时间投入到新功能开发上。</p>
<p>但是，我们仍然应该看一看重构的好处，以及它们与工作流程、客户、收入和业务增长的关系。重构得当可以改善代码，交付有效更新以及急需的功能，从而吸引新客户和回头客。即使在成功发布产品之后，软件公司也可以通过这种方式保持竞争力。 </p>
<p>为了获取高层管理的支持，还有一个更好的方法，即量化团队当前花费在修复原始代码中的错误或bug上的时间。具体一点，比如每天一个小时？每天两个小时？持续记录一个星期，你就会惊讶地发现原来团队每年需要花费数周或数月时间来修复遗留的代码。</p>
<h1 id="团队支持与重构：一个Sprint还是马拉松？"><a href="#团队支持与重构：一个Sprint还是马拉松？" class="headerlink" title="团队支持与重构：一个Sprint还是马拉松？"></a><strong>团队支持与重构：一个Sprint还是马拉松？</strong></h1><p>很难在团队内部开展重构工作？提及重构就会哀声载道？顺利开展重构的最重要的标志就是有计划、有目标以及有文档记录的行动。Ron Jeffries（极限编程的三大创始人之一）将重构比喻为清道：</p>
<p>“花些时间清出一条道来，那么下一次我们就可以直奔我们要构建的下一个功能，而无需绕过杂草和灌木丛。”</p>
<p>但是，他强调指出，糟糕的代码需要花费很长的时间来清理，而且重构应该经过深思熟虑：</p>
<p>“如果我们只改进手头的代码，而忽略目前不涉及的代码，那么以后必然会走回头路。”</p>
<p>在同一个Sprint中，我们经常发现后面的功能用到了我们之前清理过的代码。我们就会立即享受重构的好处。如果我们等积攒了一堆技术负债，再开始重构，那么我们享受的好处会延迟，甚至可能会在一些没大有用的地方浪费精力。</p>
<p>产品工程师兼首席技术官Andreas Klinger是Fix-it Friday的粉丝，他表示：</p>
<p>“Fix-it Friday的规则很简单：除非当前的项目十万火急，否则周五的工作就应该是重构。让工程师选择他们的工作。我们不应该因为微观管理而抹杀这种乐趣。有些人会尝试新的库。有些人会修复积压的bug。这两种工作都很好。我们尝试鼓励大家平衡这些任务。”</p>
<p>无论采用哪种方法，你都需要慎重思考，询问团队哪些代码最影响他们的效率。</p>
<ul>
<li>修复哪些代码对你的其他代码产生的影响最大？</li>
<li>解决哪些问题得到的回报最多？</li>
</ul>
<p>你不太可能找到一整块专门的时间来重构代码，重构代码必然会牺牲你花费在其他项目上的时间，但请不要低估定期坚持开展小范围的重构带来的影响。聚沙成塔，集腋成裘，最终你会获得丰厚的回报。</p>
<h1 id="文档与重构"><a href="#文档与重构" class="headerlink" title="文档与重构"></a><strong>文档与重构</strong></h1><p>标准化命名约定之类的文档可以让每个人都达成共识。Xerox的高级开发人员的研究发现，缺乏文档是重构最大的难题之一。</p>
<p>记录重构的工作内容不仅可以记录花费的时间，而且还可以为将来的团队成员提供说明。</p>
<p>最后，你还通过文档记录下自己的成功：重构带来的最大成功是什么？这些可以成为代码审核的考虑因素吗？</p>
<p><strong>需求案例</strong></p>
<p><strong>项目需求</strong></p>
<p>项目开发阶段，有一个关于下单发货的需求：如果今天下午 3 点前进行下单，那么发货时间是明天，如果今天下午 3 点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加 1 天为发货时间。</p>
<p><strong>思考与重构</strong></p>
<p>我相信这个需求看似很简单，无论怎么写都可以完成。</p>
<p>很多人可能看到这个需求，就动手开始写 Calendar 或 Date 进行计算，从而完成需求。</p>
<p>而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用 Calendar 或 Date 去解决，一定要看场景。</p>
<p>对于时间的计算我们要考虑 joda-time 这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。</p>
<p>请读者先考虑这个需求如何用 Java 代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final DateTime DISTRIBUTION_TIME_SPLIT_TIME &#x3D; new DateTime().withTime(15,0,0,0);</span><br><span class="line">private Date calculateDistributionTimeByOrderCreateTime(Date orderCreateTime)&#123;</span><br><span class="line">    DateTime orderCreateDateTime &#x3D; new DateTime(orderCreateTime);</span><br><span class="line">    Date tomorrow &#x3D; orderCreateDateTime.plusDays(1).toDate();</span><br><span class="line">    Date theDayAfterTomorrow &#x3D; orderCreateDateTime.plusDays(2).toDate();</span><br><span class="line">    return orderCreateDateTime.isAfter(DISTRIBUTION_TIME_SPLIT_TIME) ? wrapDistributionTime(theDayAfterTomorrow) : wrapDistributionTime(tomorrow);</span><br><span class="line">&#125;</span><br><span class="line">private Date wrapDistributionTime(Date distributionTime)&#123;</span><br><span class="line">    DateTime currentDistributionDateTime &#x3D; new DateTime(distributionTime);</span><br><span class="line">    DateTime plusOneDay &#x3D; currentDistributionDateTime.plusDays(1);</span><br><span class="line">    boolean isSunday &#x3D; (DateTimeConstants.SUNDAY &#x3D;&#x3D; currentDistributionDateTime.getDayOfWeek());</span><br><span class="line">    return isSunday ? plusOneDay.toDate() : currentDistributionDateTime.toDate() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回，这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了 3 遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。</p>
<p><strong>提高方法</strong></p>
<p>如果你做了 3 年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写 Java 的程序员，就好好的思考和重构代码吧。</p>
<p>写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的 Java 程序员。</p>
<p>提高代码水平最好的方法就是有条理的重构！(注意：是有条理的重构)</p>
<p><strong>设计模式</strong></p>
<p>设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。</p>
<p>我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。</p>
<p><strong>业务驱动技术 or 技术驱动业务</strong></p>
<p>业务驱动技术 or 技术驱动业务 ？ 其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个 Java 程序员，我们应该如何判断自己所处于的位置.</p>
<p><strong>业务驱动技术：</strong>如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。</p>
<p><strong>技术驱动业务：</strong>如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益，比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。</p>
<p>我相信大部分人还都处于业务驱动技术的方向吧。</p>
<p>所以你既然不能驱动业务，那就请拥抱业务变化吧。</p>
<p><strong>代码设计</strong></p>
<p>一直在做 Java 后端的项目，经常会有一些变动，我相信大家也都遇到过。</p>
<p>比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。</p>
<p>慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。</p>
<p>说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。</p>
<p>Java 编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计!</p>
<p><strong>你真的优秀吗？</strong></p>
<p>真不好意思，我取了一个这么无聊的标题。</p>
<p>国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边 code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？</p>
<p>“平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？</p>
<p>答案就是:</p>
<ol>
<li>多看成熟框架的源码</li>
<li>多回头看自己的代码</li>
<li>勤于重构</li>
</ol>
<p>你真的优秀吗？ 如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。</p>
<p>即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写java代码的程序员了。</p>
<h1 id="为什么要重构？"><a href="#为什么要重构？" class="headerlink" title="为什么要重构？"></a>为什么要重构？</h1><p>项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。</p>
<p>造成这样的原因往往有以下几点：</p>
<ol>
<li>编码之前缺乏有效的设计</li>
<li>成本上的考虑，在原功能堆砌式编程</li>
<li>缺乏有效代码质量监督机制</li>
</ol>
<p>对于此类问题，业界已有有很好的解决思路：通过持续不断的重构将代码中的“坏味道”清除掉。</p>
<h1 id="什么是重构"><a href="#什么是重构" class="headerlink" title="什么是重构"></a>什么是重构</h1><p>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。<br>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p>
<p>根据重构的规模可以大致分为大型重构和小型重构：</p>
<p><strong>大型重构</strong>：对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入bug的风险也会相对比较大。</p>
<p><strong>小型重构</strong>：对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名和注释、消除超大类或函数、提取重复代码等等。小型重构更多的是使用统一的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入bug的风险相对来说也会比较小。什么时候重构 新功能开发、修bug或者代码review中出现“代码坏味道”，我们就应该及时进行重构。持续在日常开发中进行小重构，能够降低重构和测试的成本。</p>
<p>代码的坏地方：</p>
<p><strong>代码重复</strong></p>
<ul>
<li>实现逻辑相同、执行流程相同</li>
</ul>
<p><strong>方法过长</strong></p>
<ul>
<li>方法中的语句不在同一个抽象层级</li>
<li>逻辑难以理解，需要大量的注释</li>
<li>面向过程编程而非面向对象</li>
</ul>
<p><strong>过大的类</strong></p>
<ul>
<li>类做了太多的事情</li>
<li>包含过多的实例变量和方法</li>
<li>类的命名不足以描述所做的事情</li>
</ul>
<p><strong>逻辑分散</strong></p>
<ul>
<li>发散式变化：某个类经常因为不同的原因在不同的方向上发生变化</li>
<li>散弹式修改：发生某种变化时，需要在多个类中做修改</li>
</ul>
<p><strong>严重的情结依恋</strong></p>
<ul>
<li>某个类的方法过多的使用其他类的成员</li>
</ul>
<p><strong>数据泥团/基本类型偏执</strong></p>
<ul>
<li>两个类、方法签名中包含相同的字段或参数</li>
<li>应该使用类但使用基本类型，比如表示数值与币种的Money类、起始值与结束值的Range类</li>
</ul>
<p><strong>不合理的继承体系</strong></p>
<ul>
<li>继承打破了封装性，子类依赖其父类中特定功能的实现细节</li>
<li>子类必须跟着其父类的更新而演变，除非父类是专门为了扩展而设计，并且有很好的文档说明</li>
</ul>
<p><strong>过多的条件判断</strong></p>
<p><strong>过长的参数列</strong></p>
<p><strong>临时变量过多</strong></p>
<p><strong>令人迷惑的暂时字段</strong></p>
<ul>
<li>某个实例变量仅为某种特定情况而设置</li>
<li>将实例变量与相应的方法提取到新的类中</li>
</ul>
<p><strong>纯数据类</strong></p>
<ul>
<li>仅包含字段和访问（读写）这些字段的方法</li>
<li>此类被称为数据容器，应保持最小可变性</li>
</ul>
<p><strong>不恰当的命名</strong></p>
<ul>
<li>命名无法准确描述做的事情</li>
<li>命名不符合约定俗称的惯例</li>
</ul>
<p><strong>过多的注释</strong></p>
<p>带来的问题：</p>
<ul>
<li><strong>难以复用</strong></li>
<li>系统关联性过多，导致很难分离可重用部分</li>
<li><strong>难于变化</strong></li>
<li>一处变化导致其他很多部分的修改，不利于系统稳定</li>
<li><strong>难于理解</strong></li>
<li>命名杂乱，结构混乱，难于阅读和理解</li>
<li><strong>难以测试</strong></li>
<li>分支、依赖较多，难以覆盖全面</li>
</ul>
<p>好代码的评价标准</p>
<p>可维护性、可读性、可扩展性</p>
<p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p>
<h1 id="如何重构"><a href="#如何重构" class="headerlink" title="如何重构"></a>如何重构</h1><p><strong>SOLID原则</strong></p>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720141907210.png" alt="image-20210720141907210"></p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类只负责完成一个职责或者功能，不要存在多于一种导致类变更的原因。</p>
<p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>
<h3 id="开放-关闭原则"><a href="#开放-关闭原则" class="headerlink" title="开放-关闭原则"></a>开放-关闭原则</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p>
<p>开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</p>
<p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p>
<p>子类可以扩展父类的功能，但不能改变父类原有的功能</p>
<blockquote>
<p>父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。</p>
</blockquote>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>调用方不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<h3 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h3><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>一个对象应该对其他对象保持最少的了解</p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，告诉我们要对扩展开放，对修改关闭。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h1><blockquote>
<p>设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。</p>
</blockquote>
<ul>
<li><strong>创建型</strong>：主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码</li>
<li><strong>结构型</strong>：主要通过类或对象的不同组合，解耦不同功能的耦合</li>
<li><strong>行为型</strong>：主要解决的是类或对象之间的交互行为的耦合</li>
</ul>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142318893.png" alt="image-20210720142318893"></p>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142334301.png" alt="image-20210720142334301"></p>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142346463.png" alt="image-20210720142346463"></p>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142358859.png" alt="image-20210720142358859"></p>
<h1 id="代码分层"><a href="#代码分层" class="headerlink" title="代码分层"></a><strong>代码分层</strong></h1><p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142117537.png" alt="image-20210720142117537"></p>
<p><strong>模块结构说明</strong></p>
<ul>
<li>server_main：配置层，负责整个项目的module管理，maven配置管理、资源管理等；</li>
<li>server_application：应用接入层，承接外部流量入口，例如：RPC接口实现、消息处理、定时任务等；不要在此包含业务逻辑；</li>
<li>server_biz：核心业务层，用例服务、领域实体、领域事件等</li>
<li>server_irepository：资源接口层，负责资源接口的暴露</li>
<li>server_repository：资源层，负责资源的proxy访问，统一外部资源访问，隔离变化。注意：这里强调的是弱业务性，强数据性；</li>
<li>server_common：公共层，vo、工具等</li>
</ul>
<p>代码开发要遵守各层的规范，并注意层级之间的依赖关系。</p>
<h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a><strong>命名规范</strong></h1><p>一个好的命名应该要满足以下两个约束：</p>
<ul>
<li>准确描述所做得事情</li>
<li>格式符合通用的惯例</li>
</ul>
<p>如果你觉得一个类或方法难以命名的时候，可能是其承载的功能太多了，需要进一步拆分。</p>
<h3 id="约定俗称的惯例"><a href="#约定俗称的惯例" class="headerlink" title="约定俗称的惯例"></a>约定俗称的惯例</h3><p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/640" alt="图片"></p>
<h3 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h3><blockquote>
<p>类名使用大驼峰命名形式，类命通常使用名词或名词短语。接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。</p>
</blockquote>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720143839909.png" alt="image-20210720143839909"></p>
<h3 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h3><blockquote>
<p>方法命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p>
</blockquote>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144034337.png" alt="image-20210720144034337"></p>
<h1 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a><strong>重构技巧</strong></h1><h3 id="提炼方法"><a href="#提炼方法" class="headerlink" title="提炼方法"></a>提炼方法</h3><p>多个方法代码重复、方法中代码过长或者方法中的语句不在一个抽象层级。<br>方法是代码复用的最小粒度，方法过长不利于复用，可读性低，提炼方法往往是重构工作的第一步。</p>
<p><strong>意图导向编程</strong>：把处理某件事的流程和具体做事的实现方式分开。</p>
<ul>
<li>把一个问题分解为一系列功能性步骤，并假定这些功能步骤已经实现</li>
<li>我们只需把把各个函数组织在一起即可解决这一问题</li>
<li>在组织好整个功能后，我们在分别实现各个方法函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">  * 1、交易信息开始于一串标准ASCII字符串。 </span><br><span class="line">  * 2、这个信息字符串必须转换成一个字符串的数组，数组存放的此次交易的领域语言中所包含的词汇元素（token)。 </span><br><span class="line">  * 3、每一个词汇必须标准化。 </span><br><span class="line">  * 4、包含超过150个词汇元素的交易，应该采用不同于小型交易的方式（不同的算法）来提交，以提高效率。 </span><br><span class="line">  * 5、如果提交成功，API返回”true”；失败，则返回”false”。 </span><br><span class="line">  *&#x2F;</span><br><span class="line">public class Transaction &#123;    </span><br><span class="line">  public Boolean commit(String command) &#123;        </span><br><span class="line">    Boolean result &#x3D; true;        </span><br><span class="line">    String[] tokens &#x3D; tokenize(command);        </span><br><span class="line">    normalizeTokens(tokens);        </span><br><span class="line">    if (isALargeTransaction(tokens)) &#123;            </span><br><span class="line">      result &#x3D; processLargeTransaction(tokens);        </span><br><span class="line">    &#125; else &#123;            </span><br><span class="line">      result &#x3D; processSmallTransaction(tokens);        </span><br><span class="line">    &#125;        </span><br><span class="line">    return result;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以函数对象取代函数"><a href="#以函数对象取代函数" class="headerlink" title="以函数对象取代函数"></a>以函数对象取代函数</h3><p>将函数放进一个单独对象中，如此一来局部变量就变成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。</p>
<h3 id="引入参数对象"><a href="#引入参数对象" class="headerlink" title="引入参数对象"></a>引入参数对象</h3><h3 id="方法参数比较多时，将参数封装为参数对象"><a href="#方法参数比较多时，将参数封装为参数对象" class="headerlink" title="方法参数比较多时，将参数封装为参数对象"></a>方法参数比较多时，将参数封装为参数对象</h3><h3 id="移除对参数的赋值"><a href="#移除对参数的赋值" class="headerlink" title="移除对参数的赋值"></a>移除对参数的赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int discount(int inputVal, int quantity, int yearToDate) &#123;</span><br><span class="line">  if (inputVal &gt; 50) inputVal -&#x3D; 2;</span><br><span class="line">  if (quantity &gt; 100) inputVal -&#x3D; 1;</span><br><span class="line">  if (yearToDate &gt; 10000) inputVal -&#x3D; 4;</span><br><span class="line">  return inputVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int discount(int inputVal, int quantity, int yearToDate) &#123; </span><br><span class="line">  int result &#x3D; inputVal;</span><br><span class="line">  if (inputVal &gt; 50) result -&#x3D; 2; </span><br><span class="line">  if (quantity &gt; 100) result -&#x3D; 1; </span><br><span class="line">  if (yearToDate &gt; 10000) result -&#x3D; 4; </span><br><span class="line">  return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将查询与修改分离"><a href="#将查询与修改分离" class="headerlink" title="将查询与修改分离"></a>将查询与修改分离</h3><p>任何有返回值的方法，都不应该有副作用</p>
<ul>
<li>不要在convert中调用写操作，避免副作用</li>
<li>常见的例外：将查询结果缓存到本地</li>
</ul>
<h3 id="移除不必要临时变量"><a href="#移除不必要临时变量" class="headerlink" title="移除不必要临时变量"></a>移除不必要临时变量</h3><p>临时变量仅使用一次或者取值逻辑成本很低的情况下</p>
<h3 id="引入解释性变量"><a href="#引入解释性变量" class="headerlink" title="引入解释性变量"></a>引入解释性变量</h3><p>将复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if ((platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1) </span><br><span class="line">    &amp;&amp; (browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1) &amp;&amp; wasInitialized() &amp;&amp; resize &gt; 0) &#123;   </span><br><span class="line">  &#x2F;&#x2F; do something </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">final boolean isMacOs &#x3D; platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1; </span><br><span class="line">final boolean isIEBrowser &#x3D; browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1; </span><br><span class="line">final boolean wasResized &#x3D; resize &gt; 0; </span><br><span class="line">if (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123;   </span><br><span class="line">  &#x2F;&#x2F; do something </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用卫语句替代嵌套条件判断"><a href="#使用卫语句替代嵌套条件判断" class="headerlink" title="使用卫语句替代嵌套条件判断"></a>使用卫语句替代嵌套条件判断</h3><p>把复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的if - then-else语句，转换为多个if语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;未使用卫语句</span><br><span class="line">public void getHello(int type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (type &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (type &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                setHello();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用卫语句</span><br><span class="line">public void getHello(int type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (type &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (type &#x3D;&#x3D; 3) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    setHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用多态替代条件判断断"><a href="#使用多态替代条件判断断" class="headerlink" title="使用多态替代条件判断断"></a>使用多态替代条件判断断</h3><p>当存在这样一类条件表达式，它根据对象类型的不同选择不同的行为。可以将这种表达式的每个分支放进一个子类内的复写函数中，然后将原始函数声明为抽象函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int calculate(int a, int b, String operator) &#123;</span><br><span class="line">    int result &#x3D; Integer.MIN_VALUE;</span><br><span class="line"> </span><br><span class="line">    if (&quot;add&quot;.equals(operator)) &#123;</span><br><span class="line">        result &#x3D; a + b;</span><br><span class="line">    &#125; else if (&quot;multiply&quot;.equals(operator)) &#123;</span><br><span class="line">        result &#x3D; a * b;</span><br><span class="line">    &#125; else if (&quot;divide&quot;.equals(operator)) &#123;</span><br><span class="line">        result &#x3D; a &#x2F; b;</span><br><span class="line">    &#125; else if (&quot;subtract&quot;.equals(operator)) &#123;</span><br><span class="line">        result &#x3D; a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当出现大量类型检查和判断时，if else（或switch）语句的体积会比较臃肿，这无疑降低了代码的可读性。 另外，if else（或switch）本身就是一个“变化点”，当需要扩展新的类型时，我们不得不追加if else（或switch）语句块，以及相应的逻辑，这无疑降低了程序的可扩展性，也违反了面向对象的开闭原则。</p>
<blockquote>
<p>基于这种场景，我们可以考虑使用“多态”来代替冗长的条件判断，将if else（或switch）中的“变化点”封装到子类中。这样，就不需要使用if else（或switch）语句了，取而代之的是子类多态的实例，从而使得提高代码的可读性和可扩展性。很多设计模式使用都是这种套路，比如策略模式、状态模式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface Operation &#123; </span><br><span class="line">  int apply(int a, int b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Addition implements Operation &#123; </span><br><span class="line">  @Override </span><br><span class="line">  public int apply(int a, int b) &#123; </span><br><span class="line">    return a + b; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OperatorFactory &#123;</span><br><span class="line">    private final static Map&lt;String, Operation&gt; operationMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    static &#123;</span><br><span class="line">        operationMap.put(&quot;add&quot;, new Addition());</span><br><span class="line">        operationMap.put(&quot;divide&quot;, new Division());</span><br><span class="line">        &#x2F;&#x2F; more operators</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Operation getOperation(String operator) &#123;</span><br><span class="line">        return operationMap.get(operator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int calculate(int a, int b, String operator) &#123;</span><br><span class="line">    if (OperatorFactory .getOperation &#x3D;&#x3D; null) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Invalid Operator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return OperatorFactory .getOperation(operator).apply(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用异常替代返回错误码"><a href="#使用异常替代返回错误码" class="headerlink" title="使用异常替代返回错误码"></a>使用异常替代返回错误码</h3><p>非正常业务状态的处理，使用抛出异常的方式代替返回错误码</p>
<ul>
<li><p>不要使用异常处理用于正常的业务流程控制</p>
</li>
<li><ul>
<li>异常处理的性能成本非常高</li>
</ul>
</li>
<li><p>尽量使用标准异常</p>
</li>
<li><p>避免在finally语句块中抛出异常</p>
</li>
<li><ul>
<li>如果同时抛出两个异常，则第一个异常的调用栈会丢失</li>
<li>finally块中应只做关闭资源这类的事情</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用错误码</span><br><span class="line">public boolean withdraw(int amount) &#123;</span><br><span class="line">    if (balance &lt; amount) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        balance -&#x3D; amount;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用异常</span><br><span class="line">public void withdraw(int amount) &#123;</span><br><span class="line">    if (amount &gt; balance) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;amount too large&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">    balance -&#x3D; amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引入断言"><a href="#引入断言" class="headerlink" title="引入断言"></a>引入断言</h3><p>某一段代码需要对程序状态做出某种假设，以断言明确表现这种假设。</p>
<ul>
<li>不要滥用断言，不要使用它来检查“应该为真”的条件，只使用它来检查“一定必须为真”的条件</li>
<li>如果断言所指示的约束条件不能满足，代码是否仍能正常运行？如果可以就去掉断言</li>
</ul>
<h3 id="引入Null对象或特殊对象"><a href="#引入Null对象或特殊对象" class="headerlink" title="引入Null对象或特殊对象"></a>引入Null对象或特殊对象</h3><p>当使用一个方法返回的对象时，而这个对象可能为空，这个时候需要对这个对象进行操作前，需要进行判空，否则就会报空指针。当这种判断频繁的出现在各处代码之中，就会影响代码的美观程度和可读性，甚至增加Bug的几率。</p>
<p>空引用的问题在Java中无法避免，但可以通过代码编程技巧（引入空对象）来改善这一问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;空对象的例子</span><br><span class="line">public class OperatorFactory &#123; </span><br><span class="line">  static Map&lt;String, Operation&gt; operationMap &#x3D; new HashMap&lt;&gt;(); </span><br><span class="line">  static &#123; </span><br><span class="line">    operationMap.put(&quot;add&quot;, new Addition()); </span><br><span class="line">    operationMap.put(&quot;divide&quot;, new Division()); </span><br><span class="line">    &#x2F;&#x2F; more operators </span><br><span class="line">  &#125; </span><br><span class="line">  public static Optional&lt;Operation&gt; getOperation(String operator) &#123; </span><br><span class="line">    return Optional.ofNullable(operationMap.get(operator)); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">public int calculate(int a, int b, String operator) &#123; </span><br><span class="line">  Operation targetOperation &#x3D; OperatorFactory.getOperation(operator) </span><br><span class="line">     .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Invalid Operator&quot;)); </span><br><span class="line">  return targetOperation.apply(a, b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;特殊对象的例子</span><br><span class="line">public class InvalidOp implements Operation &#123; </span><br><span class="line">  @Override </span><br><span class="line">  public int apply(int a, int b)  &#123; </span><br><span class="line">    throw new IllegalArgumentException(&quot;Invalid Operator&quot;);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提炼类"><a href="#提炼类" class="headerlink" title="提炼类"></a>提炼类</h3><p>根据单一职责原则，一个类应该有明确的责任边界。但在实际工作中，类会不断的扩展。当给某个类添加一项新责任时，你会觉得不值得分离出一个单独的类。于是，随着责任不断增加，这个类包含了大量的数据和函数，逻辑复杂不易理解。</p>
<p>此时你需要考虑将哪些部分分离到一个单独的类中，可以依据高内聚低耦合的原则。如果某些数据和方法总是一起出现，或者某些数据经常同时变化，这就表明它们应该放到一个类中。另一种信号是类的子类化方式：如果你发现子类化只影响类的部分特性，或者类的特性需要以不同方式来子类化，这就意味着你需要分解原来的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原始类</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String officeAreaCode;</span><br><span class="line">    private String officeNumber;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTelephoneNumber() &#123;</span><br><span class="line">        return (&quot;(&quot; + officeAreaCode + &quot;)&quot; + officeNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getOfficeAreaCode() &#123;</span><br><span class="line">        return officeAreaCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOfficeAreaCode(String arg) &#123;</span><br><span class="line">        officeAreaCode &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getOfficeNumber() &#123;</span><br><span class="line">        return officeNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOfficeNumber(String arg) &#123;</span><br><span class="line">        officeNumber &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新提炼的类（以对象替换数据值）</span><br><span class="line">public class TelephoneNumber &#123;</span><br><span class="line">    private String areaCode;</span><br><span class="line">    private String number;</span><br><span class="line"></span><br><span class="line">    public String getTelephnoeNumber() &#123;</span><br><span class="line">        return (&quot;(&quot; + getAreaCode() + &quot;)&quot; + number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String getAreaCode() &#123;</span><br><span class="line">        return areaCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setAreaCode(String arg) &#123;</span><br><span class="line">        areaCode &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setNumber(String arg) &#123;</span><br><span class="line">        number &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合优先于继承"><a href="#组合优先于继承" class="headerlink" title="组合优先于继承"></a>组合优先于继承</h3><p>继承使实现代码重用的有力手段，但这并非总是完成这项工作的最佳工具，使用不当会导致软件变得很脆弱。与方法调用不同的是，继承打破了封装性。子类依赖于其父类中特定功能的实现细节，如果父类的实现随着发行版本的不同而变化，子类可能会遭到破坏，即使他的代码完全没有改变。</p>
<p>举例说明，假设有一个程序使用HashSet，为了调优该程序的性能，需要统计HashSet自从它创建以来添加了多少个元素。为了提供该功能，我们编写一个HashSet的变体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Inappropriate use of inheritance!</span><br><span class="line">public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; The number of attempted element insertions</span><br><span class="line">    private int addCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet(int initCap, float loadFactor) &#123;</span><br><span class="line">        super(initCap, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount +&#x3D; c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称为组合，因为现有的类变成了新类的一个组件。这样得到的类将会非常稳固，它不依赖现有类的实现细节。即使现有的类添加了新的方法，也不会影响新的类。许多设计模式使用就是这种套路，比如代理模式、装饰者模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reusable forwarding class</span><br><span class="line">public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123;</span><br><span class="line">    private final Set&lt;E&gt; s;</span><br><span class="line">    public ForwardingSet(Set&lt;E&gt; s) &#123; this.s &#x3D; s; &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123; return s.size(); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123; return s.isEmpty(); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(Object o) &#123; return s.contains(o); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123; return s.iterator(); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object[] toArray() &#123; return s.toArray(); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123; return s.toArray(a); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) &#123; return s.add(e); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean remove(Object o) &#123; return s.remove(o); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean containsAll(Collection&lt;?&gt; c) &#123; return s.containsAll(c); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return s.addAll(c); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c) &#123; return s.retainAll(c); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c) &#123; return s.removeAll(c); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123; s.clear(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Wrappter class - uses composition in place of inheritance</span><br><span class="line">public class InstrumentedHashSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123;</span><br><span class="line">    private int addCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet1(Set&lt;E&gt; s) &#123;</span><br><span class="line">        super(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount +&#x3D; c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承与组合如何取舍</strong></p>
<ul>
<li>只有当子类真正是父类的子类型时，才适合继承。对于两个类A和B，只有两者之间确实存在“is-a”关系的时候，类B才应该继承A；</li>
<li>在包的内部使用继承是非常安全的，子类和父类的实现都处在同一个程序员的控制之下；</li>
<li>对于专门为了继承而设计并且具有很好的文档说明的类来说，使用继承也是非常安全的；</li>
<li>其他情况就应该优先考虑组合的方式来实现</li>
</ul>
<h3 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h3><p>Java提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。自从Java8为接口增加缺省方法（default method），这两种机制都允许为实例方法提供实现。主要区别在于，为了实现由抽象类定义的类型，类必须称为抽象类的一个子类。因为Java只允许单继承，所以用抽象类作为类型定义受到了限制。</p>
<p>接口相比于抽象类的优势：</p>
<ul>
<li>现有的类可以很容易被更新，以实现新的接口。</li>
<li>接口是定义混合类型（比如Comparable）的理想选择。</li>
<li>接口允许构造非层次结构的类型框架。</li>
</ul>
<p>接口虽然提供了缺省方法，但接口仍有有以下局限性：</p>
<ul>
<li>接口的变量修饰符只能是public static final的</li>
<li>接口的方法修饰符只能是public的</li>
<li>接口不存在构造函数，也不存在this</li>
<li>可以给现有接口增加缺省方法，但不能确保这些方法在之前存在的实现中都能良好运行。</li>
<li>因为这些默认方法是被注入到现有实现中的，它们的实现者并不知道，也没有许可</li>
</ul>
<p>接口缺省方法的设计目的和优势在于：</p>
<p><strong>为了接口的演化</strong></p>
<ul>
<li>Java 8 之前我们知道，一个接口的所有方法其子类必须实现（当然，这个子类不是一个抽象类），但是 java 8 之后接口的默认方法可以选择不实现，如上的操作是可以通过编译期编译的。这样就避免了由 Java 7 升级到 Java 8 时项目编译报错了。Java8在核心集合接口中增加了许多新的缺省方法，主要是为了便于使用lambda。</li>
</ul>
<p><strong>可以减少第三方工具类的创建</strong></p>
<ul>
<li>例如在 List 等集合接口中都有一些默认方法，List 接口中默认提供 replaceAll(UnaryOperator)、sort(Comparator)、、spliterator()等默认方法，这些方法在接口内部创建，避免了为了这些方法而专门去创建相应的工具类。</li>
</ul>
<p><strong>可以避免创建基类</strong></p>
<ul>
<li>在 Java 8 之前我们可能需要创建一个基类来实现代码复用，而默认方法的出现，可以不必要去创建基类。</li>
</ul>
<p><strong>由于接口的局限性和设计目的的不同，接口并不能完全替换抽象类。但是通过对接口提供一个抽象的骨架实现类，可以把接口和抽象类的优点结合起来。</strong> 接口负责定义类型，或许还提供一些缺省方法，而骨架实现类则负责实现除基本类型接口方法之外，剩下的非基本类型接口方法。扩展骨架实现占了实现接口之外的大部分工作。这就是模板方法（Template Method）设计模式。</p>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144200655.png" alt="image-20210720144200655"></p>
<p>接口Protocol：定义了RPC协议层两个主要的方法，export暴露服务和refer引用服务</p>
<p>抽象类AbstractProtocol：封装了暴露服务之后的Exporter和引用服务之后的Invoker实例，并实现了服务销毁的逻辑</p>
<p>具体实现类XxxProtocol：实现export暴露服务和refer引用服务具体逻辑</p>
<h3 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h3><p>声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）类或者接口。泛型类和接口统称为泛型（generic type）。泛型从Java 5引入，提供了编译时类型安全检测机制。泛型的本质是参数化类型，通过一个参数来表示所操作的数据类型，并且可以限制这个参数的类型范围。泛型的好处就是编译期类型检测，避免类型转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 比较三个值并返回最大值</span><br><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z) &#123;   </span><br><span class="line">  T max &#x3D; x; </span><br><span class="line">  &#x2F;&#x2F; 假设x是初始最大值   </span><br><span class="line">  if ( y.compareTo( max ) &gt; 0 ) &#123;      </span><br><span class="line">    max &#x3D; y; &#x2F;&#x2F;y 更大  </span><br><span class="line">  &#125;   if ( z.compareTo( max ) &gt; 0 ) &#123;     </span><br><span class="line">    max &#x3D; z; &#x2F;&#x2F; 现在 z 更大              </span><br><span class="line">  &#125;   return max; &#x2F;&#x2F; 返回最大对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main( String args[] ) &#123;   </span><br><span class="line">  System.out.printf( &quot;%d, %d 和 %d 中最大的数为 %d\n\n&quot;,  3, 4, 5, maximum( 3, 4, 5 ));   </span><br><span class="line">  System.out.printf( &quot;%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n&quot;,  6.6, 8.8, 7.7,  maximum( 6.6, 8.8, 7.7 ));   </span><br><span class="line">  System.out.printf( &quot;%s, %s 和 %s 中最大的数为 %s\n&quot;,&quot;pear&quot;, &quot;apple&quot;, &quot;orange&quot;, maximum( &quot;pear&quot;, &quot;apple&quot;, &quot;orange&quot; ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要使用原生态类型"><a href="#不要使用原生态类型" class="headerlink" title="不要使用原生态类型"></a>不要使用原生态类型</h4><p>由于为了保持Java代码的兼容性，支持和原生态类型转换，并使用擦除机制实现的泛型。但是使用原生态类型就会失去泛型的优势，会受到编译器警告。</p>
<h4 id="要尽可能地消除每一个非受检警告"><a href="#要尽可能地消除每一个非受检警告" class="headerlink" title="要尽可能地消除每一个非受检警告"></a>要尽可能地消除每一个非受检警告</h4><p>每一条警告都表示可能在运行时抛出ClassCastException异常。要尽最大的努力去消除这些警告。如果无法消除但是可以证明引起警告的代码是安全的，就可以在尽可能小的范围中，使用＠SuppressWarnings(“unchecked”)注解来禁止警告，但是要把禁止的原因记录下来。</p>
<h4 id="利用有限制通配符来提升API的灵活性"><a href="#利用有限制通配符来提升API的灵活性" class="headerlink" title="利用有限制通配符来提升API的灵活性"></a>利用有限制通配符来提升API的灵活性</h4><p>参数化类型不支持协变的，即对于任何两个不同的类型Type1和Type2而言，List既不是List的子类型，也不是它的超类。为了解决这个问题，提高灵活性，Java提供了一种特殊的参数化类型，称作有限制的通配符类型，即List&lt;? extends E&gt;和List&lt;? super E&gt;。使用原则是producer-extends，consumer-super（PECS）。如果即是生产者，又是消费者，就没有必要使用通配符了。</p>
<p>还有一种特殊的无限制通配符List&lt;?&gt;，表示某种类型但不确定。常用作泛型的引用，不可向其添加除Null以外的任何对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;List&lt;? extends E&gt;</span><br><span class="line">&#x2F;&#x2F; Number 可以认为 是Number 的 &quot;子类&quot;</span><br><span class="line">List&lt;? extends Number&gt; numberArray &#x3D; new ArrayList&lt;Number&gt;(); </span><br><span class="line">&#x2F;&#x2F; Integer 是 Number 的子类</span><br><span class="line">List&lt;? extends Number&gt; numberArray &#x3D; new ArrayList&lt;Integer&gt;(); </span><br><span class="line">&#x2F;&#x2F; Double 是 Number 的子类</span><br><span class="line">List&lt;? extends Number&gt; numberArray &#x3D; new ArrayList&lt;Double&gt;();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;List&lt;? super E&gt;</span><br><span class="line">&#x2F;&#x2F; Integer 可以认为是 Integer 的 &quot;父类&quot;</span><br><span class="line">List&lt;? super Integer&gt; array &#x3D; new ArrayList&lt;Integer&gt;();、</span><br><span class="line">&#x2F;&#x2F; Number 是 Integer 的 父类</span><br><span class="line">List&lt;? super Integer&gt; array &#x3D; new ArrayList&lt;Number&gt;();</span><br><span class="line">&#x2F;&#x2F; Object 是 Integer 的 父类</span><br><span class="line">List&lt;? super Integer&gt; array &#x3D; new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;    </span><br><span class="line">  int srcSize &#x3D; src.size();    </span><br><span class="line">  if (srcSize &gt; dest.size())        </span><br><span class="line">   throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);    </span><br><span class="line">  if (srcSize &lt; COPY_THRESHOLD || (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) &#123;        </span><br><span class="line">    for (int i&#x3D;0; i&lt;srcSize; i++)            </span><br><span class="line">    dest.set(i, src.get(i));    </span><br><span class="line">  &#125; else &#123;        </span><br><span class="line">    ListIterator&lt;? super T&gt; di&#x3D;dest.listIterator();        </span><br><span class="line">    ListIterator&lt;? extends T&gt; si&#x3D;src.listIterator();        </span><br><span class="line">    for (int i&#x3D;0; i&lt;srcSize; i++) &#123;            </span><br><span class="line">      di.next();            </span><br><span class="line">      di.set(si.next());        </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员类优于非静态成员类"><a href="#静态成员类优于非静态成员类" class="headerlink" title="静态成员类优于非静态成员类"></a>静态成员类优于非静态成员类</h3><p>嵌套类（nested class）是指定义在另一个类的内部的类。<strong>嵌套类存在的目的只是为了它的外部类提供服务，如果其他的环境也会用到的话，应该成为一个顶层类（top-level class）。</strong> 嵌套类有四种：静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名类（anonymous class）和 局部类（local class）。除了第一种之外，其他三种都称为内部类（inner class）。</p>
<h4 id="匿名类（anonymous-class）"><a href="#匿名类（anonymous-class）" class="headerlink" title="匿名类（anonymous class）"></a>匿名类（anonymous class）</h4><p>没有名字，声明的同时进行实例化，只能使用一次。当出现在非静态的环境中，会持有外部类实例的引用。通常用于创建函数对象和过程对象，不过现在会优先考虑lambda。</p>
<h4 id="局部类（local-class）"><a href="#局部类（local-class）" class="headerlink" title="局部类（local class）"></a>局部类（local class）</h4><p>任何可以声明局部变量的地方都可以声明局部类，同时遵循同样的作用域规则。跟匿名类不同的是，有名字可以重复使用。不过实际很少使用局部类。</p>
<h4 id="静态成员类（static-member-class）"><a href="#静态成员类（static-member-class）" class="headerlink" title="静态成员类（static member class）"></a>静态成员类（static member class）</h4><p>最简单的一种嵌套类，声明在另一个类的内部，是这个类的静态成员，遵循同样的可访问性规则。常见的用法是作为公有的辅助类，只有与它的外部类一起使用才有意义。</p>
<h4 id="非静态成员类（nonstatic-member-class）"><a href="#非静态成员类（nonstatic-member-class）" class="headerlink" title="非静态成员类（nonstatic member class）"></a>非静态成员类（nonstatic member class）</h4><p>尽管语法上，跟静态成员类的唯一区别就是类的声明不包含static，但两者有很大的不同。非静态成员类的每个实例都隐含地与外部类的实例相关联，可以访问外部类的成员属性和方法。另外必须先创建外部类的实例之后才能创建非静态成员类的实例。</p>
<p>总而言之，这四种嵌套类都有自己的用途。假设这个嵌套类属于一个方法的内部，如果只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类。如果一个嵌套类需要在单个方法之外仍然可见，或者它太长了，不适合放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的，否则就做成静态的。</p>
<h3 id="优先使用模板-工具类"><a href="#优先使用模板-工具类" class="headerlink" title="优先使用模板/工具类"></a>优先使用模板/工具类</h3><p>通过对常见场景的代码逻辑进行抽象封装，形成相应的模板工具类，可以大大减少重复代码，专注于业务逻辑，提高代码质量。</p>
<h3 id="分离对象的创建与使用"><a href="#分离对象的创建与使用" class="headerlink" title="分离对象的创建与使用"></a>分离对象的创建与使用</h3><p>面向对象编程相对于面向过程，多了实例化这一步，而对象的创建必须要指定具体类型。我们常见的做法是“哪里用到，就在哪里创建”，使用实例和创建实例的是同一段代码。这似乎使代码更具有可读性，但是某些情况下造成了不必要的耦合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class BusinessObject &#123;</span><br><span class="line"> public void actionMethond &#123;</span><br><span class="line">     &#x2F;&#x2F;Other things</span><br><span class="line">     Service myServiceObj &#x3D; new Service();</span><br><span class="line">       myServiceObj.doService();</span><br><span class="line">       &#x2F;&#x2F;Other things</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BusinessObject &#123;</span><br><span class="line"> public void actionMethond &#123;</span><br><span class="line">     &#x2F;&#x2F;Other things</span><br><span class="line">     Service myServiceObj &#x3D; new ServiceImpl();</span><br><span class="line">       myServiceObj.doService();</span><br><span class="line">       &#x2F;&#x2F;Other things</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BusinessObject &#123;</span><br><span class="line">   private Service myServiceObj;</span><br><span class="line">   public BusinessObject(Service aService) &#123;</span><br><span class="line">       myServiceObj &#x3D; aService;</span><br><span class="line">    &#125;</span><br><span class="line"> public void actionMethond &#123;</span><br><span class="line">     &#x2F;&#x2F;Other things</span><br><span class="line">       myServiceObj.doService();</span><br><span class="line">       &#x2F;&#x2F;Other things</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BusinessObject &#123;</span><br><span class="line">   private Service myServiceObj;</span><br><span class="line">   public BusinessObject() &#123;</span><br><span class="line">       myServiceObj &#x3D; ServiceFactory;</span><br><span class="line">    &#125;</span><br><span class="line"> public void actionMethond &#123;</span><br><span class="line">     &#x2F;&#x2F;Other things</span><br><span class="line">       myServiceObj.doService();</span><br><span class="line">       &#x2F;&#x2F;Other things</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的创建者耦合的是对象的具体类型，而对象的使用者耦合的是对象的接口。也就是说，创建者关心的是这个对象是什么，而使用者关心的是它能干什么。这两者应该视为独立的考量，它们往往会因为不同的原因而改变。</p>
</blockquote>
<p>当对象的类型涉及多态、对象创建复杂（依赖较多）可以考虑将对象的创建过程分离出来，使得使用者不用关注对象的创建细节。设计模式中创建型模式的出发点就是如此，实际项目中可以使用工厂模式、构建器、依赖注入的方式。</p>
<h3 id="可访问性最小化"><a href="#可访问性最小化" class="headerlink" title="可访问性最小化"></a>可访问性最小化</h3><p>区分一个组件设计得好不好，一个很重要的因素在于，它对于外部组件而言，是否隐藏了其内部数据和实现细节。Java提供了访问控制机制来决定类、接口和成员的可访问性。实体的可访问性由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符（private、protected、public）共同决定的。</p>
<p>对于顶层的（非嵌套的）类和接口，只有两种的访问级别：包级私有的（没有public修饰）和公有的（public修饰）。</p>
<p>对于成员（实例/域、方法、嵌套类和嵌套接口）由四种的访问级别，可访问性如下递增：</p>
<ul>
<li>私有的（private修饰）–只有在声明该成员的顶层类内部才可以访问这个成员；</li>
<li>包级私有的（默认）–声明该成员的包内部的任何类都可以访问这个成员；</li>
<li>受保护的（protected修饰）–声明该成员的类的子类可以访问这个成员，并且声明该成员的包内部的任何类也可以访问这个成员；</li>
<li>公有的（public修饰）–在任何地方都可以访问该成员；</li>
</ul>
<p>正确地使用这些修饰符对于实现信息隐藏是非常关键的，原则就是：尽可能地使每个类和成员不被外界访问（私有或包级私有）。这样好处就是在以后的发行版本中，可以对它进行修改、替换或者删除，而无须担心会影响现有的客户端程序。</p>
<ul>
<li>如果类或接口能够做成包级私有的，它就应该被做成包级私有的；</li>
<li>如果一个包级私有的顶层类或接口只是在某一个类的内部被用到，就应该考虑使它成为那个类的私有嵌套类；</li>
<li>公有类不应直接暴露实例域，应该提供相应的方法以保留将来改变该类的内部表示法的灵活性；</li>
<li>当确定了类的公有API之后，应该把其他的成员都变成私有的；</li>
<li>如果同一个包下的类之间存在比较多的访问时，就要考虑重新设计以减少这种耦合；</li>
</ul>
<h3 id="可变性最小化"><a href="#可变性最小化" class="headerlink" title="可变性最小化"></a>可变性最小化</h3><p>不可变类是指其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例时提供，并在对象的整个生命周期内固定不变。不可变类好处就是简单易用、线程安全、可自由共享而不容易出错。Java平台类库中包含许多不可变的类，比如String、基本类型包装类、BigDecimal等。</p>
<p><strong>为了使类成为不可变，要遵循下面五条规则：</strong></p>
<ul>
<li><p>声明所有的域都是私有的</p>
</li>
<li><p>声明所有的域都是final的</p>
</li>
<li><ul>
<li><em>如果一个指向新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必须确保正确的行为</em></li>
</ul>
</li>
<li><p>不提供任何会修改对象状态的方法</p>
</li>
<li><p>保证类不会被扩展（防止子类化，类声明为final）</p>
</li>
<li><ul>
<li><em>防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为</em></li>
</ul>
</li>
<li><p>确保对任何可变组件的互斥访问</p>
</li>
<li><ul>
<li><em>如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象引用。在构造器、访问方法和readObject 方法中使用保护性拷贝技术</em></li>
</ul>
</li>
</ul>
<p><strong>可变性最小化的一些建议：</strong></p>
<ul>
<li>除非有很好的理由要让类成为可变的类，否则它就应该是不可变的；</li>
<li>如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性；</li>
<li>除非有令人信服的理由要使域变成非final的，否则要使每个域都是private final的；</li>
<li>构造器应该创建完全初始化的对象，并建立起所有的约束关系；</li>
</ul>
<h1 id="质量如何保证"><a href="#质量如何保证" class="headerlink" title="质量如何保证"></a>质量如何保证</h1><h2 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h2><blockquote>
<p>测试驱动开发（TDD）要求以测试作为开发过程的中心，要求在编写任何代码之前，首先编写用于产码行为的测试，而编写的代码又要以使测试通过为目标。TDD要求测试可以完全自动化地运行，并在对代码重构前后必须运行测试。</p>
</blockquote>
<p>TDD的最终目标是整洁可用的代码（clean code that works）。大多数的开发者大部分时间无法得到整洁可用的代码。办法是分而治之。首先解决目标中的“可用”问题，然后再解决“代码的整洁”问题。这与体系结构驱动（architecture-driven）的开发相反。</p>
<p>采用TDD另一个好处就是让我们拥有一套伴随代码产生的详尽的自动化测试集。将来无论出于任何原因（需求、重构、性能改进）需要对代码进行维护时，在这套测试集的驱动下工作，我们代码将会一直是健壮的。</p>
<h2 id="TDD的开发周期"><a href="#TDD的开发周期" class="headerlink" title="TDD的开发周期"></a>TDD的开发周期</h2><p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144601409.png" alt="image-20210720144601409"></p>
<p>添加一个测试 -&gt; 运行所有测试并检查测试结果 -&gt; 编写代码以通过测试 -&gt; 运行所有测试且全部通过 -&gt; 重构代码，以消除重复设计，优化设计结构</p>
<h2 id="两个基本的原则"><a href="#两个基本的原则" class="headerlink" title="两个基本的原则"></a>两个基本的原则</h2><ul>
<li>仅在测试失败时才编写代码并且只编写刚好使测试通过的代码</li>
<li>编写下一个测试之前消除现有的重复设计，优化设计结构</li>
</ul>
<p>关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“整洁”目标，每次只关注一件事！</p>
<h2 id="分层测试点"><a href="#分层测试点" class="headerlink" title="分层测试点"></a>分层测试点</h2><p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144618190.png" alt="image-20210720144618190"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/" data-id="ckvc2kues006t9kwd4xpldc7e" data-title="关于重构" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>