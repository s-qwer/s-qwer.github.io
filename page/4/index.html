<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/4/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-4.22.关于null" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.22.%E5%85%B3%E4%BA%8Enull/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:18:39.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.22.%E5%85%B3%E4%BA%8Enull/">关于null</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>开发原则：只要是对象，我们就要判断对象是否为null。</p>
<p>java空指针异常：java.lang.NullPointException</p>
<h2 id="java中的null"><a href="#java中的null" class="headerlink" title="java中的null"></a><strong>java中的null</strong></h2><p>  null是Java中一个很重要的概念。null设计初衷是为了表示一些缺失的东西，例如缺失的用户、资源或其他东西。但是，一年后，令人头疼的空指针异常给Java程序员带来不少的骚扰。</p>
<p>  null是java中的关键字，因此，它不能写成NULL，Null，只能是null。</p>
<p>  null是所有引用类型的默认值，如果没有让一个引用指向一个实际存在的对象，它的默认值就是null。null本质上是一个值，这跟int的默认值是0，boolean的默认值是false一样。现在，我们通常都使用像eclipse等的集成开发环境进行开发，一般在定义变量的时候都会进行初始化（这也是写代码的一个良好的习惯），如果没有进行初始化，系统会进行提示。</p>
<p><strong>报空指针异常的原因有以下几种：</strong> </p>
<p>1.字符串变量未初始化； </p>
<p>初始化或赋值后则不会报错了<br>2.接口类型的对象没有用具体的类初始化，比如：<br>List it；会报错<br>List it = new ArrayList()；则不会报错了<br>3.当一个对象的值为空时，你没有判断为空的情况。你可以试着把下面的代码前加一行代码：<br>if(rb!=null &amp;&amp; rb!=””)<br>改成：<br>if(rb == null)   或者   if(“”).equals(rb))<br>空指针的解决办法：<br>    重点关注报错发生的所在行，通过空指针异常产生的两条主要原因诊断具体的错误。同时为了避免空指针的发生，最好在做判断处理时将“null”或者空值放于设定的值之前。<br>常见空指针异常的简要分析：<br>（1）空指针错误<br>  Java中的8种基本数据类型，变量的值可以有其默认值，假如没有对其正常赋值，java虚拟机是不能正确编译通过的，因此使用基本的Java数据类型一般是不会引起空指针异常的。实际开发中，大多数的空指针异常主要与对象的操作相关。<br>  下面列出可能发生空指针异常的几种情况及相应解决方案：<br>  代码段1：<br>　　out.println(request.getParameter(“username”));<br>分析：代码段1的功能十分简单，就是输出用户输入”username”的值。<br>说明：看上去，上面的语句找不出什么语法错误，而且在大多数情况下也遇不到什么问题。但是，如果某个用户在输入数据时并没有提供表单 域”username” 的值，或通过某种途径绕过表单直接输入时，此request.getParameter(“username”)的值为空（注意不是空字符串，是空对象 null。），out对象的println方法是无法直接对空对象操作的，因此代码段1所在的JSP页面将会抛出 “Java.lang.NullPointerException”异常。而且即使对象可能为空时，也调用Java.lang.Object或 Object对象本身的一些方法如toString()， equal(Object obj)等操作。<br>  代码段2：<br>　　String userName = request.getParameter(“username”);<br>　　If (userName.equals(“root”))<br>　　{….}<br>分析：代码段2的功能是检测用户提供的用户名，如果是用户名称为”root”的用户时，就执行一些特别的操作。<br>说明：在代码段2中，如果有用户没有提供表单域”username”的值时，字符串对象userName为null值，不能够将一个null的对象与另一 个对象直接比较，同样，代码段2所在的JSP页面就会抛空指针错误。</p>
<p>一个小技巧：如果要把某个方法的返回值与常量做比较，把常量放在前面，可以避免调用null对象的equals方法。譬如：<br>  If (“root”.equals(userName))<br>　 {….}<br>  即使userName对象返回了null对象，这里也不会有空指针异常，可以照常运转。<br>  代码段3：<br>　　String userName = session.getAttribute(“session.username”).toString();<br>分析：代码段3的功能是将session中session.username的值取出，并将该值赋给字符串对象userName。<br>说明：在一般情况下，如果在用户已经进行某个会话，则不会出现什么问题；但是，如果此时应用服务器重新启动，而用户还没有重新登录，（也可能是用户关闭浏 览器，但是仍打开原来的页面。）那么，此时该session的值就会失效，同时导致session中的session.username的值为空。对一个 为 null的对象的直接执行toString()操作，就会导致系统抛出空指针异常。<br>  代码段4：<br>public static void main(String args[]){<br>    Person p=null;<br>    p.setName(“张三”)；<br>    System.out.println(p.getName());<br>}<br>分析：声明一个Person对象，并打印出该对象的中的Name名字。<br>说明：这个时候你的p就出现空指针异常，因为你只是声明了这个Person类型的对象并没有创建对象，所以它的堆里面没有地址引用，切忌你要<strong>用对象调用方法的时候一定要创建对象</strong>。</p>
<p>为了避免空指针调用，我们经常会看到这样的语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...if (someobject !&#x3D; null) &#123;</span><br><span class="line">    someobject.doCalc();&#125;...</span><br></pre></td></tr></table></figure>

<p>最终，项目中会存在大量判空代码，多么丑陋繁冗！如何避免这种情况？我们是否滥用了判空呢？</p>
<p>在方法中返回null，在调用这些方法时，也不得不去判空。另外，也许受此习惯影响，他们总潜意识地认为，所有的返回都是不可信任的，为了保护自己程序，就加了大量的判空</p>
<p>进行判空前，请区分以下两种情况：</p>
<p>1、null 是一个有效有意义的返回值(Where null is a valid response in terms of the contract)</p>
<p>2、null是无效有误的(Where it isn’t a valid response)</p>
<p><strong>先说第2种情况</strong></p>
<p>null就是一个不合理的参数，就应该明确地中断程序，往外抛错误。这种情况常见于api方法。例如你开发了一个接口，id是一个必选的参数，如果调用方没传这个参数给你，当然不行。你要感知到这个情况，告诉调用方“嘿，哥们，你传个null给我做甚”。</p>
<p>相对于判空语句，更好的检查方式有两个</p>
<p>(1)assert语句，你可以把错误原因放到assert的参数中，这样不仅能保护你的程序不往下走，而且还能把错误原因返回给调用方，岂不是一举两得</p>
<p>(2)也可以直接抛出空指针异常。上面说了，此时null是个不合理的参数，有问题就是有问题，就应该大大方方往外抛。</p>
<p><strong>第1种情况会更复杂一些。</strong></p>
<p>这种情况下，null是个”看上去“合理的值，例如，我查询数据库，某个查询条件下，就是没有对应值，此时null算是表达了“空”的概念。</p>
<p>这里给一些实践建议：</p>
<p>1、假如方法的返回类型是collections，当返回结果是空时，你可以返回一个空的collections（empty list),而不要返回null，这样调用侧就能大胆地处理这个返回，例如调用侧拿到返回后，可以直接print list.size()，又无需担心空指针问题。（什么？想调用这个方法时，不记得之前实现该方法有没按照这个原则？所以说，代码习惯很重要！如果你养成习惯，都是这样写代码（<strong>返回空collections而不返回null</strong>)，你调用自己写的方法时，就能大胆地忽略判空）</p>
<p>2、返回类型不是collections，又怎么办呢？</p>
<p>那就<strong>返回一个空对象（而非null对象）</strong>，下面举个“栗子”，假设有如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span> </span>&#123;</span><br><span class="line">  <span class="function">Action <span class="title">findAction</span><span class="params">(String userInput)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Parse有一个接口FindAction，这个接口会依据用户的输入，找到并执行对应的动作。假如用户输入不对，可能就找不到对应的动作（Action），因此findAction就会返回null，接下来action调用doSomething方法时,就会出现空指针。</p>
<p>解决这个问题的一个方式，就是使用Null Object pattern（空对象模式）</p>
<p>我们来改造一下</p>
<p>类定义如下，这样定义findAction方法后，确保无论用户输入什么，都不会返回null对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParser</span> <span class="keyword">implements</span> <span class="title">Parser</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Action DO_NOTHING = <span class="keyword">new</span> Action() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; <span class="comment">/* do nothing */</span> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Action <span class="title">findAction</span><span class="params">(String userInput)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">/* we can&#x27;t find any actions */</span> ) &#123;</span><br><span class="line">      <span class="keyword">return</span> DO_NOTHING;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>对比下面两份调用实例</p>
<p>1、冗余:每获取一个对象，就判一次空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Parser parser = ParserFactory.getParser();</span><br><span class="line"><span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// now what?</span></span><br><span class="line">  <span class="comment">// this would be an example of where null isn&#x27;t (or shouldn&#x27;t be) a valid response</span></span><br><span class="line">&#125;</span><br><span class="line">Action action = parser.findAction(someInput);</span><br><span class="line"><span class="keyword">if</span> (action == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// do nothing</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  action.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、精简</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserFactory.getParser().findAction(someInput).doSomething();</span><br></pre></td></tr></table></figure>

<p>因为无论什么情况，都不会返回空对象，因此通过findAction拿到action后，可以放心地调用action的方法。</p>
<p><strong>其他回答精选：</strong></p>
<p>1、如果要用equal方法，请用object&lt;不可能为空&gt;.equals(object&lt;可能为空&gt;))</p>
<p>例如：</p>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;bar&quot;.equals(foo) </span><br></pre></td></tr></table></figure>

<p>而不是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.equals(&quot;bar&quot;) </span><br></pre></td></tr></table></figure>

<p>2、Java8或者guava lib中，提供了Optional类，这是一个元素容器，通过它来封装对象，可以减少判空。不过代码量还是不少。不爽。</p>
<p>3、如果你想返回null，请挺下来想一想，这个地方是否更应该抛出一个异常</p>
<h3 id="null与””的区别"><a href="#null与””的区别" class="headerlink" title="null与””的区别"></a>null与””的区别</h3><p>null是没有地址<br>“”是有地址但是里面的内容是空的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">问题一：</span><br><span class="line">null和&quot;&quot;的区别</span><br><span class="line">String s&#x3D;null;</span><br><span class="line">string.trim()就会抛出为空的exception   </span><br><span class="line">String s&#x3D;&quot;&quot;;   </span><br><span class="line">string.trim()就不会抛,为什么? </span><br><span class="line">答：</span><br><span class="line">NULL代表声明了一个空对象，根本就不是一个字符串。   </span><br><span class="line">&quot;&quot;代表声明了一个对象实例，这个对象实例的值是一个长度为0的空字符串。</span><br><span class="line"></span><br><span class="line">NULL代表声明了一个空对象,对空对象做任何操作都不行的,除了&#x3D;和&#x3D;&#x3D;   </span><br><span class="line">&quot;&quot;是一个字符串了,只是这个字符串里面没有内容了</span><br><span class="line"></span><br><span class="line">String s&#x3D;null;只是定义了一个句柄，也就是说你有了个引用，但是这个引用未指向任何内存空间   </span><br><span class="line">String s&#x3D;&quot;&quot;;这个引用已经指向了一块是空字符串的内存空间，是一个实际的东东了，所以你可以对它操作，而不用担心什么了</span><br><span class="line"></span><br><span class="line">你说数字0和没有是不是一种概念啊？？道理一样的</span><br><span class="line"></span><br><span class="line">而且,null可以赋值给任何对象.&quot;&quot;就不行了.</span><br><span class="line"></span><br><span class="line">这里&quot;&quot;和NULL绝对是两个概念   </span><br><span class="line">&quot;&quot;代表一个字符串存在，它的值就是“”   </span><br><span class="line">NULL代表字符串根本没有实际的值，你并不知道它是什么。。。</span><br><span class="line"></span><br><span class="line">哦,我明白了,意思就是String   string   &#x3D;   null   跟String   string;是一回事儿</span><br><span class="line"></span><br><span class="line">null是空对象     &quot;&quot;是空字符串</span><br><span class="line">String s&#x3D;null;&#x2F;&#x2F;null是未分配堆内存空间   </span><br><span class="line">String   a;&#x2F;&#x2F;分配了一个内存空间,没存入任何对象   </span><br><span class="line">String   a&#x3D;&quot;&quot;;&#x2F;&#x2F;分配了一个内存空间,存了一个字符串对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题二：</span><br><span class="line">String s;和String s&#x3D;null;和String s&#x3D;&quot;a&quot;;有什么区别？   </span><br><span class="line">针对这三种情况，使用out.println(s);的时候，第一个会出现异常，第二个会输出null.第三个则会输出a.   </span><br><span class="line">这是为什么呢？这三句声明语句，各自作了什么呢？</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">第一个只是定义了一个String类型变量s，并没有给它赋初值，在Java中，默认在使用一个变量的时候必须赋予它初值（降低风险）。 </span><br><span class="line">第二个和第三个都定义了String类型变量s，并赋予它初值，只不过第二个赋予的值为null（空）罢了</span><br><span class="line"></span><br><span class="line">主要要理解的是String s; s为一个引用～～它不是对象   </span><br><span class="line">第一个是没有初始化的引用；   </span><br><span class="line">第二个为空引用；</span><br><span class="line">第三个是在字符串池里写入一个字符&#39;a&#39;,然后用s指向它。</span><br><span class="line">另外，   </span><br><span class="line">String s&#x3D;&quot;a&quot;和String s&#x3D;new String(&quot;a&quot;);是有本质上的区别的   </span><br><span class="line">前者是在字符串池里写入一个字符&#39;a&#39;,然后用s指向它；</span><br><span class="line">后者是在堆上创建一个内容为&quot;a&quot;的字符串对象。</span><br><span class="line">String   str&#x3D;&quot;aaa&quot;;                    &#x2F;&#x2F;于栈上分配内存</span><br><span class="line">String   str&#x3D;new   String(&quot;aaa&quot;);      &#x2F;&#x2F;于堆上分配内存</span><br><span class="line"></span><br><span class="line">String s; 系统会自动赋值null</span><br><span class="line"></span><br><span class="line">String s;只是给s分配一个内存空间   </span><br><span class="line">String s&#x3D;null;是分配的空间中存储的值为空值   </span><br><span class="line">String s&#x3D;&quot;a&quot;;是分配的空间的值为字符a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题三：</span><br><span class="line">声明了一个string a;变量    </span><br><span class="line">在以后的判断中，a&#x3D;&#x3D;&quot;&quot;和a&#x3D;&#x3D;null有何不同?   </span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">如果没有给a赋过值，a&#x3D;&#x3D;&quot;&quot;会导致异常。     </span><br><span class="line">在实际处理时，往往认为&quot;&quot;和null代表相同的含义，即都代表无值。   </span><br><span class="line">此时建议用如下语法：   </span><br><span class="line">if(a&#x3D;&#x3D;null   ||   a&#x3D;&#x3D;&quot;&quot;)   </span><br><span class="line">&#123;   </span><br><span class="line">&#125;   </span><br><span class="line">如果a为null，就不会执行后面的判断，直接返回true。   </span><br><span class="line"></span><br><span class="line">null是用来判断引用类型是否分配了存储空间   </span><br><span class="line">&quot;&quot;是针对字符串的；   </span><br><span class="line">string类型实际上是字符串指针，也即是一个引用类型   </span><br><span class="line">所以如果没有给a赋过值，a&#x3D;&#x3D;&quot;&quot;会导致异常   </span><br><span class="line">所以if(a&#x3D;&#x3D;null   ||   a&#x3D;&#x3D;&quot;&quot;)&#123;&#125;这种写法也是正确的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题四：</span><br><span class="line">String abc&#x3D;null;String abc&#x3D;&quot;&quot;;String abc;三种写法有什么区别？ </span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">1：创建一个空字符串对象，   </span><br><span class="line">2：创建一个字符串为空的字符串对象。   </span><br><span class="line">3：声明一个字符串对象，但并没有分配内存，而1，2已经分配了内存   </span><br><span class="line">对于最后一种表示,你不能if(abc&#x3D;&#x3D;null),或者int   length   &#x3D;   abc.length();编译的时候会提示可能没有初始化.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String   abc&#x3D;null;   </span><br><span class="line">String   abc&#x3D;&quot;&quot;;   </span><br><span class="line">一般推荐使用第二种   </span><br><span class="line">第一种abc指向null，很多时候要判断字符串是否为空时，容易漏掉这种情况，在调用String的相关方法的时候就会出错   </span><br><span class="line">第二种则相对简单，String的方法都可以用，判断的时候也不会出错</span><br><span class="line"></span><br><span class="line">1) String   abc&#x3D;null;   </span><br><span class="line">2) String   abc;    </span><br><span class="line">3）String   a&#x3D;&quot;&quot;;   </span><br><span class="line">4) String   b&#x3D;&quot;&quot;;   </span><br><span class="line">5) String   c&#x3D;new String(&quot;&quot;);   </span><br><span class="line">6) String   d&#x3D;new String(&quot;&quot;); </span><br><span class="line">&#x2F;&#x2F;1)等于2），和C语言不同，JAVA为安全原因不允许一个悬挂引用，没有赋值的引用地址一律自动赋值为NULL，以防止访问到任意内存   </span><br><span class="line">&#x2F;&#x2F;3)和4)中,变量a和b将会指向同一内存地址(&quot;&quot;的地址)   </span><br><span class="line">&#x2F;&#x2F;5)和6)中，变量c和d不会指向同一地址,而是两个&quot;&quot;内容的地址,并且和a,b不同,实际上,3)和4)相当于new String(&quot;&quot;).intern().   </span><br><span class="line">&#x2F;&#x2F;String类维护着一个字符串池,对于像3)和4)这样的赋值方法,String会在这个池中查找字符串是否已经在池中,如果在,就直接指向该地址,</span><br><span class="line"></span><br><span class="line">如果不在,生成一个实例放入池中再指向那个地址,可见对于同样内容的字符串多次引用时3)4)的方法要比5)6)的方法剩内存,之所以这样做,是</span><br><span class="line"></span><br><span class="line">因为String是一个内容不可变的量,运用的是设计模式GOF.FlyWeight   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但有个关键的一点,没有人说到，这就是:   </span><br><span class="line">String s;在什么情况下可以等同于String s&#x3D;null;而在什么情况下又不等同？！</span><br><span class="line">考虑下面的代码:   </span><br><span class="line">&#x2F;&#x2F;StringTest.java   </span><br><span class="line">public   class   StringTest   &#123;      </span><br><span class="line">    static   String   s;     &#x2F;&#x2F;*   </span><br><span class="line">    public   static   void   main(String[]   args)   &#123;   </span><br><span class="line">        &#x2F;&#x2F;String   s;         &#x2F;&#x2F;**   </span><br><span class="line">        System.out.println(s);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;     </span><br><span class="line">编译并运行上面的代码,将打印null。</span><br><span class="line">可见标有*号的行是自动初始化了的(s被自动初始化为null)。   </span><br><span class="line">而如果把标有**号的行取消注释,代码将不能通过编译,这是因为这行定义的是本地变量,而本地变量是不会自动初始化的。</span><br><span class="line">由此得出结论：</span><br><span class="line">在成员变量的定义中,String s;等同于String s&#x3D;null;</span><br><span class="line">而在本地变量(方法变量)的定义中,String s;不等同于String s&#x3D;null;,这时要使用s必须显式地赋值。</span><br><span class="line">这些虽然是小知识点,但在实际应用中很重要,也很容易被一些人忽视,特此提出。</span><br><span class="line">还有一点要说明的是：</span><br><span class="line">只要是在方法在中定义变量都要显示赋初值，main()方法也不例外，而在方法之外编译器回自动赋初值</span><br></pre></td></tr></table></figure>



<p>spring的判空</p>
<p>Spring-core中提供了大量的工具类，常用的有StringUtils、ObjectUtils、NumberUtils、Base64Utils等，Spring工具类在spring-core.jar中的org.springframework.util包下。</p>
<p>1.isEmpty 没有忽略空格参数，是以是否为空和是否存在为判断依据。<br>2.isBlank 是在 isEmpty 的基础上进行了为空（字符串都为空格、制表符、tab 的情况）的判断。（一般更为常用）</p>
<p>这里推荐使用isBlank方法，因为可能会存在“     ”的情况，当这种情况下，需要根据自己的业务判断是不是为null的情况，避免出现错误，影响业务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.isEmpty(<span class="string">&quot;yyy&quot;</span>) = <span class="keyword">false</span></span><br><span class="line">StringUtils.isEmpty(<span class="string">&quot;&quot;</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.isEmpty(<span class="string">&quot;   &quot;</span>) = <span class="keyword">false</span></span><br><span class="line"> </span><br><span class="line">StringUtils.isBlank(<span class="string">&quot;yyy&quot;</span>) = <span class="keyword">false</span></span><br><span class="line">StringUtils.isBlank(<span class="string">&quot;&quot;</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.isBlank(<span class="string">&quot;   &quot;</span>) = <span class="keyword">true</span></span><br></pre></td></tr></table></figure>



<p>null只有=和==方法可以使用，如果使用其他方法会报空指针异常的错误。</p>
<p>总结：</p>
<p>1.null==判断的对象：只判断null的情况</p>
<p>2.StringUtils.isEmpty(判断的对象)：判断null和””的情况</p>
<p>3.StringUtils.isBlank(判断的对象)：判断null和””和”     “的情况</p>
<p>判空方法：</p>
<p>1.字符串与已知值进行比较，已知值放在前面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">123</span>”.equals(value)</span><br></pre></td></tr></table></figure>

<p>2.两个字符串比较，不确定是否有空值，使用Object.equals() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> r = Objects.equals(a,b);</span><br></pre></td></tr></table></figure>

<p>3.使用 java8 中的 Optional 类代替显示判空：Java 8中，每当一个函数需要返回 null，应该返回 Optional</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(<span class="keyword">null</span>).orElse(<span class="string">&quot;0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>首先，创建第二个getter返回 Optional：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Optional getMemberCardOpt() &#123;   return Optional.ofNullable(memberCard); &#125; </span><br></pre></td></tr></table></figure>

<p>其次，更改原始的getter以委托给新的getter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String getMemberCard() &#123;   return getMemberCardOpt().orElse(null); &#125;</span><br></pre></td></tr></table></figure>









<ol>
<li>经典 if 判断</li>
<li>使用Java 8的检查 java.util.Objects -在当今开发中的项目中使用最广泛</li>
<li>Lombok @NonNull 导致将 if 检查添加到生成的字节码中。</li>
<li>assert关键字：我个人不喜欢它，因为可以通过JVM参数全局禁用断言</li>
</ol>
<p>写业务代码的时候，通常会遇到数据库POJO对象转换为前端需要的VO对象，这时经常会遇到烦人的空指针问题，Java 8之前，我们可能这么写：</p>
<p>对于对象field复制风格:<br>a.setCreateTime(b.getCreateTime().getTime());<br>a.setAmount(b.getPayed()+b.getVoucher());<br>1<br>2<br>对于装饰器风格：<br>public Long getCreateTime() {<br>    return b.getCreateTime().getTime();<br>}<br>public Long getAmount() {<br>    return b.getPayed()+b.getVoucher()<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>很明显，这些代码会有空指针异常的风险.一般我们会这么修改：</p>
<p>对于对象field复制风格:<br>if (b.getCreateTime()!= null) {<br>    a.setCreateTime(b.getCreateTime().getTime());<br>}<br>if (b.getPayed() != null) {<br>    a.setAmount(b.getPayed();<br>} else {<br>    a.setAmount(0L);<br>}<br>if (b.getVoucher() != null) {<br>a.setAmount(a.getAmount()+b.getVoucher());<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>对于装饰器风格：<br>public Long getCreateTime() {<br>    if (b.getCreateTime()!= null) {<br>        return b.getCreateTime().getTime();<br>    } else {<br>        return null;<br>    }<br>}<br>public Long getAmount() {<br>    Long result = 0L;<br>    if (b.getPayed() != null) {<br>        result += b.getPayed();<br>    }<br>    if (b.getVoucher() != null) {<br>        result += b.getVoucher();<br>    }<br>    return result;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>Java8引入的Optional写法：</p>
<p>对于对象field复制风格:<br>Optional.ofNullable(b.getCreateTime()).ifPresent(timestamp -&gt; a.setCreateTime(timestamp.getTime()));<br>a.setAmount(Optional.ofNullable(b.getPayed()).orElse(0L) + Optional.ofNullable(b.getVoucher()).orElse(0L));<br>1<br>2<br>对于装饰器风格：<br>public Long getCreateTime() {<br>    Optional<Timestamp> createTime = Optional.ofNullable(b.getCreateTime());<br>    if (createTime.isPresent()) {<br>        return createTime.get();<br>    } else {<br>        return null;<br>    }<br>}<br>public Long getAmount() {<br>    return Optional.ofNullable(b.getPayed()).orElse(0L) + Optional.ofNullable(b.getVoucher()).orElse(0L)<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>这样依然很复杂，尤其是嵌套多层之后。<br>更进一步，有没有通用简便的方法呢？联想到Java8的Functional Interface以及我们需要处理的异常只有空指针异常，可以写工具类：</p>
<p>import java.util.function.Supplier;</p>
<p>public class OptionalUtil {<br>    /**<br>     * 忽略NullPointerException的获取<br>     * @param supplier<br>     * @param <T><br>     * @return 如果有空指针，返回null<br>     */<br>    public static <T> T orNull(Supplier<T> supplier) {<br>        try {<br>            return supplier.get();<br>        } catch (NullPointerException e) {<br>            return null;<br>        }<br>    }</p>
<p>   /**<br>     * 忽略NullPointerException的获取<br>     *<br>     * @param supplier<br>     * @param or<br>     * @param <T><br>     * @return 如果有空指针，返回or<br>     */<br>    public static <T> T or(Supplier<T> supplier, T or) {<br>        try {<br>            T t = supplier.get();<br>            if (t != null) {<br>                return t;<br>            }<br>            return or;<br>        } catch (NullPointerException e) {<br>            return or;<br>        }<br>    }<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>这样，我们的代码就变得简洁多了：</p>
<p>对于对象field复制风格:<br>a.setCreateTime(OptionalUtil.orNull(() -&gt; b.getCreateTime().getTime()));<br>a.setAmount(OptionalUtil.or(() -&gt; b.getPayed(), 0L) + OptionalUtil.or(() -&gt; b.getAmount(), 0L));<br>1<br>2<br>对于装饰器风格：<br>public Long getCreateTime() {<br>    return OptionalUtil.orNull(() -&gt; b.getCreateTime().getTime());<br>}<br>public Long getAmount() {<br>    return OptionalUtil.or(() -&gt; b.getPayed(), 0L) + OptionalUtil.or(() -&gt; b.getAmount(), 0L);<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.22.%E5%85%B3%E4%BA%8Enull/" data-id="ckqk8k3eb004k2wwdfhvn6gug" data-title="关于null" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.20.JDBC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.20.JDBC/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:18:28.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.20.JDBC/">JDBC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>jdbc（Java数据库连接）是一种用于执行<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=12370852&ss_c=ssc.citiao.link">SQL语句</a>的Java API，由一组用Java语言编写的类和接口组成。</p>
<p>驱动：两个设备（应用）之间通信的桥梁。</p>
<p>SUN公司提供一套统一的规范（接口）。然后各个数据库生产商提供这套接口的实现。这套接口规范就是JDBC的规范。</p>
<p>JDBC的环境准备：</p>
<p>\1. 创建数据库和表</p>
<p>\2. 创建项目，引入jar包</p>
<p>JDBC的开发步骤：</p>
<p>1.加载驱动：Class.forname</p>
<p>2.获得连接：DriverManager</p>
<p>\3. 基本操作：执行SQL：</p>
<p>获得执行SQL语句的对象：createStatement()方法，返回值是Statement</p>
<p>编写SQL语句：String sql = “select * from user”;</p>
<p>执行SQL：executeQuery(sql)方法，返回值是ResultSet</p>
<p>遍历该set集合</p>
<p>\4. 释放资源：集合、执行SQL语句的对象、获得的连接都要释放资源</p>
<p>DriverManager：驱动管理类</p>
<p>作用：1.注册驱动：DriverManager.registerDriver(Driver driver);</p>
<p>这个方法可以完成驱动的注册，但是实际开发中一般不会使用这个方法完成驱动的注册，而是使用Class.forname(“com.mysql.jdbc.Driver”);</p>
<p>因为如果需要注册驱动，就会使用DriverManager.registerDriver(new Driver());，但是查看Driver源代码发现，在代码中有一段静态代码块，静态代码块已经调用了注册驱动的方法，如果再手动调用该方法注册驱动，就会导致驱动被注册两次</p>
<p>2.获得连接：DriverManager.getConnection(String url, String username, String password);</p>
<p>url：与数据库连接的路径</p>
<p>user    ：与数据库连接的用户名</p>
<p>password：与数据库连接的密码</p>
<p>url的写法：jdbc:mysql://localhost:3306/web_test3</p>
<p>jdbc    :连接数据库的协议</p>
<p>mysql:是jdbc的子协议</p>
<p>localhost:连接的MySQL数据库服务器的主机地址。（连接是本机就可以写成localhost），如果连接不是本机的，就需要写上连接主机的IP地址。</p>
<p>3306:MySQL数据库服务器的端口号</p>
<p>web_test3:数据库名称</p>
<p>url如果连接的是本机的路径，可以简化为：jdbc:mysql:///web_test3</p>
<p>Connection：与数据库连接对象</p>
<p>作用：1.创建执行SQL语句的对象：</p>
<p>Statement:执行SQL Statement createStatement()</p>
<p>CallableStatement:执行数据库中存储过程 CallableStatement prepareCall(String sql)</p>
<p>PreparedStatement:（主要用这个）执行SQL.对SQL进行预处理。解决SQL注入漏洞 PreparedStatement preparedStatement (String sql)</p>
<p>\2. 管理事务</p>
<p>void setAutoCommit(boolean autoCommit):将此连接的自动提交模式改为给定状态</p>
<p>void commit():将所有上一次提交/回滚后进行的更改变为永久性更改，并释放此Connection对象当前持有的所有数据库锁</p>
<p>void rollback():取消在当前事务中进行的所有更改，并释放此Connection对象当前持有的所有数据库锁</p>
<p>Statement：执行SQL</p>
<p>作用：1.执行SQL</p>
<p>boolean execute(String sql); 执行查询，修改，添加，删除的SQL语句 （如果第一个结果为ResultSet对象，则返回true；如果是更新计数或者不存在任何结果，返回false）</p>
<p>ResultSet executeQuery(String sql); 执行查询（执行select语句）</p>
<p>int executeUpate(String sql);执行修改，添加，删除的SQL语句 （SQL DDL语句也可以）（返回的是影响的行数）</p>
<p>2.执行批处理</p>
<p>void addBatch(String sql)  将给定的sql命令添加到此Statement对象的当前命令列表中</p>
<p>void clearBatch()  清空此Statement对象的当前SQL命令列表</p>
<p>int[] executeBatch()  将一批命令交给数据库来执行，如果全部命令执行成功，则返回更新计数组成的数组</p>
<p>ResultSet：结果集，通过select语句的查询结果（只有select语句才有结果集）</p>
<p>结果集的遍历：</p>
<p>boolean next（）；  将光标从当前位置向下移一行（刚开始是在第一行之前的空白，调用了该方法之后会移动到第一行）</p>
<p>结果集的获取：</p>
<p>结果集获取可以使用结果集中的: getXXX(); 方法通常都会有一个重载的方法（int、long、String，Object就比较通用）</p>
<p>传递的参数可以是列号也可以是列名：</p>
<p>getXXX(int columnIndex);</p>
<p>getXXX(String columnName); （一般传的参数是列名，因为查询的话，有可能结果的列号不一样）</p>
<p>资源释放：</p>
<p>JDBC程序执行结束后，将与数据库进行交互的对象释放掉，通常是ResultSet,Statement,Connection</p>
<p>这几个对象中尤其是Connection对象是非常稀有的。这个对象一定要做到尽量晚创建，尽早释放掉。</p>
<p>将资源释放的代码写入到finally的代码块中，确保资源会释放。但是资源释放的时候仍可能出现异常，所以资源释放的代码应该写的标准：再用trycatch语句进行判空，判完之后要将对象赋值为null：因为可以让垃圾回收器尽快的将资源回收。</p>
<p>JDBC的CRUD操作：</p>
<p>添加、删除、修改操作：</p>
<p>\1. 创建Connection和Statement并赋值为null</p>
<p>\2. try语句中进行：注册驱动，获得连接，创建执行SQL语句对象，编写相应的SQL语句，执行SQL（excuteUpdate(sql)方法），对返回值进行判断。</p>
<p>\3. 释放资源（判空，抛异常，赋值为null）</p>
<p>查询操作：查询多条记录和查询一条记录</p>
<p>1.创建Connection和Statement和ResultSet并赋值为null</p>
<p>2.try语句中进行：注册驱动，获得连接，创建执行SQL语句对象，编写相应的SQL语句，执行SQL（excuteQuery（sql）方法）。多条语句进行遍历while，一条语句进行判断if，并输出</p>
<p>3.释放资源（判空，抛异常，赋值为null）</p>
<p>JDBC的工具类的抽取：因为注册驱动，获得连接，释放资源的代码都是相同的，所以可以抽取成一个工具类。</p>
<p>/**</p>
<p> * JDBC的工具类</p>
<p> * <em><strong>*@author*</strong></em> swx</p>
<p> */</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JDBCUtils {</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>driverClassName*</em>***;</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>url*</em>***;</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>username*</em>***;</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>password*</em>***;</p>
<p>​    <em><strong>*static*</strong></em>{</p>
<p>​        ****<em>driverClassName*</em>***=”com.mysql.jdbc.Driver”;</p>
<p>​        ****<em>url*</em>***=”jdbc:mysql:///web_test3”;</p>
<p>​        ****<em>username*</em>***=”root”;</p>
<p>​        ****<em>password*</em>***=”abc”;</p>
<p>​    }</p>
<p>​    /**</p>
<p>​     * 注册驱动的方法</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> loadDriver(){</p>
<p>​        <em><strong>*try*</strong></em> {</p>
<p>​            Class.<strong>forName</strong>(****<em>driverClassName*</em>***);</p>
<p>​        } <em><strong>*catch*</strong></em> (ClassNotFoundException e) {</p>
<p>​            e.printStackTrace();</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     * 获得连接的方法</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> Connection getConnection(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 将驱动一并注册:</p>
<p>​            <strong>loadDriver</strong>();</p>
<p>​            // 获得连接</p>
<p>​            conn = DriverManager.<strong>getConnection</strong>(<em><strong>*<em>url*</em>***,</strong></em>*<em>username*</em>***, ****<em>password*</em>***);</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }</p>
<p>​        <em><strong>*return*</strong></em> conn;</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     * 释放资源的方法</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> release(Statement stmt,Connection conn){</p>
<p>​        <em><strong>*if*</strong></em>(stmt != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                stmt.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            </p>
<p>​            stmt = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​        <em><strong>*if*</strong></em>(conn != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                conn.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            conn = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> release(ResultSet rs,Statement stmt,Connection conn){</p>
<p>​        // 资源释放：</p>
<p>​        <em><strong>*if*</strong></em>(rs != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                rs.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            </p>
<p>​            rs = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​        <em><strong>*if*</strong></em>(stmt != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                stmt.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            </p>
<p>​            stmt = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​        <em><strong>*if*</strong></em>(conn != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                conn.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            conn = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>静态代码块可以写成配置文件</p>
<p>配置文件：两种</p>
<p>\1. 属性文件：扩展名为.properties  内容是key=value</p>
<p>\2. XML文件</p>
<p>定义一个配置文件：写好键值对的相应配置，修改文件扩展名为.properties</p>
<p><img src="/4.20.JDBC/wps1.jpg" alt="img"> </p>
<p>在工具类中解析属性文件：依然在静态代码块中进行解析：</p>
<p><img src="/4.20.JDBC/wps2.jpg" alt="img"> </p>
<p>SQL注入漏洞：通过知道用户名，然后进行sql语句查询就可以进行登录。</p>
<p><img src="/4.20.JDBC/wps3.jpg" alt="img"> </p>
<p>“+username+”和“+password+” 是字符串拼接</p>
<p><img src="/4.20.JDBC/wps4.jpg" alt="img"> </p>
<p>当用户名输入为aaa’ or ‘1=1 ，密码随意写，就能登录成功：</p>
<p>select * from user where username = ‘ aaa’ or ‘ 1=1  ‘ and password = ‘ asdafaf ’</p>
<p>因为先进行and运算，true and false 结果为false 。再进行or运算， true or false 结果为true，所以可以成功。</p>
<p>当用户名输入为aaa’ or ‘1=1 ，密码随意写，也能登录成功：</p>
<p>select * from user where username = ‘ aaa’ –  ‘ and password = ‘ asdafaf ’</p>
<p>因为– 代表注释，相当于aaa后面的都没了，结果为true，所以可以成功。</p>
<p>出现漏洞的原因就是因为 or  和 – 都是SQL的关键字</p>
<p>解决方案：得在后台，后端解决。（因为可以绕过前端）</p>
<p>需要采用PreparedStatement对象解决SQL注入漏洞。这个对象将SQL预先进行编译，使用?作为占位符。?所代表内容是SQL所固定。再次传入变量（包含SQL的关键字）。这个时候也不会识别这些关键字。</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> UserDao {</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*boolean*</strong></em> login(String username,String password){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        // 定义一个变量:</p>
<p>​        <em><strong>*boolean*</strong></em> flag = <em><strong>*false*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接:</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            // 编写SQL语句:</p>
<p>​            String sql = “select * from user where username = ? and password = ?”;</p>
<p>​            // 预编译SQL</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setString(1, username); //1代表第一个问号</p>
<p>​            pstmt.setString(2, password); // 2代表第二个问号</p>
<p>​            // 执行SQL语句:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*if*</strong></em>(rs.next()){</p>
<p>​                // 说明根据用户名和密码可以查询到这条记录</p>
<p>​                flag = <em><strong>*true*</strong></em>;</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);//这里传的pstmt实际是stmt的子类，实际上用的是多态</p>
<p>​        }</p>
<p>​        <em><strong>*return*</strong></em> flag;</p>
<p>​    }</p>
<p>所以以后的Statement都最好用PreparedStatement</p>
<p>增加操作：String sql = “insert into user values (null,?,?,?,?)”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setString(1, “eee”);</p>
<p>​            pstmt.setString(2, “abc”);</p>
<p>​            pstmt.setString(3, “旺财”);</p>
<p>​            pstmt.setInt(4, 32);</p>
<p>​            // 执行SQL</p>
<p>​            <em><strong>*int*</strong></em> num = pstmt.executeUpdate();</p>
<p>​            <em><strong>*if*</strong></em>(num &gt; 0){</p>
<p>​                System.****<em>out*</em>***.println(“保存成功！”);</p>
<p>​            }</p>
<p>修改操作：String sql = “update user set username = ?,password =?,nickname=?,age = ? where id = ?”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setString(1, “abc”);</p>
<p>​            pstmt.setString(2, “1234”);</p>
<p>​            pstmt.setString(3, “旺旺”);</p>
<p>​            pstmt.setInt(4, 23);</p>
<p>​            pstmt.setInt(5, 6);</p>
<p>​            // 执行SQL：</p>
<p>​            <em><strong>*int*</strong></em> num = pstmt.executeUpdate();</p>
<p>​            <em><strong>*if*</strong></em>(num &gt; 0){</p>
<p>​                System.****<em>out*</em>***.println(“修改成功！”);</p>
<p>​            }</p>
<p>删除操作：String sql = “delete from user where id = ?”;</p>
<p>​            // 预编译SQL</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setInt(1, 4);</p>
<p>​            // 执行SQL:</p>
<p>​            <em><strong>*int*</strong></em> num = pstmt.executeUpdate();</p>
<p>​            <em><strong>*if*</strong></em>(num &gt; 0){</p>
<p>​                System.****<em>out*</em>***.println(“删除成功！”);</p>
<p>​            }</p>
<p>查找操作：String sql = “select * from user”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 执行SQL:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            // 遍历结果集:</p>
<p>​            while(rs.next()){</p>
<p>​                System.out.println(rs.getInt(“id”)+” “+rs.getString(“username”)+” “+rs.getString(“password”)+” “+rs.getString(“nickname”));</p>
<p>}</p>
<p>JDBC的批处理：之前进行JDBC的操作的时候，都是一条SQL语句执行。现在如果使用批处理，可以将一批SQL一起执行。</p>
<p>用Statement进行批处理：@Test</p>
<p>​    /**</p>
<p>​     * 批处理基本操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        Statement stmt = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接:</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            // 创建执行批处理对象:</p>
<p>​            stmt = conn.createStatement();</p>
<p>​            // 编写一批SQL语句：</p>
<p>​            String sql1 = “create database test1”;</p>
<p>​            String sql2 = “use test1”;</p>
<p>​            String sql3 = “create table user(id int primary key auto_increment,name varchar(20))”;</p>
<p>​            String sql4 = “insert into user values (null,’aaa’)”;</p>
<p>​            String sql5 = “insert into user values (null,’bbb’)”;</p>
<p>​            String sql6 = “insert into user values (null,’ccc’)”;</p>
<p>​            String sql7 = “update user set name = ‘mmm’ where id = 2”;</p>
<p>​            String sql8 = “delete from user where id = 1”;</p>
<p>​            // 添加到批处理</p>
<p>​            stmt.addBatch(sql1);</p>
<p>​            stmt.addBatch(sql2);</p>
<p>​            stmt.addBatch(sql3);</p>
<p>​            stmt.addBatch(sql4);</p>
<p>​            stmt.addBatch(sql5);</p>
<p>​            stmt.addBatch(sql6);</p>
<p>​            stmt.addBatch(sql7);</p>
<p>​            stmt.addBatch(sql8);</p>
<p>​            // 执行批处理:</p>
<p>​            stmt.executeBatch();</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(stmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>使用PreparedStatement进行批量插入：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 批量插入记录:</p>
<p>​     * * 默认情况下MySQL批处理没有开启的，需要在url后面拼接一个参数即可：</p>
<p>?rewriteBatchedStatements=true</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2(){</p>
<p>​        // 记录开始时间:</p>
<p>​        <em><strong>*long*</strong></em> begin = System.<strong>currentTimeMillis</strong>();</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接:</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            // 编写SQL语句：</p>
<p>​            String sql = “insert into user values (null,?)”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            <em><strong>*for*</strong></em>(<em><strong>*int*</strong></em> i=1;i&lt;=10000;i++){</p>
<p>​                pstmt.setString(1, “name”+i);</p>
<p>​                // 添加到批处理</p>
<p>​                pstmt.addBatch();</p>
<p>​                // 注意问题：</p>
<p>​                // 执行批处理：每1000次进行一次批量处理和清空，以防止内存溢出</p>
<p>​                <em><strong>*if*</strong></em>(i % 1000 == 0){</p>
<p>​                    // 执行批处理:</p>
<p>​                    pstmt.executeBatch();</p>
<p>​                    // 清空批处理:</p>
<p>​                    pstmt.clearBatch();</p>
<p>​                }</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(pstmt, conn);</p>
<p>​        }</p>
<p>​        <em><strong>*long*</strong></em> end = System.<strong>currentTimeMillis</strong>();</p>
<p>​        System.****<em>out*</em>***.println((end-begin));</p>
<p>​    }</p>
<p>JDBC的事务：</p>
<p>事务指的是逻辑上的一组操作，组成这组操作各个逻辑单元要么全都成功，要么全都失败。</p>
<p>如果写一个转账代码，没有加事务的话，可能会出现扣钱了，但是另一个账户没有加钱的情况，所以需要加事务。</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 完成转账的案例</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            /**</p>
<p>​             * 完成转账代码：</p>
<p>​             * * 扣除某个账号的钱</p>
<p>​             * * 给另外一个账号加钱</p>
<p>​             */</p>
<p>​            // 获得连接：</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            <em><strong>*// 开启事务*</strong></em></p>
<p>​            <em><strong>*conn.setAutoCommit(*</strong>***</em>*false*<strong><strong><strong>*);*</strong></strong></strong>*//设置为false是需要手动提交，设为true的话，写一条sql语句就会提交一句****</p>
<p>​            // 编写SQL语句：</p>
<p>​            String sql = “update account set money = money + ? where name = ?”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 用aaa账号给bbb账号转1000元</p>
<p>​            pstmt.setDouble(1, -1000);</p>
<p>​            pstmt.setString(2, “aaa”);</p>
<p>​            // 执行SQL：扣除aaa账号1000元</p>
<p>​            pstmt.executeUpdate();</p>
<p>​            </p>
<p>​            <em><strong>*int*</strong></em> i = 1 / 0; //假设这里出现了异常，结果账户的钱也不会发生改变</p>
<p>​            </p>
<p>​            // 给bbb账号加1000</p>
<p>​            pstmt.setDouble(1, 1000);</p>
<p>​            pstmt.setString(2, “bbb”);</p>
<p>​            pstmt.executeUpdate();</p>
<p>​            </p>
<p>​            <em><strong>*// 提交事务:*</strong></em></p>
<p>​            <em><strong>*conn.commit();*</strong></em></p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            <em><strong>*// 回滚事务:*</strong></em></p>
<p>​            <em><strong>*try*</strong></em> <em><strong>*{*</strong></em></p>
<p>​                <em><strong>*conn.rollback();*</strong></em></p>
<p>​            <em><strong>*}*</strong></em> <em><strong>*catch*</strong></em> <em><strong>*(SQLException e1) {*</strong></em></p>
<p>​                <em><strong>*e1.printStackTrace();*</strong></em></p>
<p>​            <em><strong>*}*</strong></em></p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="*连接池*"></a><em><strong>*连接池*</strong></em></h1><p>连接池是装有连接的容器，线程使用连接的话，可以从连接池中进行获取，使用完成之后将连接归还给连接池。</p>
<p>连接对象创建和销毁是需要耗费时间的，在服务器初始化的时候就初始化一些连接。把这些连接放入到内存中，使用的时候可以从内存中获取，使用完成之后将连接放入连接池中。从内存中获取和归还的效率要远远高于创建和销毁的效率。（提升性能）</p>
<p>自定义连接池：</p>
<p>\1. 编写一个类实现DataSource接口</p>
<p>\2. 重写getConnection方法</p>
<p>\3. 初始化多个连接在内存中</p>
<p>\4. 编写归还连接的方法</p>
<p><img src="/4.20.JDBC/wps5.jpg" alt="img"> </p>
<p>测试：</p>
<p><img src="/4.20.JDBC/wps6.jpg" alt="img"> </p>
<p>但是这个自定义连接池也存在两个问题：</p>
<p>使用接口的实现类完成的构造：</p>
<p>MyDataSource dataSource = new MyDataSource(); 这种写法不利于程序的扩展：</p>
<p>应该用这样的DataSource dataSource = new MyDataSource(); （多态）</p>
<p>但是这样的话，因为DataSource下没有addBack方法所以下面的调用会出错；同时因为调用了addBack方法，会对使用连接池的用户增加难度（因为要理解什么是addBack方法，额外提供了方法归还连接）</p>
<p>解决：不提供自定义的方法addBack就可以解决这个问题，所以需要改写一个方法解决归还的问题。</p>
<p>在Connection中是有一个close方法的，colse方法完成了连接的销毁。现在需要写一个方法，将原有的连接的close方法改为归还。</p>
<p>增强一个类中的方法：</p>
<p>\1. 采用继承：是最简单的一种增强某个类中的方法的方式。</p>
<p>条件：需要控制这个类的构造才能进行继承。</p>
<p>\2. 采用装饰者模式：比如：BufferedInputStream（InputStream）</p>
<p>条件：增强的类和被增强的那个类要实现同样的接口；在增强的类中要有被增强的那个类的引用。</p>
<p>\3. 动态代理</p>
<p>使用装饰者模式增强Connection中的close方法：（因为接口内的方法需要全部重写，而继承的话，可以只重写某一个或几个方法）</p>
<p>为了简化编程，提供一个模板类（模板类原封不动的将接口中的所有方法都实现，但是都没有增强）。编写一个装饰类继承模板类。在装饰类中只需要增强某一个方法即可。</p>
<p><img src="/4.20.JDBC/wps7.jpg" alt="img"> </p>
<p>连接池的代码：</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> MyDataSource <em><strong>*implements*</strong></em> DataSource {</p>
<p>​    // 将一些连接存入到内存中，可以定义一个集合，用于存储连接对象。</p>
<p>​    <em><strong>*private*</strong></em> List<Connection> connList = <em><strong>*new*</strong></em> ArrayList<Connection>();</p>
<p>​    </p>
<p>​    // 在初始化的时候提供一些连接</p>
<p>​    <em><strong>*public*</strong></em> MyDataSource() {</p>
<p>​        // 初始化连接：</p>
<p>​        <em><strong>*for*</strong></em>(<em><strong>*int*</strong></em> i = 1;i&lt;=3;i++){</p>
<p>​            // 向集合中存入连接:</p>
<p>​            connList.add(JDBCUtils.<strong>getConnection</strong>());</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    // 从连接池中获得连接的方法</p>
<p>​    @Override</p>
<p>​    <em><strong>*public*</strong></em> Connection getConnection() <em><strong>*throws*</strong></em> SQLException {</p>
<p>​        Connection conn = connList.remove(0);</p>
<p>​        <em><strong>*// 增强连接：*</strong></em></p>
<p>​        <em><strong>*MyConnectionWrapper connWrapper =*</strong></em> <em><strong>*new*</strong></em> <em><strong>*MyConnectionWrapper(conn, connList);*</strong></em></p>
<p>​        <em><strong>*return*</strong></em> connWrapper;</p>
<p>​    }</p>
<p>​    </p>
<p>​    <em><strong>*// 编写一个归还连接的方法:*</strong></em></p>
<p>​    <em><strong>*/*public void addBack(Connection*</strong></em> <em><strong>*conn*</strong>***</em>*){****</p>
<p>​        <em><strong>*connList.add(*</strong>***</em>*conn****<em><strong>*);*</strong></em></p>
<p>​    <em><strong>*}*/*</strong></em></p>
<p>}</p>
<p>测试：</p>
<p><img src="/4.20.JDBC/wps8.jpg" alt="img"> </p>
<h1 id="Druid开源连接池"><a href="#Druid开源连接池" class="headerlink" title="*Druid开源连接池*"></a><em><strong>*Druid开源连接池*</strong></em></h1><p>Druid是阿里旗下开源连接池产品，使用非常简单，可以与Spring框架进行快速整合。</p>
<p>在项目下新建一个文件夹folder名为lib，复制mysql的驱动包，druid的jar包到lib中，添加buid path。</p>
<p>/<em>可以直接添加工具类，配置文件。然后直接获得连接，执行SQL语句，释放资源。（但是最好用连接池，不用这个）</em>/</p>
<p>使用这个druid连接池可以去百度搜索它的帮助文档查看相关的API。核心类：DruidDataSource</p>
<p>利用这个核心类可以创建对象，然后手动设置数据库连接的参数：setXxx的方法，（也可以使用配置文件进行获取参数）获得连接：getConnection方法。最后释放资源中conn的释放不是销毁而是归还到连接池中（Druid连接池底层一定重写了这个方法变成了归还）</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * Druid的使用:</p>
<p>​     * * 手动设置参数的方式</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 使用连接池：</p>
<p>​            DruidDataSource dataSource = <em><strong>*new*</strong></em> DruidDataSource();</p>
<p>​            // 手动设置数据库连接的参数:</p>
<p>​            dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);</p>
<p>​            dataSource.setUrl(“jdbc:mysql:///web_test4”);</p>
<p>​            dataSource.setUsername(“root”);</p>
<p>​            dataSource.setPassword(“abc”);</p>
<p>​            // 获得连接：</p>
<p>//            conn = JDBCUtils.getConnection();</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL:</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 执行SQL:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>也可以用配置文件进行参数的获取：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * Druid的使用:</p>
<p>​     * * 配置文件方式设置参数</p>
<p>​     * Druid配置方式可以使用属性文件配置的。</p>
<p>​     * * 文件名称没有规定但是属性文件中的key要一定的。</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 使用连接池：</p>
<p>​            // 从属性文件中获取：</p>
<p>​            Properties properties = <em><strong>*new*</strong></em> Properties();</p>
<p>​            properties.load(<em><strong>*new*</strong></em> FileInputStream(“src/druid.properties”));</p>
<p>//这里()内需要传一个InputStream，现在可以这样子传，在WEB中是另一种。</p>
<p>​            DataSource dataSource = DruidDataSourceFactory.<strong>createDataSource</strong>(properties);</p>
<p>​            // 获得连接：</p>
<p>//            conn = JDBCUtils.getConnection();</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL:</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 执行SQL:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>虽然可以在这里进行配置文件的配置，但是不太好，可以放在JDBC的工具类中。</p>
<h1 id="C3P0开源连接池"><a href="#C3P0开源连接池" class="headerlink" title="*C3P0开源连接池*"></a><em><strong>*C3P0开源连接池*</strong></em></h1><p>C3P0是一个开源的JDBC<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8024867&ss_c=ssc.citiao.link">连接池</a>，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=54630&ss_c=ssc.citiao.link">Hibernate</a>，Spring等。</p>
<p>C3P0的核心类是：ComboPooledDataSource</p>
<p>手动设置参数：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 手动设置参数的方式:</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接：从连接池中获取：</p>
<p>​            // 创建连接池：</p>
<p>​            ComboPooledDataSource dataSource = <em><strong>*new*</strong></em> ComboPooledDataSource();</p>
<p>​            // 设置连接参数:</p>
<p>​            dataSource.setDriverClass(“com.mysql.jdbc.Driver”);</p>
<p>​            dataSource.setJdbcUrl(“jdbc:mysql:///web_test4”);</p>
<p>​            dataSource.setUser(“root”);</p>
<p>​            dataSource.setPassword(“abc”);</p>
<p>​            // 从连接池中获得连接:</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL：</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 执行SQL：</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>配置文件设置参数：</p>
<p>默认情况下，c3p0会在类加载的resource路径下查找一个配置文件“/c3p0-config.xml”。所以XML文件应该在应用的CLASSPATH下的一个文件夹或者jar包中，如果是WEB的话会在WEB-INF/classes下，其他的话也是类似的路径。c3p0不仅支持xml文件，也支持properties文件（以后的重点）。</p>
<p>配置连接池：</p>
<p>在src下新建一个xml文件，设置名为c3p0-config.xml，可以在帮助文档中找到xml的配置代码:</p>
<p><default-config>…… </default-config>  默认配置</p>
<p>&lt;named-config  name=” ”&gt; ……</named-config>  自定义配置</p>
<p>可以修改其中的配置key，value。</p>
<p><img src="/4.20.JDBC/wps9.jpg" alt="img"> </p>
<p>使用连接池：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 采用配置文件的方式：</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接：从连接池中获取：</p>
<p>​            // 创建连接池：//创建连接池默认去类路径下查找c3p0-config.xml，并且将其中的各种参数加载好</p>
<p>​            ComboPooledDataSource dataSource = <em><strong>*new*</strong></em> ComboPooledDataSource();</p>
<p>//()里面可以传递配置的名称从而加载不同的参数。如果名称没有匹配的，会加载默认的配置参数</p>
<p>​            // 从连接池中获得连接:</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL：</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 执行SQL：</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>参数可以设置很多个，很多种，所以其应用很灵活。</p>
<p>以上的代码都不规范，因为每次都会创建一个新的连接池，会浪费资源，所以需要对工具类进行改写和完善</p>
<p><img src="/4.20.JDBC/wps10.jpg" alt="img"> </p>
<h1 id="DBUtils"><a href="#DBUtils" class="headerlink" title="*DBUtils*"></a><em><strong>*DBUtils*</strong></em></h1><p>Commons DbUtils是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Apache/8512995">Apache</a>组织提供的一个对<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JDBC">JDBC</a>进行简单封装的开源工具类库，使用它能够简化<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JDBC">JDBC</a>应用程序的开发，同时也不会影响程序的性能。</p>
<p>因为JDBC手写比较麻烦，而且有非常多的代码是类似的。比如获得连接，预编译SQL，释放资源等..那么可以将这些代码抽取出来放到工具类中。将类似的代码进行抽取。大大简化JDBC的编程。</p>
<p>API</p>
<p>QueryRunner对象：核心运行类</p>
<p>构造方法：</p>
<p>无参构造</p>
<p><img src="/4.20.JDBC/wps11.jpg" alt="img"> </p>
<p>带参构造</p>
<p><img src="/4.20.JDBC/wps12.jpg" alt="img"> </p>
<p>方法：</p>
<p>增删改的方法</p>
<p><img src="/4.20.JDBC/wps13.jpg" alt="img"> </p>
<p><img src="/4.20.JDBC/wps14.jpg" alt="img"> </p>
<p>查找的方法</p>
<p><img src="/4.20.JDBC/wps15.jpg" alt="img"> </p>
<p><img src="/4.20.JDBC/wps16.jpg" alt="img"> </p>
<p>在一般情况下如果执行CRUD的操作：</p>
<p>构造：</p>
<p>QueryRunner(DataSource ds);</p>
<p>方法：</p>
<p>int update(String sql,Object… args);</p>
<p>T query(String sql,ResultSetHandler rsh,Object… args);</p>
<p>如果有事务管理的话使用另一套完成CRUD的操作</p>
<p>构造：</p>
<p>QueryRunner();</p>
<p>方法:</p>
<p>int update(Connection conn,String sql,Object… args);</p>
<p>T query(Connection conn,String sql,ResultSetHandler rsh,Object… args);</p>
<p>批量处理的方法</p>
<p><img src="/4.20.JDBC/wps17.jpg" alt="img"> </p>
<p>还有一个类：DbUtils</p>
<p>提交事务的方法：（这里的close不是销毁而是归还）</p>
<p><img src="/4.20.JDBC/wps18.jpg" alt="img"> </p>
<p>回滚事务的方法：</p>
<p><img src="/4.20.JDBC/wps19.jpg" alt="img"> </p>
<p>添加DBUtils的构建路径</p>
<p>DBUtils的添加操作：</p>
<p>​    @Test</p>
<p>​    /**</p>
<p>​     * 添加操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1() <em><strong>*throws*</strong></em> SQLException{</p>
<p>​        // 创建核心类：QueryRunner:</p>
<p>​        QueryRunner queryRunner = <em><strong>*new*</strong></em> QueryRunner(JDBCUtils2.<strong>getDataSource</strong>());</p>
<p>​        queryRunner.update(“insert into account values (null,?,?)”, “ddd”,10000);</p>
<p>​    }</p>
<p>DBUtils的修改操作：</p>
<p>​    @Test</p>
<p>​    /**</p>
<p>​     * 修改操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2() <em><strong>*throws*</strong></em> SQLException{</p>
<p>​        // 创建核心类:</p>
<p>​        QueryRunner queryRunner = <em><strong>*new*</strong></em> QueryRunner(JDBCUtils2.<strong>getDataSource</strong>());</p>
<p>​        queryRunner.update(“update account set name=?,money=? where id =?”, “eee”,20000,4);</p>
<p>​    }</p>
<p>DBUtils的删除操作：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 删除操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo3() <em><strong>*throws*</strong></em> SQLException{</p>
<p>​        // 创建核心类:</p>
<p>​        QueryRunner queryRunner = <em><strong>*new*</strong></em> QueryRunner(JDBCUtils2.<strong>getDataSource</strong>());</p>
<p>​        queryRunner.update(“delete from account where id = ?”, 3);</p>
<p>​    }</p>
<p>DBUtils的查询操作：</p>
<p>查询一条记录：</p>
<p>创建一个对象：Account（这个对象实例其实就是javabean）</p>
<p><img src="/4.20.JDBC/wps20.jpg" alt="img"> </p>
<p>也要重写toString方法</p>
<p>查询的代码实现：T query(String sql,ResultSetHandler rsh,Object… args);</p>
<p><img src="/4.20.JDBC/wps21.jpg" alt="img"> </p>
<p>查询多条语句：</p>
<p><img src="/4.20.JDBC/wps22.jpg" alt="img"> </p>
<p>ResultSetHandler接口的实现类：</p>
<p>\1. ArrayHandler和ArrayListHandler</p>
<p>ArrayHandler：将查询到的一条记录封装到一个数组当中，这个数组应该是Object[]</p>
<p><img src="/4.20.JDBC/wps23.jpg" alt="img"> </p>
<p>ArrayListHandler：将多条记录封装到一个装有Object[]的List集合中。</p>
<p><img src="/4.20.JDBC/wps24.jpg" alt="img"> </p>
<p>\2. BeanHandler和BeanListHandler（重要）</p>
<p>BeanHandler：将一条记录封装到一个JavaBean中。</p>
<p><img src="/4.20.JDBC/wps25.jpg" alt="img"> </p>
<p>必须保证Acoount中的变量和SQL中的列名一致</p>
<p>BeanListHandler：将多条记录封装到一个装有JavaBean的List集合中。</p>
<p><img src="/4.20.JDBC/wps26.jpg" alt="img"> </p>
<p>\3. MapHandler和MapListHandler</p>
<p>MapHandler：将一条记录封装到一个Map集合中，Map的key是列名，Map的value就是表中列的记录值。</p>
<p><img src="/4.20.JDBC/wps27.jpg" alt="img"> </p>
<p>MapListHandler：将多条记录封装到一个装有Map的List集合中。</p>
<p><img src="/4.20.JDBC/wps28.jpg" alt="img"> </p>
<p>\4. ColumnListHandler、ScalarHandler、KeyedHandler</p>
<p>ColumnListHandler：将数据库中的某列的值封装到List集合中。</p>
<p><img src="/4.20.JDBC/wps29.jpg" alt="img"> </p>
<p>ScalarHandler：将单个值封装。</p>
<p><img src="/4.20.JDBC/wps30.jpg" alt="img"> </p>
<p>KeyedHandler（了解即可，用的很少）：将一条记录封装到一个Map集合中。将多条记录封装到一个装有Map集合的Map集合中。而且外面的Map的key是可以指定的（可以指定为数据库中的某一列名）。</p>
<p><img src="/4.20.JDBC/wps31.jpg" alt="img"> </p>
<p>因为可能是不同的类型，为了通用性，一般都用Object类型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.20.JDBC/" data-id="ckqk8k3eq00672wwd039ifav8" data-title="JDBC" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.16.泛型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.16.%E6%B3%9B%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:12:27.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.16.%E6%B3%9B%E5%9E%8B/">泛型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JDK5以后出现了自动装箱，所以在需要引用类型的时候如果是个基本类型也是可以的，是因为有自动装箱。</p>
<p>当我们往集合中存储了String和Integer两种类型时的数据时，而在遍历时都进行String类型的转化时，就会报错。但这个报错在编译期间不会出现，在编译的时候只有警告，只有执行的时候才会出现。于是集合也开始在创建对象的时候明确元素的数据类型，这就是泛型。</p>
<p>泛型：是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。参数化类型，把类型当作参数一样的传递。</p>
<p>格式：&lt;数据类型&gt;  此处的数据类型只能是引用类型</p>
<p>好处：1.运行时期的问题提取到了编译期间</p>
<p>\2. 避免了强制类型转换</p>
<p>\3. 简化了程序设计，解决了黄色警告线</p>
<p>在API中，如果类，接口，抽象类中出现了<E>，就说明要使用泛型。一般来说就是在集合中使用。</p>
<p>JDK7的新特性：泛型推断。</p>
<p>早期我们使用Object类型可以接收任意的对象类型。但是在实际的使用中，会有类型转换的问题（向上转型是没有任何问题的，但是在向下转型的时候隐含了类型转换的问题），也就存在着隐患，这样的程序是不安全的，所以在JDK5以后Java提供了泛型来解决这个问题，提高程序的安全性。</p>
<p>应用：</p>
<p>1.泛型类：把泛型定义在类上</p>
<p>格式:public class 类名&lt;泛型类型1,…&gt;</p>
<p>注意:泛型类型必须是引用类型</p>
<p>2.泛型方法：把泛型定义在方法上</p>
<p>格式:public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .)</p>
<p>方法可以接收任意的类型</p>
<p>3.泛型接口：把泛型定义在接口上</p>
<p>格式:public  interface 接口名&lt;泛型类型1…&gt;</p>
<p>实现类在实现接口的时候：</p>
<p>1.已经知道是什么类型的了：</p>
<p>public class InterImpl implements Inter<String>{}</p>
<p>\2. 还不知道是什么类型：(这种情况用的比较多)</p>
<p>public class InterImpl<T> implements Inter<T>{}</p>
<p>泛型通配符：泛型如果写的时候，前后必须一致（ArrayList<T> array=new ArrayList<T>();  这里的前后两个T必须一致，？可以表示任意）</p>
<p>\1. &lt;?&gt;:任意类型，如果没有明确，那么就是Object以及任意的Java类了</p>
<p>\2. &lt;? extends E&gt;：向下限定，E及其子类</p>
<p>\3. &lt;? super E&gt;：向上限定，E及其父类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.16.%E6%B3%9B%E5%9E%8B/" data-id="ckqk8k3de001v2wwd8npn3yjf" data-title="泛型" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.15.枚举" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.15.%E6%9E%9A%E4%B8%BE/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:12:20.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.15.%E6%9E%9A%E4%B8%BE/">枚举</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>枚举：是有限个值的集合。</p>
<p>是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内</p>
<p>如果没有枚举类，我们自己定义一个类的话，会非常麻烦。（//需要用到构造方法私有，静态方法调用，对象调用方法，匿名类重写方法等）</p>
<p>格式：</p>
<p>public enum 枚举类名 {</p>
<p>​            枚举项1，枚举项2，枚举项3…;</p>
<p>}</p>
<p>public String toString():  返回枚举常量的名称，它包含在声明中（枚举重写了toString方法，返回的是枚举项的名字）</p>
<p>注意事项</p>
<p>定义枚举类要用关键字enum</p>
<p>所有枚举类都是Enum的子类</p>
<p>枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略</p>
<p>枚举类可以有构造器，但必须是private的，它默认的也是private的。枚举项的用法比较特殊：枚举(“”);</p>
<p>枚举类也可以有抽象方法，但是枚举项必须重写该方法</p>
<p>枚举在switch语句中的使用</p>
<p>枚举类中的几个常见方法</p>
<p>int compareTo(E o) 比较此枚举与指定对象的顺序，枚举中隐含数字 1 2 3 …</p>
<p>String name() 返回此枚举常量的名称，在其枚举声明中对其进行声明</p>
<p>int ordinal()  返回枚举常量的序数（它在枚举声明中的位置，初始常量序数为0）</p>
<p>String toString() 返回枚举常量的名称，它包含在声明中</p>
<p><T> T valueOf(Class<T> type,String name)  静态方法，返回带指定名称的指定枚举类型的枚举常量</p>
<p>values()  此方法虽然在JDK文档中查找不到，但每个枚举类都具有该方法，它遍历枚举类的所有枚举值非常方便</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.15.%E6%9E%9A%E4%B8%BE/" data-id="ckqk8k3dd001t2wwd7su8bjx9" data-title="枚举" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.23JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.23JVM/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:36:18.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.23JVM/">JVM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java语言是跨平台的，jvm不是跨平台的。</p>
<p>虚拟机（Virture Machine）指通过软件的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</p>
<p>Java的源代码经过编译后生成的不是特定CPU使用的本地代码，而是名为字节代码的程序。直接代码的运行环境就叫做java虚拟机（JVM），边转换边运行。</p>
<p>java中的内存分配：java程序在运行时，需要在内存中的分配空间。</p>
<p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p>
<p>\1. 栈：存储局部变量（加载的变量、方法）</p>
<p>结构：先进后出</p>
<p>特点：栈内存的数据用完（脱离数据域）就释放掉。（堆内存的数据可能要使用多次。）</p>
<p>\2. 堆：存储new出来的东西（里面含有该new类的成员变量、静态标记、方法标记）</p>
<p>特点：每一个new出来的东西都有地址值；每个变量都有默认值：</p>
<p>byte,short,int,long  0</p>
<p>float,double  0.0</p>
<p>char  \u000</p>
<p>boolean  false </p>
<p>引用类型  null</p>
<p>使用完毕就变成了垃圾，但是并没有立即回收，会在垃圾回收器空闲时候回收。</p>
<p>C++中用析构函数来回收释放空间。</p>
<p>栈内存的两个引用指向同一个堆内存空间，无论是它们谁的操作，都是针对同一个地方。</p>
<p>3.方法区：class类区（包括类的成员变量和成员方法）、静态区（static）、常量池</p>
<p>4.本地方法区：和系统相关</p>
<p>5.寄存器：CPU使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.23JVM/" data-id="ckqk8k3dg00242wwd333ra39f" data-title="JVM" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.24.JUC并发编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.24.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:36:12.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.24.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">JUC并发编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.24.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="ckqk8k3dh00252wwd4uqb4xh1" data-title="JUC并发编程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.17.反射和注解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:57.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/">反射和注解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>类的加载</p>
<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。</p>
<p>加载 </p>
<p>就是指将class文件读入内存，并为之创建一个Class对象。</p>
<p>任何类被使用时系统都会建立一个Class对象。</p>
<p>连接</p>
<p>验证 是否有正确的内部结构，并和其他类协调一致</p>
<p>准备 负责为类的静态成员分配内存，并设置默认初始化值</p>
<p>解析 将类的二进制数据中的符号引用替换为直接引用</p>
<p>初始化 </p>
<p>就是我们以前讲过的初始化步骤</p>
<p>类初始化时机：</p>
<p>1.创建类的实例</p>
<p>2.访问类的静态变量，或者为静态变量赋值</p>
<p>3.调用类的静态方法</p>
<p>4.使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p>
<p>5.初始化某个类的子类</p>
<p>6.直接使用java.exe命令来运行某个主类</p>
<p>类加载器</p>
<p>负责将.class文件加载到内在中，并为之生成对应的Class对象。</p>
<p>虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行</p>
<p>类加载器的组成</p>
<p>Bootstrap ClassLoader 根类加载器 </p>
<p>也被称为引导类加载器，负责Java核心类的加载。比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</p>
<p>Extension ClassLoader 扩展类加载器</p>
<p>负责JRE的扩展目录中jar包的加载。在JDK中JRE的lib目录下ext目录</p>
<p>Sysetm ClassLoader 系统类加载器</p>
<p>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径</p>
<p>反射，一种计算机处理方式。是程序可以访问、检测和修改它本身状态或行为的一种能力。</p>
<p>反射：就是通过class文件对象，去使用该文件中的成员变量，构造方法，成员方法</p>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种****动态获取****的信息以及动态调用对象的方法的功能称为java语言的反射机制</p>
<p>//要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象</p>
<p>对于我们学习反射，我们在操作中一般会获取类的成员 Constructor  Field  Method。但是要想获取这些对象，必须首先得到其Class,通过Class再来获得其它对象</p>
<p>Java反射常用API</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps1.jpg" alt="img"> </p>
<p>Java中的Class可以代表任意的类或接口类型</p>
<p>在java.lang.reflect包下有三个类</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps2.jpg" alt="img"> </p>
<p>三种获取Class对象的方式</p>
<p>1:如果持有一个对象，可以直接从Object类继承的getClass()方法获取</p>
<p>Person p = new Person();</p>
<p> Class c = p.getClass();</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps3.jpg" alt="img"> </p>
<p>2:可以直接通过类包(接口)直接调用其静态属性.class获取</p>
<p>Class c2 = Person.class;</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps4.jpg" alt="img"> </p>
<p> 任意数据类型都具备一个class静态属性,看上去要比第一种方式简单.</p>
<p>3:可以通过Class类中提供的forName方法获取（将类名作为字符串传递给Class类中的静态方法forName即可）：</p>
<p>public static Class forName(String className)  这个类名必须是全路径：包名.类名（可以在外面写，会提示是否出错，没错的话沾过去；也可以点击类名下的类名右击copy Qualified name ）</p>
<p> Class c3 = Class.forName(“Person”);</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps5.jpg" alt="img"> </p>
<p>第三种和前两种的区别    ：前两种你必须明确Person类型；后面是一个字符串就行，而不需要是一个具体的类名.这种扩展更强.我不需要知道你的类.我只提供字符串,将这样的字符串配置到配置文件中，按照配置文件加载就可以了</p>
<p>所以开发中一般用第三种方法</p>
<p>Class类：</p>
<p>成员变量            Field</p>
<p>构造方法            Constructor</p>
<p>成员方法            Method</p>
<p>通过反射获取构造方法并使用：</p>
<p>获取构造方法：</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps6.jpg" alt="img"> </p>
<p>getConstructor它获取的是类的public构造</p>
<p>getConstructors它获取的是类的所有的public构造</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps7.jpg" alt="img"> </p>
<p>这两个方法不仅可以获取public，也可以获取其它权限的</p>
<p>获取单个构造方法</p>
<p>public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)  参数表示的是你要获取的构造方法的构造参数个数及数据类型的****class字节码****文件对象。…表示可以是0个（无参）一个（一个参数）多个（多个参数）</p>
<p>/*获取的单个构造方法实际上是一个对象，通过这个对象可以创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例</p>
<p>public T newInstance(Object… initargs)</p>
<p>反射可以获取私有的构造方法，成员方法，成员变量：</p>
<p>获取的如果是私有的构造方法，要用public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes),但是会显示非法的访问异常。所以还要用暴力访问：.setAccessible(true); 值为true指示反射的对象在使用时应该取消java语言访问检查  （XJAD软件就用到了反射）*/</p>
<p>我们得到构造器，就可以实例化对象</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps8.jpg" alt="img"> </p>
<p>如果不是public，那么我们需要构造器对象的实例调用AccessibleObject中的</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps9.jpg" alt="img"> </p>
<p>来取消语言检查</p>
<p>Reflect类继承于AccessibleObject类继承于Object类</p>
<p>通过反射获取成员变量并使用：Java.lang.reflect.Field它描述的属性对象</p>
<p>1.获取一个Field</p>
<p>获取所有成员</p>
<p>getFields  公共的</p>
<p>getDeclaredFields 所有的</p>
<p>获取单个成员</p>
<p>getField</p>
<p>getDeclaredField</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps10.jpg" alt="img"> </p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps11.jpg" alt="img"> </p>
<p>2.Field的操作</p>
<p>（1）对Field进行赋值</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps12.jpg" alt="img"> </p>
<p>赋值或修改成员的值</p>
<p>set(Object obj,Object value)<br>  将指定对象变量上此 Field 对象表示的字段设置为指定的新值。此处的obj需要通过构造方法创建一个obj对象，也可以直接通过Class的实例的newInstance方法直接获得obj对象（这个方法的底层就是使用了Class类额无参构造来实例化）</p>
<p>（2）对Field进行取值</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps13.jpg" alt="img"> </p>
<p>通过反射获取成员方法并使用：Java.lang.reflect.Method它描述的是类或接口中的方法</p>
<p>获取所有方法</p>
<p>​        getMethods 获取自己的包括父亲的公共方法</p>
<p>​        getDeclaredMethods 获取自己的所有方法</p>
<p>获取单个方法</p>
<p>​        getMethod（String name，Class&lt;?&gt;… parameterTypes）</p>
<p>​        getDeclaredMethod（String name，Class&lt;?&gt;… parameterTypes）</p>
<p>第一个参数是方法的名称，第二个参数是一个可变参数Class[]，它描述的是方法的参数Class</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps14.jpg" alt="img"> </p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps15.jpg" alt="img"> </p>
<p>Method的使用：public Object invoke (Object obj , Object… args)  返回值是Object接收，第一个参数表示对象是谁，第二个参数表示调用该方法的实际参数</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps16.jpg" alt="img"> </p>
<p>Method的invoke使用时注意事项?</p>
<p>\1. 如果方法是static，我们怎样调用？</p>
<p>如果方法是静态的，在通过invoke调用时不需要传递对象，传递null</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps17.jpg" alt="img"> </p>
<p>\2. 如果方法的参数是一个数组类型，怎样处理?</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps18.jpg" alt="img"> </p>
<p>为什么不能直接传args：因为数组也是object类型。在传递时，底层的invoke方法认为要调用的参数有四个。</p>
<p>为什么int[]直接传递args不报错，而Integer[]会报错：因为int[]数组中的每一个元素不是Object，只是基本数据类型，int[]被认为是一个对象。而Integer[]数组中的每一个元素都是Object</p>
<p>/*反射的调用和正常类的调用是恰好相反的。</p>
<p>正常类：p.show()    p.show(参数)</p>
<p>反射：show.invoke(p)   show.invoke(p，参数)</p>
<p>*/</p>
<p>案例：（这个案例可以帮助我们把集合中的值通过反射赋到一个类中）</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps19.jpg" alt="img"> </p>
<p>并提供get/set方法</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps20.jpg" alt="img"> </p>
<p>使用java中的反射技术将类中的属性与map中的key相同名称的，使用反射技术将key对应的value值赋值给属性.</p>
<p>采用两种方式完成操作：</p>
<p>1.直接操作属性 Field来完成操作（不常用）</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps21.jpg" alt="img"> </p>
<p>2.通过属性对应的setXxx方法来完成操作</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps22.jpg" alt="img"> </p>
<p>优点：</p>
<p>1、反射提高了程序的灵活性和扩展性。</p>
<p>2、降低耦合性，提高自适应能力。</p>
<p>3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。<br>缺点：<br>    1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</p>
<p>2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</p>
<p>反射：需要配置文件配合使用。 </p>
<p>配置文件是键值对。必须要有键，代码获取键；然后可以自己通过改变值，来使代码中的对象改变，从而获得不同的运行效果。</p>
<p>反射可以越过泛型检查。</p>
<p>真实的需求应该是在你调用方法后，每次操作前，都需要进行权限校验，在进行操作后，必须留下日志记录。</p>
<p>代理即Proxy Pattern，23种常用的面向对象软件的设计模式之一</p>
<p>代理模式的定义：为其他对象提供一种<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/24001.htm">代理</a>以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<p>组成：</p>
<p>抽象角色：通过接口或抽象类声明真实角色实现的业务方法。</p>
<p>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。</p>
<p>真实角色(目标对象)：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p>
<p>分类：</p>
<p>静态代理：是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p>
<p>动态代理：是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。</p>
<p>优点：</p>
<p>(1).职责清晰，真实的角色就是实现实际的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1642754.htm">业务逻辑</a>，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。</p>
<p>(2).代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。</p>
<p>(3).高扩展性</p>
<p>动态代理</p>
<p>代理：本来应该自己做的事情，却请了别人来做，被请的人就是代理对象。</p>
<p>动态代理：在程序运行过程中产生的这个对象</p>
<p>而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理</p>
<p>在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib（框架中学到，这个代理不仅仅是针对接口）</p>
<p>注意：在java中使用Proxy来完成动态代理对象的创建，只能为目标实现了接口的类创建代理对象。</p>
<p>Proxy类中的方法创建动态代理类对象：</p>
<p>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) </p>
<p>ClassLoader loader 是对象的字节码文件的类加载器：.getClass().getClassLoader()</p>
<p>Class&lt;?&gt;[] interfaces是对象的字节码文件的接口：.getClass().getInterfaces()</p>
<p>动态代理是在内存中直接生成代理对象。</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps23.jpg" alt="img"> </p>
<p>通过这个方法可以直接创建一个代理对象。</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps24.jpg" alt="img"> </p>
<p>//InvocationHandler应用了观察者模式，因为代理类没有实例，所以需要监听代理对象调用时，其底层实现的是目标行为</p>
<p>InvocationHandler h是一个接口，这里需要的是这个接口的实现类对象，所以需要创建一个类实现InvocationHandler接口。这个类中再重写InvocationHandler方法：public Object invoke(Object proxy,Method method,Object[] args)</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps25.jpg" alt="img"> </p>
<p>Invoke方法，它是在代理对象调用行为时，会执行的方法，而invoke方法上有三个参数：</p>
<p>proxy:代表动态代理对象</p>
<p>method:要访问的目标行为，代表要调用的方法对象</p>
<p>args:目标行为，代表调用目标方法时传入的实参</p>
<p>这个方法的主要作用是：当我们通过代理对象调用行为时，来控制目标行为是否可以被调用（可以自己写代码控制，return null 不让调，return method.invoke(target,args)控制目标对象的方法执行）。</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps26.jpg" alt="img"> </p>
<p>Proxy.newProxyInstance</p>
<p>创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。</p>
<p>System.out.println(u.getClass().getName());</p>
<p>案例:测试addUser方法的运行时间</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps27.jpg" alt="img"> </p>
<p>在开发中，在代理中通过目标来调用真实行为，我们使用动态代理可以完成性能监控（如上，进行时间的记录来监控性能），权限控制（在调用目标行为之前先判断是否有权限），日志记录（在调用方法之前，进行日志记录一些信息）等操作</p>
<p>注释（先写注释在写程序）</p>
<p>作用：用于解释说明程序的文字，提高程序的阅读性；可以帮助我们调试程序。</p>
<p>注释分类格式：</p>
<p>单行注释//  可以嵌套</p>
<p>多行注释/*   */  不能嵌套</p>
<p>文档注释/**   */</p>
<p>对于单行和多行注释，被注释的文字是不会被JVM解释执行</p>
<p>对于文档注释 是java特有的注释，其中的注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。</p>
<p>/*</p>
<p>需求：</p>
<p>分析：</p>
<p>实现：</p>
<p>*/</p>
<p>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的</p>
<p>它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。你可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现（SOURCE/CLASS/RUNTIME）。</p>
<p>作用：如果要对于元数据的作用进行分类，还没有明确的定义，不过我们可以根据它所起的作用，大致可分为三类：</p>
<p>编写文档：通过代码里标识的元数据生成文档。</p>
<p>代码分析：通过代码里标识的元数据对代码进行分析。</p>
<p>编译检查：通过代码里标识的元数据让<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/487018.htm">编译器</a>能实现基本的编译检查</p>
<p>在现在开发中使用注解，一般是用于将注解替换配置文件。（xml配置文件）</p>
<p>Java中基本内置注解:</p>
<p>1.@Override</p>
<p>它的作用是对覆盖超类中方法的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编译器会发出错误警告。</p>
<p>注意事项:</p>
<p>​    对于接口中的方法重写，<a href="mailto:在jdk1.5时@Override">在jdk1.5时@Override</a>它是会报错.</p>
<p>​    在jdk1.6后的版本就可以描述接口与类之间的重写</p>
<p>2.@Deprecated</p>
<p>它的作用是对不应该再使用的方法添加注解，当编程人员使用这些方法时，将会在编译时显示提示信息</p>
<p>问题:什么时候方法是过时的?</p>
<p>当前版本中这个方法存在隐患，在后续版本中对其进行了补充，这时前一个版本中的方法就会标注成过时的。</p>
<p>3.@SuppressWarnings</p>
<p>它的作用是去掉程序中的警告.</p>
<p>其参数有：</p>
<p>deprecation，使用了过时的类或方法时的警告</p>
<p>unchecked，执行了未检查的转换时的警告</p>
<p>fallthrough，当 switch 程序块直接通往下一种情况而没有 break 时的警告</p>
<p>path，在类路径、源文件路径等中有不存在的路径时的警告</p>
<p>serial，当在可序列化的类上缺少serialVersionUID 定义时的警告</p>
<p>finally ，任何 finally 子句不能正常完成时的警告</p>
<p>all，关于以上所有情况的警告</p>
<p>可以在方法之前加@SuppressWarnings（“rawtype”）</p>
<p>当一个类中出现了很多，可以在类上加@SuppressWarnings（“all”），一劳永逸</p>
<p>自定义注解</p>
<p>1.注解声明：声明一个注解格式：  修饰符 @interface 注解名{}</p>
<p>2.注解本质分析</p>
<p>分析一下注解的本质:将其.class文件找到，反编译.  (可以使用javap命令或反编译工具)</p>
<p>@interface MyAnnoation{}</p>
<p>反编译后的结果</p>
<p>interface MyAnnotation    extends Annotation</p>
<p>{</p>
<p>}</p>
<p>结论:注解本质上就是一个接口。它扩展了java.lang.annotation.Annotation接口;</p>
<p>在java中所有注解都是Annotation接口的子接口。</p>
<p>3.注解成员</p>
<p>注解本质上就是一个接口，那么它也可以有属性和方法。</p>
<p>但是接口中的属性是 public static final的，在注解中注解没有什么意义。</p>
<p>在开发中注解中经常存在的是方法（这个方法的返回值类型有要求）。而在注解中接口的方法叫做注解的属性.</p>
<p>4.自定义注解-属性操作</p>
<p>注解属性类型：</p>
<p>1.基本类型  byte short int long float double char boolean</p>
<p>​    2.String</p>
<p>​    3.枚举类型：可以自己创建一个枚举类，然后类名 方法名();</p>
<p>​    4.注解类型</p>
<p>​    5.Class类型</p>
<p>​    6.以上类型的一维数组类型</p>
<p>注解属性的使用</p>
<p>1.如果一个注解有属性，那么在使用注解时，要对属性进行赋值操作.</p>
<p>​    例如:@MyAnnotation(st = “aaa”)</p>
<p>2.如果一个注解的属性有多个，都需要赋值，使用”,”分开属性.</p>
<p>​    @MyAnnotation(st = “aaa”,i=10)</p>
<p>3.也可以给属性赋默认值</p>
<p>​    double d() <em><strong>*default 1.23*</strong></em>;</p>
<p>​    如果属性有默认值，在使用注解时，就可以不用为属性赋值。    </p>
<p>4.如果属性是数组类型</p>
<p>​        1.可以直接使用  属性名={值1,值2,。。。}方式,例如</p>
<p>​            @MyAnnotation(st = “aaa”,i=10,sts={“a”,”b”})</p>
<p>​        2.如果数组的值只有一个也可以写成下面方式</p>
<p>​            @MyAnnotation(st = “aaa”,i=10,sts=”a”)</p>
<p>​            注意sts属性它是数组类型，也就是说，只有一个值时，可以省略”{}”</p>
<p>​        </p>
<p>5.对于属性名称 value的操作.</p>
<p>​            1.如果属性名称叫value,那么在使用时，可以省略属性名称</p>
<p>​                @MyAnnotation(“hello”)</p>
<p>​            2.如果有多个属性，都需要赋值，其中一个叫value,这时，必须写属性名称</p>
<p>​                @MyAnnotation(value=”hello”,i=10)</p>
<p>​        </p>
<p>​            3.如果属性名称叫value,它的类型是数组类型.</p>
<p>​                1.只有这个value属性</p>
<p>​                可以直接赋值，不能写属性名称,但是，如果只有一个值</p>
<p>​                    @MyAnnotation({“abc”})或  @MyAnnotation(“abc”)</p>
<p>​                但是如果有多个值</p>
<p>​                    @MyAnnotation({“abc”,”def”})                        </p>
<p>​                2.如果有多个属性，属性名称叫value</p>
<p>​                    所有属性都需要赋值，那么必须写属性名称.</p>
<p>5.自定义注解-元注解</p>
<p>元注解及其作用：用于修饰注解的注解，可以描述注解在什么范围及在什么阶段使用等</p>
<p>四个元注解介绍：</p>
<p>@Retention</p>
<p>指定注解信息在哪个阶段存在 Source Class Runtime</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps1-1618812955705.jpg" alt="img"> </p>
<p>SOURCE它对应着编译阶段，可以帮助我们进行检查。</p>
<p>CLASS 它对应解析执行阶段</p>
<p>RUNTIME 它对应着在JVM中,在运行时结合反射技术，可以使注解具有一些功能</p>
<p>@Target</p>
<p>指定注解修饰目标对象的类型  </p>
<p>TYPE 类、接口   FIELD 成员变量   METHOD 方法</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps2-1618812955706.jpg" alt="img"> </p>
<p><a href="mailto:在接口的定义中前面进行元注解@Target(ElementType.TYPE)标注">在接口的定义中前面进行元注解@Target(ElementType.TYPE)标注</a>后，这个自定义注解只能用在TYPE即类、接口上，不能用于方法上。</p>
<p><a href="mailto:如果要求自定义的注解需要用在多个地方。可以@Target({ElementType.TYPE,ElementType.METHOD})">如果要求自定义的注解需要用在多个地方。可以@Target({ElementType.TYPE,ElementType.METHOD})</a></p>
<p>@Documented</p>
<p>使用该元注解修饰，该注解的信息可以生成到javadoc 文档中</p>
<p>@Inherited</p>
<p>如果一个注解使用该元注解修饰，应用注解目标类的子类会自动继承该注解 </p>
<p>@Retention @Target 是自定义注解必须使用两个元注解，并且，@Retention它的值应该是RUNTIME,因为我们会结合反射技术来使用。 @Target我们一般使用TYPE或METHOD</p>
<p>案例-获取Connection连接数据库</p>
<p>目的：让注解具有功能，必须结合反射技术来应用。</p>
<p>注解它可以替换配置文件。</p>
<p>第一步:创建注解</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps3-1618812955706.jpg" alt="img"> </p>
<p>第二步:使用注解</p>
<p>在方法上进行注解标注：</p>
<p>@JdbcProperty（driverClass=””,url=””,user=””,password=””）</p>
<p>我们可以通过getAnnotation()方法（这个方法在Class，Method。Field中都有）来获取注解对象</p>
<p><img src="/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/wps4-1618812955706.jpg" alt="img"> </p>
<p>通过jp.driverClass  jp.url 等就可以得到注解的值，然后在数据库连接中使用，进行数据库连接</p>
<p>这里的操作实际上相当于是以前在配置文件中写这些属性值，在代码中从配置文件中取。</p>
<p>问题:使用注解可以替换配置文件，为什么要替换?</p>
<p>​    配置文件中的信息，它会随着程序的变大，配置信息越来越多，不利于开发。而将配置信息通过注解来替换，便于开发与阅读。</p>
<p>缺点：如果需要更改，需要在源代码上修改注解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.17.%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/" data-id="ckqk8k3ea004h2wwdh7vx3di3" data-title="反射和注解" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.21.GUI编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.21.GUI%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:41.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.21.GUI%E7%BC%96%E7%A8%8B/">GUI编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>GUI(图形用户界面)</p>
<p>Java为GUI提供的对象都存在java.Awt和javax.Swing两个包中</p>
<p>GUI：Graphical User Interface(图形用户接口)。</p>
<p>用图形的方式，来显示计算机操作的界面，这样更方便更直观。</p>
<p>CLI：Command line User Interface (命令行用户接口）</p>
<p>就是常见的Dos命令行操作。</p>
<p>需要记忆一些常用的命令，操作不直观。</p>
<p>java.awt：Abstract Window ToolKit (抽象窗口工具包)，需要调用本地系统方法实现功能。属重量级控件。</p>
<p>javax.swing：在AWT的基础上，建立的一套图形界面系统，其中提供了更多的组件，而且完全由Java实现。增强了移植性，属轻量级控件。</p>
<p>javax是java扩展包</p>
<p>和本地系统相关的，就是重量级控件，因为移植性很差。完全由java实现的，移植性就很好，属于轻量级控件。（这里的轻重是与操作系统的关系）</p>
<p><img src="/4.21.GUI%E7%BC%96%E7%A8%8B/wps1.jpg" alt="img"> </p>
<p>Component（组件）</p>
<p>Container：为容器，是一个特殊的组件，该组件中可以通过add方法添加其他组件进来。</p>
<p>Window：窗体  没有边界和标题</p>
<p>Panel：面板</p>
<p>Frame：框架  有边界和标题</p>
<p>Dialog：对话框</p>
<p>FileDialog：文件对话框</p>
<p>Button：按钮</p>
<p>Label：标签</p>
<p>Checkbox：复选框</p>
<p>TextComponent：文本组件</p>
<p>TextArea：文本域  多行多列</p>
<p>TextField：文本框  单行多列</p>
<p>Frame  f = new Frame(“my window”);//构造方法命名 setTile是方法命名</p>
<p>f.setLayout(new FlowLayout());//设置为流式布局</p>
<p>f.setSize(300,400);//设置窗体大小 Dimension</p>
<p>f.setLocation(300,200);//设置窗体出现在屏幕的位置 Point</p>
<p>f.setVisible(true);//设置窗体是否可见</p>
<p>一个方法：setBounds（int x,int y,int width,int height）</p>
<p>前后是有顺序关系的，如果f.setVisible(true);在前面就会先显示再加载到指定位置。一般是这个步骤：创建窗体对象；设置窗体属性；设置窗体可见</p>
<p>事件监听机制</p>
<p>事件源：事件发生的地方</p>
<p>事件：要发生的事情</p>
<p>事件处理：针对发生的事情做出的处理方案</p>
<p>事件监听器：就是把事件源和事件关联起来</p>
<p>窗体布局：窗体中组件的排列方式</p>
<p>流式布局FlowLayout：从上到下，从左到右。</p>
<p>边界布局BorderLayout：东西南北中</p>
<p>网格布局GridLayout：网格状，标准n行n列</p>
<p>网格包布局GridBagLayout：可以将任意个相连的网格状连在一起当一个</p>
<p>卡片布局CardLayout：类似于卡片，点一个卡片会在主界面加载一个</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.21.GUI%E7%BC%96%E7%A8%8B/" data-id="ckqk8k3df00212wwd5i10b7ve" data-title="GUI编程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.18.网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:31.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>计算机网络：是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<p>网络编程：就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。</p>
<p>网络模型：</p>
<p>OSI（Open System Interconnection开放系统互连）参考模型</p>
<p>TCP/IP参考模型</p>
<p><img src="/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/wps1.png" alt="img"> </p>
<p>网络模型7层概述：</p>
<p> 1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 </p>
<ol start="2">
<li><p>数据链路层：主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 </p>
</li>
<li><p>网络层：主要将从下层接收到的数据进行IP地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 </p>
</li>
<li><p>传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 </p>
</li>
<li><p>会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） </p>
</li>
</ol>
<p>6.表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 </p>
<p>7.应用层： 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。</p>
<p>网络应用程序：网络编程、IO流、多线程组成。集合</p>
<p>网络通信三要素：</p>
<p>1.IP地址:InetAddress（找到电脑）</p>
<p>​    网络中设备的标识，不易记忆，可用主机名</p>
<p>2.端口号：（区分电脑的程序）</p>
<p>​    用于标识进程的逻辑地址，不同进程的标识</p>
<p>3.传输协议：（怎么交流传输）</p>
<p>​    通讯的规则，常见协议：TCP，UDP</p>
<p>IP地址</p>
<p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接受数据的计算机和识别发送的计算机，在TCP/IP协议中，这个标识号就是IP地址</p>
<p>所谓IP地址就是给每个连接在Internet上的主机分配的一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，比特换算成字节，就是4个字节。例如一个采用二进制形式的IP地址是“00001010000000000000000000000001”，这么长的地址，人们处理起来也太费劲了。为了方便人们的使用，IP地址经常被写成十进制的形式，中间使用符号“.”分开不同的字节。于是，上面的IP地址可以表示为“10.0.0.1”。IP地址的这种把IP地址的每一个字节的数据换算成十进制，然后用.分开来表示的方法叫做“点分十进制表示法”，这显然比1和0容易记忆得多。</p>
<p>IP地址的组成：IP地址 = 网络号码+主机地址</p>
<p>A类    1.0.0.1—127.255.255.254</p>
<p>(1)10.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)        </p>
<p>(2)127.X.X.X是保留地址，用做循环测试用的。</p>
<p>B类    128.0.0.1—191.255.255.254    </p>
<p>172.16.0.0—172.31.255.255是私有地址。</p>
<p>169.254.X.X是保留地址。</p>
<p>C类    192.0.0.1—223.255.255.254    192.168.X.X是私有地址</p>
<p>D类    224.0.0.1—239.255.255.254     </p>
<p>E类    240.0.0.1—247.255.255.254    </p>
<p>DOS命令 ipconfig:查看本机IP地址</p>
<p>ping+IP地址：测试本机与指定的ip地址间的通信是否有问题</p>
<p>127.0.0.1 回环地址,可用于测试本机的网络是否有问题. ping 127.0.0.1  </p>
<p>xxx.xxx.xxx.0 网络地址</p>
<p>xxx.xxx.xxx.255 广播地址</p>
<p>A类IP地址:第一段号码为网络号码，剩下的三段号码为本地计算机的号码</p>
<p>B类IP地址:前二段号码为网络号码，剩下的二段号码为本地计算机的号码</p>
<p>C类IP地址:前三段号码为网络号码，剩下的一段号码为本地计算机的号码</p>
<p>//A类大部分在美国，中国可能有几个。B类一般是校园网之类的。C类是平常我们用的。DE类是保留地址，不用。</p>
<p>为了方便我们对IP地址的获取和操作，java提供了一个类InetAddress 供我们使用。但是这个类没有构造方法</p>
<p>如果一个类没有构造方法：</p>
<p>A：成员全部是静态的（Math，Arrays，Collections）</p>
<p>B：单例设计模式（Runtime）</p>
<p>C：类中有静态方法返回该类的对象（InetAddress）</p>
<p>class Demo{</p>
<p>private Demo(){}</p>
<p>public static Demo getXxx(){</p>
<p>return new Demo();</p>
<p>}</p>
<p>}</p>
<p>成员方法：</p>
<p>public static InetAdress getByName(String host):根据主机名或者ip地址的字符串表示得到IP地址对象</p>
<p>主机名：getHostName</p>
<p>主机Ip地址：getHostAddress</p>
<p>端口号：正在运行的程序的标识</p>
<p>物理端口 网卡口</p>
<p>逻辑端口 我们指的就是逻辑端口</p>
<p>​    A:每个网络程序都会至少有一个逻辑端口</p>
<p>​    B:用于标识进程的逻辑地址，不同进程的标识</p>
<p>​    C:有效端口：0<del>65535，其中0</del>1024系统使用或保留端口。</p>
<p>​    通过一些应用程序就可以查看端口号</p>
<p>协议</p>
<p>UDP：将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小在限制在64k；因无连接，是不可靠协议；不需要建立连接，速度快</p>
<p>TCP：建立连接，形成传输数据的通道；在连接中进行大数据量传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍低</p>
<p>Socket套接字</p>
<p>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</p>
<p>Socket原理机制：</p>
<p>通信的两端都有Socket。</p>
<p>网络通信其实就是Socket间的通信。</p>
<p>数据在两个Socket间通过IO传输。</p>
<p>原则上是先存在接收端。</p>
<p>UDP协议发送数据：</p>
<p>A：创建发送端Socket对象</p>
<p>B：创建数据，并把数据打包</p>
<p>C：调用Socket对象的发送方法发送数据包</p>
<p>D：释放资源</p>
<p>UDP协议接收数据：</p>
<p>A：创建接收端Socket对象</p>
<p>B：创建一个数据包（接收容器）</p>
<p>C：调用Socket对象的接收方法接收数据  阻塞式方法</p>
<p>D：解析数据包，并显示在控制台</p>
<p>E：释放资源</p>
<p>运行的时候先运行接收端，在运行发送端。第二次运行接收端会报错：该端口已经被占用</p>
<p>TCP协议发送数据：</p>
<p>A：创建发送端的Socket对象</p>
<p>B：获取输出流，写数据</p>
<p>C：释放资源</p>
<p>运行的话会出现连接被拒绝的错误。所以TCP协议一定要先开服务器</p>
<p>TCP协议发送数据：</p>
<p>A：创建接收端的Socket对象  ServerSocket</p>
<p>B：监听客户端连接，返回一个对应的Socket对象  阻塞式方法</p>
<p>C：获取输入流，读取数据显示在控制台</p>
<p>D：释放资源</p>
<p>TCP传输容易出现的问题：</p>
<p>客户端连接上服务端，两端都在等待，没有任何数据传输：</p>
<p>因为read方法或者readLine方法是阻塞式。</p>
<p>解决办法：A：再多写一条数据告诉服务器，读到这条就结束（不推荐）</p>
<p>B：Socket提供了一个终止功能：public void shutdownOutput()</p>
<p>shutdownInput（）方法</p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。</p>
<h5 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h5><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OKUeiaP72uRyLxLtgCJqzyegqJrXr5UdiaLB9wpXuEpfjflJAG5ALCN2um0YKmxJeNZfJejcECbfocuwrsKuttOw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>特点：</p>
<ol>
<li>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</li>
<li>无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</li>
<li>基于请求和响应：基本的特性，由客户端发起请求，服务端响应</li>
<li>简单快速、灵活</li>
<li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.18.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="ckqk8k3df001y2wwda8w36f5k" data-title="网络编程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.19.多线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.19.%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T03:35:24.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.19.%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>程序只有一个执行流程，所以这样的程序就是单线程程序。</p>
<p>假如一个程序有多条执行流程，那么，该程序就是多线程程序。</p>
<p>线程是依赖于进程而存在的</p>
<p>进程：就是正在运行的程序。</p>
<p>是系统进行资源分配和调用的独立单位，每一个进程都有它自己的内存空间和系统资源。</p>
<p>单进程的计算机只能做一件事情，现在的计算机都是支持多进程的。可以在一个时间段内执行多个任务，并且可以提高CPU的使用率。</p>
<p>单CPU在某个时间点只能做一件事情，CPU在做程序间的高效切换让我们觉得是同时进行的。</p>
<p>线程：在同一个进程内又可以执行多个任务，而这每一个任务就可以看作是一个线程。是进程中的单个顺序控制流，是一条执行路径</p>
<p>线程是程序的执行单元，执行路径。是程序使用CPU的最基本的单位。</p>
<p>一个进程如果只有一条执行路径，则称为单线程程序。</p>
<p>一个进程如果有多条执行路径，则称为多线程程序。</p>
<p>多线程的存在不是提高程序的执行速度，其实是为了提高应用程序的使用率。</p>
<p>程序的执行其实都是在抢CPU的资源，CPU的执行权，多个线程都在抢这个资源，而其中的某一个进程如果执行路径比较多，就会有更高的几率抢到CPU的执行权。我们不敢保证哪一个线程能够在哪个时刻抢到，所以线程的执行有随机性。</p>
<p>并行：逻辑上同时发生，指在某一个时间内同时运行多个程序</p>
<p>并发：物理上同时发生。指在某一个时间点同时运行多个程序</p>
<p>java程序的运行原理：由java命令启动了JVM，JVM启动就相当于启动了一个进程。接着由该进程创建了一个主线程去调用main方法</p>
<p>jvm虚拟机的启动是单线程的还是多线程的？</p>
<p>多线程的。因为垃圾回收线程也要先启动，否则就会出现内存溢出。</p>
<p>如何实现多线程的程序：</p>
<p>A：继承Thread类</p>
<p>步骤：1.自定义类继承Thread类</p>
<p>\2. 在自定义类内重写run()方法</p>
<p>\3. 创建该类的对象</p>
<p>\4. 启动线程</p>
<p>为什么要重写run()方法：不是类中的所有代码都需要被线程执行的。为了区分哪些代码能够被线程执行，java提供了Thread类中的run()方法用来包含那些被线程执行的代码</p>
<p>//一般来说，被线程执行的代码肯定是比较耗时的。所以用循环改进</p>
<p>run()和start()方法的区别：</p>
<p>run()仅仅是封装被线程执行的代码，直接调用是普通方法</p>
<p>start()首先启动了线程，然后由jvm去调用该线程的run()方法</p>
<p>如何获取和设置线程名称</p>
<p>public final String getName() 获取线程的名称</p>
<p>public final void setName(String name) </p>
<p>通过构造方法也可以给线程起名字，带参构造</p>
<p>如何获取main方法所在的线程名称呢?</p>
<p>public static Thread currentThread() 返回当前正在执行的线程对象</p>
<p>Thread.currentThread().getName() 这样就可以获取任意方法所在的线程名称</p>
<p>线程有两种调度模型：</p>
<p>分时调度模型:所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</p>
<p>抢占式调度模型:优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 </p>
<p>Java使用的是抢占式调度模型。</p>
<p>如何设置和获取线程优先级</p>
<p>public final int getPriority() 返回线程对象的优先级 线程默认优先级是5</p>
<p>public final void setPriority(int newPriority) 更改线程的优先级 线程优先级的范围是1-10</p>
<p>线程优先级仅仅表示线程获取CPU时间片的几率高，但是要在次数比较多或者多次运行的时候才能看到比较好的效果</p>
<p>线程控制</p>
<p>线程休眠</p>
<p>public static void sleep(long millis)</p>
<p>线程加入</p>
<p>public final void join() 等待该线程终止</p>
<p>线程礼让</p>
<p>public static void yield() 暂停当前正在执行的线程对象，并执行其他线程</p>
<p>让多个线程的执行更和谐，但是不能靠它保证一人一次</p>
<p>后台线程</p>
<p>public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程</p>
<p>当正在运行的线程都是守护线程时，java虚拟机退出，该方法必须在启动线程前调用</p>
<p>中断线程</p>
<p>public final void stop() 已过时。具有不安全性，不建议使用</p>
<p>public void interrupt() 中断线程。把线程状态终止，并抛出一个InterruptedException</p>
<p>线程的生命周期：</p>
<p>新建：创建线程对象</p>
<p>就绪：有执行资格，没有执行权</p>
<p>运行：有执行资格，有执行权</p>
<p>阻塞：由于一些操作让线程处于该状态，没有执行资格，没有执行权。而另一些操作却可以把它激活，激活后处于就绪状态</p>
<p>死亡：线程对象变为垃圾，等待回收</p>
<p>B：实现Runnable接口</p>
<p>步骤：1.自定义类实现Runnable接口</p>
<p>\2. 重写run()方法</p>
<p>\3. 创建自定义类对象</p>
<p>\4. 创建Thread类对象，并把3中的对象作为构造参数传递</p>
<p>B方式的好处，实现接口方式的好处：</p>
<p>可以避免由于Java单继承带来的局限性。</p>
<p>适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。</p>
<p>电影院售票出现问题：</p>
<p>1.相同的票出现多次：CPU的一次操作必须是原子性的</p>
<p>2.还出现了负数的票：随机性和延迟导致的</p>
<p>判断是否有多线程问题的标准：</p>
<p>1.是否是多线程环境</p>
<p>2.是否有共享数据</p>
<p>3.是否有多条语句操作共享数据</p>
<p>解决线程安全问题实现：</p>
<p>1.同步代码块</p>
<p>格式：</p>
<p>​        synchronized(对象){需要同步的代码;}</p>
<p>同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。这个对象可以是任意对象。</p>
<p>同步的前提：多个线程，多个线程使用的是同一个锁对象</p>
<p>同步的好处：同步的出现解决了多线程的安全问题。</p>
<p>同步的弊端：当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</p>
<p>2.同步方法</p>
<p>就是把同步关键字加到方法上（一般在权限修饰符后面）</p>
<p>同步方法的锁对象是：this</p>
<p>静态方法的同步方法的锁对象：是当前类的字节码文件对象。（反射）</p>
<p>如果锁对象是this，就可以考虑使用同步方法。</p>
<p>否则能使用同步代码块的尽量使用同步代码块。</p>
<p>线程安全的类：</p>
<p>StringBuffer  </p>
<p>Vector&lt;&gt; 即使要安全，也不用。可以用Collections工具类中的静态方法synchronizedXxx方法</p>
<p>Hashtable&lt;,&gt;</p>
<p>JDK5以后提供了一个新的锁对象Lock</p>
<p>Lock是一个接口</p>
<p>void lock() 获取锁</p>
<p>void unlock() 释放锁</p>
<p>ReentrantLock Lock的实现类。这个类同时也实现了序列化Serializable接口</p>
<p>可能加锁后的代码会出问题，导致无法释放锁。所以可以选择加try…finally语句</p>
<p>同步弊端：效率低；如果出现了同步嵌套，就容易产生死锁问题</p>
<p>死锁问题：是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> DieLock <em><strong>*extends*</strong></em> Thread {</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*boolean*</strong></em> flag;</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> main(String[] args) {</p>
<p>​        DieLock l1 = <em><strong>*new*</strong></em> DieLock(<em><strong>*true*</strong></em>);</p>
<p>​        DieLock l2 = <em><strong>*new*</strong></em> DieLock(<em><strong>*false*</strong></em>);</p>
<p>​        l1.start();</p>
<p>​        l2.start();</p>
<p>​    }</p>
<p>​    <em><strong>*public*</strong></em> DieLock(<em><strong>*boolean*</strong></em> flag) {</p>
<p>​        <em><strong>*this*</strong></em>.flag = flag;</p>
<p>​    }</p>
<p>​    @Override</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> run() {</p>
<p>​        <em><strong>*if*</strong></em> (flag) {</p>
<p>​            <em><strong>*synchronized*</strong></em> (MyLock.****<em>objA*</em>***) {</p>
<p>​                System.****<em>out*</em>***.println(“if的ogjA”);</p>
<p>​                <em><strong>*synchronized*</strong></em> (MyLock.****<em>objB*</em>***) {</p>
<p>​                    System.****<em>out*</em>***.println(“if的ogjB”);</p>
<p>​                }</p>
<p>​            }</p>
<p>​        } <em><strong>*else*</strong></em> {</p>
<p>​            <em><strong>*synchronized*</strong></em> (MyLock.****<em>objB*</em>***) {</p>
<p>​                System.****<em>out*</em>***.println(“else的ogjB”);</p>
<p>​                <em><strong>*synchronized*</strong></em> (MyLock.****<em>objA*</em>***) {</p>
<p>​                    System.****<em>out*</em>***.println(“else的ogjA”);</p>
<p>​                }</p>
<p>​            }</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>线程间通信问题：不同种类的线程间针对同一个资源的操作</p>
<p>通过设置线程(生产者)和获取线程(消费者)针对同一个对象进行操作</p>
<p>1.如何保证是同一个对象的操作：在外界把这个对象创建出来，然后通过构造方法传递给其他的类。</p>
<p>2.CPU的时间片在很短的时间内可以执行很多条代码会产生相同的数据，线程抢占的随机性也会导致安全问题：所以要加锁。不同种类的线程都要加锁，而且这加的锁必须是同一把才能保证安全。（传的对象要是同一个）</p>
<p>3.如果消费者先抢到执行权，就会先执行，但是会输出默认值，无意义。如果生产者先抢到先执行后再抢到会继续生产，不合常理。所以应该：生产者先看是否有数据，有就等待，没有就生产，生产完之后通知消费者来消费数据。消费者先看是否有数据，有就消费，没有就等待，通知生产者生产数据。</p>
<p>所以java提供了一种机制：等待唤醒机制实现数据依次出现</p>
<p>Object类中提供了三个方法：</p>
<p>wait()  等待  会立即释放锁，当唤醒时从此处继续执行</p>
<p>notify()  唤醒单个线程  唤醒并不代表立即执行，还需要抢夺执行权</p>
<p>notifyAll()  唤醒所有线程</p>
<p>为什么这些方法不定义在Thread类中：因为这些方法的调用必须通过锁对象调用，而我们使用的同步块锁对象是任意锁对象。所以这些方法必须定义在Object类中</p>
<p>把同步代码块改进为同步方法实现，以后只需要调用方法即可</p>
<p>ThreadGroup 线程组：把多个线程组合到一起。它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制</p>
<p>线程类里面的方法：</p>
<p>public final ThreadGroup getThreadGroup() </p>
<p>线程组里面的方法：public final String getName()</p>
<p>默认情况下，所有的线程都属于主线程组main</p>
<p>也可以给线程设置分组:创建一个线程组；创建其他线程的时候，把其他线程的组指定为我们自己新建线程组</p>
<p>Thread(ThreadGroup group, Runnable target, String name) </p>
<p>线程组的意义：通过组名称调用方法，可以设置此线程组的各种优先级，状态等等。</p>
<p>线程池</p>
<p>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。</p>
<p>好处：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</p>
<p>在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</p>
<p>JDK5新增了一个Executors工厂类来产生线程池</p>
<p>public static ExecutorService newCachedThreadPool() 创建一个新的缓存线程池</p>
<p>public static ExecutorService newFixedThreadPool(int nThreads) 创建一个int值的线程池</p>
<p>public static ExecutorService newSingleThreadExecutor() 创建一个线程池 相当于是int=1</p>
<p>如何实现线程池的代码：</p>
<p>\1. 创建一个线程池对象，控制要创建几个线程对象</p>
<p>public static ExecutorService newFixedThreadPool(int nThreads) </p>
<p>\2. 这种线程池的线程可以执行：</p>
<p>Runnable对象或者Callable对象代表的线程</p>
<p>做一个类实现Runnable接口</p>
<p>\3. 线程池调用方法：</p>
<p>Future&lt;?&gt; submit(Runnable task)</p>
<p><T> Future<T> submit(Callable<T> task)</p>
<p>4.线程池结束：shutdown()方法</p>
<p>第三种实现线程的方式：实现Callable接口（是带泛型的接口）</p>
<p>这里指定的泛型是call()方法的返回值类型（这里的call()方法相当于那两个方法的run()方法）</p>
<p>好处：</p>
<p>可以有返回值</p>
<p>可以抛出异常</p>
<p>弊端：</p>
<p>代码比较复杂，必须依赖线程池，所以一般不用</p>
<p>匿名内部类方式使用多线程</p>
<p>继承Thread类来实现多线程：</p>
<p>new Thread(){代码…}.start();</p>
<p>实现Runnable接口来实现多线程：</p>
<p>new Thread(new Runnable(){代码…}){}.start();</p>
<p>(如果既继承了Thread类，又实现了Runnable接口，则输出是以继承的Thread类为主，但这是毫无意义的代码)</p>
<p>定时器：可以让我们在指定的时间做某件事情，还可以重复的做某件事情</p>
<p>定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行。在Java中，可以通过Timer和TimerTask类来实现定义调度的功能</p>
<p>Timer类：定时</p>
<p>public Timer() 构造方法</p>
<p>public void schedule(TimerTask task, long delay) delay毫秒后执行任务</p>
<p>public void schedule(TimerTask task,long delay,long period) delay毫秒后执行任务，period毫秒后重复执行</p>
<p>public void cancel()</p>
<p>TimerTask类（抽象类）：任务</p>
<p>public abstract void run()</p>
<p>public boolean cancel()</p>
<p>开发中（基本不用上两种方法，而是使用框架）</p>
<p>Quartz是一个完全由java编写的开源调度框架</p>
<p>sleep()和wait()的区别：</p>
<p>sleep()：必须指时间；不释放锁</p>
<p>wait():可以不指时间，也可以指时间；释放锁</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.19.%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="ckqk8k3df00202wwd05f31qim" data-title="多线程" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/30/4.27.%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">序列化与反序列化</a>
          </li>
        
          <li>
            <a href="/2021/06/28/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/">电商项目</a>
          </li>
        
          <li>
            <a href="/2021/06/24/4.26.JSR/">JSR</a>
          </li>
        
          <li>
            <a href="/2021/06/24/31.3.%E8%85%BE%E8%AE%AF%E4%BA%91%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9A%84%E5%BC%80%E5%8F%91/">腾讯云音视频的开发</a>
          </li>
        
          <li>
            <a href="/2021/06/23/%E7%94%B3%E8%AF%B7%E8%BD%AF%E8%91%97/">申请软著</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>