<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/4/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-9.4.WEB之JSP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.4.WEB%E4%B9%8BJSP/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:29:46.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.4.WEB%E4%B9%8BJSP/">WEB之JSP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JSP：Java Server Pages (Java服务器端页面)，其实就是在HTML中嵌入Java代码。</p>
<p>JSP将Java代码和特定变动内容嵌入到静态的页面中，实现以静态页面为模板，动态生成其中的部分内容。</p>
<p>JSP引入了被称为“JSP动作”的XML标签，用来调用内建功能。另外，可以创建JSP标签库，然后像使用标准HTML或XML标签一样使用它们。标签库能增强功能和服务器性能，而且不受<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台</a>问题的限制。</p>
<p>JSP文件在运行时会被其编译器转换成更原始的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Servlet">Servlet</a>代码。JSP编译器可以把JSP文件编译成用Java代码写的Servlet，然后再由Java编译器来编译成能快速执行的二进制<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E7%A0%81">机器码</a>，也可以直接编译成二进制码。</p>
<p>SUN公司提供了动态网页开发技术：Servlet。Servlet技术生成动态网页的时候很麻烦，需要通过response获得输出流，调用print方法进行打印的。这种编程方式很麻烦，而且美工也不容易处理，SUN公司发现了这些问题，推出了一个新的动态网页开发技术JSP。</p>
<p>缺点：Servlet需要进行配置，不方便维护；Servlet很难向网页中输出HTML页面内容</p>
<p>JSP的简单使用：</p>
<p>创建一个web项目，2.5版本，finish。在WebContent下新建一个包，新建一个JSPfile。将其中的编码改为UTF-8</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps1.jpg" alt="img"> </p>
<p>JSP需要发布到服务器中才可以运行：</p>
<p>在services中添加这个web项目，finish。启动服务器。浏览器输入访问。</p>
<p>运行原理：JSP文件翻译成Java文件，将这个Java文件编译生成class文件，运行class文件。JSP在执行时，会被服务器翻译为Servlet编译执行，JSP就是一个Servlet。</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps2.jpg" alt="img"> </p>
<p>JSP = HTML + Java代码 + JSP自身东西</p>
<p>JSP的脚本元素就是在JSP中嵌入Java代码。</p>
<p>分类：</p>
<p>1.声明标签：写在这个脚本中的代码，翻译成Servlet内部的成员变量或成员方法（JSP声明 翻译成 Servlet成员部分的内容。声明变量，方法，内部类）</p>
<p>语法：&lt;%! 变量或方法声明 %&gt;</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps3.jpg" alt="img"> </p>
<p>2.表达式标签：写在这个脚本中的代码，翻译成方法内部的out.print();当中的内容（翻译out.print(),在service方法内部。用于生成HTML页面源码）</p>
<p>语法：&lt;%= 表达式 %&gt;</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps4.jpg" alt="img"> </p>
<p>3.程序代码标签：写在这个脚本中的代码，翻译成方法内部的局部变量或方法内部代码片段（嵌入Java代码 翻译成service方法内部的代码块。声明变量，内部类）</p>
<p>语法：&lt;% 程序代码 %&gt;</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps5.jpg" alt="img"> </p>
<p>因为Servlet被认为是线程不安全的，所以用声明标签来定义局部变量不合适，一般都会用程序代码标签来定义变量。</p>
<p>JSP的开发模式：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps6.jpg" alt="img"> </p>
<p>以后开发一般都用MVC开发模式</p>
<p>开发中的路径问题：</p>
<p>提供一些页面，在页面中会提供链接或者表单，当点击链接或者表单的时候需要进行提交，提交到Servlet中。从页面向Servlet发送请求的地址（路径）应该如何编写。</p>
<p>路径的分类：</p>
<p>1.相对路径：相对路径不是以 / 开头的</p>
<p>比如：</p>
<p>在根路径下的页面访问Servlet：</p>
<p>假如demo2.jsp的访问路径：<a target="_blank" rel="noopener" href="http://localhost:8080/web02/demo2.jsp">http://localhost:8080/web02/demo2.jsp</a></p>
<p>ServletDemo1的访问路径：<a target="_blank" rel="noopener" href="http://localhost:8080/web02/ServletDemo1">http://localhost:8080/web02/ServletDemo1</a></p>
<p>则：<img src="/9.4.WEB%E4%B9%8BJSP/wps7.jpg" alt="img"></p>
<p>加不加./都可以</p>
<p>在某个目录下的页面访问Servlet：</p>
<p>假如demo2.jsp的访问路径：<a target="_blank" rel="noopener" href="http://localhost:8080/web02/demo2/demo2.jsp">http://localhost:8080/web02/demo2/demo2.jsp</a></p>
<p>ServletDemo1的访问路径：<a target="_blank" rel="noopener" href="http://localhost:8080/web02/ServletDemo1">http://localhost:8080/web02/ServletDemo1</a></p>
<p>则：<img src="/9.4.WEB%E4%B9%8BJSP/wps8.jpg" alt="img"></p>
<p>需要先返回上一级再去访问</p>
<p>2.绝对路径（通常用这个）：通常以 / 开始的路径</p>
<p><em><strong>*使用绝对路径，不需要关心当前文件和要请求的文件的相对位置的关系*</strong></em></p>
<p><em><strong>*绝对路径分成服务器端路径和客户端路径*</strong>***</em>*：****</p>
<p><em><strong>*客户端路径  需要带工程名*</strong></em></p>
<p><em><strong>*服务器端路径 不需要带工程名*</strong></em></p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps9.jpg" alt="img"> </p>
<p>这个例子的工程名是web02</p>
<p>JSP的模板修改JSP的字符集编码：在window下的Preferences中找到jsp</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps10.jpg" alt="img"> </p>
<p>JSP的注释：</p>
<p>1.HTML的注释：</p>
<p>写法：<!--HTML的注释 --></p>
<p>存在时机：存在JSP的源码中，翻译成Servlet后这个注释也存在，在生成HTML响应到页面的时候这个注释也会存在。</p>
<p>2.JAVA代码的注释：</p>
<p>写法：&lt;% // 单行注释 </p>
<p>/* 多行注释 */ </p>
<p>/*<em>文档注释</em>/</p>
<p> %&gt;</p>
<p>存在时机：存在JSP的源码中，翻译成Servlet后Java代码的注释也会存在，但是生成HTML响应到页面后，这种注释就消失了。</p>
<p>3.JSP自身的注释：</p>
<p>写法：&lt;%– JSP的注释 –%&gt;</p>
<p>存在时机：存在JSP的源码中，翻译Servlet后注释就没有了。</p>
<p>注意：HTML的注释只能注释一些元素，不能注释java代码</p>
<h1 id="JSP的指令元素"><a href="#JSP的指令元素" class="headerlink" title="JSP的指令元素"></a>JSP的指令元素</h1><p>作用：用于指示JSP执行的某些步骤；用于指示JSP变现特定行为</p>
<p>语法：&lt;%@ 指令名称 属性名称=属性的值 属性名称=属性的值 %&gt;</p>
<p>分类：</p>
<p>page指令：指示JSP的页面设置属性和行为</p>
<p>include指令：指示JSP包含哪些其他页面</p>
<p>taglib指令：指示JSP页面包含哪些标签库</p>
<p>page指令：</p>
<p>写法：&lt;%@ page 属性名=属性值 属性名=属性值 属性名=属性值 %&gt;</p>
<p>Page指令用来定义JSP文件的全局属性。</p>
<p>这些属性可以单独使用，也可以几个或多个同时使用。</p>
<p>在JSP页面中，只有import属性可以出现多次，其他属性都只能出现一次。</p>
<p>language属性：声明使用脚本的语言。只能是java。</p>
<p>extends属性：标明JSP编译成Servlet的时候继承的类。默认值：HttpJspBase。</p>
<p>session属性：标明JSP中是否可以直接使用session对象。默认值是true。</p>
<p>buffer属性：标明JSP对客户端输出缓冲区大小。默认值8kb。</p>
<p>autoFlush属性：如果缓冲区大小溢出，是否自动刷出。默认true。</p>
<p><em><strong>*import属性：用于导入Java包或类。*</strong>***</em>*（*<strong><strong><strong>*写完java代码后alt+/自动导入*</strong></strong></strong>*）****</p>
<p><em><strong>*contentType属性：标明JSP被浏览器解析和打开的时候采用的默认的字符集。*</strong></em></p>
<p><em><strong>*pageEncoding属性：JSP文件及JSP翻译后的Servlet保存到硬盘上采用字符集。*</strong></em></p>
<p>isErrorPage属性：处理JSP页面异常。默认为false，改为true后，可以&lt;%= exception.getMessage&gt;就可以输出异常信息</p>
<p>errorPage属性：处理JSP页面异常。(后面可以跟一个jsp的页面地址，当出现异常时，就可以跳转到)</p>
<p>isELIgnored属性：通知JSP是否忽略EL表达式。默认是false。改为true后，EL内的信息会直接输出，EL写进标签就会报错。</p>
<p>include指令：</p>
<p>写法：&lt;%@ include 属性名=属性值%&gt;</p>
<p>作用：在JSP页面中****静态包含****一个文件，同时由该JSP解析包含的文件内容。</p>
<p>file属性：指示JSP页面包含页面路径。</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps11.jpg" alt="img"> </p>
<p>注意：应该将被包含的页面的结构去掉（会有重复的HTML标签，被包含的去掉）。在被包含的页面中定义变量，在包含的页面中还可以使用。</p>
<p>taglib指令:</p>
<p>写法：&lt;%@ taglib 属性名=属性值%&gt;</p>
<p>作用：用于在JSP页面中引入标签库。</p>
<p>uri属性：引入的标签库的路径</p>
<p>prefix属性：引入标签库的别名（前缀）</p>
<p>JSP的内置对象：指的是可以直接在JSP页面中使用的对象。</p>
<p>JSP当中有9大内置对象（具体类型）：</p>
<p>l request（HttpServletRequest）：从客户端向服务器发送的请求对象</p>
<p>l response    （HttpServletResponse）：从服务器端向客户端作出响应对象</p>
<p>l session    （HttpSession）：服务器为客户端创建会话对象</p>
<p>l application（ServletContext）：代表应用。获得的ServletContext对象。</p>
<p>l out    （JspWriter）：向输出流写入内容的对象。</p>
<p>l page（Object）：当前的JSP翻译成Servlet后的对象的引用。</p>
<p>l pageContext    （PageContext）：本JSP的页面的上下文对象。</p>
<p>l config（ServletConfig）：本JSP的ServletConfig对象。</p>
<p>l exception（Throwable）：表示JSP页面运行时产生的异常对象。</p>
<p>pageContext对象：pageContext对象直接翻译为“页面上下文”对象，代表的是当前页面运行的一些属性。</p>
<p>它是javax.servlet.jsp.PageContext类的实例对象。</p>
<p>1.提供了page范围的数据存取的方法：</p>
<p>向page范围中存入数据：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps12.jpg" alt="img"> </p>
<p>从page范围获取数据</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps13.jpg" alt="img"> </p>
<p>从page范围移除数据</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps14.jpg" alt="img"> </p>
<p>查找属性的方法：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps15.jpg" alt="img"> </p>
<p>2.通过这个对象获得其他的8个内置对象：</p>
<p>获得其他8个内置对象的方法</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps16.jpg" alt="img"> </p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps17.jpg" alt="img"> </p>
<p>JSP的四个作用范围</p>
<p>PageScope：页面范围。</p>
<p>页面范围指的是在当前的页面内有效，出了这个页面，用pageContext保存的数据就无效了。</p>
<p>RequestScope：请求范围。</p>
<p>从客户端向服务器发送一次请求，服务器对这次请求作出了响应之后，用request保存的数据就无效了。</p>
<p>SessionScope：会话范围。</p>
<p>每个浏览器向服务器发送请求（多次请求）。将该会话结束，用session保存的数据就无效了。</p>
<p>ApplicationScope：应用范围。</p>
<p>在整个应用中任意的地方都可以获取。用application保存。</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps18.jpg" alt="img"> </p>
<p>调取的时候使用重载方法：</p>
<p>pageContext.getAttribute(“name”,PageContext.SESSION_SCOPE)</p>
<p>findAttribute方法：查找属性方法，先根据小范围的名称进行查找，如果找到了就返回，如果没有找到就会去比其大一个域的范围进行查找。（page–request–session–application）</p>
<p>JSP的动作标签：用于在JSP页面中提供业务逻辑功能，避免在JSP页面中直接编写Java代码（会有大量的&lt;%  &gt;），造成jsp页面难以维护。</p>
<p>常用的动作标签：</p>
<p><em><strong>*&lt;jsp:forward**** ****page=“”********&gt;*</strong></em> <em><strong>*&lt;********/********jsp:forward********&gt;*</strong></em>    <em><strong>*：请求转发。*</strong></em></p>
<p><em><strong>*&lt;jsp:include**** ****page=********””********&gt;*</strong></em> <em><strong>*&lt;/********jsp:include********&gt;*</strong>***</em>*：包含（*<strong><strong><strong>*是一种*</strong></strong></strong>*动态包含）。****</p>
<p>&lt;jsp:param value=“” name=“” /&gt;：传递参数。（很少使用，因为可以用set/getAttribute来设置获取参数）</p>
<p>动态包含的原理：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps19.jpg" alt="img"> </p>
<p>查看Tomcat的work下的localhost下的项目下会找到被包含的jsp都被编译成了java和clss文件。</p>
<h1 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h1><p>EL（Expression Language） 是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。</p>
<p>EL：Expression Language表达式语言。</p>
<p>EL和JSTL一起使用取代JSP页面中嵌入Java代码写法。（去掉&lt;&gt;和%）</p>
<p>EL的语法：${ EL表达式 }</p>
<p>EL的功能：</p>
<p>1.EL获取数据（域对象中）</p>
<p>EL表达式语句在执行的时候，会调用pageContext.findAttribute()方法。分别从page、request、session、application范围查找相应对象，找到就会返回相应对象，找不到返回””(不是null，是空的字符串)。EL所获取的数据需要在四个作用范围中。</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps20.jpg" alt="img"> </p>
<p>这两种方式的区别：如果没有存入数据，前者获取输出的是null，后者输出的是“”。直接写${name}会先从最小范围查找，找不到的话会向上一级域查找（其实相当于调用了pageContext.findAttribute()方法）。</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps21.jpg" alt="img"> </p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps22.jpg" alt="img"> </p>
<p>（需要引包：alt+/）</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps23.jpg" alt="img"> </p>
<p>如果map的key中包含了特殊字符，不能使用.必须使用[]。</p>
<p>因为：  .用来获取对象的属性的  []用来获得下标</p>
<p>例如，包含特殊字符.</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps24.jpg" alt="img"> </p>
<p><em><strong>*2.*</strong>***</em>*EL执行运算****</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps25.jpg" alt="img"> </p>
<p>会自动类型转换，即使是字符串，也会转换成算数运算</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps26.jpg" alt="img"> </p>
<p>lt：less than   gt：great than   ne：not equal</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps27.jpg" alt="img"> </p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps28.jpg" alt="img"> </p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps29.jpg" alt="img"> </p>
<p>判断一个对象是否为空 也可以${not empty user}</p>
<p>不支持位运算</p>
<p><em><strong>*3.*</strong>***</em>*EL获取web开发常用的对象****</p>
<p>EL表达式定义了11个web开发常用对象。使用这些对象可以很方便获取web开发中的一些常见对象，并可以读取这些对象中的数据。</p>
<p><em><strong>*pageContext*</strong></em>    ：相当于JSP内置对象中pageContext（可以通过这个获取其他八个对象）</p>
<p>pageScope：获取指定域下的名称的数据</p>
<p>requestScope：获取指定域下的名称的数据</p>
<p>sessionScope：获取指定域下的名称的数据</p>
<p>applicationScope    ：获取指定域下的名称的数据</p>
<p>param：在页面中接收请求参数（接收一个名称对应一个值参数）。相当于requset.getParam</p>
<p>paramValues    ：在页面中接收请求参数（接收一个名称对应多个值参数）。</p>
<p>header：在页面上获取请求头（获取一个key对应一个value 头）</p>
<p>headerValues：在页面上获取请求头（获取一个key对应多个value 头）</p>
<p>cookie：访问cookie的名称和值（${cookie.key.name} ${cookie.key.value}）</p>
<p>initParam：获取全局初始化参数的值</p>
<p>4.EL调用Java方法（基本不用）</p>
<h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><p>JSTL（Java server pages standarded tag library，即JSP标准标签库）是由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JCP/2679009">JCP</a>（Java community Proces）所制定的标准规范，它主要提供给Java Web开发人员一个标准通用的标签库，并由Apache的Jakarta小组来维护。开发人员可以利用这些标签取代JSP页面上的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Java/85979">Java</a>代码，从而提高程序的可读性，降低程序的维护难度。</p>
<p>JSTL：JSP的标准标签库。</p>
<p>JSTL主要是和EL来取代传统页面上直接嵌入Java代码写法。提升程序可读性、维护性和方便性。</p>
<p>版本：JSTL1.0、JSTL1.1和JSTL1.2版本</p>
<p>1.0版本不支持EL表达式。<em><strong>*1.1和1.2支持了EL表达式。*</strong></em></p>
<p>标签库：</p>
<p><em><strong>*c标签（core标签库*</strong>***</em>*，*<strong><strong><strong>*核心标签库*</strong></strong></strong>*）****</p>
<p>fmt标签（国际化标签库）</p>
<p>xml标签（后台编写，前台标签不怎么用）</p>
<p>sql标签（后台编写，前台标签不怎么用）</p>
<p><em><strong>*jstl函数库（EL函数）*</strong></em></p>
<p>使用：先导入JSTL的jar包到lib中</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps30.jpg" alt="img"> </p>
<p>新建一个jsp页面：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps31.jpg" alt="img"> </p>
<p>在上面导入标签库：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps32.jpg" alt="img"> </p>
<p>可以直接使用：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps33.jpg" alt="img"> </p>
<p>value相当于是值，var相当于是name，scope是域对象的范围</p>
<p>JSTL有很多标签，可以查看文档使用，用的较多的是：</p>
<p>JSTL的if标签使用：只有if没有else</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps34.jpg" alt="img"> </p>
<p>test属性：条件</p>
<p>var属性：将test中的条件的值赋给一个变量，在var中定义变量</p>
<p>scope属性：作用范围</p>
<p>&lt;c:if  var=”flag” test=”${ i&lt;10 }” scope =”page”&gt;  </c:if > </p>
<p>后面可以直接使用flag  </p>
<p>&lt;c:if  test=”${flag }” &gt;  </c:if ></p>
<p>JSTL的forEach标签使用：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps35.jpg" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.4.WEB%E4%B9%8BJSP/" data-id="ckvc2kudc002o9kwd8to39zug" data-title="WEB之JSP" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-9.3.WEB之servlet" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.3.WEB%E4%B9%8Bservlet/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:29:35.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.3.WEB%E4%B9%8Bservlet/">WEB之servlet</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>动态网页的开发：Servlet和JSP</p>
<p>Servlet其实就一个运行在web服务器上的小的Java程序，用于处理从web客户端发送的请求，并且对请求作出响应。</p>
<p>静态页面不能写循环，判断，SQL等语句。而Servlet就可以写。</p>
<p>使用Servlet：编写一个Java类实现Servlet的接口；配置Servlet</p>
<p>相关内容可以查JAVAEE的API中的Servlet</p>
<p>1.创建一个项目，在<img src="/9.3.WEB%E4%B9%8Bservlet/wps1.jpg" alt="img">中建包建类</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps2.jpg" alt="img"> </p>
<p>其他方法保持不变</p>
<p>2.配置这个类，在WEB-INF下的web.xml中配置</p>
<p>双击类名，右击copy全路径</p>
<p>前后的servlet-name必须要一致</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps3.jpg" alt="img"> </p>
<p>启动服务器，打开浏览器：<a target="_blank" rel="noopener" href="http://localhost:8080/web_test/hello">http://localhost:8080/web_test/hello</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/web_test/+%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84">http://localhost:8080/web_test/+访问路径</a></p>
<p>执行流程：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps4.jpg" alt="img"> </p>
<p>Servlet的实现关系：</p>
<p>Servlet接口            </p>
<p>​    |</p>
<p>​    |</p>
<p>GenericServlet类        通用的Servlet，是一个与协议无关的Servlet</p>
<p>​    |</p>
<p>​    |</p>
<p>HttpServlet类            Http专用的Servlet</p>
<p>SUN设计之初，是有野心，以后的互联网不仅仅只使用http协议，其他协议就可以通过GenericServlet实现。HttpServlet是一个与协议相关的Servlet是专门用来处理HTTP协议的请求。通常编写一个Servlet一般都会让这个Servlet<em><strong>*继承HttpServlet重写service方法*</strong>***</em>*（*<strong><strong><strong>*不用再实现Servlet接口，因为会有很多用不到的方法也要重写*</strong></strong></strong>*）****<em><strong>*。*</strong></em></p>
<p><em><strong>*查看源码可以知道，*</strong>***</em>*在service方法内部根据请求方式不同执行不同的doXXX的方法（get请求执行doGet方法，如果是post请求就会执行doPost方法）。****</p>
<p><em><strong>*所以*</strong>***</em>*一般*<strong><strong><strong>*继承了HttpServlet之后不需要重写service方法，只需要重写doGet和doPost方法即可。往往请求要处理的内容的代码都是一致的，所以需要让doGet和doPost相互调用可以简化编程*</strong></strong></strong>*（*<strong><strong><strong>*编码一次，另一个方法调用这个方法即可*</strong></strong></strong>*）****<em><strong>*。*</strong></em></p>
<p>Eclipse中使用Servlet模版：（不用在web.xml中修改完成配置，这样是自动完成了Servlet的配置）</p>
<p>右击new的时候选择新建Servlet；输入name（默认继承了HttpServlet）后，点击next；对Servlet进行配置：name和前面一致（一般不用改），URL mapping就是访问名字（右边edit可以修改），点击next；构造方法可以不用选，重写方法选择doGet和doPost方法。点击finish</p>
<p>生命周期：一个对象从创建到销毁过程</p>
<p>Servlet生命周期：Servlet对象从创建到销毁的过程</p>
<p>Servlet中有****init,service,destroy****方法，这几个方法称为是Servlet生命周期相关的方法</p>
<p>Servlet是在第一次被访问的时候会被实例化，只要Servlet一被实例化那么Servlet中的init方法就会执行（init只会执行一次，Servlet是单例的）。</p>
<p>任何一次从客户端发送来的请求，那么Servlet中的service方法就会执行（在service方法的内部根据请求的方式不同调用不同doXXX方法）。</p>
<p>当Servlet从服务器中移除或者服务器关闭的时候Servlet对象被销毁，里面的destroy方法就会执行，然后垃圾回收就会将其回收掉（在servers下点红色方框关闭服务器，在控制台下的红色方框是强制退出，不是服务器）</p>
<p>Servlet的启动时加载：Servlet对象是第一次被访问的时候会被创建的，init方法就会执行。假设在init方法中做了一些比较耗时的操作（比如：加载了一些配置文件并且解析可能需要花费3秒钟）。第一个用户第一次访问这个Servlet的时候，需要等待3秒钟，这样会使体验感很差，所以要改为启动时加载。</p>
<p>Servlet默认是在第一次访问的时候创建的对象，现在通过一个配置将Servlet的实例化的过程放在服务器启动的时候（****让服务器启动的时候创建Servlet的对象****）。如果现在这样做那么之前花费的时间就会在服务器启动的时候一起花费掉了。对于用户来讲就不需要额外花费这个时间。</p>
<p>在web.xml中配置。值越小，优先级越高。有一个默认的Servlet启动优先级为1，所以配置的最高为2。（可以在Tomcat的conf下的web.xml中查看文档）</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps5.jpg" alt="img"> </p>
<p>Servlet的访问路径的配置：<url-pattern>的配置方式</p>
<p>1.完全路径匹配：以 / 开始   比如：/ServletDemo1    /aaa/ServletDemo2</p>
<p>2.目录匹配：以 / 开始，以 /<em>结束  比如：/</em>    /aaa/*    /aaa/bbb/*</p>
<p>3.扩展名匹配：不能以 / 开始，以<em>开始        比如：</em>.action    *.do    *.jsp</p>
<p>（*代表的是任意字符）</p>
<p>访问的优先级：完全路径匹配  &gt;  目录匹配  &gt;  扩展名匹配</p>
<p>如果输入的三个都匹配，比如：/aaa/ServletDemo2.do  实际会先进行完全路径的匹配，再进行目录匹配，最后是扩展名匹配。</p>
<p>ServletConfig对象：</p>
<p>ServletConfig用来获得Servlet的相关的配置的对象。（init方法中可以传递这个对象）</p>
<p>获得ServletConfig对象：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps6.jpg" alt="img"> </p>
<p>ServletConfig对象的API：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps7.jpg" alt="img"> </p>
<p>获得Servlet的初始化参数（值和名字） <param-name><param-value></p>
<p>获得ServletContext对象</p>
<p>获得Servlet的名称<servlet-name></servlet-name></p>
<p>配置初始化参数的例子：在web.xml中添加配置：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps8.jpg" alt="img"> </p>
<p>实现：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps9.jpg" alt="img"> </p>
<p>ServletContext对象：</p>
<p>ServletContext：Servlet的上下文对象。ServletContext对象对Servlet之前和之后的内容都知道。这个对象一个web项目只有一个。在服务器启动的时候为每个web项目创建一个单独的ServletContext对象。</p>
<p>作用：</p>
<p>1.用来获取web项目信息：因为一个web项目只有一个ServletContext对象，所以这个对象对整个项目的相关内容都是了解的</p>
<p>获取文件的MIME类型：文件上传和下载的时候会用到这个方法（这些类型都可以在conf下的web.xml中找到）</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps10.jpg" alt="img"> </p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps11.jpg" alt="img"> </p>
<p>获取web项目请求工程名：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps12.jpg" alt="img"> </p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps13.jpg" alt="img"> </p>
<p>获取web项目的初始化参数：全局的参数</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps14.jpg" alt="img"> </p>
<p>可以在前面配置全局的初始化参数（原来的局部配置参数是在Servlet标签内部配置的，现在配置全局的话在最前面配置）</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps15.jpg" alt="img"> </p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps16.jpg" alt="img"> </p>
<p>2.读取web项目下的文件：之前使用IO流就可以读取文件（java项目中）。现在是一个web项目，web项目需要发布到tomcat下才能访问的。获取web项目下的文件如果使用传统的IO就会出现问题（原因：路径中使用的是相对路径，相对的是JRE环境，是Tomcat的bin路径）。</p>
<p>使用getServletContext的getResourceAsStream方法或者getServletContext的getRealPath方法</p>
<p>以/开头的都是相对路径。</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps17.jpg" alt="img"> </p>
<p>3.作为域对象存取数据：</p>
<p>域对象：指的是将数据存入到域对象中，这个数据就会有一定的作用范围。域指的是一定的作用范围。</p>
<p>作为域对象的API：</p>
<p>存入数据的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps18.jpg" alt="img"> </p>
<p>获取数据的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps19.jpg" alt="img"> </p>
<p>移除数据的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps20.jpg" alt="img"> </p>
<p>作用范围：</p>
<p>ServletContext是在服务器启动的时候为每个web项目单独创建一个ServletContext对象。当web项目从服务器中移除，或者是关闭服务器的时候ServletContext对象会被销毁。向ServletContext中保存的数据一直存在（当服务器关闭的时候ServletContext对象被销毁，然后里面数据才会失效）。<em><strong>*范围：整个web应用。*</strong></em></p>
<p>例子：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps21.jpg" alt="img"> </p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps22.jpg" alt="img"> </p>
<p>在demo7中初始化的时候存入数据，发现访问demo7和8的时候都能访问到name的值，所以ServletContext的域对象是整个web应用。</p>
<p>开发的软件是B/S结构的软件，可以通过浏览器访问服务器的软件。</p>
<p>从浏览器输入一个地址访问服务器（将这个过程称为是请求：将浏览器向服务器发送的数据的封装）。服务器接收到请求，需要进行处理，处理以后需要将处理结果显示回浏览器端（将这个过程称为是响应：将服务器向浏览器发送数据的封装）。</p>
<p>Response对象：</p>
<p>Response关于响应行的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps23.jpg" alt="img"> </p>
<p>设置响应的状态码：</p>
<p>200 正确</p>
<p>302 重定向</p>
<p>304 查找本地缓存</p>
<p>404 请求资源不存在</p>
<p>500 服务器内部错误</p>
<p>Response关于响应头的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps24.jpg" alt="img"> </p>
<p>set开头的方法：针对一个key对应一个value的情况</p>
<p>举例：比如有一个头 </p>
<p>content-Type:text/html  setHeader(“content-Type”,”text/plain”);</p>
<p>最终得到头的结果：content-Type:text/plain</p>
<p>add开头的方法：针对一个key对应多个value的情况</p>
<p>举例：比如有一个</p>
<p>content-Type:text/html     addHeader(“content-Type”,”text/plain”);</p>
<p>最终得到头的结果：content-Type:text/html,text/plain</p>
<p>Response关于响应体的方法：</p>
<p>向页面输出内容：字节和字符</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps25.jpg" alt="img"> </p>
<p>Response其他的API：</p>
<p>重定向的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps26.jpg" alt="img"> </p>
<p>设置浏览器打开页面时候采用的字符集：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps27.jpg" alt="img"> </p>
<p>设置响应字符流的缓冲区字符集：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps28.jpg" alt="img"> </p>
<p>服务器向浏览器回写Cookie的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps29.jpg" alt="img"> </p>
<p>// 一般由服务器向浏览器的方法都能在response中找到</p>
<p>完成重定向：302状态码和Location响应头结合使用的效果</p>
<p>Demo1跳转到了Demo2</p>
<p>也可以使用response.sendRedirect(“/web01/ResponseDemo2”);替换重定向两句写法（实际开发中常用）</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps30.jpg" alt="img"> </p>
<p>定时刷新效果：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps31.jpg" alt="img"> </p>
<p>在HTML中完成页面跳转：使用<meata>标签的http-quiv设置。url的路径在后面介绍</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps32.jpg" alt="img"> </p>
<p>这里的n秒后跳转的n是我们人为输入的定值，不能变化，所以我们可以用JS来完成读秒的效果：</p>
<p>需要n变化，先要对这个n加标签：<span id=”span1”>i</span>,再对<body></body>加方法onload=“load()”，然后编写scrip语句：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps33.jpg" alt="img"> </p>
<p>Response向页面响应中文（可能会出现乱码）</p>
<p>1.使用字节流响应中文</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps34.jpg" alt="img"> </p>
<p>这里的“中文”这两个字可能会产生乱码：因为这个乱码的产生与中文转成字节数组及浏览器打开方式（打开的时候采用的默认字符集）有关</p>
<p>解决办法：将中文转成字节数组的时候和浏览器默认打开的时候采用的字符集一致即可</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps35.jpg" alt="img"> </p>
<p><em><strong>*2.使用字符流相应中文*</strong></em></p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps36.jpg" alt="img"> </p>
<p>这里一定会产生乱码：字符流是有缓冲区的，response获得字符流，response设计默认的缓冲区编码是ISO-8859-1。这个字符集不支持中文的。</p>
<p>解决办法：设置response获得字符流缓冲区的编码和设置浏览器默认打开时候采用的字符集一致即可</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps37.jpg" alt="img"> </p>
<p>字符流向页面响应中文，有一种简化的方式：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps38.jpg" alt="img"> </p>
<p>Request对象：开发的软件都是B/S结构软件，从浏览器向服务器提交一些数据，将这些内容进行封装就封装成了一个请求对象（Request对象）</p>
<p>1.获得客户机信息：</p>
<p>****获得请求的方式****：get还是post</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps39.jpg" alt="img"> </p>
<p>获得请求路径后的提交参数的字符串：？xx=xxx&amp;xxx=xxxxx</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps40.jpg" alt="img"> </p>
<p>获得请求路径的URL和URI：URI范围比URL大（URI，统一资源标识符。URL，统一资源定位符。URI包括URL和URN。URL是全写，URI是名字）</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps41.jpg" alt="img"> </p>
<p>****获得客户机的ip地址****：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps42.jpg" alt="img"> </p>
<p>2.获得请求头的方法：</p>
<p>获得一个key对应一个value的请求头：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps43.jpg" alt="img"> </p>
<p>获得一个key对应多个value的请求头：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps44.jpg" alt="img"> </p>
<p>3****.获得请求参数的方法****：</p>
<p>获得提交的参数（一个name对应一个value）：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps45.jpg" alt="img"> </p>
<p>获得提交的参数（一个name对应多个value）：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps46.jpg" alt="img"> </p>
<p>获得提交的参数，将提交的参数的名称和对应的值存入到一个Map集合中：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps47.jpg" alt="img"> </p>
<p>4.****作为域对象存取数据的方法****：</p>
<p>向request域中存数据：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps48.jpg" alt="img"> </p>
<p>从request域中获取数据：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps49.jpg" alt="img"> </p>
<p>从request域中移除数据：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps50.jpg" alt="img"> </p>
<p>Request对象其实就是从客户端浏览器向服务器发送的一次请求信息的封装。那么实质上向Request中所保存的数据有效期也是<em><strong>*一次请求范围。*</strong></em></p>
<p><em><strong>*一次请求范围：从客户端浏览器向服务器发送一次请求，服务器针对这次请求对浏览器作出响应。当服务器作出响应之后，请求对象就销毁了，保存在其中的数据就无效了。*</strong></em></p>
<p>代码演示：</p>
<p>Request对象获取客户机信息：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps51.jpg" alt="img"> </p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps52.jpg" alt="img"> </p>
<p>Request对象接收表单请求参数：</p>
<p>编写一个静态页面：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps53.jpg" alt="img"> </p>
<p>在RequestDemo2中接收参数：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps54.jpg" alt="img"> </p>
<p>（数组无法直接输出，需要调用Arrays.toString（）方法输出）</p>
<p>Request对象接收表单请求参数的中文乱码处理：</p>
<p>POST方式接收中文：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps55.jpg" alt="img"> </p>
<p>GET方式接收中文：(基本不用，因为一般表单提交都是用post方法)</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps56.jpg" alt="img"> </p>
<p>从Servlet向JSP中跳转的方法：请求转发和重定向</p>
<p>1.请求转发：</p>
<p>通过ServletRequest对象获得RequestDispatcher对象</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps57.jpg" alt="img"> </p>
<p>再根据RequestDispatcher中的方法进行请求转发</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps58.jpg" alt="img"> </p>
<p>代码实现：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps59.jpg" alt="img"> </p>
<p>请求转发后访问Servlet的页面：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps60.jpg" alt="img"> </p>
<p>重定向：</p>
<p>通过HttpServletResponse对象中的以下方法实现重定向</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps61.jpg" alt="img"> </p>
<p>代码实现：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps62.jpg" alt="img"> </p>
<p>重定向后访问Servlet的效果：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps63.jpg" alt="img"> </p>
<p>请求转发和重定向的区别：</p>
<p>请求转发是一次请求一次响应，而重定向是两次请求两次响应。</p>
<p>请求转发地址栏不会变化的，重定向地址栏发生变化。</p>
<p>请求转发路径不带工程名，重定向需要带工程名路径。</p>
<p>请求转发只能在本网站内部，重定向可以定向到任何网站。</p>
<p><em><strong>*如果需要使用request进行值传递，需要通过请求转发完成。如果页面需要跳转到其他网站上必须使用重定向。*</strong></em></p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps64.jpg" alt="img"> </p>
<p>因为request对象作为域对象的范围是一次请求，所以如果JSP需要获取request中的数据的话，只能用请求转发；如果用重定向的话，存入的值会获取不到，为null。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.3.WEB%E4%B9%8Bservlet/" data-id="ckvc2kudb002m9kwd6fv0g59t" data-title="WEB之servlet" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-9.2.WEB之http协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:29:20.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/">WEB之http协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>HTTP协议：规定了浏览器和服务器端的数据交互的格式</p>
<p>http是一个简单的请求-响应协议，它通常运行在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/TCP/33012">TCP</a>之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。HTTP是应用层协议。</p>
<p>特性：</p>
<p>1.基于请求和响应模型：必须要先有请求，后有响应；请求和响应必须成对出现</p>
<p>2.简单快捷：因为发送请求的时候只需要发送请求方式和请求路径即可</p>
<p>版本：</p>
<p>HTTP1.0：该协议对每一次请求和相应进行一次建立连接和拆除（每进行一次请求建立连接，相应完毕后拆除连接）</p>
<p>HTTP1.1：该协议相当于TCP，双方规定了连接方式和连接类型，会一直进行请求相应</p>
<p>分析HTTP协议：</p>
<p>可以用HTTPWatch（只能在ie浏览器上使用），也可以用浏览器自带的查看HTTP协议的工具（F12就可进入）</p>
<p>创建一个html页面：</p>
<p>demo1.html</p>
<p><img src="/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/wps1.jpg" alt="img"> </p>
<p>method默认为get方式，可以手动修改为post方式</p>
<p>demo2.html</p>
<p><img src="/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/wps2.jpg" alt="img"> </p>
<p>在浏览器中输入<a target="_blank" rel="noopener" href="http://localhost:8080/web_set/demo1.html">http://localhost:8080/web_set/demo1.html</a></p>
<p>打开HTTPWatch工具，点击record。输入表单内容，提交。点击项目下的Stream查看：</p>
<p>GET方式的请求部分：</p>
<p>GET /web_test/demo2.html?name=aaa&amp;name=man HTTP/1.1</p>
<p>Accept: text/html, application/xhtml+xml, <em>/</em></p>
<p>X-HttpWatch-RID: 9561-10011</p>
<p>Referer: <a target="_blank" rel="noopener" href="http://localhost:8080/web_test/demo1.html">http://localhost:8080/web_test/demo1.html</a></p>
<p>Accept-Language: zh-CN</p>
<p>User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</p>
<p>Accept-Encoding: gzip, deflate</p>
<p>Host: localhost:8080</p>
<p>DNT: 1</p>
<p>Connection: Keep-Alive</p>
<p>POST请求：</p>
<p>POST /web_test/demo2.html HTTP/1.1</p>
<p>Accept: text/html, application/xhtml+xml, <em>/</em></p>
<p>X-HttpWatch-RID: 9561-10041</p>
<p>Referer: <a target="_blank" rel="noopener" href="http://localhost:8080/web_test/demo1.html">http://localhost:8080/web_test/demo1.html</a></p>
<p>Accept-Language: zh-CN</p>
<p>User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</p>
<p>Content-Type: application/x-www-form-urlencoded</p>
<p>Accept-Encoding: gzip, deflate</p>
<p>Host: localhost:8080</p>
<p>Content-Length: 19</p>
<p>DNT: 1</p>
<p>Connection: Keep-Alive</p>
<p>Cache-Control: no-cache</p>
<p>name=bbb&amp;name=woman</p>
<p>请求部分内容：3部分</p>
<p>请求行：</p>
<p>请求方式：有很多种，GET和POST最常见</p>
<p>GET：请求的参数会显示到地址栏。通常是有大小的限制。没有请求体</p>
<p>POST：请求的参数不会显示到地址栏（在请求体中）。POST没有大小的限制。有请求体（请求参数）。只有表单设置method=”post”才是post请求。</p>
<p>请求路径：一般都是固定的</p>
<p>协议版本：一般都是固定的</p>
<p>请求头:请求头的格式一般都是一个key对应一个value的，也有一个key对应多个value的情况</p>
<p>一些常见的请求头：</p>
<p>Referer    ：代表网页的来源。（防盗链）</p>
<p>User-Agent    ：获得客户端浏览器类型</p>
<p>请求体：只有POST请求方式才有请求体，而且请求体是POST方式请求参数</p>
<p>响应部分：</p>
<p>HTTP/1.1 200 OK</p>
<p>Server: Apache-Coyote/1.1</p>
<p>Accept-Ranges: bytes</p>
<p>ETag: W/“151-1484111223984”</p>
<p>Last-Modified: Wed, 11 Jan 2017 05:07:03 GMT</p>
<p>Content-Type: text/html</p>
<p>Content-Length: 151</p>
<p>Date: Wed, 11 Jan 2017 05:14:00 GMT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;title&gt;Insert title here&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Success&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>响应部分的内容：3部分</p>
<p>响应行：</p>
<p>协议版本</p>
<p>状态码：</p>
<p><em><strong>*200*</strong></em>    <em><strong>*：代表响应成功*</strong></em></p>
<p><em><strong>*302*</strong></em>    <em><strong>*：需要进行重定向操作*</strong></em></p>
<p><em><strong>*304*</strong></em>    <em><strong>*：需要查找本地缓存*</strong></em></p>
<p><em><strong>*404*</strong></em>    <em><strong>*：请求资源不存在*</strong></em></p>
<p><em><strong>*405：请求的方式不对*</strong></em></p>
<p><em><strong>*500*</strong></em>    <em><strong>*：服务器内部错误*</strong></em></p>
<p>状态码描述</p>
<p>响应头:通常一个key对应一个value，也有一个key对应多个value</p>
<p>一些常见的响应头：</p>
<p>Location    ：重定向的路径</p>
<p>Refresh    ：定时刷新</p>
<p>Content-Disposition：文件下载的时候使用</p>
<p>响应体：就是显示到浏览器上页面的代码</p>
<p><img src="/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/image-20211012083815373.png" alt="image-20211012083815373"></p>
<h2 id="http的三次握手和四次挥手"><a href="#http的三次握手和四次挥手" class="headerlink" title="http的三次握手和四次挥手"></a>http的三次握手和四次挥手</h2><p>tcp协议建立连接要3次握手，断开连接要4次挥手，而http是基于tcp协议的，所以通常我们也这么说而已，我们日常网络访问的http用的是tcp</p>
<p>tcp可以提供全双工的数据流传输服务，全双工说白了，就是同一时间A可以发信息给B，B也可以发消息给A，俩人同时都可以给对方发消息；半双工就是某个时间段A可以发给B，但B不能给A，换个时间段，就反过来了；单工就是只能一个给另一个类似于汽车单行道</p>
<p>连接过程：</p>
<p><img src="/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/393620-20180422133751246-1216639897.png" alt="img"></p>
<p>1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</p>
<p>2、TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位<strong>SYN=1</strong>，同时选择一个初始序列号 <strong>seq=x</strong> ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</p>
<p>3、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <strong>ACK=1</strong>，<strong>SYN=1</strong>，确认号是<strong>ack=x+1</strong>，同时也要为自己初始化一个序列号 <strong>seq=y</strong>，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</p>
<p>4、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的<strong>ACK=1</strong>，<strong>ack=y+1</strong>，自己的序列号<strong>seq=x+1</strong>，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</p>
<p>5、当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</p>
<p>这个过程理解起来，就像两人在喊话：</p>
<p>A：喂，有人吗，我想建立连接</p>
<p>B：有哇，你建立吧，等你吆</p>
<p>A：好哒，我来啦</p>
<p><strong>为什么需要三次？</strong></p>
<p>tcp的核心思想是保证数据可靠传输。可能存在第三次的时候网络中断了，导致连接并没有成功。所以无论握手多少次都不能满足传输的绝对可靠，为了效率跟相对可靠而看，3次刚刚好，所以就3次了(正好AB相互确认了一次)</p>
<p>连接断开过程：</p>
<p><img src="/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/393620-20180422133915537-2039149694.png" alt="img"></p>
<p>1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p>
<p>2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p>3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p>
<p>4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<p>5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
<p>6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<p><strong>建立连接要3次，断开为什么要4次呢？</strong><br>因为tcp是全双工的，每个方向要单独断开，每个方向2次，所以4次。<br><strong>一定4次吗，3次不行么，跟建立连接一样，服务端回复的时候顺带请求断开不可以么？</strong><br>不可以，因为客户端请求服务端断开的时候，客户端向服务端发送数据的这个方向已经没有数据要发送了，但服务端可能仍有信息往客户端发送，需要的时间不好确定，不能一直不回复让客户端等着，只能先回复一个，让客户端断掉，然后服务端把数据发送完了之后再断掉服务端到客户端方向的连接；<br><strong>为什么客户端最后还要等待2MSL？</strong><br>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。<br>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。<br>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<p><strong>等待2MSL就一定能确认没问题么？</strong><br>不，还有一个超时机制，超时了，即使没收到回复也会关闭连接。</p>
<p>tcp关闭连接状态转换：</p>
<p><img src="/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/393620-20180422134027396-1029063112.png" alt="img"></p>
<p>（1）应用层调用close函数发起关闭连接请求</p>
<p>（2）发送FIN到对端，关闭写通道，自己进入FIN_WAIT1状态</p>
<p>（3）等待对端的确认ACK到来，接受到ACK后进入FIN_WAIT2状态；如果在超时时间内没有收到确认ACK直接进入CLOSED状态</p>
<p>（4）如果在FIN_WAIT1状态时收到了对端的FIN则进入CLOSING状态（双发都发出了关闭连接请求）</p>
<p>（5）在FIN_WAIT2接受到了对端FIN后进入TIME_WAIT状态；如果在超时时间内没有收这个FIN则直接进入CLOSED状态</p>
<p>（6）在TIME_WAIT状态等待2个MSL（2个报文最长存活周期）后进入CLOSED状态</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/" data-id="ckvc2kuda002k9kwd8c2de49r" data-title="WEB之http协议" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-9.1.WEB之概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.1.WEB%E4%B9%8B%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:29:06.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.1.WEB%E4%B9%8B%E6%A6%82%E8%BF%B0/">WEB之概述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><p>web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超链接将Internet上的信息节点组织成一个互为关联的网状结构。</p>
<p>javaWEB：使用Java语言进行WEB的开发。</p>
<p>软件架构：</p>
<p>CS架构的软件：Client/Server 客户端和服务器，这种软件往往需要安装。</p>
<p>优点：界面很美观；可以减轻服务器端压力，将部分代码写到客户端。</p>
<p>缺点：一旦服务器更新了，客户端也需要更新；分布式开发比较弱。</p>
<p><strong>BS架构的软件</strong>：Browser/Server 浏览器和服务器，这种软件不需要安装，只需要通过浏览器就可以访问。</p>
<p>优点：服务器一旦更新，不需要更新客户端，因为客户端就是浏览器；比较强的分布式能力</p>
<p>缺点：界面效果不如CS结构软件（可以用前端技术美化）；服务器端压力会比较大(会搭一些集群减轻压力，也会用Ajax异步交互)</p>
<p>WEB服务器：</p>
<p>硬件：其实就是一台电脑（这台电脑配置要求很高）</p>
<p>软件：需要在这台电脑上安装web服务器的软件</p>
<p>常见的WEB服务器：</p>
<p>Tomcat        ：Apache组织提供的一个开源的免费的web服务器。满足EE的Servlet和JSP的规范。</p>
<p>WebSphere    ：IBM公司开发的一个收费的大型web服务器。满足了EE开发的所有规范。</p>
<p>WebLogic        ：BEA公司开发的一个收费的大型web服务器。满足了EE开发的所有规范。</p>
<p>IIS            ：应用在.NET平台上。</p>
<p>Apache        ：应用在PHP平台上。</p>
<p>WEB开发中的资源：</p>
<p>静态web资源：HTML   /   CSS   /   JS</p>
<p>动态web资源：Servlet、JSP  （java的） /  PHP  /  ASP</p>
<p><img src="/9.1.WEB%E4%B9%8B%E6%A6%82%E8%BF%B0/wps1.jpg" alt="img"> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.1.WEB%E4%B9%8B%E6%A6%82%E8%BF%B0/" data-id="ckvc2kuda002j9kwdaao56rn1" data-title="WEB之概述" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.25.关于递归" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.25.%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:24:06.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.25.%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92/">关于递归</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>能用循环尽量不用递归</p>
<p>递归 ：方法定义中调用方法本身的现象。</p>
<p>方法的嵌套使用，不是递归：Math.max(Math.max(a,b),c);</p>
<p>这才是递归: public void show(){</p>
<p>show();</p>
<p>}</p>
<p>注意事项：递归一定要有出口，否则就是死递归</p>
<p>递归的次数不能太多，否则就内存溢出</p>
<p>构造方法不能递归使用</p>
<p>递归解决问题的思想：（找到出口和找到规律）</p>
<p>分解法和合并法</p>
<p>递归实现：做递归要写一个方法；出口条件；规律</p>
<p>兔子问题(斐波那契数列)</p>
<p>A：数组实现</p>
<p>B：变量的变化实现</p>
<p>C：递归实现</p>
<p>回调</p>
<p>模块间调用</p>
<p>（1）同步调用：同步调用是最基本并且最简单的一种调用方式，类A的方法a()调用类B的方法b()，一直等待b()方法执行完毕，a()方法继续往下走。<strong>这种调用方式适用于方法b()执行时间不长的情况</strong>，因为b()方法执行时间一长或者直接阻塞的话，a()方法的余下代码是无法执行下去的，这样会造成整个流程的阻塞</p>
<p>（2）异步调用：异步调用是为了解决同步调用可能出现阻塞，导致整个流程卡住而产生的一种调用方式。<strong>类A的方法方法a()通过新起线程的方式调用类B的方法b()，代码接着直接往下执行</strong>，这样无论方法b()执行时间多久，都不会阻塞住方法a()的执行。但是这种方式，由于方法a()不等待方法b()的执行完成，在方法a()需要方法b()执行结果的情况下（视具体业务而定，有些业务比如启异步线程发个微信通知、刷新一个缓存这种就没必要），必须通过一定的方式对方法b()的执行结果进行监听。在Java中，可以使用Future+Callable的方式做到这一点</p>
<p>（3）回调：是一种<strong>双向</strong>的调用方式</p>
<ul>
<li><p><strong>类A的a()方法调用类B的b()方法</strong></p>
</li>
<li><p><strong>类B的b()方法执行完毕主动调用类A的callback()方法</strong></p>
</li>
</ul>
<p>例子</p>
<p>1.回调接口：public interface Callback {  public void tellAnswer(int answer); }</p>
<p>2.定义一个老师对象，实现Callback接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> Student student;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.student = student;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">askQuestion</span><span class="params">()</span> </span>&#123;<span class="comment">//问问题方法askQuestion()，即向学生问问题</span></span><br><span class="line">         student.resolveQuestion(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tellAnswer</span><span class="params">(<span class="keyword">int</span> answer)</span> </span>&#123;<span class="comment">//回调接口tellAnswer(int answer)，即学生回答完毕问题之后，老师要做的事情</span></span><br><span class="line">        System.out.println(<span class="string">&quot;知道了，你的答案是&quot;</span> + answer);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>3.定义一个学生接口，学生当然是解决问题，但是接收一个Callback参数，这样学生就知道解决完毕问题向谁报告</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Student</span> </span>&#123;     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resolveQuestion</span><span class="params">(Callback callback)</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>4.定义一个学生的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ricky</span> <span class="keyword">implements</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resolveQuestion</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 模拟解决问题</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             </span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 回调，告诉老师作业写了多久</span></span><br><span class="line">         callback.tellAnswer(<span class="number">3</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Student student = <span class="keyword">new</span> Ricky();</span><br><span class="line">         Teacher teacher = <span class="keyword">new</span> Teacher(student);</span><br><span class="line">        </span><br><span class="line">        teacher.askQuestion();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>回调的核心就是回调方将本身即this传递给调用方</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.25.%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92/" data-id="ckvc2kud0001x9kwd4qahbx1v" data-title="关于递归" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-3.1.java开发工具之eclipse" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/3.1.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8Beclipse/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:23:57.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/3.1.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8Beclipse/">java开发工具</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>集成开发环境IDE（Integrated Development Environment）：把开发，运行，编译集成在一起</p>
<h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><p>Eclipse是一种可扩展的开放源代码的IDE。</p>
<p>特点：免费，纯JAVA语言编写，免安装，扩展性强。由OTI和IBM公司开发。</p>
<p>（//CS版客户端服务器，BS版网络端服务器）</p>
<h3 id="Eclipse的使用："><a href="#Eclipse的使用：" class="headerlink" title="Eclipse的使用："></a>Eclipse的使用：</h3><p>选择工作空间（其实就是源代码所在的目录）</p>
<p>代码以项目为单位，创建项目，创建包，创建类，编写代码。</p>
<p>是自动编译，在保存的那一刻就会被编译。</p>
<p>运行：1.点击bug图标后面的内在三角形按钮</p>
<p>​            2.点击Run菜单下的run，或者快捷键CTRL+F11</p>
<p>​            3.在要运行的文件或文件内容中右击选择Run as-Java Application</p>
<p>​            当出现console控制台时，表示运行成功。</p>
<p>汉化：在dropins目录下解压插件即可。</p>
<p>语法检查：红色波浪线：错误的源代码（必须解决）</p>
<p>黄色波浪线：未使用的成员或有安全隐患的成员（可以不管）</p>
<p>视窗：每一个基本的窗体被称为视窗</p>
<p>PackageExplorer  显示项目的结构，包，类，及资源</p>
<p>Outline：显示类的结构，方便查找，识别，修改</p>
<p>Console：显示程序运行的结果</p>
<p>Problems：显示所有的语法及错误存在的位置</p>
<p>Hierarchy：显示java继承层次结构，选中类后按F4</p>
<p>视图：是由某些视窗组合而成的：Java视图，Debug视图</p>
<p>程序的编译和运行的环境配置：（一般不会改）window–Preferences–Java</p>
<p>编译环境：Compiles：默认选中的就是最高版本。</p>
<p>运行环境：Installed JREs：默认会找到你安装的那个JDK。建议配置java的环境变量。</p>
<p>低编译，高运行：可以。</p>
<p>高编译，低运行：不可以。所以建议编译和运行的版本一致（都选java8）。</p>
<p>去掉默认注释：widow–Prederences–Java–Code Style–Code Templates    选择不想要的内容，通过右边Edit编辑。（只删除注释部分，不是注释部分的不要删除）</p>
<p>行号的显示和隐藏：在代码区域的最左边的空白区域，右键–Show Line Numbers</p>
<p>字体的大小和颜色：window–Preferences–General–Appearance–Colors And Fonts–</p>
<p>窗体弄乱了：window–Reset Perspective</p>
<p>控制台没了：window–show View-console</p>
<h3 id="快捷键："><a href="#快捷键：" class="headerlink" title="快捷键："></a>快捷键：</h3><p>内容辅助建：</p>
<p>​    Alt+/  起提示作用</p>
<p>​    main+Alt+/</p>
<p>常用快捷键：</p>
<p>​    格式化（让格式看起来更标准规范）：  ctrl+shift+f  或者在代码区域内右键–source–Format</p>
<p>​    导入包（当你用到其他包内东西时）：  ctrl+shift+o  </p>
<p>​    注释ctrl+shift+c （选中后按，批量注释掉）   ctrl+/  （单行注释掉）</p>
<p>​    代码上下移动  选中代码alt+上/下箭头</p>
<p>查看源码：选中类名（F3或者Ctrl+鼠标点击）</p>
<p><strong>如何提高开发效率：</strong></p>
<p>自带生成构造方法：</p>
<p>​    无参构造：在代码区域右键–source–Generate Constructors form Superclass      或者alt+shift+s 再按c</p>
<p>​    带参构造：在代码区域右键–source–Generate Constructors using fields..–finish     或者alt+shift+s  再按o</p>
<p>​    自动生成get/set方法：在代码区域右键–source–Generate Getters and Setters       或者alt+shift+s  再按r 在全选 再回车    </p>
<p>​    快捷键操作：alt+shift+s  再看那个词条下面有下划线对应的就是那个字母的快捷键。</p>
<p>在创建一个新类的时候 可以选择继承的父类和实现的接口名，选中后会直接生成。</p>
<p>制作帮助文档：</p>
<p>​    1.编写源程序</p>
<ol start="2">
<li><p>针对源程序添加文档注释</p>
</li>
<li><p>选中项目–右键–Export–java–javadoc（后缀一定要是\doc）–Finish</p>
</li>
</ol>
<p>Eclipse中打jar包并使用jar包：（当想用其他项目的class时，无法直接引用或者导包，就可以将其他项目的东西打包成jar包）</p>
<p>jar是多个class文件的压缩包。是别人写好的东西。</p>
<p>打jar包：选中项目–右键–Export–java–jar–自己指定一个路径和一个名称–Finish</p>
<p>使用jar包：复制到项目路径下（ctrl+c，ctrl+v），添加至构建路径（右键–build path–add to build path）。</p>
<p>一般来说，jar包和doc是配套使用的。</p>
<p>删除项目：选中项目–右键–删除（选中的话是从硬盘上删除，不选的话是只从项目区域中删除）</p>
<p>导入项目：项目区域内右键–import–General展开找到Existing Projects into Workspace–点击next选择要导入的项目（整个项目即项目的名称）</p>
<p>注意事项：</p>
<p>​    查看项目所在路径：选中–右键–Properties–Resource–Location</p>
<p>​    导入项目时，项目区域中不能出现同名的项目（新建或者导入），自己随意建立的文件夹是不能作为项目导入的（没有配置文件的）</p>
<p>​    修改项目时，不要随意修改项目名称，非要修改时，不要忘记把项目中的配置文件.projcet中的   <name> 修改后的项目名称  </name></p>
<p>Debug调试：</p>
<p>作用：调试程序；查看程序的执行流程</p>
<p>断点：就是一个标记，从哪里开始</p>
<p>设置断点：想看哪个程序，就在那个有效程序的左边双击即可。（<strong>初学时先在每个方法的第一条语句加断点</strong>）</p>
<p>Debug视图：</p>
<p>Debug：断点测试的地方。按F6或者按↓，跳到下一条语句（一次看一行）</p>
<p>Variables：查看程序的变量变化</p>
<p>xxx.java：被查看的源文件</p>
<p>Console：控制台</p>
<p>去除断点：再次双击即可；多个断点时进入debug视图中的variables界面中的Breakpoints点击，看到所有的断点，点击双×。（单x就是删除一个断点）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/3.1.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8Beclipse/" data-id="ckvc2kuct00159kwdeh0r0yx4" data-title="java开发工具" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-25.设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/25.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:23:42.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/25.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>设计原则：都是为了提高代码的维护性，扩展性，复用性</p>
<p>1.单一职责原则：高内聚，低耦合  </p>
<p>每个类只有一个职责，对外只能提供一种功能，而引起类变化的原因只有一个  </p>
<p>所有的设计模式都遵循这一原则</p>
<p>2.开闭原则：一个对象对扩展开放，对修改关闭</p>
<p>对类的改动是通过增加代码进行的，而不是修改现有代码 </p>
<p>借助于抽象和多态，把可能变化的内容抽象出来，从而使抽象的部分相对稳定，而具体的实现是可以改变和扩展的。</p>
<p>\3. 里氏替换原则：在任何父类出现的地方都可以用它的子类来替代</p>
<p>同一个继承体系中的对象应该有共同的行为特征</p>
<p>4.依赖注入原则：要依赖于抽象，不要依赖于具体实现<br>在应用程序中，所有的类如果使用或依赖于其他类，则应依赖于这些其他类的抽象类，而不是具体类。这就要求我们在编程的时候针对抽象类或接口编程，而不是针对具体实现编程</p>
<p>5.接口分离原则：不应该强迫程序依赖它们不需要使用的方法<br>一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。</p>
<p>6.迪米特原则：一个对象应当对其他对象尽可能少的了解<br>降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用</p>
<p>设计模式</p>
<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计<em><strong>*经验的总结*</strong></em></p>
<p>设计模式不是一种方法和技术，而是一种思想。设计模式和具体的语言无关，学习设计模式就是要建立面向对象的思想，尽可能的面向接口编程，低耦合，高内聚，使设计的程序可复用</p>
<p>要素：</p>
<p>名字：必须有一个简单，有意义的名字</p>
<p>问题：描述在何时使用模式</p>
<p>解决方案：描述设计的组成部分以及如何解决问题</p>
<p>效果：描述模式的效果以及优缺点</p>
<p>分类：</p>
<p>1.创建型模式：对象的创建 6个</p>
<p>简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式，单例模式</p>
<p>2.结构型模式：对象的组成(结构) 7个<br>    外观模式，适配器模式，代理模式，装饰模式，桥接模式，组合模式，享元模式</p>
<p>3.行为型模式：对象的行为 10个</p>
<p>模版方法模式，观察者模式，状态模式，职责链模式，命令模式，访问者模式，策略模式，备忘录模式，迭代器模式，解释器模式</p>
<p>几种设计模式：</p>
<p>1.简单工厂模式（静态工厂方法模式） （接口）</p>
<p>它定义一个具体的工厂类负责创建一些类的实例<br>优点：客户端不需要在负责对象的创建，从而明确了各个类的职责</p>
<p>缺点：这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护</p>
<p>\2. 工厂方法模式 （接口）<br>工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</p>
<p>优点：客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性</p>
<p>缺点：需要额外的编写代码，增加了工作量</p>
<p>\3. 单例设计模式 （多线程）<br>单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。</p>
<p>如何实现类在内存中只有一个对象：把构造方法私有；在成员位置自己创建一个对象；通过一个公共的方法让外界访问（为了保证外界能够直接使用该方法，加静态（静态方法只能调静态变量，所以造的变量要用static修饰，为了不让外界直接访问修改这个变量，所以还要加private修饰））</p>
<p>优点：在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</p>
<p>缺点：没有抽象层，因此扩展很难；职责过重，在一定程序上违背了单一职责</p>
<p>单例设计模式分类：</p>
<p>饿汉式：类一加载就创建对象（开发用，因为是一种不会出问题的单例模式）</p>
<p>代码：</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> SingleDemo {</p>
<p>​    <em><strong>*private*</strong></em> SingleDemo() {</p>
<p>​    }</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> SingleDemo <strong>s</strong> = <em><strong>*new*</strong></em> SingleDemo();</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> SingleDemo getSingleDemo() {</p>
<p>​        <em><strong>*return*</strong></em> <strong>s</strong>;</p>
<p>​    }</p>
<p>}</p>
<p>懒汉式：用的时候，才去创建（面试用，因为可能会出问题）</p>
<p>懒加载思想(延迟加载)</p>
<p>线程安全问题 需要在方法上加synchronized</p>
<p>代码：</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> SingleDemo2 {</p>
<p>​    <em><strong>*private*</strong></em> SingleDemo2() {</p>
<p>​    }</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> SingleDemo2 <strong>s</strong> = <em><strong>*null*</strong></em>;</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*synchronized*</strong></em> <em><strong>*static*</strong></em> SingleDemo2 getSingleDemo2() {</p>
<p>​        <em><strong>*if*</strong></em> (<strong>s</strong> == <em><strong>*null*</strong></em>) {</p>
<p>​            <strong>s</strong> = <em><strong>*new*</strong></em> SingleDemo2();</p>
<p>​        }</p>
<p>​        <em><strong>*return*</strong></em> <strong>s</strong>;</p>
<p>​    }</p>
<p>}</p>
<p>Runtime类就是饿汉式</p>
<p>每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接</p>
<p>应用程序不能创建自己的 Runtime 类实例</p>
<p>方法：</p>
<p>public Process exec(String command)  调用dos命名比如：”notepad”</p>
<p>\4. 模版设计模式（抽象类）<br>模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现</p>
<p>优点：使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求</p>
<p>缺点：如果算法骨架有修改的话，则需要修改抽象类</p>
<p>\5. 装饰设计模式（IO流）<br>装饰模式就是使用被装饰类的一个子类的实例，在客户端将这个子类的实例交给装饰类。是继承的替代方案</p>
<p>优点：使用装饰模式，可以提供比继承更灵活的扩展对象的功能，它可以动态的添加对象的功能，并且可以随意的组合这些功能</p>
<p>缺点：正因为可以随意组合，所以就可能出现一些不合理的逻辑</p>
<p>\6. 适配器设计模式（GUI）<br>将一个类的接口转换成另外一个客户希望的接口。从而使原来不能直接调用的接口变的可以调用。</p>
<p>接口（方法比较多）–适配器类（实现接口，仅仅空实现）–实现类（用哪个重写哪个）</p>
<p>优点：让本来不适合使用的接口变得适合使用</p>
<p>缺点：一次只能适配一个类，使用有一定的局限性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/25.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="ckvc2kucq00119kwd5zwtec2a" data-title="设计模式" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.5.面向对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.5.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:23:34.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.5.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象<strong>思想</strong>：面向对象是基于面向过程的编程思想。</p>
<p>​    面向过程：强调的是每一个功能的步骤</p>
<p>​    面向对象：强调的是对象，然后由对象去调用功能</p>
<p>面向对象<strong>特点</strong>：是一种更符合我们思想习惯的思想；可以将复杂的事情简单化；将我们从执行者变为指挥者。</p>
<p>面向对象<strong>开发</strong>：就是不断创建对象，使用对象，指挥对象做事情。</p>
<p>面向对象<strong>设计</strong>：管理和维护对象之间的关系。</p>
<p>面向对象<strong>特征</strong>：</p>
<ol>
<li><p>封装（encapsulation）</p>
</li>
<li><p>继承(inheritance)</p>
</li>
<li><p>多态(polymorphism)</p>
</li>
</ol>
<p>完成某个需求时：</p>
<ol>
<li><p>分析有哪些类：UML（统一建模语言），名词提取法。</p>
</li>
<li><p>每个类都有哪些东西：属性，方法</p>
</li>
<li><p>类与类之间的关系是什么：耦合</p>
</li>
</ol>
<h1 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h1><p>java中最基本的单位是类。</p>
<p>类：一组相关的属性和行为的集合，是一个抽象的概念。</p>
<p>事物就是通过类来体现出来。事物是由属性（该事务的描述信息）和行为（该事务能做什么）组成。</p>
<p>对应类中为：成员变量和成员方法。</p>
<p>对象：是该类事物的具体实现形式，具体存在的个体。</p>
<p>​    成员变量：和以前变量的定义是一样的格式，但是位置不同，在类中方法外。</p>
<p>​    成员方法：和以前的方法定义是一样的格式，但是把static去掉。</p>
<p>如何使用类及类中的属性和行为呢：创建该类的一个对象使用。</p>
<p>格式： <code>类名  对象名=new  类名（）;</code></p>
<p>如何使用成员变量：  对象名.变量名</p>
<p>如何使用成员方法：  对象名.方法名(参数…)</p>
<p>匿名对象：就是没有名字的对象。</p>
<p>应用场景：</p>
<p>A：调用方法：仅仅只调用一次的时候（若多次调用，不适合）</p>
<p>优点：匿名对象调用是在堆内存中，调用完毕就是垃圾，可以被垃圾回收器回收</p>
<p>B：匿名对象可以作为实际参数传递。（当方法中的形式参数是一个引用类型比如类的时候，实际参数可以用匿名对象当作该类的一个对象）</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>通过对象给成员变量赋值，可以赋值一些非法的数据，这是不合理的。</p>
<p>在赋值之前，应该先对数据进行判断。怎么进行判断呢？就是写一个方法对数据进行校验。但是不用方法就起不到作用了。所以要求必须使用方法，不能直接调用成员变量。</p>
<p>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p>
<p>原则：将不需要对外提供的内容都隐藏起来。把属性隐藏，提供公共方法对其访问。</p>
<p>优点：隐藏实现细节，提供公共的访问方式；提高了代码的复用性；提高安全性。</p>
<p>private：私有的，是一个权限修饰符，可以修饰成员变量和成员方法。</p>
<p>被private修饰的成员只能在本类中访问。</p>
<p>最常见的应用：把成员变量用private修饰，提供对应的getXxx（）/setXxx（）方法以使外界可以访问</p>
<p>this关键字：this代表所在当前类的一个对象引用。</p>
<p>方法被哪个对象调用，this就代表那个对象。</p>
<p>用this的场景：当局部变量隐藏成员变量时，成员变量可能被局部变量覆盖无意义，所以要用this。   super</p>
<p><strong>构造方法</strong></p>
<p>作用：给对象的数据进行初始化</p>
<p>格式：方法名和类名相同。没有返回值，连void都没有。没有具体的返回值。</p>
<p>注意事项：如果不提供构造方法，系统会给出默认的构造方法</p>
<p>如果提供了构造方法，系统将不再提供默认的构造方法。如果还想使用无参构造方法，就必须自己给出，建议永远自己给出无参构造方法。</p>
<p>构造方法也可以重载。</p>
<p>给成员变量赋值有2种方法：</p>
<p>A. 无参构造方法+setXxx();</p>
<p>B. 带参构造方法</p>
<p>类中包含有：成员变量、成员方法、构造方法。</p>
<p><strong>成员方法</strong></p>
<p>根据返回值可以分为：void类型和非void类型。</p>
<p>根据形式参数：空参方法和非空参方法。</p>
<p><code>Student s=new Student();</code>在内存中发生了什么？</p>
<ol>
<li><p>加载Student.class文件进内存</p>
</li>
<li><p>在栈内存为s开辟空间</p>
</li>
<li><p>在堆内存为学生对象开辟空间</p>
</li>
<li><p>对学生对象的成员变量进行默认初始化。null  0   0.0   \u0000</p>
</li>
<li><p>对学生对象的成员变量进行显式初始化</p>
</li>
<li><p>通过构造方法对学生对象的成员变量赋值</p>
</li>
<li><p>学生对象初始化完毕，把对象地址赋值给s变量。</p>
</li>
</ol>
<p>当一个变量是用来描述类的信息时，这个变量就应该被定义为成员变量。（成员变量不要瞎定义）</p>
<p>变量的范围是越小越好，因为能及时的被回收。</p>
<p>当多个对象有共同的成员变量值的时候，java就提供了一个关键字来修饰：static。</p>
<p>static可以修饰成员变量和成员方法。</p>
<p>static关键字的特点：随着类的加载而加载；优先于对象存在；被类的所有对象共享（这也是我们判断是否使用静态关键字的条件）；可以通过类名调用（其实本身也可以通过对象名调用，推荐使用类名调用）静态修饰的内容我们一般称为与类相关的，类成员</p>
<p>注意事项：在静态方法中是没有this关键字的（因为静态是随着类的加载而加载，而this是随着对象的创建而存在，静态比对象先存在）</p>
<p>静态方法只能访问静态的成员变量和静态的成员方法。(main方法是静态方法，不能调用非静态方法，如果想调用的话，可以先在main方法中创建一个对象，通过这个对象来调用非静态方法)</p>
<p>非静态方法可以访问静态的成员变量和成员方法，也可以访问非静态的成员变量和成员方法。</p>
<p>静态变量和成员变量的区别：</p>
<p>所属不同：静态变量属于类，也被称为类变量</p>
<p>​                    成员变量属于对象，也被称为实例变量（对象变量）</p>
<p>内存中的位置不同：静态变量存储于方法区的静态区</p>
<p>​                    成员变量存储于堆内存中</p>
<p>内存出现的时间不同：静态变量随着类的加载而加载，随着类的消失而消失</p>
<p>​                    成员变量随着对象的创建而存在，随着对象的消失而消失</p>
<p>调用不同：静态变量可以通过类名调用，也可以通过对象名调用</p>
<p>​                    成员变量只能通过对象名调用</p>
<p>main方法的格式讲解：</p>
<p>public:公共的，访问权限是最大的。由于main方法是被jvm调用的，所以权限要够大。</p>
<p>static:静态的，不需要创建对象，通过类名就可以调用，方便jvm的调用。</p>
<p>void:方法的返回值是返回给调用者，而main方法是被jvm调用的，返回给jvm无意义。</p>
<p>main：是一个常见的方法入口，所有语言都是以main方法为入口</p>
<p>String[] args:这是一个字符串数组。这个东西早期是为了接收键盘录入的数据的。</p>
<p>eg：java  类名  hello  world  java  遍历args就会发现是 hello  world  java</p>
<p>后来用java.util.Scanner代替了</p>
<p>测试类的作用：创建其他类的对象，调用其他类的功能。</p>
<p>在同一个文件夹下，类定义在两个文件中和定义在一个文件中其实一样的。</p>
<p>静态的一种用法：在工具类中，将构造方法私有化，这样外界无法创建该类的对象，然后将要调用的方法static静态化，这样main方法调用时候只能通过类名.方法名调用。</p>
<p>项目提供的都是class文件，无从得知class文件内都有哪些方法哪些属性。所以需要加说明书。</p>
<p>说明书的制作：</p>
<p>A：写一个工具类</p>
<p>B：对这个类加文档注释：</p>
<p>/**</p>
<p>*@author</p>
<p>*@version</p>
<p>*@param</p>
<p>*return</p>
<p>*/</p>
<p>C:用工具解析文档注释：javadoc工具</p>
<p>D：格式：</p>
<p>javadoc  -d  (文件夹的路径)  -author  -version  (类名).java</p>
<p>制作帮助文档出错：找不到可以文档化的公共或受保护的类。告诉我们类的权限不够。（若想权限够，在class前加public）</p>
<p>所以以后开发可以利用工具类加说明书，对该类中实现的方法的static、返回值、方法名、参数注意然后就可以调用使用，对怎么实现的方法不用在意，这就是面向对象思想。</p>
<p>.html转换为帮助文档就是.chm文档</p>
<p>使用帮助文档API（Application Progaramming Interface,应用程序编程接口）：</p>
<ol>
<li><p>打开帮助文档</p>
</li>
<li><p>点击显示，找到索引，找到输入框</p>
</li>
<li><p>明确要找什么</p>
</li>
<li><p>在输入框内输入要查找的类，回车</p>
</li>
<li><p>看包，java.lang包下的类不需要导入，其他的都需要全部导入</p>
</li>
<li><p>再简单的看看类的解释和说明，类的版本信息</p>
</li>
<li><p>看类的结构</p>
<p>成员变量：字段摘要</p>
<p>构造方法：构造方法摘要</p>
<p>成员方法：方法摘要</p>
</li>
<li><p>学习构造方法</p>
<p>有构造方法：创建对象</p>
<p>无构造方法：成员可能都是静态的</p>
</li>
<li><p>看成员方法：</p>
<p>静态、返回值类型、方法名、参数列表。</p>
</li>
</ol>
<p>代码块：在java中使用｛｝括起来的代码称为代码块，根据其声明和位置不同，可以分为局部代码块，构造代码块，静态代码块和同步代码块。</p>
<p>局部代码块：局部位置，在方法中出现，限定变量生命周期，及早释放，提高内存利用率。</p>
<p>构造代码块：在类中成员位置出现（直接｛｝括起来），每次调用构造方法都执行，并且在构造方法前执行。</p>
<p>作用：可以把多个构造方法方法中相同的代码存放到一起。</p>
<p>静态代码块：在类中成员位置出现（直接｛｝括起来），｛前面加了static修饰。在加载的时候就执行，且只执行一次。</p>
<p>作用：用于给类进行初始化。</p>
<p>一个类中的执行顺序：与书写顺序无关，执行时都是这个顺序</p>
<p>静态代码块（只执行一次，加载类的时候就执行）–构造代码块（每次调用构造方法都执行）–构造方法</p>
<p>Math类：是针对数学进行操作的类，没有构造方法，成员都是静态的。</p>
<p>产生随机数：public static double random():  [0.0,1.0)</p>
<p>产生1-100的随机数：int number=(new)(Math.random()*100)+1;</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>多个类的成员变量，成员方法等都是相同的。每一次定义的时候都需要重新定义一遍，所以要考虑改进，提高代码的复用性，用继承。</p>
<p>多个类中存在相同的属性和行为时，将这些内容抽取到单独的一个类中，那么多个类无需在定义这些属性和行为，只要继承那个类即可。</p>
<p>格式：</p>
<p>class 子类名  extends  父类名{}</p>
<p>单独的这个类称为父类，基类，超类。</p>
<p>多个类称为子类，派生类。</p>
<p>优点：提高了代码的复用性：多个类相同的成员可以放到同一个类中</p>
<p>提高了代码的维护性：如果功能的代码需要修改，修改一处即可。</p>
<p>让类与类之间产生了关系，是多态的前提。（也是继承的弊端：类的耦合性很强）</p>
<p>开发的原则：低耦合，高内聚。</p>
<p>耦合：类与类的关系</p>
<p>内聚：自己完成某件事情的能力</p>
<p>继承的特点：</p>
<p>\1. java中只支持单继承，不支持多继承。（C++支持多继承，格式：extends 类1，类2…）</p>
<p>\2. java支持多层继承（继承体系）</p>
<p>继承的注意事项：</p>
<p>\1. 子类只能继承父类所有非私有的成员（成员方法和成员变量），也体现了继承的一个弊端：打破了封装性</p>
<p>\2. 子类不能继承父类的构造方法，但是可以通过super关键字来访问父类的构造方法</p>
<p>\3. 不要为了部分功能而去继承（当类与类之间的关系是“is a”的关系时使用继承）子类is父类的a</p>
<p>子类中的成员变量和父类中的成员变量如果一样的话，再调用时候遵循就近原则。</p>
<p>在子类方法中访问一个变量的查找顺序：1.在子类方法的局部范围找，有就用</p>
<p>2.在子类的成员范围找，有就用</p>
<p>\3. 在父类的成员范围找（不可能在父类的方法局部范围找，因为方法不调用不执行，相当于没有）</p>
<p>super关键字：super代表父类存储空间的标识（父类引用，可以操作父类的成员，但不是父类的一个对象，只是父类的一个存储空间）</p>
<p>this代表本类对象的引用</p>
<p>用法：</p>
<p>A. 调用成员变量：</p>
<p>this.成员变量：调用本类的成员变量</p>
<p>super.成员变量：调用父类的成员变量</p>
<p>B. 调用构造方法：</p>
<p>this（…）：调用本类的构造方法</p>
<p>super（…）：调用父类的构造方法</p>
<p>C. 调用成员方法：</p>
<p>this.成员方法：调用本类的成员方法</p>
<p>super.成员方法：调用父类的成员方法</p>
<p>继承中构造方法的关系：子类中所有的构造方法默认都会先访问父类中空参数的构造方法。</p>
<p>因为子类会继承父类中的数据，可能还会使用父类的数据，所以，子类初始化之前，一定要先完成父类数据的初始化。每一个构造方法的第一条语句默认都是super（）;</p>
<p>如果父类没有无参构造方法，那么子类的构造方法会出现报错。（这就是为什么建议构造方法永远手动给个无参的构造方法）</p>
<p>解决方法：A.在父类中加一个无参构造方法</p>
<p>B.子类通过super(…)去显示调用父类其他的带参的构造方法。</p>
<p>C. 子类通过this去调用本类的其他构造方法,但是一定会有一个去访问了父类的构造方法。</p>
<p>子类中一定要有一个去访问了父类的构造方法，否则父类的数据就没有初始化。</p>
<p>注意事项：this（）或者super（）必须出现在第一条语句上。如果 不是放在第一条语句上，就可能会对父类数据进行了多次初始化。</p>
<p>一个类的初始化过程：成员变量进行初始化（默认初始化，显示初始化），构造方法初始化</p>
<p>子父类的初始化（分层初始化）先进行父类初始化，再进行子类初始化。虽然子类中构造方法默认有一个super() ，但是初始化的时候不是按照那个顺序的，而是按照分层初始化进行的。super()只是表示要先初始化父类数据在初始化子类数据。</p>
<p>继承中成员方法的关系：通过子类对象去访问一个方法，首先在子类中找，然后在父类中找，如果没有就报错（不会去父类的父类中找）</p>
<p>方法重写（方法覆盖，方法复写）：子类中出现了和父类中方法声明一模一样的方法。</p>
<p>方法重载：本类中出现的方法名一样，参数列表不同的方法，与返回值无关。</p>
<p>方法重写的应用：当子类需要父类的功能，而功能主体子类有自己特有的内容时，可以重写父类中的方法（重写是完全重写，如果还想用父类中的方法内容，可以用super调用），这样，既沿袭了父类的功能，又定义了子类特有的功能。</p>
<p>注意事项：父类中私有方法不能被重写。（其实父类中私有方法子类根本就无法继承，更谈不上重写）</p>
<p>子类重写父类方法时，访问权限不能更低。（最好就一致）</p>
<p>父类是静态方法，子类也必须通过静态方法进行重写。（其实不算方法重写）</p>
<p>父类不是静态，子类用static静态，会报错。</p>
<p>所以，子类重写父类方法的时候，最好声明一模一样。</p>
<p>由于继承中方法有一个方法重写，所以父类的功能会被子类覆盖，当不想让覆盖的时候，java提供了一个关键字：final</p>
<p>final：最终的意思。可以修饰类、方法、变量。</p>
<p>final可以修饰类：该类不能被继承</p>
<p>final可以修饰方法：该方法不能被重写</p>
<p>final可以修饰变量：该变量不能被重新赋值。这个变量其实是常量。</p>
<p>final修饰局部变量（一般权限修饰符修饰局部变量无意义，但是final特殊）：在方法内部，该变量不能被改变。</p>
<p>在方法声明上，基本类型是值不能被改变。引用类型是地址值不能被改变，但是该对象的堆内存的值还可以改变，注意区别。</p>
<p>final修饰变量的初始化时机：</p>
<p>1.被final修饰的变量只能赋值一次</p>
<p>2.在初始化时就给值（建议）或者在构造方法完毕前给值（非静态的常量）。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="*多态*"></a><em><strong>*多态*</strong></em></h1><p>多态：同一个对象，在不同时刻体现出不同的状态。</p>
<p>判断多态可以从左往右念：子是父？是的话可以多态，不是的话不能。</p>
<p>多态的前提：</p>
<p>A. 要有继承或者实现关系。</p>
<p>B. 要有方法重写。（如果没有方法重写也是可以的，但是就没有了意义）</p>
<p>C. 要有父类或者父接口引用指向子类对象。</p>
<p>父  f=new 子();</p>
<p>多态中的成员访问特点：</p>
<p>A. 成员变量：编译看左边（父类），运行看左边。</p>
<p>B. 构造方法：创建子类对象的时候，访问父类的构造方法，并对父类的数据进行初始化。</p>
<p>C. 成员方法：编译看左边（父类），运行看右边（方法重写相当于覆盖了）。</p>
<p>D. 静态方法：编译看左边（父类），运行看左边。（所以说静态方法的重写根本不算是重写）</p>
<p>由于成员方法存在方法重写，所以只有它运行的时候看右边。</p>
<p>多态的好处：</p>
<p>A. 提高了代码的维护性（继承保证）</p>
<p>B. 提高了代码的扩展性（由多态保证，以后如果在添加父类的子类，可以使用父类的引用调用工具类，便于代码的扩展性）</p>
<p>多态的弊端：不能使用子类的特有功能。</p>
<p>如果非要调用子类的这些功能：</p>
<p>A. 创建子类的对象调用方法。（可以，但是不合理，太占内存）</p>
<p>B. 把父类的引用强制转换为子类的引用。（向下转型）</p>
<p>Fu  f=new Zi();  (向上转型，从子到父，父类引用指向子类对象)</p>
<p>Zi  z=(Zi)f;   （向下转型，从父到子，父类引用转为子类对象） 要求f必须是能够转换为Zi的。</p>
<p>ClassCastException：类型转换异常，一般在多态的向下转型中容易出现。</p>
<p>当一个类中的东西特别多时，我们可以把这个类分成几个小类：基本类、操作类等。</p>
<p>分包：A.功能划分</p>
<p>B.模块划分</p>
<p>C.先按模块划分，再按功能划分</p>
<p>集合实现，IO实现，GUI实现，数据库实现。</p>
<p>如果一个方法传的参数是三个以上，建议传个对象。</p>
<p>如果多个地方用到了某个变量，可以把这个变量定义为成员变量，定义在成员方法外。</p>
<p>能小范围尽量不大范围，因为用完最好回收。</p>
<p>让多个对象共享同一个成员变量，用static修饰。</p>
<p>循环里面如果有switch，并且在其中有break，结束的不是循环，而是switch语句，如果想结束整体，可以用 System.exit(0);</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.5.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" data-id="ckvc2kue1004x9kwd1fbb1l2r" data-title="面向对象" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.22.关于null" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.22.%E5%85%B3%E4%BA%8Enull/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:18:39.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.22.%E5%85%B3%E4%BA%8Enull/">关于null</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>开发原则：只要是对象，我们就要判断对象是否为null。</p>
<p>java空指针异常：java.lang.NullPointException</p>
<h2 id="java中的null"><a href="#java中的null" class="headerlink" title="java中的null"></a><strong>java中的null</strong></h2><p>  null是Java中一个很重要的概念。null设计初衷是为了表示一些缺失的东西，例如缺失的用户、资源或其他东西。但是，一年后，令人头疼的空指针异常给Java程序员带来不少的骚扰。</p>
<p>  null是java中的关键字，因此，它不能写成NULL，Null，只能是null。</p>
<p>  null是所有引用类型的默认值，如果没有让一个引用指向一个实际存在的对象，它的默认值就是null。null本质上是一个值，这跟int的默认值是0，boolean的默认值是false一样。现在，我们通常都使用像eclipse等的集成开发环境进行开发，一般在定义变量的时候都会进行初始化（这也是写代码的一个良好的习惯），如果没有进行初始化，系统会进行提示。</p>
<p><strong>报空指针异常的原因有以下几种：</strong> </p>
<p>1.字符串变量未初始化； </p>
<p>初始化或赋值后则不会报错了<br>2.接口类型的对象没有用具体的类初始化，比如：<br>List it；会报错<br>List it = new ArrayList()；则不会报错了<br>3.当一个对象的值为空时，你没有判断为空的情况。你可以试着把下面的代码前加一行代码：<br>if(rb!=null &amp;&amp; rb!=””)<br>改成：<br>if(rb == null)   或者   if(“”).equals(rb))<br>空指针的解决办法：<br>    重点关注报错发生的所在行，通过空指针异常产生的两条主要原因诊断具体的错误。同时为了避免空指针的发生，最好在做判断处理时将“null”或者空值放于设定的值之前。<br>常见空指针异常的简要分析：<br>（1）空指针错误<br>  Java中的8种基本数据类型，变量的值可以有其默认值，假如没有对其正常赋值，java虚拟机是不能正确编译通过的，因此使用基本的Java数据类型一般是不会引起空指针异常的。实际开发中，大多数的空指针异常主要与对象的操作相关。<br>  下面列出可能发生空指针异常的几种情况及相应解决方案：<br>  代码段1：<br>　　out.println(request.getParameter(“username”));<br>分析：代码段1的功能十分简单，就是输出用户输入”username”的值。<br>说明：看上去，上面的语句找不出什么语法错误，而且在大多数情况下也遇不到什么问题。但是，如果某个用户在输入数据时并没有提供表单 域”username” 的值，或通过某种途径绕过表单直接输入时，此request.getParameter(“username”)的值为空（注意不是空字符串，是空对象 null。），out对象的println方法是无法直接对空对象操作的，因此代码段1所在的JSP页面将会抛出 “Java.lang.NullPointerException”异常。而且即使对象可能为空时，也调用Java.lang.Object或 Object对象本身的一些方法如toString()， equal(Object obj)等操作。<br>  代码段2：<br>　　String userName = request.getParameter(“username”);<br>　　If (userName.equals(“root”))<br>　　{….}<br>分析：代码段2的功能是检测用户提供的用户名，如果是用户名称为”root”的用户时，就执行一些特别的操作。<br>说明：在代码段2中，如果有用户没有提供表单域”username”的值时，字符串对象userName为null值，不能够将一个null的对象与另一 个对象直接比较，同样，代码段2所在的JSP页面就会抛空指针错误。</p>
<p>一个小技巧：如果要把某个方法的返回值与常量做比较，把常量放在前面，可以避免调用null对象的equals方法。譬如：<br>  If (“root”.equals(userName))<br>　 {….}<br>  即使userName对象返回了null对象，这里也不会有空指针异常，可以照常运转。<br>  代码段3：<br>　　String userName = session.getAttribute(“session.username”).toString();<br>分析：代码段3的功能是将session中session.username的值取出，并将该值赋给字符串对象userName。<br>说明：在一般情况下，如果在用户已经进行某个会话，则不会出现什么问题；但是，如果此时应用服务器重新启动，而用户还没有重新登录，（也可能是用户关闭浏 览器，但是仍打开原来的页面。）那么，此时该session的值就会失效，同时导致session中的session.username的值为空。对一个 为 null的对象的直接执行toString()操作，就会导致系统抛出空指针异常。<br>  代码段4：<br>public static void main(String args[]){<br>    Person p=null;<br>    p.setName(“张三”)；<br>    System.out.println(p.getName());<br>}<br>分析：声明一个Person对象，并打印出该对象的中的Name名字。<br>说明：这个时候你的p就出现空指针异常，因为你只是声明了这个Person类型的对象并没有创建对象，所以它的堆里面没有地址引用，切忌你要<strong>用对象调用方法的时候一定要创建对象</strong>。</p>
<p>为了避免空指针调用，我们经常会看到这样的语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...if (someobject !&#x3D; null) &#123;</span><br><span class="line">    someobject.doCalc();&#125;...</span><br></pre></td></tr></table></figure>

<p>最终，项目中会存在大量判空代码，多么丑陋繁冗！如何避免这种情况？我们是否滥用了判空呢？</p>
<p>在方法中返回null，在调用这些方法时，也不得不去判空。另外，也许受此习惯影响，他们总潜意识地认为，所有的返回都是不可信任的，为了保护自己程序，就加了大量的判空</p>
<p>进行判空前，请区分以下两种情况：</p>
<p>1、null 是一个有效有意义的返回值(Where null is a valid response in terms of the contract)</p>
<p>2、null是无效有误的(Where it isn’t a valid response)</p>
<p><strong>先说第2种情况</strong></p>
<p>null就是一个不合理的参数，就应该明确地中断程序，往外抛错误。这种情况常见于api方法。例如你开发了一个接口，id是一个必选的参数，如果调用方没传这个参数给你，当然不行。你要感知到这个情况，告诉调用方“嘿，哥们，你传个null给我做甚”。</p>
<p>相对于判空语句，更好的检查方式有两个</p>
<p>(1)assert语句，你可以把错误原因放到assert的参数中，这样不仅能保护你的程序不往下走，而且还能把错误原因返回给调用方，岂不是一举两得</p>
<p>(2)也可以直接抛出空指针异常。上面说了，此时null是个不合理的参数，有问题就是有问题，就应该大大方方往外抛。</p>
<p><strong>第1种情况会更复杂一些。</strong></p>
<p>这种情况下，null是个”看上去“合理的值，例如，我查询数据库，某个查询条件下，就是没有对应值，此时null算是表达了“空”的概念。</p>
<p>这里给一些实践建议：</p>
<p>1、假如方法的返回类型是collections，当返回结果是空时，你可以返回一个空的collections（empty list),而不要返回null，这样调用侧就能大胆地处理这个返回，例如调用侧拿到返回后，可以直接print list.size()，又无需担心空指针问题。（什么？想调用这个方法时，不记得之前实现该方法有没按照这个原则？所以说，代码习惯很重要！如果你养成习惯，都是这样写代码（<strong>返回空collections而不返回null</strong>)，你调用自己写的方法时，就能大胆地忽略判空）</p>
<p>2、返回类型不是collections，又怎么办呢？</p>
<p>那就<strong>返回一个空对象（而非null对象）</strong>，下面举个“栗子”，假设有如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span> </span>&#123;</span><br><span class="line">  <span class="function">Action <span class="title">findAction</span><span class="params">(String userInput)</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Parse有一个接口FindAction，这个接口会依据用户的输入，找到并执行对应的动作。假如用户输入不对，可能就找不到对应的动作（Action），因此findAction就会返回null，接下来action调用doSomething方法时,就会出现空指针。</p>
<p>解决这个问题的一个方式，就是使用Null Object pattern（空对象模式）</p>
<p>我们来改造一下</p>
<p>类定义如下，这样定义findAction方法后，确保无论用户输入什么，都不会返回null对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParser</span> <span class="keyword">implements</span> <span class="title">Parser</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Action DO_NOTHING = <span class="keyword">new</span> Action() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; <span class="comment">/* do nothing */</span> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Action <span class="title">findAction</span><span class="params">(String userInput)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">/* we can&#x27;t find any actions */</span> ) &#123;</span><br><span class="line">      <span class="keyword">return</span> DO_NOTHING;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>对比下面两份调用实例</p>
<p>1、冗余:每获取一个对象，就判一次空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Parser parser = ParserFactory.getParser();</span><br><span class="line"><span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// now what?</span></span><br><span class="line">  <span class="comment">// this would be an example of where null isn&#x27;t (or shouldn&#x27;t be) a valid response</span></span><br><span class="line">&#125;</span><br><span class="line">Action action = parser.findAction(someInput);</span><br><span class="line"><span class="keyword">if</span> (action == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// do nothing</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  action.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、精简</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserFactory.getParser().findAction(someInput).doSomething();</span><br></pre></td></tr></table></figure>

<p>因为无论什么情况，都不会返回空对象，因此通过findAction拿到action后，可以放心地调用action的方法。</p>
<p><strong>其他回答精选：</strong></p>
<p>1、如果要用equal方法，请用object&lt;不可能为空&gt;.equals(object&lt;可能为空&gt;))</p>
<p>例如：</p>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;bar&quot;.equals(foo) </span><br></pre></td></tr></table></figure>

<p>而不是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.equals(&quot;bar&quot;) </span><br></pre></td></tr></table></figure>

<p>2、Java8或者guava lib中，提供了Optional类，这是一个元素容器，通过它来封装对象，可以减少判空。不过代码量还是不少。不爽。</p>
<p>3、如果你想返回null，请挺下来想一想，这个地方是否更应该抛出一个异常</p>
<h3 id="null与””的区别"><a href="#null与””的区别" class="headerlink" title="null与””的区别"></a>null与””的区别</h3><p>null是没有地址<br>“”是有地址但是里面的内容是空的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">问题一：</span><br><span class="line">null和&quot;&quot;的区别</span><br><span class="line">String s&#x3D;null;</span><br><span class="line">string.trim()就会抛出为空的exception   </span><br><span class="line">String s&#x3D;&quot;&quot;;   </span><br><span class="line">string.trim()就不会抛,为什么? </span><br><span class="line">答：</span><br><span class="line">NULL代表声明了一个空对象，根本就不是一个字符串。   </span><br><span class="line">&quot;&quot;代表声明了一个对象实例，这个对象实例的值是一个长度为0的空字符串。</span><br><span class="line"></span><br><span class="line">NULL代表声明了一个空对象,对空对象做任何操作都不行的,除了&#x3D;和&#x3D;&#x3D;   </span><br><span class="line">&quot;&quot;是一个字符串了,只是这个字符串里面没有内容了</span><br><span class="line"></span><br><span class="line">String s&#x3D;null;只是定义了一个句柄，也就是说你有了个引用，但是这个引用未指向任何内存空间   </span><br><span class="line">String s&#x3D;&quot;&quot;;这个引用已经指向了一块是空字符串的内存空间，是一个实际的东东了，所以你可以对它操作，而不用担心什么了</span><br><span class="line"></span><br><span class="line">你说数字0和没有是不是一种概念啊？？道理一样的</span><br><span class="line"></span><br><span class="line">而且,null可以赋值给任何对象.&quot;&quot;就不行了.</span><br><span class="line"></span><br><span class="line">这里&quot;&quot;和NULL绝对是两个概念   </span><br><span class="line">&quot;&quot;代表一个字符串存在，它的值就是“”   </span><br><span class="line">NULL代表字符串根本没有实际的值，你并不知道它是什么。。。</span><br><span class="line"></span><br><span class="line">哦,我明白了,意思就是String   string   &#x3D;   null   跟String   string;是一回事儿</span><br><span class="line"></span><br><span class="line">null是空对象     &quot;&quot;是空字符串</span><br><span class="line">String s&#x3D;null;&#x2F;&#x2F;null是未分配堆内存空间   </span><br><span class="line">String   a;&#x2F;&#x2F;分配了一个内存空间,没存入任何对象   </span><br><span class="line">String   a&#x3D;&quot;&quot;;&#x2F;&#x2F;分配了一个内存空间,存了一个字符串对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题二：</span><br><span class="line">String s;和String s&#x3D;null;和String s&#x3D;&quot;a&quot;;有什么区别？   </span><br><span class="line">针对这三种情况，使用out.println(s);的时候，第一个会出现异常，第二个会输出null.第三个则会输出a.   </span><br><span class="line">这是为什么呢？这三句声明语句，各自作了什么呢？</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">第一个只是定义了一个String类型变量s，并没有给它赋初值，在Java中，默认在使用一个变量的时候必须赋予它初值（降低风险）。 </span><br><span class="line">第二个和第三个都定义了String类型变量s，并赋予它初值，只不过第二个赋予的值为null（空）罢了</span><br><span class="line"></span><br><span class="line">主要要理解的是String s; s为一个引用～～它不是对象   </span><br><span class="line">第一个是没有初始化的引用；   </span><br><span class="line">第二个为空引用；</span><br><span class="line">第三个是在字符串池里写入一个字符&#39;a&#39;,然后用s指向它。</span><br><span class="line">另外，   </span><br><span class="line">String s&#x3D;&quot;a&quot;和String s&#x3D;new String(&quot;a&quot;);是有本质上的区别的   </span><br><span class="line">前者是在字符串池里写入一个字符&#39;a&#39;,然后用s指向它；</span><br><span class="line">后者是在堆上创建一个内容为&quot;a&quot;的字符串对象。</span><br><span class="line">String   str&#x3D;&quot;aaa&quot;;                    &#x2F;&#x2F;于栈上分配内存</span><br><span class="line">String   str&#x3D;new   String(&quot;aaa&quot;);      &#x2F;&#x2F;于堆上分配内存</span><br><span class="line"></span><br><span class="line">String s; 系统会自动赋值null</span><br><span class="line"></span><br><span class="line">String s;只是给s分配一个内存空间   </span><br><span class="line">String s&#x3D;null;是分配的空间中存储的值为空值   </span><br><span class="line">String s&#x3D;&quot;a&quot;;是分配的空间的值为字符a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题三：</span><br><span class="line">声明了一个string a;变量    </span><br><span class="line">在以后的判断中，a&#x3D;&#x3D;&quot;&quot;和a&#x3D;&#x3D;null有何不同?   </span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">如果没有给a赋过值，a&#x3D;&#x3D;&quot;&quot;会导致异常。     </span><br><span class="line">在实际处理时，往往认为&quot;&quot;和null代表相同的含义，即都代表无值。   </span><br><span class="line">此时建议用如下语法：   </span><br><span class="line">if(a&#x3D;&#x3D;null   ||   a&#x3D;&#x3D;&quot;&quot;)   </span><br><span class="line">&#123;   </span><br><span class="line">&#125;   </span><br><span class="line">如果a为null，就不会执行后面的判断，直接返回true。   </span><br><span class="line"></span><br><span class="line">null是用来判断引用类型是否分配了存储空间   </span><br><span class="line">&quot;&quot;是针对字符串的；   </span><br><span class="line">string类型实际上是字符串指针，也即是一个引用类型   </span><br><span class="line">所以如果没有给a赋过值，a&#x3D;&#x3D;&quot;&quot;会导致异常   </span><br><span class="line">所以if(a&#x3D;&#x3D;null   ||   a&#x3D;&#x3D;&quot;&quot;)&#123;&#125;这种写法也是正确的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题四：</span><br><span class="line">String abc&#x3D;null;String abc&#x3D;&quot;&quot;;String abc;三种写法有什么区别？ </span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">1：创建一个空字符串对象，   </span><br><span class="line">2：创建一个字符串为空的字符串对象。   </span><br><span class="line">3：声明一个字符串对象，但并没有分配内存，而1，2已经分配了内存   </span><br><span class="line">对于最后一种表示,你不能if(abc&#x3D;&#x3D;null),或者int   length   &#x3D;   abc.length();编译的时候会提示可能没有初始化.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String   abc&#x3D;null;   </span><br><span class="line">String   abc&#x3D;&quot;&quot;;   </span><br><span class="line">一般推荐使用第二种   </span><br><span class="line">第一种abc指向null，很多时候要判断字符串是否为空时，容易漏掉这种情况，在调用String的相关方法的时候就会出错   </span><br><span class="line">第二种则相对简单，String的方法都可以用，判断的时候也不会出错</span><br><span class="line"></span><br><span class="line">1) String   abc&#x3D;null;   </span><br><span class="line">2) String   abc;    </span><br><span class="line">3）String   a&#x3D;&quot;&quot;;   </span><br><span class="line">4) String   b&#x3D;&quot;&quot;;   </span><br><span class="line">5) String   c&#x3D;new String(&quot;&quot;);   </span><br><span class="line">6) String   d&#x3D;new String(&quot;&quot;); </span><br><span class="line">&#x2F;&#x2F;1)等于2），和C语言不同，JAVA为安全原因不允许一个悬挂引用，没有赋值的引用地址一律自动赋值为NULL，以防止访问到任意内存   </span><br><span class="line">&#x2F;&#x2F;3)和4)中,变量a和b将会指向同一内存地址(&quot;&quot;的地址)   </span><br><span class="line">&#x2F;&#x2F;5)和6)中，变量c和d不会指向同一地址,而是两个&quot;&quot;内容的地址,并且和a,b不同,实际上,3)和4)相当于new String(&quot;&quot;).intern().   </span><br><span class="line">&#x2F;&#x2F;String类维护着一个字符串池,对于像3)和4)这样的赋值方法,String会在这个池中查找字符串是否已经在池中,如果在,就直接指向该地址,</span><br><span class="line"></span><br><span class="line">如果不在,生成一个实例放入池中再指向那个地址,可见对于同样内容的字符串多次引用时3)4)的方法要比5)6)的方法剩内存,之所以这样做,是</span><br><span class="line"></span><br><span class="line">因为String是一个内容不可变的量,运用的是设计模式GOF.FlyWeight   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但有个关键的一点,没有人说到，这就是:   </span><br><span class="line">String s;在什么情况下可以等同于String s&#x3D;null;而在什么情况下又不等同？！</span><br><span class="line">考虑下面的代码:   </span><br><span class="line">&#x2F;&#x2F;StringTest.java   </span><br><span class="line">public   class   StringTest   &#123;      </span><br><span class="line">    static   String   s;     &#x2F;&#x2F;*   </span><br><span class="line">    public   static   void   main(String[]   args)   &#123;   </span><br><span class="line">        &#x2F;&#x2F;String   s;         &#x2F;&#x2F;**   </span><br><span class="line">        System.out.println(s);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;     </span><br><span class="line">编译并运行上面的代码,将打印null。</span><br><span class="line">可见标有*号的行是自动初始化了的(s被自动初始化为null)。   </span><br><span class="line">而如果把标有**号的行取消注释,代码将不能通过编译,这是因为这行定义的是本地变量,而本地变量是不会自动初始化的。</span><br><span class="line">由此得出结论：</span><br><span class="line">在成员变量的定义中,String s;等同于String s&#x3D;null;</span><br><span class="line">而在本地变量(方法变量)的定义中,String s;不等同于String s&#x3D;null;,这时要使用s必须显式地赋值。</span><br><span class="line">这些虽然是小知识点,但在实际应用中很重要,也很容易被一些人忽视,特此提出。</span><br><span class="line">还有一点要说明的是：</span><br><span class="line">只要是在方法在中定义变量都要显示赋初值，main()方法也不例外，而在方法之外编译器回自动赋初值</span><br></pre></td></tr></table></figure>



<p>spring的判空</p>
<p>Spring-core中提供了大量的工具类，常用的有StringUtils、ObjectUtils、NumberUtils、Base64Utils等，Spring工具类在spring-core.jar中的org.springframework.util包下。</p>
<p>1.isEmpty 没有忽略空格参数，是以是否为空和是否存在为判断依据。<br>2.isBlank 是在 isEmpty 的基础上进行了为空（字符串都为空格、制表符、tab 的情况）的判断。（一般更为常用）</p>
<p>这里推荐使用isBlank方法，因为可能会存在“     ”的情况，当这种情况下，需要根据自己的业务判断是不是为null的情况，避免出现错误，影响业务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.isEmpty(<span class="string">&quot;yyy&quot;</span>) = <span class="keyword">false</span></span><br><span class="line">StringUtils.isEmpty(<span class="string">&quot;&quot;</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.isEmpty(<span class="string">&quot;   &quot;</span>) = <span class="keyword">false</span></span><br><span class="line"> </span><br><span class="line">StringUtils.isBlank(<span class="string">&quot;yyy&quot;</span>) = <span class="keyword">false</span></span><br><span class="line">StringUtils.isBlank(<span class="string">&quot;&quot;</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.isBlank(<span class="string">&quot;   &quot;</span>) = <span class="keyword">true</span></span><br></pre></td></tr></table></figure>



<p>null只有=和==方法可以使用，如果使用其他方法会报空指针异常的错误。</p>
<p>总结：</p>
<p>1.null==判断的对象：只判断null的情况</p>
<p>2.StringUtils.isEmpty(判断的对象)：判断null和””的情况</p>
<p>3.StringUtils.isBlank(判断的对象)：判断null和””和”     “的情况</p>
<p>判空方法：</p>
<p>1.字符串与已知值进行比较，已知值放在前面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">123</span>”.equals(value)</span><br></pre></td></tr></table></figure>

<p>2.两个字符串比较，不确定是否有空值，使用Object.equals() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> r = Objects.equals(a,b);</span><br></pre></td></tr></table></figure>

<p>3.使用 java8 中的 Optional 类代替显示判空：Java 8中，每当一个函数需要返回 null，应该返回 Optional</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(<span class="keyword">null</span>).orElse(<span class="string">&quot;0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>首先，创建第二个getter返回 Optional：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Optional getMemberCardOpt() &#123;   return Optional.ofNullable(memberCard); &#125; </span><br></pre></td></tr></table></figure>

<p>其次，更改原始的getter以委托给新的getter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String getMemberCard() &#123;   return getMemberCardOpt().orElse(null); &#125;</span><br></pre></td></tr></table></figure>









<ol>
<li>经典 if 判断</li>
<li>使用Java 8的检查 java.util.Objects -在当今开发中的项目中使用最广泛</li>
<li>Lombok @NonNull 导致将 if 检查添加到生成的字节码中。</li>
<li>assert关键字：我个人不喜欢它，因为可以通过JVM参数全局禁用断言</li>
</ol>
<p>写业务代码的时候，通常会遇到数据库POJO对象转换为前端需要的VO对象，这时经常会遇到烦人的空指针问题，Java 8之前，我们可能这么写：</p>
<p>对于对象field复制风格:<br>a.setCreateTime(b.getCreateTime().getTime());<br>a.setAmount(b.getPayed()+b.getVoucher());<br>1<br>2<br>对于装饰器风格：<br>public Long getCreateTime() {<br>    return b.getCreateTime().getTime();<br>}<br>public Long getAmount() {<br>    return b.getPayed()+b.getVoucher()<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>很明显，这些代码会有空指针异常的风险.一般我们会这么修改：</p>
<p>对于对象field复制风格:<br>if (b.getCreateTime()!= null) {<br>    a.setCreateTime(b.getCreateTime().getTime());<br>}<br>if (b.getPayed() != null) {<br>    a.setAmount(b.getPayed();<br>} else {<br>    a.setAmount(0L);<br>}<br>if (b.getVoucher() != null) {<br>a.setAmount(a.getAmount()+b.getVoucher());<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>对于装饰器风格：<br>public Long getCreateTime() {<br>    if (b.getCreateTime()!= null) {<br>        return b.getCreateTime().getTime();<br>    } else {<br>        return null;<br>    }<br>}<br>public Long getAmount() {<br>    Long result = 0L;<br>    if (b.getPayed() != null) {<br>        result += b.getPayed();<br>    }<br>    if (b.getVoucher() != null) {<br>        result += b.getVoucher();<br>    }<br>    return result;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>Java8引入的Optional写法：</p>
<p>对于对象field复制风格:<br>Optional.ofNullable(b.getCreateTime()).ifPresent(timestamp -&gt; a.setCreateTime(timestamp.getTime()));<br>a.setAmount(Optional.ofNullable(b.getPayed()).orElse(0L) + Optional.ofNullable(b.getVoucher()).orElse(0L));<br>1<br>2<br>对于装饰器风格：<br>public Long getCreateTime() {<br>    Optional<Timestamp> createTime = Optional.ofNullable(b.getCreateTime());<br>    if (createTime.isPresent()) {<br>        return createTime.get();<br>    } else {<br>        return null;<br>    }<br>}<br>public Long getAmount() {<br>    return Optional.ofNullable(b.getPayed()).orElse(0L) + Optional.ofNullable(b.getVoucher()).orElse(0L)<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>这样依然很复杂，尤其是嵌套多层之后。<br>更进一步，有没有通用简便的方法呢？联想到Java8的Functional Interface以及我们需要处理的异常只有空指针异常，可以写工具类：</p>
<p>import java.util.function.Supplier;</p>
<p>public class OptionalUtil {<br>    /**<br>     * 忽略NullPointerException的获取<br>     * @param supplier<br>     * @param <T><br>     * @return 如果有空指针，返回null<br>     */<br>    public static <T> T orNull(Supplier<T> supplier) {<br>        try {<br>            return supplier.get();<br>        } catch (NullPointerException e) {<br>            return null;<br>        }<br>    }</p>
<p>   /**<br>     * 忽略NullPointerException的获取<br>     *<br>     * @param supplier<br>     * @param or<br>     * @param <T><br>     * @return 如果有空指针，返回or<br>     */<br>    public static <T> T or(Supplier<T> supplier, T or) {<br>        try {<br>            T t = supplier.get();<br>            if (t != null) {<br>                return t;<br>            }<br>            return or;<br>        } catch (NullPointerException e) {<br>            return or;<br>        }<br>    }<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>这样，我们的代码就变得简洁多了：</p>
<p>对于对象field复制风格:<br>a.setCreateTime(OptionalUtil.orNull(() -&gt; b.getCreateTime().getTime()));<br>a.setAmount(OptionalUtil.or(() -&gt; b.getPayed(), 0L) + OptionalUtil.or(() -&gt; b.getAmount(), 0L));<br>1<br>2<br>对于装饰器风格：<br>public Long getCreateTime() {<br>    return OptionalUtil.orNull(() -&gt; b.getCreateTime().getTime());<br>}<br>public Long getAmount() {<br>    return OptionalUtil.or(() -&gt; b.getPayed(), 0L) + OptionalUtil.or(() -&gt; b.getAmount(), 0L);<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.22.%E5%85%B3%E4%BA%8Enull/" data-id="ckvc2kue0004v9kwdbt1z2r2g" data-title="关于null" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-4.20.JDBC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/4.20.JDBC/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:18:28.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/4.20.JDBC/">JDBC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>jdbc（Java数据库连接）是一种用于执行<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=12370852&ss_c=ssc.citiao.link">SQL语句</a>的Java API，由一组用Java语言编写的类和接口组成。</p>
<p>驱动：两个设备（应用）之间通信的桥梁。</p>
<p>SUN公司提供一套统一的规范（接口）。然后各个数据库生产商提供这套接口的实现。这套接口规范就是JDBC的规范。</p>
<p>JDBC的环境准备：</p>
<p>\1. 创建数据库和表</p>
<p>\2. 创建项目，引入jar包</p>
<p>JDBC的开发步骤：</p>
<p>1.加载驱动：Class.forname</p>
<p>2.获得连接：DriverManager</p>
<p>\3. 基本操作：执行SQL：</p>
<p>获得执行SQL语句的对象：createStatement()方法，返回值是Statement</p>
<p>编写SQL语句：String sql = “select * from user”;</p>
<p>执行SQL：executeQuery(sql)方法，返回值是ResultSet</p>
<p>遍历该set集合</p>
<p>\4. 释放资源：集合、执行SQL语句的对象、获得的连接都要释放资源</p>
<p>DriverManager：驱动管理类</p>
<p>作用：1.注册驱动：DriverManager.registerDriver(Driver driver);</p>
<p>这个方法可以完成驱动的注册，但是实际开发中一般不会使用这个方法完成驱动的注册，而是使用Class.forname(“com.mysql.jdbc.Driver”);</p>
<p>因为如果需要注册驱动，就会使用DriverManager.registerDriver(new Driver());，但是查看Driver源代码发现，在代码中有一段静态代码块，静态代码块已经调用了注册驱动的方法，如果再手动调用该方法注册驱动，就会导致驱动被注册两次</p>
<p>2.获得连接：DriverManager.getConnection(String url, String username, String password);</p>
<p>url：与数据库连接的路径</p>
<p>user    ：与数据库连接的用户名</p>
<p>password：与数据库连接的密码</p>
<p>url的写法：jdbc:mysql://localhost:3306/web_test3</p>
<p>jdbc    :连接数据库的协议</p>
<p>mysql:是jdbc的子协议</p>
<p>localhost:连接的MySQL数据库服务器的主机地址。（连接是本机就可以写成localhost），如果连接不是本机的，就需要写上连接主机的IP地址。</p>
<p>3306:MySQL数据库服务器的端口号</p>
<p>web_test3:数据库名称</p>
<p>url如果连接的是本机的路径，可以简化为：jdbc:mysql:///web_test3</p>
<p>Connection：与数据库连接对象</p>
<p>作用：1.创建执行SQL语句的对象：</p>
<p>Statement:执行SQL Statement createStatement()</p>
<p>CallableStatement:执行数据库中存储过程 CallableStatement prepareCall(String sql)</p>
<p>PreparedStatement:（主要用这个）执行SQL.对SQL进行预处理。解决SQL注入漏洞 PreparedStatement preparedStatement (String sql)</p>
<p>\2. 管理事务</p>
<p>void setAutoCommit(boolean autoCommit):将此连接的自动提交模式改为给定状态</p>
<p>void commit():将所有上一次提交/回滚后进行的更改变为永久性更改，并释放此Connection对象当前持有的所有数据库锁</p>
<p>void rollback():取消在当前事务中进行的所有更改，并释放此Connection对象当前持有的所有数据库锁</p>
<p>Statement：执行SQL</p>
<p>作用：1.执行SQL</p>
<p>boolean execute(String sql); 执行查询，修改，添加，删除的SQL语句 （如果第一个结果为ResultSet对象，则返回true；如果是更新计数或者不存在任何结果，返回false）</p>
<p>ResultSet executeQuery(String sql); 执行查询（执行select语句）</p>
<p>int executeUpate(String sql);执行修改，添加，删除的SQL语句 （SQL DDL语句也可以）（返回的是影响的行数）</p>
<p>2.执行批处理</p>
<p>void addBatch(String sql)  将给定的sql命令添加到此Statement对象的当前命令列表中</p>
<p>void clearBatch()  清空此Statement对象的当前SQL命令列表</p>
<p>int[] executeBatch()  将一批命令交给数据库来执行，如果全部命令执行成功，则返回更新计数组成的数组</p>
<p>ResultSet：结果集，通过select语句的查询结果（只有select语句才有结果集）</p>
<p>结果集的遍历：</p>
<p>boolean next（）；  将光标从当前位置向下移一行（刚开始是在第一行之前的空白，调用了该方法之后会移动到第一行）</p>
<p>结果集的获取：</p>
<p>结果集获取可以使用结果集中的: getXXX(); 方法通常都会有一个重载的方法（int、long、String，Object就比较通用）</p>
<p>传递的参数可以是列号也可以是列名：</p>
<p>getXXX(int columnIndex);</p>
<p>getXXX(String columnName); （一般传的参数是列名，因为查询的话，有可能结果的列号不一样）</p>
<p>资源释放：</p>
<p>JDBC程序执行结束后，将与数据库进行交互的对象释放掉，通常是ResultSet,Statement,Connection</p>
<p>这几个对象中尤其是Connection对象是非常稀有的。这个对象一定要做到尽量晚创建，尽早释放掉。</p>
<p>将资源释放的代码写入到finally的代码块中，确保资源会释放。但是资源释放的时候仍可能出现异常，所以资源释放的代码应该写的标准：再用trycatch语句进行判空，判完之后要将对象赋值为null：因为可以让垃圾回收器尽快的将资源回收。</p>
<p>JDBC的CRUD操作：</p>
<p>添加、删除、修改操作：</p>
<p>\1. 创建Connection和Statement并赋值为null</p>
<p>\2. try语句中进行：注册驱动，获得连接，创建执行SQL语句对象，编写相应的SQL语句，执行SQL（excuteUpdate(sql)方法），对返回值进行判断。</p>
<p>\3. 释放资源（判空，抛异常，赋值为null）</p>
<p>查询操作：查询多条记录和查询一条记录</p>
<p>1.创建Connection和Statement和ResultSet并赋值为null</p>
<p>2.try语句中进行：注册驱动，获得连接，创建执行SQL语句对象，编写相应的SQL语句，执行SQL（excuteQuery（sql）方法）。多条语句进行遍历while，一条语句进行判断if，并输出</p>
<p>3.释放资源（判空，抛异常，赋值为null）</p>
<p>JDBC的工具类的抽取：因为注册驱动，获得连接，释放资源的代码都是相同的，所以可以抽取成一个工具类。</p>
<p>/**</p>
<p> * JDBC的工具类</p>
<p> * <em><strong>*@author*</strong></em> swx</p>
<p> */</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> JDBCUtils {</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>driverClassName*</em>***;</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>url*</em>***;</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>username*</em>***;</p>
<p>​    <em><strong>*private*</strong></em> <em><strong>*static*</strong></em> <em><strong>*final*</strong></em> String ****<em>password*</em>***;</p>
<p>​    <em><strong>*static*</strong></em>{</p>
<p>​        ****<em>driverClassName*</em>***=”com.mysql.jdbc.Driver”;</p>
<p>​        ****<em>url*</em>***=”jdbc:mysql:///web_test3”;</p>
<p>​        ****<em>username*</em>***=”root”;</p>
<p>​        ****<em>password*</em>***=”abc”;</p>
<p>​    }</p>
<p>​    /**</p>
<p>​     * 注册驱动的方法</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> loadDriver(){</p>
<p>​        <em><strong>*try*</strong></em> {</p>
<p>​            Class.<strong>forName</strong>(****<em>driverClassName*</em>***);</p>
<p>​        } <em><strong>*catch*</strong></em> (ClassNotFoundException e) {</p>
<p>​            e.printStackTrace();</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     * 获得连接的方法</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> Connection getConnection(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 将驱动一并注册:</p>
<p>​            <strong>loadDriver</strong>();</p>
<p>​            // 获得连接</p>
<p>​            conn = DriverManager.<strong>getConnection</strong>(<em><strong>*<em>url*</em>***,</strong></em>*<em>username*</em>***, ****<em>password*</em>***);</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }</p>
<p>​        <em><strong>*return*</strong></em> conn;</p>
<p>​    }</p>
<p>​    </p>
<p>​    /**</p>
<p>​     * 释放资源的方法</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> release(Statement stmt,Connection conn){</p>
<p>​        <em><strong>*if*</strong></em>(stmt != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                stmt.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            </p>
<p>​            stmt = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​        <em><strong>*if*</strong></em>(conn != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                conn.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            conn = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*static*</strong></em> <em><strong>*void*</strong></em> release(ResultSet rs,Statement stmt,Connection conn){</p>
<p>​        // 资源释放：</p>
<p>​        <em><strong>*if*</strong></em>(rs != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                rs.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            </p>
<p>​            rs = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​        <em><strong>*if*</strong></em>(stmt != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                stmt.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            </p>
<p>​            stmt = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​        <em><strong>*if*</strong></em>(conn != <em><strong>*null*</strong></em>){</p>
<p>​            <em><strong>*try*</strong></em> {</p>
<p>​                conn.close();</p>
<p>​            } <em><strong>*catch*</strong></em> (SQLException e) {</p>
<p>​                e.printStackTrace();</p>
<p>​            }</p>
<p>​            conn = <em><strong>*null*</strong></em>;</p>
<p>​        }</p>
<p>​    }</p>
<p>}</p>
<p>静态代码块可以写成配置文件</p>
<p>配置文件：两种</p>
<p>\1. 属性文件：扩展名为.properties  内容是key=value</p>
<p>\2. XML文件</p>
<p>定义一个配置文件：写好键值对的相应配置，修改文件扩展名为.properties</p>
<p><img src="/4.20.JDBC/wps1.jpg" alt="img"> </p>
<p>在工具类中解析属性文件：依然在静态代码块中进行解析：</p>
<p><img src="/4.20.JDBC/wps2.jpg" alt="img"> </p>
<p>SQL注入漏洞：通过知道用户名，然后进行sql语句查询就可以进行登录。</p>
<p><img src="/4.20.JDBC/wps3.jpg" alt="img"> </p>
<p>“+username+”和“+password+” 是字符串拼接</p>
<p><img src="/4.20.JDBC/wps4.jpg" alt="img"> </p>
<p>当用户名输入为aaa’ or ‘1=1 ，密码随意写，就能登录成功：</p>
<p>select * from user where username = ‘ aaa’ or ‘ 1=1  ‘ and password = ‘ asdafaf ’</p>
<p>因为先进行and运算，true and false 结果为false 。再进行or运算， true or false 结果为true，所以可以成功。</p>
<p>当用户名输入为aaa’ or ‘1=1 ，密码随意写，也能登录成功：</p>
<p>select * from user where username = ‘ aaa’ –  ‘ and password = ‘ asdafaf ’</p>
<p>因为– 代表注释，相当于aaa后面的都没了，结果为true，所以可以成功。</p>
<p>出现漏洞的原因就是因为 or  和 – 都是SQL的关键字</p>
<p>解决方案：得在后台，后端解决。（因为可以绕过前端）</p>
<p>需要采用PreparedStatement对象解决SQL注入漏洞。这个对象将SQL预先进行编译，使用?作为占位符。?所代表内容是SQL所固定。再次传入变量（包含SQL的关键字）。这个时候也不会识别这些关键字。</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> UserDao {</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*boolean*</strong></em> login(String username,String password){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        // 定义一个变量:</p>
<p>​        <em><strong>*boolean*</strong></em> flag = <em><strong>*false*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接:</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            // 编写SQL语句:</p>
<p>​            String sql = “select * from user where username = ? and password = ?”;</p>
<p>​            // 预编译SQL</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setString(1, username); //1代表第一个问号</p>
<p>​            pstmt.setString(2, password); // 2代表第二个问号</p>
<p>​            // 执行SQL语句:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*if*</strong></em>(rs.next()){</p>
<p>​                // 说明根据用户名和密码可以查询到这条记录</p>
<p>​                flag = <em><strong>*true*</strong></em>;</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);//这里传的pstmt实际是stmt的子类，实际上用的是多态</p>
<p>​        }</p>
<p>​        <em><strong>*return*</strong></em> flag;</p>
<p>​    }</p>
<p>所以以后的Statement都最好用PreparedStatement</p>
<p>增加操作：String sql = “insert into user values (null,?,?,?,?)”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setString(1, “eee”);</p>
<p>​            pstmt.setString(2, “abc”);</p>
<p>​            pstmt.setString(3, “旺财”);</p>
<p>​            pstmt.setInt(4, 32);</p>
<p>​            // 执行SQL</p>
<p>​            <em><strong>*int*</strong></em> num = pstmt.executeUpdate();</p>
<p>​            <em><strong>*if*</strong></em>(num &gt; 0){</p>
<p>​                System.****<em>out*</em>***.println(“保存成功！”);</p>
<p>​            }</p>
<p>修改操作：String sql = “update user set username = ?,password =?,nickname=?,age = ? where id = ?”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setString(1, “abc”);</p>
<p>​            pstmt.setString(2, “1234”);</p>
<p>​            pstmt.setString(3, “旺旺”);</p>
<p>​            pstmt.setInt(4, 23);</p>
<p>​            pstmt.setInt(5, 6);</p>
<p>​            // 执行SQL：</p>
<p>​            <em><strong>*int*</strong></em> num = pstmt.executeUpdate();</p>
<p>​            <em><strong>*if*</strong></em>(num &gt; 0){</p>
<p>​                System.****<em>out*</em>***.println(“修改成功！”);</p>
<p>​            }</p>
<p>删除操作：String sql = “delete from user where id = ?”;</p>
<p>​            // 预编译SQL</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            pstmt.setInt(1, 4);</p>
<p>​            // 执行SQL:</p>
<p>​            <em><strong>*int*</strong></em> num = pstmt.executeUpdate();</p>
<p>​            <em><strong>*if*</strong></em>(num &gt; 0){</p>
<p>​                System.****<em>out*</em>***.println(“删除成功！”);</p>
<p>​            }</p>
<p>查找操作：String sql = “select * from user”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 执行SQL:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            // 遍历结果集:</p>
<p>​            while(rs.next()){</p>
<p>​                System.out.println(rs.getInt(“id”)+” “+rs.getString(“username”)+” “+rs.getString(“password”)+” “+rs.getString(“nickname”));</p>
<p>}</p>
<p>JDBC的批处理：之前进行JDBC的操作的时候，都是一条SQL语句执行。现在如果使用批处理，可以将一批SQL一起执行。</p>
<p>用Statement进行批处理：@Test</p>
<p>​    /**</p>
<p>​     * 批处理基本操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        Statement stmt = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接:</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            // 创建执行批处理对象:</p>
<p>​            stmt = conn.createStatement();</p>
<p>​            // 编写一批SQL语句：</p>
<p>​            String sql1 = “create database test1”;</p>
<p>​            String sql2 = “use test1”;</p>
<p>​            String sql3 = “create table user(id int primary key auto_increment,name varchar(20))”;</p>
<p>​            String sql4 = “insert into user values (null,’aaa’)”;</p>
<p>​            String sql5 = “insert into user values (null,’bbb’)”;</p>
<p>​            String sql6 = “insert into user values (null,’ccc’)”;</p>
<p>​            String sql7 = “update user set name = ‘mmm’ where id = 2”;</p>
<p>​            String sql8 = “delete from user where id = 1”;</p>
<p>​            // 添加到批处理</p>
<p>​            stmt.addBatch(sql1);</p>
<p>​            stmt.addBatch(sql2);</p>
<p>​            stmt.addBatch(sql3);</p>
<p>​            stmt.addBatch(sql4);</p>
<p>​            stmt.addBatch(sql5);</p>
<p>​            stmt.addBatch(sql6);</p>
<p>​            stmt.addBatch(sql7);</p>
<p>​            stmt.addBatch(sql8);</p>
<p>​            // 执行批处理:</p>
<p>​            stmt.executeBatch();</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(stmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>使用PreparedStatement进行批量插入：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 批量插入记录:</p>
<p>​     * * 默认情况下MySQL批处理没有开启的，需要在url后面拼接一个参数即可：</p>
<p>?rewriteBatchedStatements=true</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2(){</p>
<p>​        // 记录开始时间:</p>
<p>​        <em><strong>*long*</strong></em> begin = System.<strong>currentTimeMillis</strong>();</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接:</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            // 编写SQL语句：</p>
<p>​            String sql = “insert into user values (null,?)”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            <em><strong>*for*</strong></em>(<em><strong>*int*</strong></em> i=1;i&lt;=10000;i++){</p>
<p>​                pstmt.setString(1, “name”+i);</p>
<p>​                // 添加到批处理</p>
<p>​                pstmt.addBatch();</p>
<p>​                // 注意问题：</p>
<p>​                // 执行批处理：每1000次进行一次批量处理和清空，以防止内存溢出</p>
<p>​                <em><strong>*if*</strong></em>(i % 1000 == 0){</p>
<p>​                    // 执行批处理:</p>
<p>​                    pstmt.executeBatch();</p>
<p>​                    // 清空批处理:</p>
<p>​                    pstmt.clearBatch();</p>
<p>​                }</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(pstmt, conn);</p>
<p>​        }</p>
<p>​        <em><strong>*long*</strong></em> end = System.<strong>currentTimeMillis</strong>();</p>
<p>​        System.****<em>out*</em>***.println((end-begin));</p>
<p>​    }</p>
<p>JDBC的事务：</p>
<p>事务指的是逻辑上的一组操作，组成这组操作各个逻辑单元要么全都成功，要么全都失败。</p>
<p>如果写一个转账代码，没有加事务的话，可能会出现扣钱了，但是另一个账户没有加钱的情况，所以需要加事务。</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 完成转账的案例</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            /**</p>
<p>​             * 完成转账代码：</p>
<p>​             * * 扣除某个账号的钱</p>
<p>​             * * 给另外一个账号加钱</p>
<p>​             */</p>
<p>​            // 获得连接：</p>
<p>​            conn = JDBCUtils.<strong>getConnection</strong>();</p>
<p>​            <em><strong>*// 开启事务*</strong></em></p>
<p>​            <em><strong>*conn.setAutoCommit(*</strong>***</em>*false*<strong><strong><strong>*);*</strong></strong></strong>*//设置为false是需要手动提交，设为true的话，写一条sql语句就会提交一句****</p>
<p>​            // 编写SQL语句：</p>
<p>​            String sql = “update account set money = money + ? where name = ?”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 用aaa账号给bbb账号转1000元</p>
<p>​            pstmt.setDouble(1, -1000);</p>
<p>​            pstmt.setString(2, “aaa”);</p>
<p>​            // 执行SQL：扣除aaa账号1000元</p>
<p>​            pstmt.executeUpdate();</p>
<p>​            </p>
<p>​            <em><strong>*int*</strong></em> i = 1 / 0; //假设这里出现了异常，结果账户的钱也不会发生改变</p>
<p>​            </p>
<p>​            // 给bbb账号加1000</p>
<p>​            pstmt.setDouble(1, 1000);</p>
<p>​            pstmt.setString(2, “bbb”);</p>
<p>​            pstmt.executeUpdate();</p>
<p>​            </p>
<p>​            <em><strong>*// 提交事务:*</strong></em></p>
<p>​            <em><strong>*conn.commit();*</strong></em></p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            <em><strong>*// 回滚事务:*</strong></em></p>
<p>​            <em><strong>*try*</strong></em> <em><strong>*{*</strong></em></p>
<p>​                <em><strong>*conn.rollback();*</strong></em></p>
<p>​            <em><strong>*}*</strong></em> <em><strong>*catch*</strong></em> <em><strong>*(SQLException e1) {*</strong></em></p>
<p>​                <em><strong>*e1.printStackTrace();*</strong></em></p>
<p>​            <em><strong>*}*</strong></em></p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="*连接池*"></a><em><strong>*连接池*</strong></em></h1><p>连接池是装有连接的容器，线程使用连接的话，可以从连接池中进行获取，使用完成之后将连接归还给连接池。</p>
<p>连接对象创建和销毁是需要耗费时间的，在服务器初始化的时候就初始化一些连接。把这些连接放入到内存中，使用的时候可以从内存中获取，使用完成之后将连接放入连接池中。从内存中获取和归还的效率要远远高于创建和销毁的效率。（提升性能）</p>
<p>自定义连接池：</p>
<p>\1. 编写一个类实现DataSource接口</p>
<p>\2. 重写getConnection方法</p>
<p>\3. 初始化多个连接在内存中</p>
<p>\4. 编写归还连接的方法</p>
<p><img src="/4.20.JDBC/wps5.jpg" alt="img"> </p>
<p>测试：</p>
<p><img src="/4.20.JDBC/wps6.jpg" alt="img"> </p>
<p>但是这个自定义连接池也存在两个问题：</p>
<p>使用接口的实现类完成的构造：</p>
<p>MyDataSource dataSource = new MyDataSource(); 这种写法不利于程序的扩展：</p>
<p>应该用这样的DataSource dataSource = new MyDataSource(); （多态）</p>
<p>但是这样的话，因为DataSource下没有addBack方法所以下面的调用会出错；同时因为调用了addBack方法，会对使用连接池的用户增加难度（因为要理解什么是addBack方法，额外提供了方法归还连接）</p>
<p>解决：不提供自定义的方法addBack就可以解决这个问题，所以需要改写一个方法解决归还的问题。</p>
<p>在Connection中是有一个close方法的，colse方法完成了连接的销毁。现在需要写一个方法，将原有的连接的close方法改为归还。</p>
<p>增强一个类中的方法：</p>
<p>\1. 采用继承：是最简单的一种增强某个类中的方法的方式。</p>
<p>条件：需要控制这个类的构造才能进行继承。</p>
<p>\2. 采用装饰者模式：比如：BufferedInputStream（InputStream）</p>
<p>条件：增强的类和被增强的那个类要实现同样的接口；在增强的类中要有被增强的那个类的引用。</p>
<p>\3. 动态代理</p>
<p>使用装饰者模式增强Connection中的close方法：（因为接口内的方法需要全部重写，而继承的话，可以只重写某一个或几个方法）</p>
<p>为了简化编程，提供一个模板类（模板类原封不动的将接口中的所有方法都实现，但是都没有增强）。编写一个装饰类继承模板类。在装饰类中只需要增强某一个方法即可。</p>
<p><img src="/4.20.JDBC/wps7.jpg" alt="img"> </p>
<p>连接池的代码：</p>
<p><em><strong>*public*</strong></em> <em><strong>*class*</strong></em> MyDataSource <em><strong>*implements*</strong></em> DataSource {</p>
<p>​    // 将一些连接存入到内存中，可以定义一个集合，用于存储连接对象。</p>
<p>​    <em><strong>*private*</strong></em> List<Connection> connList = <em><strong>*new*</strong></em> ArrayList<Connection>();</p>
<p>​    </p>
<p>​    // 在初始化的时候提供一些连接</p>
<p>​    <em><strong>*public*</strong></em> MyDataSource() {</p>
<p>​        // 初始化连接：</p>
<p>​        <em><strong>*for*</strong></em>(<em><strong>*int*</strong></em> i = 1;i&lt;=3;i++){</p>
<p>​            // 向集合中存入连接:</p>
<p>​            connList.add(JDBCUtils.<strong>getConnection</strong>());</p>
<p>​        }</p>
<p>​    }</p>
<p>​    </p>
<p>​    // 从连接池中获得连接的方法</p>
<p>​    @Override</p>
<p>​    <em><strong>*public*</strong></em> Connection getConnection() <em><strong>*throws*</strong></em> SQLException {</p>
<p>​        Connection conn = connList.remove(0);</p>
<p>​        <em><strong>*// 增强连接：*</strong></em></p>
<p>​        <em><strong>*MyConnectionWrapper connWrapper =*</strong></em> <em><strong>*new*</strong></em> <em><strong>*MyConnectionWrapper(conn, connList);*</strong></em></p>
<p>​        <em><strong>*return*</strong></em> connWrapper;</p>
<p>​    }</p>
<p>​    </p>
<p>​    <em><strong>*// 编写一个归还连接的方法:*</strong></em></p>
<p>​    <em><strong>*/*public void addBack(Connection*</strong></em> <em><strong>*conn*</strong>***</em>*){****</p>
<p>​        <em><strong>*connList.add(*</strong>***</em>*conn****<em><strong>*);*</strong></em></p>
<p>​    <em><strong>*}*/*</strong></em></p>
<p>}</p>
<p>测试：</p>
<p><img src="/4.20.JDBC/wps8.jpg" alt="img"> </p>
<h1 id="Druid开源连接池"><a href="#Druid开源连接池" class="headerlink" title="*Druid开源连接池*"></a><em><strong>*Druid开源连接池*</strong></em></h1><p>Druid是阿里旗下开源连接池产品，使用非常简单，可以与Spring框架进行快速整合。</p>
<p>在项目下新建一个文件夹folder名为lib，复制mysql的驱动包，druid的jar包到lib中，添加buid path。</p>
<p>/<em>可以直接添加工具类，配置文件。然后直接获得连接，执行SQL语句，释放资源。（但是最好用连接池，不用这个）</em>/</p>
<p>使用这个druid连接池可以去百度搜索它的帮助文档查看相关的API。核心类：DruidDataSource</p>
<p>利用这个核心类可以创建对象，然后手动设置数据库连接的参数：setXxx的方法，（也可以使用配置文件进行获取参数）获得连接：getConnection方法。最后释放资源中conn的释放不是销毁而是归还到连接池中（Druid连接池底层一定重写了这个方法变成了归还）</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * Druid的使用:</p>
<p>​     * * 手动设置参数的方式</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 使用连接池：</p>
<p>​            DruidDataSource dataSource = <em><strong>*new*</strong></em> DruidDataSource();</p>
<p>​            // 手动设置数据库连接的参数:</p>
<p>​            dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);</p>
<p>​            dataSource.setUrl(“jdbc:mysql:///web_test4”);</p>
<p>​            dataSource.setUsername(“root”);</p>
<p>​            dataSource.setPassword(“abc”);</p>
<p>​            // 获得连接：</p>
<p>//            conn = JDBCUtils.getConnection();</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL:</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 执行SQL:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>也可以用配置文件进行参数的获取：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * Druid的使用:</p>
<p>​     * * 配置文件方式设置参数</p>
<p>​     * Druid配置方式可以使用属性文件配置的。</p>
<p>​     * * 文件名称没有规定但是属性文件中的key要一定的。</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 使用连接池：</p>
<p>​            // 从属性文件中获取：</p>
<p>​            Properties properties = <em><strong>*new*</strong></em> Properties();</p>
<p>​            properties.load(<em><strong>*new*</strong></em> FileInputStream(“src/druid.properties”));</p>
<p>//这里()内需要传一个InputStream，现在可以这样子传，在WEB中是另一种。</p>
<p>​            DataSource dataSource = DruidDataSourceFactory.<strong>createDataSource</strong>(properties);</p>
<p>​            // 获得连接：</p>
<p>//            conn = JDBCUtils.getConnection();</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL:</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 设置参数:</p>
<p>​            // 执行SQL:</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>虽然可以在这里进行配置文件的配置，但是不太好，可以放在JDBC的工具类中。</p>
<h1 id="C3P0开源连接池"><a href="#C3P0开源连接池" class="headerlink" title="*C3P0开源连接池*"></a><em><strong>*C3P0开源连接池*</strong></em></h1><p>C3P0是一个开源的JDBC<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8024867&ss_c=ssc.citiao.link">连接池</a>，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有<a target="_blank" rel="noopener" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=54630&ss_c=ssc.citiao.link">Hibernate</a>，Spring等。</p>
<p>C3P0的核心类是：ComboPooledDataSource</p>
<p>手动设置参数：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 手动设置参数的方式:</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接：从连接池中获取：</p>
<p>​            // 创建连接池：</p>
<p>​            ComboPooledDataSource dataSource = <em><strong>*new*</strong></em> ComboPooledDataSource();</p>
<p>​            // 设置连接参数:</p>
<p>​            dataSource.setDriverClass(“com.mysql.jdbc.Driver”);</p>
<p>​            dataSource.setJdbcUrl(“jdbc:mysql:///web_test4”);</p>
<p>​            dataSource.setUser(“root”);</p>
<p>​            dataSource.setPassword(“abc”);</p>
<p>​            // 从连接池中获得连接:</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL：</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 执行SQL：</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>配置文件设置参数：</p>
<p>默认情况下，c3p0会在类加载的resource路径下查找一个配置文件“/c3p0-config.xml”。所以XML文件应该在应用的CLASSPATH下的一个文件夹或者jar包中，如果是WEB的话会在WEB-INF/classes下，其他的话也是类似的路径。c3p0不仅支持xml文件，也支持properties文件（以后的重点）。</p>
<p>配置连接池：</p>
<p>在src下新建一个xml文件，设置名为c3p0-config.xml，可以在帮助文档中找到xml的配置代码:</p>
<p><default-config>…… </default-config>  默认配置</p>
<p>&lt;named-config  name=” ”&gt; ……</named-config>  自定义配置</p>
<p>可以修改其中的配置key，value。</p>
<p><img src="/4.20.JDBC/wps9.jpg" alt="img"> </p>
<p>使用连接池：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 采用配置文件的方式：</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2(){</p>
<p>​        Connection conn = <em><strong>*null*</strong></em>;</p>
<p>​        PreparedStatement pstmt = <em><strong>*null*</strong></em>;</p>
<p>​        ResultSet rs = <em><strong>*null*</strong></em>;</p>
<p>​        <em><strong>*try*</strong></em>{</p>
<p>​            // 获得连接：从连接池中获取：</p>
<p>​            // 创建连接池：//创建连接池默认去类路径下查找c3p0-config.xml，并且将其中的各种参数加载好</p>
<p>​            ComboPooledDataSource dataSource = <em><strong>*new*</strong></em> ComboPooledDataSource();</p>
<p>//()里面可以传递配置的名称从而加载不同的参数。如果名称没有匹配的，会加载默认的配置参数</p>
<p>​            // 从连接池中获得连接:</p>
<p>​            conn = dataSource.getConnection();</p>
<p>​            // 编写SQL：</p>
<p>​            String sql = “select * from account”;</p>
<p>​            // 预编译SQL:</p>
<p>​            pstmt = conn.prepareStatement(sql);</p>
<p>​            // 执行SQL：</p>
<p>​            rs = pstmt.executeQuery();</p>
<p>​            <em><strong>*while*</strong></em>(rs.next()){</p>
<p>​                System.****<em>out*</em>***.println(rs.getInt(“id”)+” “+rs.getString(“name”)+” “+rs.getDouble(“money”));</p>
<p>​            }</p>
<p>​        }<em><strong>*catch*</strong></em>(Exception e){</p>
<p>​            e.printStackTrace();</p>
<p>​        }<em><strong>*finally*</strong></em>{</p>
<p>​            JDBCUtils.<strong>release</strong>(rs, pstmt, conn);</p>
<p>​        }</p>
<p>​    }</p>
<p>参数可以设置很多个，很多种，所以其应用很灵活。</p>
<p>以上的代码都不规范，因为每次都会创建一个新的连接池，会浪费资源，所以需要对工具类进行改写和完善</p>
<p><img src="/4.20.JDBC/wps10.jpg" alt="img"> </p>
<h1 id="DBUtils"><a href="#DBUtils" class="headerlink" title="*DBUtils*"></a><em><strong>*DBUtils*</strong></em></h1><p>Commons DbUtils是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Apache/8512995">Apache</a>组织提供的一个对<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JDBC">JDBC</a>进行简单封装的开源工具类库，使用它能够简化<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JDBC">JDBC</a>应用程序的开发，同时也不会影响程序的性能。</p>
<p>因为JDBC手写比较麻烦，而且有非常多的代码是类似的。比如获得连接，预编译SQL，释放资源等..那么可以将这些代码抽取出来放到工具类中。将类似的代码进行抽取。大大简化JDBC的编程。</p>
<p>API</p>
<p>QueryRunner对象：核心运行类</p>
<p>构造方法：</p>
<p>无参构造</p>
<p><img src="/4.20.JDBC/wps11.jpg" alt="img"> </p>
<p>带参构造</p>
<p><img src="/4.20.JDBC/wps12.jpg" alt="img"> </p>
<p>方法：</p>
<p>增删改的方法</p>
<p><img src="/4.20.JDBC/wps13.jpg" alt="img"> </p>
<p><img src="/4.20.JDBC/wps14.jpg" alt="img"> </p>
<p>查找的方法</p>
<p><img src="/4.20.JDBC/wps15.jpg" alt="img"> </p>
<p><img src="/4.20.JDBC/wps16.jpg" alt="img"> </p>
<p>在一般情况下如果执行CRUD的操作：</p>
<p>构造：</p>
<p>QueryRunner(DataSource ds);</p>
<p>方法：</p>
<p>int update(String sql,Object… args);</p>
<p>T query(String sql,ResultSetHandler rsh,Object… args);</p>
<p>如果有事务管理的话使用另一套完成CRUD的操作</p>
<p>构造：</p>
<p>QueryRunner();</p>
<p>方法:</p>
<p>int update(Connection conn,String sql,Object… args);</p>
<p>T query(Connection conn,String sql,ResultSetHandler rsh,Object… args);</p>
<p>批量处理的方法</p>
<p><img src="/4.20.JDBC/wps17.jpg" alt="img"> </p>
<p>还有一个类：DbUtils</p>
<p>提交事务的方法：（这里的close不是销毁而是归还）</p>
<p><img src="/4.20.JDBC/wps18.jpg" alt="img"> </p>
<p>回滚事务的方法：</p>
<p><img src="/4.20.JDBC/wps19.jpg" alt="img"> </p>
<p>添加DBUtils的构建路径</p>
<p>DBUtils的添加操作：</p>
<p>​    @Test</p>
<p>​    /**</p>
<p>​     * 添加操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo1() <em><strong>*throws*</strong></em> SQLException{</p>
<p>​        // 创建核心类：QueryRunner:</p>
<p>​        QueryRunner queryRunner = <em><strong>*new*</strong></em> QueryRunner(JDBCUtils2.<strong>getDataSource</strong>());</p>
<p>​        queryRunner.update(“insert into account values (null,?,?)”, “ddd”,10000);</p>
<p>​    }</p>
<p>DBUtils的修改操作：</p>
<p>​    @Test</p>
<p>​    /**</p>
<p>​     * 修改操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo2() <em><strong>*throws*</strong></em> SQLException{</p>
<p>​        // 创建核心类:</p>
<p>​        QueryRunner queryRunner = <em><strong>*new*</strong></em> QueryRunner(JDBCUtils2.<strong>getDataSource</strong>());</p>
<p>​        queryRunner.update(“update account set name=?,money=? where id =?”, “eee”,20000,4);</p>
<p>​    }</p>
<p>DBUtils的删除操作：</p>
<p>@Test</p>
<p>​    /**</p>
<p>​     * 删除操作</p>
<p>​     */</p>
<p>​    <em><strong>*public*</strong></em> <em><strong>*void*</strong></em> demo3() <em><strong>*throws*</strong></em> SQLException{</p>
<p>​        // 创建核心类:</p>
<p>​        QueryRunner queryRunner = <em><strong>*new*</strong></em> QueryRunner(JDBCUtils2.<strong>getDataSource</strong>());</p>
<p>​        queryRunner.update(“delete from account where id = ?”, 3);</p>
<p>​    }</p>
<p>DBUtils的查询操作：</p>
<p>查询一条记录：</p>
<p>创建一个对象：Account（这个对象实例其实就是javabean）</p>
<p><img src="/4.20.JDBC/wps20.jpg" alt="img"> </p>
<p>也要重写toString方法</p>
<p>查询的代码实现：T query(String sql,ResultSetHandler rsh,Object… args);</p>
<p><img src="/4.20.JDBC/wps21.jpg" alt="img"> </p>
<p>查询多条语句：</p>
<p><img src="/4.20.JDBC/wps22.jpg" alt="img"> </p>
<p>ResultSetHandler接口的实现类：</p>
<p>\1. ArrayHandler和ArrayListHandler</p>
<p>ArrayHandler：将查询到的一条记录封装到一个数组当中，这个数组应该是Object[]</p>
<p><img src="/4.20.JDBC/wps23.jpg" alt="img"> </p>
<p>ArrayListHandler：将多条记录封装到一个装有Object[]的List集合中。</p>
<p><img src="/4.20.JDBC/wps24.jpg" alt="img"> </p>
<p>\2. BeanHandler和BeanListHandler（重要）</p>
<p>BeanHandler：将一条记录封装到一个JavaBean中。</p>
<p><img src="/4.20.JDBC/wps25.jpg" alt="img"> </p>
<p>必须保证Acoount中的变量和SQL中的列名一致</p>
<p>BeanListHandler：将多条记录封装到一个装有JavaBean的List集合中。</p>
<p><img src="/4.20.JDBC/wps26.jpg" alt="img"> </p>
<p>\3. MapHandler和MapListHandler</p>
<p>MapHandler：将一条记录封装到一个Map集合中，Map的key是列名，Map的value就是表中列的记录值。</p>
<p><img src="/4.20.JDBC/wps27.jpg" alt="img"> </p>
<p>MapListHandler：将多条记录封装到一个装有Map的List集合中。</p>
<p><img src="/4.20.JDBC/wps28.jpg" alt="img"> </p>
<p>\4. ColumnListHandler、ScalarHandler、KeyedHandler</p>
<p>ColumnListHandler：将数据库中的某列的值封装到List集合中。</p>
<p><img src="/4.20.JDBC/wps29.jpg" alt="img"> </p>
<p>ScalarHandler：将单个值封装。</p>
<p><img src="/4.20.JDBC/wps30.jpg" alt="img"> </p>
<p>KeyedHandler（了解即可，用的很少）：将一条记录封装到一个Map集合中。将多条记录封装到一个装有Map集合的Map集合中。而且外面的Map的key是可以指定的（可以指定为数据库中的某一列名）。</p>
<p><img src="/4.20.JDBC/wps31.jpg" alt="img"> </p>
<p>因为可能是不同的类型，为了通用性，一般都用Object类型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/4.20.JDBC/" data-id="ckvc2kueg006c9kwdcwxx4lpq" data-title="JDBC" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>