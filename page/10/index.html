<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/10/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-12.1.spring" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/12.1.spring/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:42:00.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/12.1.spring/">spring</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能。</p>
<p>Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题;</p>
<p>而Spring Boot 是基于Spring的一套快速开发整合包，Spring Boot遵循的也是约定优于配置原则,它的目的在于实现自动配置，降低项目搭建的复杂度;</p>
<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>
<p>Spring是一个轻量级的**控制反转(IoC)<strong>和</strong>面向切面(AOP)**的容器框架。</p>
<p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</p>
<h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>1、JAVA EE开发应该更加简单。</p>
<p>2、使用接口而不是使用类，是更好的编程习惯。Spring将使用接口的复杂度几乎降低到了零。</p>
<p>3、为JavaBean提供了一个更好的应用配置框架。</p>
<p>4、更多地强调面向对象的设计，而不是现行的技术如JAVA EE。</p>
<p>5、尽量减少不必要的异常捕捉。</p>
<p>6、使应用程序更加容易测试。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>1、可以令人方便愉快的使用Spring。</p>
<p>2、应用程序代码并不依赖于Spring APIs。</p>
<p>3、Spring不和现有的解决方案竞争，而是致力于将它们融合在一起。</p>
<h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>1、最完善的轻量级核心框架。</p>
<p>2、通用的事务管理抽象层。</p>
<p>3、JDBC抽象层。</p>
<p>4、集成了Toplink, Hibernate, JDO, and iBATIS SQL Maps。</p>
<p>5、AOP功能。</p>
<p>6、灵活的MVC Web应用框架。</p>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>Spring框架几乎涉及到了Java企业级服务开发的所有方面，也几乎针对所有开发常用的模式、中间件、数据库进行了整合适配。</p>
<p>当我们写一个业务把逻辑写死写出来是比较容易的，但是把这个逻辑提取成模式进而打包成一个框架来给大家使用，这是比较难的。因为我们只有经历过足够多的场景后才能提取出普适的功能框架，大部分人才能用上，而且我们需要针对核心功能开放出可配置的部分，满足小部分人进一步定制和扩展功能的需要。</p>
<p>Spring框架经历了几个阶段：</p>
<p>1.第一个阶段推出的Core、Security、Data是把单体应用开发服务好。不仅仅提供了便捷的数据库访问、Web MVC等必要功能，而且通过AOP、IOC两大利器让我们的程序内在能够做到低耦合可扩展。</p>
<p>2.第二个阶段推出的Boot的意义不仅仅是加速了开发效率而且能让我们的程序从可用变为好用，应用程序核心业务逻辑可能只有70%的工作量，要让程序在线上跑的愉快还有30%的监控日志打点等工作量需要去做。</p>
<p>3.第三个阶段推出的Cloud的意义在于推动了微服务架构的落地。让不具备开发微服务基础套件的小型互联网公司也能享受到免费的开箱即用的微服务解决方案。其实很多人不是看了微服务的架构思想去寻找解决方案，而是了解到了Spring Cloud才去了解微服务思想从而落地的。</p>
<p>4.目前属于第四个阶段，大力发展Cloud Dataflow（云数据流）+容器。Dataflow的思想是不管是做实时消息处理的服务还是临时运行的任务，都可以认为是服务的组件，如果可以有一套DSL来定义这些组件之间的交互方式，然后在容器中进行自由组合、部署、伸缩，那么架构会非常灵活。下图是Dataflow管理界面的一个示意图。</p>
<p>Spring的发展可以看到互联网架构的发展，Spring给我们带来相当多的技术启发，从软件设计模式的启发慢慢到了架构的启发，甚至我觉得Spring是为Java开发打造了架构风格的模板，接下去Spring继续发展2到3年有望成为架构标准</p>
<p><img src="/12.1.spring/image-20210922142605980.png" alt="image-20210922142605980"></p>
<p>在Spring4.x中增加了新的特性：如果类只提供了一个带参数的构造方法，则不需要对对其内部的属性写@Autowired注解，Spring会自动为你注入属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看spring的版本</span></span><br><span class="line">String springVersion = SpringVersion.getVersion();</span><br><span class="line">String springBootVersion = SpringBootVersion.getVersion();</span><br><span class="line">System.out.println(springVersion);</span><br><span class="line">System.out.println(springBootVersion);</span><br></pre></td></tr></table></figure>

<p>只要用了spring框架，肯定到处都是@Autowired。4.3之后的功能，如果只有一个构造方法，自动用这个构造方法注入配合lombok的@RequiredArgsConstructor使用体验很好：</p>
<p>我们平时开发中的bean大部分都不写构造函数，系统默认一个无参构造函数，这就符合这一条件。</p>
<p><img src="/12.1.spring/20191018160134977.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101816003785.png"></p>
<p>此时helloService已经注入了，但是有些人会说以前加个@Autowired就行了，现在还要加个构造方法，更麻烦了，这时可以使用lombok插件，类上加@AllArgsConstructor就行了。</p>
<p><img src="/12.1.spring/20191018160429867.png" alt="在这里插入图片描述"></p>
<p>在编写代码的时候，使用@Autowired注解是，发现IDE报的一个警告，如下：</p>
<p><img src="/12.1.spring/20190606170140759.jpg" alt="img"> </p>
<p>Spring Team recommends “Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies”.</p>
<p>翻译：</p>
<p>Spring建议”总是在您的bean中使用构造函数建立依赖注入。总是使用断言强制依赖”。</p>
<p>这段代码警告原来的写法是：</p>
<p>@Autowired<br>private EnterpriseDbService service;<br>建议后写成下面的样子：</p>
<p>private final EnterpriseDbService service;<br>@Autowired<br>public EnterpriseDbController(EnterpriseDbService service) {<br> this.service = service;<br>}<br>奇怪，为何会有这样的建议。</p>
<p>我们知道：@Autowired 可以对成员变量、方法以及构造函数进行注释。那么对成员变量和构造函数进行注释又有什么区别呢？</p>
<p>@Autowired注入bean，相当于在配置文件中配置bean，并且使用setter注入。而对构造函数进行注释，就相当于是使用构造函数进行依赖注入了吧。莫非是这两种注入方法的不同。</p>
<p>以下是：@Autowired和构造方法执行的顺序解析</p>
<p>先看一段代码，下面的代码能运行成功吗？</p>
<p>@Autowired<br>private User user;<br>private String school;<br>public UserAccountServiceImpl(){<br> this.school = user.getSchool();<br>}<br>答案是不能。</p>
<p>因为Java类会先执行构造方法，然后再给注解了@Autowired 的user注入值，所以在执行构造方法的时候，就会报错。</p>
<p>报错信息可能会像下面：</p>
<p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘…’ defined in file [….class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate […]: Constructor threw exception; nested exception is java.lang.NullPointerException<br>报错信息说：创建Bean时出错，出错原因是实例化bean失败，因为bean时构造方法出错，在构造方法里抛出了空指针异常。</p>
<p>解决办法是，使用构造器注入，如下：</p>
<p>private User user;<br>private String school;<br>@Autowired<br>public UserAccountServiceImpl(User user){<br> this.user = user;<br> this.school = user.getSchool();<br>}<br>可以看出，使用构造器注入的方法，可以明确成员变量的加载顺序。</p>
<p>PS：Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法–&gt;@Autowired</p>
<p>@Autowired和构造方法执行的顺序解析</p>
<p>先看一段代码，下面的代码能运行成功吗？</p>
<p> @Autowired<br>    private User user;<br>    private String school;</p>
<pre><code>public UserAccountServiceImpl()&#123;
    this.school = user.getSchool();
&#125;
</code></pre>
<p>答案是不能。因为Java类会先执行构造方法，然后再给注解了@Autowired 的user注入值，所以在执行构造方法的时候，就会报错。<br>报错信息可能会像下面：</p>
<p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘…’ defined in file [….class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate […]: Constructor threw exception; nested exception is java.lang.NullPointerException</p>
<p>报错信息说：创建Bean时出错，出错原因是实例化bean失败，因为bean时构造方法出错，在构造方法里抛出了空指针异常。</p>
<p>解决办法是，使用构造器注入，如下：</p>
<p> private User user;<br>    private String school;</p>
<pre><code>@Autowired
public UserAccountServiceImpl(User user)&#123;
    this.user = user;
    this.school = user.getSchool();
&#125;
</code></pre>
<p>那么最开始Spring建议，为何要将成员变量加上final类型呢？</p>
<p>网上有解释如下：spring配置默认的bean的scope是singleton，也就是启动后一直有。通过设置bean的scope属性为prototype来声明该对象为动态创建。但是，如果你的service本身是singleton，注入只执行一次。</p>
<p>@Autowired本身就是单例模式，只会在程序启动时执行一次，即使不定义final也不会初始化第二次，所以这个final是没有意义的吧。</p>
<p>可能是为了防止，在程序运行的时候，又执行了一遍构造函数；</p>
<p>或者是更容易让人理解的意思，加上final只会在程序启动的时候初始化一次，并且在程序运行的时候不会再改变。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired 注释可以在 setter 方法中被用于自动连接 bean，就像 @Autowired 注释，容器，一个属性或者任意命名的可能带有多个参数的方法。</p>
<p>可以在属性中使用 @Autowired 注释来除去 setter 方法。当时使用 为自动连接属性传递的时候，Spring 会将这些传递过来的值或者引用自动分配给那些属性</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>踩到一个坑，有一个接口，在这个接口的实现类里，需要用到@Autowired注解，一时大意，没有在实现类上加上@Component注解，导致了Spring报错，找不到这个类</p>
<p>一旦使用关于Spring的注解出现在类里，例如我在实现类中用到了@Autowired注解，被注解的这个类是从Spring容器中取出来的，那调用的实现类也需要被Spring容器管理，加上@Component</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;conversionImpl&quot;)</span></span><br><span class="line"><span class="comment">//其实默认的spring中的Bean id 为 conversionImpl(首字母小写)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConversionImpl</span> <span class="keyword">implements</span> <span class="title">Conversion</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient redisClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>介绍</p>
<p>开发中难免会遇到这个这个注解@Component</p>
<p>@Controller 控制器（注入服务）<br> 用于标注控制层，相当于struts中的action层</p>
<p>@Service 服务（注入dao）<br> 用于标注服务层，主要用来进行业务的逻辑处理</p>
<p>@Repository（实现dao访问）<br> 用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件</p>
<p>@Component （把普通pojo实例化到spring容器中，相当于配置文件中的 ）</p>
<p>泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</p>
<h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type1">异常处理方式一. @ExceptionHandler</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type2">异常处理方式二. 实现HandlerExceptionResolver接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type3">异常处理方式三. @ControllerAdvice+@ExceptionHandler</a></li>
</ol>
<p>spring的启动</p>
<p>Spring 是一个控制反转依赖管理的容器，作为 Java Web 的开发人员，基本没有不熟悉 Spring 技术栈的，尽管在依赖注入领域，Java Web 领域不乏其他优秀的框架，如 google 开源的依赖管理框架 guice，如 Jersey web 框架等。但 Spring 已经是 Java Web 领域使用最多，应用最广泛的 Java 框架。</p>
<p>此文将专注讲解如何在 Spring 容器启动时实现我们自己想要实现的逻辑。我们时常会遇到在 Spring 启动的时候必须完成一些初始化的操作，如创建定时任务，创建连接池等。</p>
<p>本文将介绍以下几种 Spring 启动监听方式：</p>
<ul>
<li>Bean 构造函数方式</li>
<li>使用 @PostConstruct 注解</li>
<li>实现 InitializingBean 接口</li>
<li>监听 ApplicationListener 事件</li>
<li>使用 Constructor 注入方式</li>
<li>实现 SpringBoot 的 CommandLineRunner 接口</li>
<li>SmartLifecycle 机制</li>
</ul>
<h2 id="spring装填bean"><a href="#spring装填bean" class="headerlink" title="spring装填bean"></a>spring装填bean</h2><p>我们知道如果我们要在一个类使用<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javaee">spring</a>提供的bean对象，我们需要把这个类注入到spring容器中，交给spring容器进行管理，但是在实际当中，我们往往会碰到在一个普通的<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javase">Java</a>类中，想直接使用spring提供的其他对象或者说有一些不需要交给spring管理，但是需要用到spring里的一些对象。如果这是spring框架的独立应用程序，我们通过</p>
<p>ApplicationContext ac = new FileSystemXmlApplicationContext(“applicationContext.xml”);<br>ac.getBean(“beanId”); </p>
<p>这样的方式就可以很轻易的获取我们所需要的对象。</p>
<p>但是往往我们所做的都是Web Application，这时我们启动spring容器是通过在web.xml文件中配置，这样就不适合使用上面的方式在普通类去获取对象了，因为这样做就相当于加载了两次spring容器，而我们想是否可以通过在启动web服务器的时候，就把Application放在某一个类中，我们通过这个类在获取，这样就可以在普通类获取spring bean对象了，让我们接着往下看</p>
<p><strong>普通类调用Spring bean对象:</strong></p>
<p>可以参考：<a target="_blank" rel="noopener" href="http://412887952-qq-com.iteye.com/blog/1479445">http://412887952-qq-com.iteye.com/blog/1479445</a></p>
<p>这里有更多这方面的介绍，比较详细</p>
<p>下面介绍在springboot中是如何使用的</p>
<p><strong>1.在Spring Boot可以扫描的包下</strong></p>
<p><strong>写的工具类为SpringUtil，实现ApplicationContextAware接口，并加入Component注解，让spring扫描到该bean</strong></p>
<p>springutil:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.util;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class SpringUtil implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        if(SpringUtil.applicationContext &#x3D;&#x3D; null) &#123;</span><br><span class="line">            SpringUtil.applicationContext &#x3D; applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------me.shijunjie.util.SpringUtil------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ApplicationContext配置成功,在普通类可以通过调用SpringUtils.getAppContext()获取applicationContext对象,applicationContext&#x3D;&quot;+SpringUtil.applicationContext+&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取applicationContext</span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name获取 Bean.</span><br><span class="line">    public static Object getBean(String name)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过class获取Bean.</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name,以及Clazz返回指定的Bean</span><br><span class="line">    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>为了测试，我们再启动的时候先通过代码方式给spring容器中注入一个bean，入下所示</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.entity.Demo2;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class BeanConfig &#123;</span><br><span class="line">    @Bean(name&#x3D;&quot;testDemo&quot;)</span><br><span class="line">    public Demo2 generateDemo() &#123;</span><br><span class="line">        Demo2 demo &#x3D; new Demo2();</span><br><span class="line">        demo.setId(12345);</span><br><span class="line">        demo.setName(&quot;test&quot;);</span><br><span class="line">        return demo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>然后我们编写测试controller，并从刚才写的springutil中获取这个bean</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.util.SpringUtil;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;application&quot;)</span><br><span class="line">public class TestApplicationController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;&#x2F;test1&quot;)</span><br><span class="line">    public Object testSpringUtil1() &#123;</span><br><span class="line">        return SpringUtil.getBean(&quot;testDemo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>测试</p>
<p>启动web应用，打开浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8080/application/test1%EF%BC%8C%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F">http://localhost:8080/application/test1，测试成功</a></p>
<p><img src="https://images2015.cnblogs.com/blog/1097735/201703/1097735-20170302105956954-82157382.png" alt="img"></p>
<p><strong>2 不在Spring Boot的扫描包下方式一</strong></p>
<p>这种情况处理起来也很简单，先编写SpringUtil类，同样需要实现接口：ApplicationContextAware，具体编码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.util;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line">public class SpringUtil2 implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        if(SpringUtil2.applicationContext &#x3D;&#x3D; null) &#123;</span><br><span class="line">            SpringUtil2.applicationContext &#x3D; applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------me.shijunjie.util.SpringUtil------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ApplicationContext配置成功,在普通类可以通过调用SpringUtils.getAppContext()获取applicationContext对象,applicationContext&#x3D;&quot;+SpringUtil2.applicationContext+&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取applicationContext</span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name获取 Bean.</span><br><span class="line">    public static Object getBean(String name)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过class获取Bean.</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name,以及Clazz返回指定的Bean</span><br><span class="line">    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Bean注解，在App.java类中将SpringUtil注解进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.context.web.SpringBootServletInitializer;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.util.SpringUtil2;</span><br><span class="line"></span><br><span class="line">@ComponentScan(basePackages&#x3D;&#123;&quot;me.shijunjie&quot;&#125;) &#x2F;&#x2F; 扫描该包路径下的所有spring组件</span><br><span class="line">&#x2F;*@EnableJpaRepositories(&quot;me.shijunjie.dao&quot;) &#x2F;&#x2F; JPA扫描该包路径下的Repositorie</span><br><span class="line">*&#x2F;&#x2F;*@EntityScan(&quot;me.shijunjie.entity&quot;) &#x2F;&#x2F; 扫描实体类</span><br><span class="line">*&#x2F;@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class App extends SpringBootServletInitializer&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public SpringUtil2 getSpringUtil2() &#123;</span><br><span class="line">        return new SpringUtil2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试（使用热部署的需要重启服务器）</p>
<p>启动web应用，打开浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8080/application/test2%EF%BC%8C%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F">http://localhost:8080/application/test2，测试成功</a></p>
<p><img src="https://images2015.cnblogs.com/blog/1097735/201703/1097735-20170302110921157-936863400.png" alt="img"></p>
<p>除此以外，也可以在<a href="mailto:主要是在App.java中使用@Import">App.java</a>中使用@Import进行导入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.context.web.SpringBootServletInitializer;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Import;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.util.SpringUtil2;</span><br><span class="line"></span><br><span class="line">@ComponentScan(basePackages&#x3D;&#123;&quot;me.shijunjie&quot;&#125;) &#x2F;&#x2F; 扫描该包路径下的所有spring组件</span><br><span class="line">&#x2F;*@EnableJpaRepositories(&quot;me.shijunjie.dao&quot;) &#x2F;&#x2F; JPA扫描该包路径下的Repositorie</span><br><span class="line">*&#x2F;&#x2F;*@EntityScan(&quot;me.shijunjie.entity&quot;) &#x2F;&#x2F; 扫描实体类</span><br><span class="line">*&#x2F;@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">@Import(SpringUtil2.class)</span><br><span class="line">public class App extends SpringBootServletInitializer&#123;</span><br><span class="line">    &#x2F;*@Bean</span><br><span class="line">    public SpringUtil2 getSpringUtil2() &#123;</span><br><span class="line">        return new SpringUtil2();</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跑出结果和上面相同</p>
<h2 id="原始构造函数"><a href="#原始构造函数" class="headerlink" title="原始构造函数"></a>原始构造函数</h2><p>如果没有 Spring 容器，不依赖于 Spring 的实现，回归 Java 类实现本身，我们可以在静态代码块，在类构造函数中实现相应的逻辑，Java 类的初始化顺序依次是<code>静态变量</code> &gt; <code>静态代码块</code> &gt; <code>全局变量</code> &gt; <code>初始化代码块</code> &gt; <code>构造器</code>。</p>
<p>比如，Log4j 的初始化，就是在 <code>LogManager</code> 的静态代码块中实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line"></span><br><span class="line">    Hierarchy h &#x3D; new Hierarchy(new RootLogger((Level) Level.DEBUG));</span><br><span class="line">    repositorySelector &#x3D; new DefaultRepositorySelector(h);</span><br><span class="line"></span><br><span class="line">    String override &#x3D;OptionConverter.getSystemProperty(DEFAULT_INIT_OVERRIDE_KEY,null);</span><br><span class="line"></span><br><span class="line">    if(override &#x3D;&#x3D; null || &quot;false&quot;.equalsIgnoreCase(override)) &#123;</span><br><span class="line">          String configurationOptionStr &#x3D; OptionConverter.getSystemProperty(DEFAULT_CONFIGURATION_KEY, null);</span><br><span class="line">          String configuratorClassName &#x3D; OptionConverter.getSystemProperty(CONFIGURATOR_CLASS_KEY, null);</span><br><span class="line"></span><br><span class="line">          URL url &#x3D; null;</span><br><span class="line"></span><br><span class="line">          if(configurationOptionStr &#x3D;&#x3D; null) &#123;</span><br><span class="line">            url &#x3D; Loader.getResource(DEFAULT_XML_CONFIGURATION_FILE);</span><br><span class="line">            if(url &#x3D;&#x3D; null) &#123;</span><br><span class="line">              url &#x3D; Loader.getResource(DEFAULT_CONFIGURATION_FILE);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              url &#x3D; new URL(configurationOptionStr);</span><br><span class="line">            &#125; catch (MalformedURLException ex) &#123;</span><br><span class="line">              url &#x3D; Loader.getResource(configurationOptionStr);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if(url !&#x3D; null) &#123;</span><br><span class="line">            LogLog.debug(&quot;Using URL [&quot;+url+&quot;] for automatic log4j configuration.&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                OptionConverter.selectAndConfigure(url, configuratorClassName,LogManager.getLoggerRepository());</span><br><span class="line">            &#125; catch (NoClassDefFoundError e) &#123;</span><br><span class="line">                LogLog.warn(&quot;Error during default initialization&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              LogLog.debug(&quot;Could not find resource: [&quot;+configurationOptionStr+&quot;].&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">            LogLog.debug(&quot;Default initialization of overridden by &quot; +  DEFAULT_INIT_OVERRIDE_KEY + &quot;property.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如在构造函数中实现相应的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment env;</span><br><span class="line"></span><br><span class="line">    public CustomBean() &#123;</span><br><span class="line">        env.getActiveProfiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里考验一下各位，上面的代码是否可以正常运行。—— 不行，构造函数中的<code>env</code>将会发生<code>NullPointException</code>异常。这是因为在 Spring 中将先初始化 Bean，也就是会先调用类的构造函数，然后才注入成员变量依赖的 Bean（<code>@Autowired</code>和<code>@Resource</code>注解修饰的成员变量），注意<code>@Value</code>等注解的配置的注入也是在构造函数之后。</p>
<h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>在 Spring 中，我们可以使用<code>@PostConstruct</code>在 Bean 初始化之后实现相应的初始化逻辑，<code>@PostConstruct</code>修饰的方法将在 Bean 初始化完成之后执行，此时 Bean 的依赖也已经注入完成，因此可以在方法中调用注入的依赖 Bean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment env;</span><br><span class="line"></span><br><span class="line">    @PostConstruce</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        env.getActiveProfiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>@PostConstruct</code>相对应的，如果想在 Bean 注销时完成一些清扫工作，如关闭线程池等，可以使用<code>@PreDestroy</code>注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ExecutorService executor &#x3D; Executors.newFixedThreadPool(1)</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        env.getActiveProfiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h2><p>实现 Spring 的<code>InitializingBean</code>接口同样可以实现以上在 Bean 初始化完成之后执行相应逻辑的功能，实现<code>InitializingBean</code>接口，在<code>afterPropertiesSet</code>方法中实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOG</span><br><span class="line">      &#x3D; Logger.getLogger(InitializingBeanExampleBean.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        LOG.info(environment.getDefaultProfiles());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h2><p>我们可以在 Spring 容器初始化的时候实现我们想要的初始化逻辑。这时我们就可以使用到 Spring 的初始化事件。Spring 有一套完整的事件机制，在 Spring 启动的时候，Spring 容器本身预设了很多事件，在 Spring 初始化的整个过程中在相应的节点触发相应的事件，我们可以通过监听这些事件来实现我们的初始化逻辑。Spring 的事件实现如下：</p>
<ul>
<li>ApplicationEvent，事件对象，由 ApplicationContext 发布，不同的实现类代表不同的事件类型。</li>
<li>ApplicationListener，监听对象，任何实现了此接口的 Bean 都会收到相应的事件通知。实现了 ApplicationListener 接口之后，需要实现方法 onApplicationEvent()，在容器将所有的 Bean 都初始化完成之后，就会执行该方法。</li>
</ul>
<p>与 Spring Context 生命周期相关的几个事件有以下几个：</p>
<ul>
<li>ApplicationStartingEvent: 这个事件在 Spring Boot 应用运行开始时，且进行任何处理之前发送（除了监听器和初始化器注册之外）。</li>
<li>ContextRefreshedEvent: ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。</li>
<li>ContextStartedEvent: 当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被触发。你可以查询你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</li>
<li>ApplicationReadyEvent: 这个事件在任何 application/ command-line runners 调用之后发送。</li>
<li>ContextClosedEvent: 当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被触发。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</li>
<li>ContextStoppedEvent: Spring 最后完成的事件。</li>
</ul>
<p>因此，如果我们想在 Spring 启动的时候实现一些相应的逻辑，可以找到 Spring 启动过程中符合我们需要的事件，通过监听相应的事件来完成我们的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class StartupApplicationListenerExample implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">        log.info(&quot;Subject ContextRefreshedEvent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了通过实现<code>ApplicationListener</code>接口来监听相应的事件，Spring 的事件机制也实现了通过<code>@EventListener</code>注解来监听相对应事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class StartupApplicationListenerExample &#123;</span><br><span class="line"></span><br><span class="line">    @EventListener</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">        log.info(&quot;Subject ContextRefreshedEvent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Event 是一套完善的进程内事件发布订阅机制，我们除了用来监听 Spring 内置的事件，也可以使用 Spring Event 实现自定义的事件发布订阅功能。</p>
<h2 id="Constructor-注入"><a href="#Constructor-注入" class="headerlink" title="Constructor 注入"></a>Constructor 注入</h2><p>在学习 Spring 的注入机制的时候，我们都知道 Spring 可以通过构造函数、Setter 和反射成员变量注入等方式。上面我们在成员变量上通过<code>@Autoware</code>注解注入依赖 Bean，但是在 Bean 的构造函数函数中却无法使用到注入的 Bean（因为 Bean 还未注入），其实我们也是使用 Spring 的构造函数注入方式， 这也是 Spring 推荐的注入机制（在我们使用 IDEA 的时候，如果没有关闭相应的代码 Warning 机制，会发现在成员变量上的<code>@Autoware</code>是黄色的，也就是 idea 不建议的代码）。Spring 更推荐构造函数注入的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class ConstructorBean &#123;</span><br><span class="line"></span><br><span class="line">    private final Environment environment;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public LogicInConstructorExampleBean(Environment environment) &#123;</span><br><span class="line">        this.environment &#x3D; environment;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><p>如果我们的项目使用的是 Spring Boot，那么可以使用 Spring Boot 提供的 <code>CommandLineRunner</code> 接口来实现初始化逻辑，Spring Boot 将在启动初始化完成之后调用实现了<code>CommandLineRunner</code>的接口的<code>run</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommandLineAppStartupRunner implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String...args) throws Exception &#123;</span><br><span class="line">        log.info(&quot;Increment counter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，多个<code>CommandLineRunner</code>实现，可以通过<code>@Order</code>来控制它们的执行顺序。</p>
<h2 id="SmartLifecycle"><a href="#SmartLifecycle" class="headerlink" title="SmartLifecycle"></a>SmartLifecycle</h2><p>还有一种更高级的方法来实现我们的逻辑。这可以 Spring 高级开发必备技能哦。SmartLifecycle 不仅仅能在初始化后执行一个逻辑，还能再关闭前执行一个逻辑，并且也可以控制多个 <code>SmartLifecycle</code> 的执行顺序，就像这个类名表示的一样，这是一个智能的生命周期管理接口。</p>
<ul>
<li>start()：bean 初始化完毕后，该方法会被执行。</li>
<li>stop()：容器关闭后，spring 容器发现当前对象实现了 SmartLifecycle，就调用 stop(Runnable)， 如果只是实现了 Lifecycle，就调用 stop()。</li>
<li>isRunning：当前状态，用来判你的断组件是否在运行。</li>
<li>getPhase：控制多个 SmartLifecycle 的回调顺序的，返回值越小越靠前执行 start() 方法，越靠后执行 stop() 方法。</li>
<li>isAutoStartup()：start 方法被执行前先看此方法返回值，返回 false 就不执行 start 方法了。</li>
<li>stop(Runnable)：容器关闭后，spring 容器发现当前对象实现了 SmartLifecycle，就调用 stop(Runnable)， 如果只是实现了 Lifecycle，就调用 stop()。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SmartLifecycleExample implements SmartLifecycle &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        isRunning &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getPhase() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认为 0</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAutoStartup() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认为 false</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isRunning() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认返回 false</span><br><span class="line">        return isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop(Runnable callback) &#123;</span><br><span class="line">        System.out.println(&quot;stop(Runnable)&quot;);</span><br><span class="line">        callback.run();</span><br><span class="line">        isRunning &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;stop&quot;);</span><br><span class="line"></span><br><span class="line">        isRunning &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Aspect、-Before、-After-注解实现-AOP-切面功能"><a href="#Spring-Aspect、-Before、-After-注解实现-AOP-切面功能" class="headerlink" title="Spring @Aspect、@Before、@After 注解实现 AOP 切面功能"></a>Spring @Aspect、@Before、@After 注解实现 AOP 切面功能</h2><p>Spring AOP 注解概述<br>1、Spring 的 AOP 功能除了在配置文件中配置一大堆的配置，比如切入点、表达式、通知等等以外，使用注解的方式更为方便快捷，特别是 Spring boot 出现以后，基本不再使用原先的 beans.xml 等配置文件了，而都推荐注解编程。</p>
<table>
<thead>
<tr>
<th>@Aspect</th>
<th>切面声明，标注在类、接口（包括注解类型）或枚举上。</th>
</tr>
</thead>
<tbody><tr>
<td>@Pointcut</td>
<td>切入点声明，即切入到哪些目标类的目标方法。<br />value 属性指定切入点表达式，默认为 “”，用于被通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式</td>
</tr>
<tr>
<td>@Before</td>
<td>前置通知, 在目标方法(切入点)执行之前执行。<br />value 属性绑定通知的切入点表达式，可以关联切入点声明，也可以直接设置切入点表达式<br />注意：如果在此回调方法中抛出异常，则目标方法不会再执行，会继续执行后置通知 -&gt; 异常通知。</td>
</tr>
<tr>
<td>@After</td>
<td>后置通知, 在目标方法(切入点)执行之后执行</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>返回通知, 在目标方法(切入点)返回结果之后执行，在 @After 的后面执行<br />pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 “”</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>异常通知, 在方法抛出异常之后执行, 意味着跳过返回通知<br />pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 “”<br />注意：如果目标方法自己 try-catch 了异常，而没有继续往外抛，则不会进入此回调函数</td>
</tr>
<tr>
<td>@Around</td>
<td>环绕通知：目标方法执行前后分别执行一些代码，类似拦截器，可以控制目标方法是否继续执行。<br />通常用于统计方法耗时，参数校验等等操作。<br />环绕通知早于前置通知，晚于返回通知</td>
</tr>
<tr>
<td>2、上面这些 AOP 注解都是位于如下所示的 aspectjweaver 依赖中：</td>
<td></td>
</tr>
</tbody></table>
<p><img src="/12.1.spring/20200822102819511.png" alt="img"></p>
<p>3、对于习惯了 Spring 全家桶编程的人来说，并不是需要直接引入 aspectjweaver 依赖，因为 spring-boot-starter-aop 组件默认已经引用了 aspectjweaver 来实现  AOP 功能。换句话说 Spring 的 AOP 功能就是依赖的 aspectjweaver ！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-aop --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;dependency&gt;    </span><br></pre></td></tr></table></figure>

<p>@Aspect 快速入门<br>1、@Aspect 常见用于记录日志、异常集中处理、权限验证、Web 参数校验、事务处理等等</p>
<p>2、要想把一个类变成切面类，只需3步：</p>
<p>1）在类上使用 @Aspect 注解使之成为切面类</p>
<p>2）切面类需要交由 Sprign 容器管理，所以类上还需要有 @Service、@Repository、@Controller、@Component  等注解<br>2）在切面类中自定义方法接收通知</p>
<p>3、AOP 的含义就不再累述了，下面直接上示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.lang3.time.StopWatch;</span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.Signature;</span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.aspectj.lang.reflect.SourceLocation;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line"> * 切面注解 Aspect 使用入门</span><br><span class="line"></span><br><span class="line"> * 1、@Aspect：声明本类为切面类</span><br><span class="line"></span><br><span class="line"> * 2、@Component：将本类交由 Spring 容器管理</span><br><span class="line"></span><br><span class="line"> * 3、@Order：指定切入执行顺序，数值越小，切面执行顺序越靠前，默认为 Integer.MAX_VALUE</span><br><span class="line">   *</span><br><span class="line"></span><br><span class="line"> * @author wangMaoXiong</span><br><span class="line"></span><br><span class="line"> * @version 1.0</span><br><span class="line"></span><br><span class="line"> * @date 2020&#x2F;8&#x2F;20 19:22</span><br><span class="line">   *&#x2F;</span><br><span class="line">   @Aspect</span><br><span class="line">   @Order(value &#x3D; 999)</span><br><span class="line">   @Component</span><br><span class="line">   public class AspectHelloWorld &#123;</span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(AspectHelloWorld.class);</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * @Pointcut ：切入点声明，即切入到哪些目标方法。value 属性指定切入点表达式，默认为 &quot;&quot;。</span><br><span class="line"></span><br><span class="line">    * 用于被下面的通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式</span><br><span class="line"></span><br><span class="line">    * &lt;p&gt;</span><br><span class="line"></span><br><span class="line">    * 切入点表达式常用格式举例如下：</span><br><span class="line"></span><br><span class="line">    * - * com.wmx.aspect.EmpService.*(..))：表示 com.wmx.aspect.EmpService 类中的任意方法</span><br><span class="line"></span><br><span class="line">    * - * com.wmx.aspect.*.*(..))：表示 com.wmx.aspect 包(不含子包)下任意类中的任意方法</span><br><span class="line"></span><br><span class="line">    * - * com.wmx.aspect..*.*(..))：表示 com.wmx.aspect 包及其子包下任意类中的任意方法</span><br><span class="line"></span><br><span class="line">    * &lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    * value 的 execution 可以有多个，使用 || 隔开.</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @Pointcut(value &#x3D;</span><br><span class="line">          &quot;execution(* com.wmx.hb.controller.DeptController.*(..)) &quot; +</span><br><span class="line">                  &quot;|| execution(* com.wmx.hb.controller.EmpController.*(..))&quot;)</span><br><span class="line">      private void aspectPointcut() &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 前置通知：目标方法执行之前执行以下方法体的内容。</span><br><span class="line"></span><br><span class="line">    * value：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line"></span><br><span class="line">    * &lt;br&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    * * @param joinPoint：提供对连接点处可用状态和有关它的静态信息的反射访问&lt;br&#x2F;&gt; &lt;p&gt;</span><br><span class="line"></span><br><span class="line">    * * * Object[] getArgs()：返回此连接点处（目标方法）的参数，目标方法无参数时，返回空数组</span><br><span class="line"></span><br><span class="line">    * * * Signature getSignature()：返回连接点处的签名。</span><br><span class="line"></span><br><span class="line">    * * * Object getTarget()：返回目标对象</span><br><span class="line"></span><br><span class="line">    * * * Object getThis()：返回当前正在执行的对象</span><br><span class="line"></span><br><span class="line">    * * * StaticPart getStaticPart()：返回一个封装此连接点的静态部分的对象。</span><br><span class="line"></span><br><span class="line">    * * * SourceLocation getSourceLocation()：返回与连接点对应的源位置</span><br><span class="line"></span><br><span class="line">    * * * String toLongString()：返回连接点的扩展字符串表示形式。</span><br><span class="line"></span><br><span class="line">    * * * String toShortString()：返回连接点的缩写字符串表示形式。</span><br><span class="line"></span><br><span class="line">    * * * String getKind()：返回表示连接点类型的字符串</span><br><span class="line"></span><br><span class="line">    * * * &lt;&#x2F;p&gt;</span><br><span class="line">          *&#x2F;</span><br><span class="line">          @Before(value &#x3D; &quot;aspectPointcut()&quot;)</span><br><span class="line">          public void aspectBefore(JoinPoint joinPoint) &#123;</span><br><span class="line">          Object[] args &#x3D; joinPoint.getArgs();</span><br><span class="line">          Signature signature &#x3D; joinPoint.getSignature();</span><br><span class="line">          Object target &#x3D; joinPoint.getTarget();</span><br><span class="line">          Object aThis &#x3D; joinPoint.getThis();</span><br><span class="line">          JoinPoint.StaticPart staticPart &#x3D; joinPoint.getStaticPart();</span><br><span class="line">          SourceLocation sourceLocation &#x3D; joinPoint.getSourceLocation();</span><br><span class="line">          String longString &#x3D; joinPoint.toLongString();</span><br><span class="line">          String shortString &#x3D; joinPoint.toShortString();</span><br><span class="line"></span><br><span class="line">        LOG.debug(&quot;【前置通知】&quot; +</span><br><span class="line">                        &quot;args&#x3D;&#123;&#125;,signature&#x3D;&#123;&#125;,target&#x3D;&#123;&#125;,aThis&#x3D;&#123;&#125;,staticPart&#x3D;&#123;&#125;,&quot; +</span><br><span class="line">                        &quot;sourceLocation&#x3D;&#123;&#125;,longString&#x3D;&#123;&#125;,shortString&#x3D;&#123;&#125;&quot;</span><br><span class="line">                , Arrays.asList(args), signature, target, aThis, staticPart, sourceLocation, longString, shortString);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 后置通知：目标方法执行之后执行以下方法体的内容，不管目标方法是否发生异常。</span><br><span class="line">    * value：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @After(value &#x3D; &quot;aspectPointcut()&quot;)</span><br><span class="line">      public void aspectAfter(JoinPoint joinPoint) &#123;</span><br><span class="line">      LOG.debug(&quot;【后置通知】kind&#x3D;&#123;&#125;&quot;, joinPoint.getKind());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 返回通知：目标方法返回后执行以下代码</span><br><span class="line">    * value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line">    * pointcut 属性：绑定通知的切入点表达式，优先级高于 value，默认为 &quot;&quot;</span><br><span class="line">    * returning 属性：通知签名中要将返回值绑定到的参数的名称，默认为 &quot;&quot;</span><br><span class="line">      *</span><br><span class="line">    * @param joinPoint ：提供对连接点处可用状态和有关它的静态信息的反射访问</span><br><span class="line">    * @param result    ：目标方法返回的值，参数名称与 returning 属性值一致。无返回值时，这里 result 会为 null.</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @AfterReturning(pointcut &#x3D; &quot;aspectPointcut()&quot;, returning &#x3D; &quot;result&quot;)</span><br><span class="line">      public void aspectAfterReturning(JoinPoint joinPoint, Object result) &#123;</span><br><span class="line">      LOG.debug(&quot;【返回通知】,shortString&#x3D;&#123;&#125;,result&#x3D;&quot;, joinPoint.toShortString(), result);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 异常通知：目标方法发生异常的时候执行以下代码，此时返回通知不会再触发</span><br><span class="line">    * value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line">    * pointcut 属性：绑定通知的切入点表达式，优先级高于 value，默认为 &quot;&quot;</span><br><span class="line">    * throwing 属性：与方法中的异常参数名称一致，</span><br><span class="line">      *</span><br><span class="line">    * @param ex：捕获的异常对象，名称与 throwing 属性值一致</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @AfterThrowing(pointcut &#x3D; &quot;aspectPointcut()&quot;, throwing &#x3D; &quot;ex&quot;)</span><br><span class="line">      public void aspectAfterThrowing(JoinPoint jp, Exception ex) &#123;</span><br><span class="line">      String methodName &#x3D; jp.getSignature().getName();</span><br><span class="line">      if (ex instanceof ArithmeticException) &#123;</span><br><span class="line">          LOG.error(&quot;【异常通知】&quot; + methodName + &quot;方法算术异常（ArithmeticException）：&quot; + ex.getMessage());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          LOG.error(&quot;【异常通知】&quot; + methodName + &quot;方法异常：&quot; + ex.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 环绕通知</span><br><span class="line"></span><br><span class="line">    * 1、@Around 的 value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line"></span><br><span class="line">    * 2、Object ProceedingJoinPoint.proceed(Object[] args) 方法：继续下一个通知或目标方法调用，返回处理结果，如果目标方法发生异常，则 proceed 会抛异常.</span><br><span class="line"></span><br><span class="line">    * 3、假如目标方法是控制层接口，则本方法的异常捕获与否都不会影响目标方法的事务回滚</span><br><span class="line"></span><br><span class="line">    * 4、假如目标方法是控制层接口，本方法 try-catch 了异常后没有继续往外抛，则全局异常处理 @RestControllerAdvice 中不会再触发</span><br><span class="line">      *</span><br><span class="line"></span><br><span class="line">    * @param joinPoint</span><br><span class="line"></span><br><span class="line">    * @return</span><br><span class="line"></span><br><span class="line">    * @throws Throwable</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @Around(value &#x3D; &quot;aspectPointcut()&quot;)</span><br><span class="line">      public Object handleControllerMethod(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">      this.checkRequestParam(joinPoint);</span><br><span class="line"></span><br><span class="line">      StopWatch stopWatch &#x3D; StopWatch.createStarted();</span><br><span class="line">      LOG.debug(&quot;【环绕通知】执行接口开始，方法&#x3D;&#123;&#125;，参数&#x3D;&#123;&#125; &quot;, joinPoint.getSignature(), Arrays.asList(joinPoint.getArgs()).toString());</span><br><span class="line">      &#x2F;&#x2F;继续下一个通知或目标方法调用，返回处理结果，如果目标方法发生异常，则 proceed 会抛异常.</span><br><span class="line">      &#x2F;&#x2F;如果在调用目标方法或者下一个切面通知前抛出异常，则不会再继续往后走.</span><br><span class="line">      Object proceed &#x3D; joinPoint.proceed(joinPoint.getArgs());</span><br><span class="line"></span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      long watchTime &#x3D; stopWatch.getTime();</span><br><span class="line">      LOG.debug(&quot;【环绕通知】执行接口结束，方法&#x3D;&#123;&#125;, 返回值&#x3D;&#123;&#125;,耗时&#x3D;&#123;&#125; (毫秒)&quot;, joinPoint.getSignature(), proceed, watchTime);</span><br><span class="line">      return proceed;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 参数校验，防止 SQL 注入</span><br><span class="line">      *</span><br><span class="line">    * @param joinPoint</span><br><span class="line">      *&#x2F;</span><br><span class="line">      private void checkRequestParam(ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line">      Object[] args &#x3D; joinPoint.getArgs();</span><br><span class="line">      if (args &#x3D;&#x3D; null || args.length &lt;&#x3D; 0) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      String params &#x3D; Arrays.toString(joinPoint.getArgs()).toUpperCase();</span><br><span class="line">      String[] keywords &#x3D; &#123;&quot;DELETE &quot;, &quot;UPDATE &quot;, &quot;SELECT &quot;, &quot;INSERT &quot;, &quot;SET &quot;, &quot;SUBSTR(&quot;, &quot;COUNT(&quot;, &quot;DROP &quot;,</span><br><span class="line">              &quot;TRUNCATE &quot;, &quot;INTO &quot;, &quot;DECLARE &quot;, &quot;EXEC &quot;, &quot;EXECUTE &quot;, &quot; AND &quot;, &quot; OR &quot;, &quot;--&quot;&#125;;</span><br><span class="line">      for (String keyword : keywords) &#123;</span><br><span class="line">          if (params.contains(keyword)) &#123;</span><br><span class="line">              LOG.warn(&quot;参数存在SQL注入风险，其中包含非法字符 &#123;&#125;.&quot;, keyword);</span><br><span class="line">              throw new RuntimeException(&quot;参数存在SQL注入风险：params&#x3D;&quot; + params);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/12.1.spring/20200822112024130.gif" alt="img"></p>
<p>如上所示在不修改原来业务层代码的基础上，就可以使用 AOP 功能，在目标方法执行前后或者异常时都能捕获然后执行。</p>
<p>execution 切点表达式<br>1、@Pointcut 切入点声明注解，以及所有的通知注解都可以通过 value 属性或者 pointcut 属性指定切入点表达式。</p>
<p>2、切入点表达式通过 execution 函数匹配连接点，语法：execution([方法修饰符]  返回类型  方法路径(参数类型) [异常类型])</p>
<p>3、切入点表达式的写法比较灵活，比如：* 号表示任意一个，.. 表示任意多个，还可以使用 &amp;&amp;、||、! 进行逻辑运算.实际开发中常用：</p>
<table>
<thead>
<tr>
<th>execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(Integer))</th>
<th>匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，且带有一个 Integer 类型参数。</th>
</tr>
</thead>
<tbody><tr>
<td>execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(*))</td>
<td>匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，且带有一个任意类型参数。</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(..))</td>
<td>匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，参数不限</td>
</tr>
<tr>
<td>execution(* grp.basic3.se.service.SEBasAgencyService3.editAgencyInfo(..)) || execution(* grp.basic3.se.service.SEBasAgencyService3.adjustAgencyInfo(..))</td>
<td>匹配 editAgencyInfo 方法或者 adjustAgencyInfo 方法</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect.EmpService.*(..))</td>
<td>匹配 com.wmx.aspect.EmpService 类中的任意方法</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect.<em>.</em>(..))</td>
<td>匹配 com.wmx.aspect 包(不含子包)下任意类中的任意方法</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect..<em>.</em>(..))</td>
<td>匹配 com.wmx.aspect 包及其子包下任意类中的任意方法</td>
</tr>
<tr>
<td>execution(* grp.pm..<em>Controller.</em>(..))</td>
<td>匹配 grp.pm 包下任意子孙包中以 “Controller” 结尾的类中的所有方法</td>
</tr>
</tbody></table>
<ul>
<li>execution：用于匹配方法执行的连接点；</li>
<li>within：用于匹配指定类型内的方法执行；</li>
<li>this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；    </li>
<li>target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；</li>
<li>args：用于匹配当前执行的方法传入的参数为指定类型的执行方法；</li>
<li>@within：用于匹配所以持有指定注解类型内的方法；</li>
<li>@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；</li>
<li>@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；</li>
<li>@annotation：用于匹配当前执行方法持有指定注解的方法；</li>
</ul>
<h2 id="SpEL表达式"><a href="#SpEL表达式" class="headerlink" title="SpEL表达式"></a><strong>SpEL表达式</strong></h2><p>SpEL（Spring Expression Language），即Spring表达式语言，是比JSP的EL更强大的一种表达式语言</p>
<p>它可以在运行时查询和操作数据，尤其是数组列表型数据，因此可以缩减代码量，优化代码结构</p>
<p>SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression</p>
<p>1.@Value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@Value能修饰成员变量和方法形参</span><br><span class="line">&#x2F;&#x2F;#&#123;&#125;内就是表达式的内容</span><br><span class="line">@Value(&quot;#&#123;表达式&#125;&quot;)</span><br><span class="line">public String arg;</span><br></pre></td></tr></table></figure>

<p>2.<bean>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;xxx&quot; class&#x3D;&quot;com.java.XXXXX.xx&quot;&gt;</span><br><span class="line">    &lt;!-- 同@Value,#&#123;&#125;内是表达式的值，可放在property或constructor-arg内 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;arg&quot; value&#x3D;&quot;#&#123;表达式&#125;&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>代码块中使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.expression.Expression;</span><br><span class="line">import org.springframework.expression.ExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"> </span><br><span class="line">public class SpELTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;创建ExpressionParser解析表达式</span><br><span class="line">        ExpressionParser parser &#x3D; new SpelExpressionParser();</span><br><span class="line">        &#x2F;&#x2F;表达式放置</span><br><span class="line">        Expression exp &#x3D; parser.parseExpression(&quot;表达式&quot;);</span><br><span class="line">        &#x2F;&#x2F;执行表达式，默认容器是spring本身的容器：ApplicationContext</span><br><span class="line">        Object value &#x3D; exp.getValue();</span><br><span class="line">        </span><br><span class="line">        &#x2F;**如果使用其他的容器，则用下面的方法*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;创建一个虚拟的容器EvaluationContext</span><br><span class="line">        StandardEvaluationContext ctx &#x3D; new StandardEvaluationContext();</span><br><span class="line">        &#x2F;&#x2F;向容器内添加bean</span><br><span class="line">        BeanA beanA &#x3D; new BeanA();</span><br><span class="line">        ctx.setVariable(&quot;bean_id&quot;, beanA);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;setRootObject并非必须；一个EvaluationContext只能有一个RootObject，引用它的属性时，可以不加前缀</span><br><span class="line">        ctx.setRootObject(XXX);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;getValue有参数ctx，从新的容器中根据SpEL表达式获取所需的值</span><br><span class="line">        Object value &#x3D; exp.getValue(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.#{…}和${…}</p>
<ul>
<li>#{…} 用于执行SpEl表达式，并将内容赋值给属性</li>
<li>${…} 主要用于加载外部属性文件中的值</li>
<li>#{…} 和${…} 可以混合使用，但是必须<code>#&#123;&#125;外面，$&#123;&#125;在里面</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果属性文件没有spelDefault.value，则会报错</span><br><span class="line">   &#x2F;&#x2F;  @Value(&quot;$&#123;spelDefault.value&#125;&quot;)</span><br><span class="line">   &#x2F;&#x2F;  private String spelDefault2;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 使用default.value设置值，如果不存在则使用默认值</span><br><span class="line">   @Value(&quot;$&#123;spelDefault.value:127.0.0.1&#125;&quot;)</span><br><span class="line">   private String spelDefault;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SpEL：调用字符串Hello World的concat方法</span><br><span class="line">@Value(&quot;#&#123;&#39;Hello World&#39;.concat(&#39;!&#39;)&#125;&quot;)</span><br><span class="line">private String helloWorld;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; SpEL: 调用字符串的getBytes方法，然后调用length属性</span><br><span class="line">@Value(&quot;#&#123;&#39;Hello World&#39;.bytes.length&#125;&quot;)</span><br><span class="line">private String helloWorldbytes;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&#123;...&#125;和#&#123;...&#125;可以混合使用，如下文代码执行顺序：通过$&#123;server.name&#125;从属性文件中获取值并进行替换，然后就变成了 执行SpEL表达式&#123;‘server1,server2,server3’.split(‘,’)&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; SpEL: 传入一个字符串，根据&quot;,&quot;切分后插入列表中， #&#123;&#125;和$&#123;&#125;配置使用(注意单引号，注意不能反过来$&#123;&#125;在外面，#&#123;&#125;在里面)</span><br><span class="line">    @Value(&quot;#&#123;&#39;$&#123;server.name&#125;&#39;.split(&#39;,&#39;)&#125;&quot;)</span><br><span class="line">    private List&lt;String&gt; servers;</span><br><span class="line">    </span><br><span class="line">	&#x2F;&#x2F; SpEL: 注意不能反过来$&#123;&#125;在外面，#&#123;&#125;在里面，这个会执行失败</span><br><span class="line">    @Value(&quot;$&#123;#&#123;&#39;HelloWorld&#39;.concat(&#39;_&#39;)&#125;&#125;&quot;)</span><br><span class="line">    private List&lt;String&gt; servers2;    </span><br><span class="line">因为spring执行$&#123;&#125;是时机要早于#&#123;&#125;。在本例中，Spring会尝试从属性中查找#&#123;‘HelloWorld’.concat(‘_’)&#125;，那么肯定找不到，由上文已知如果找不到，然后报错。所以$&#123;&#125;在外面，#&#123;&#125;在里面是非法操作    </span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/12.1.spring/" data-id="ckw61sdx4006roswd9x1lf6sf" data-title="spring" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-8.6.VUE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/8.6.VUE/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:41:51.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/8.6.VUE/">VUE</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="VUE简介"><a href="#VUE简介" class="headerlink" title="VUE简介"></a>VUE简介</h1><p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。</p>
<p>Vue 只关注视图层， 采用自底向上增量开发的设计。</p>
<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<h1 id="VUE安装"><a href="#VUE安装" class="headerlink" title="VUE安装"></a>VUE安装</h1><h2 id="1-独立版本"><a href="#1-独立版本" class="headerlink" title="1.独立版本"></a>1.独立版本</h2><p>我们可以在 Vue.js 的官网上直接下载最新版本, 并用 <code>&lt;script&gt;</code> 标签引入。</p>
<h2 id="2-使用-CDN-方法"><a href="#2-使用-CDN-方法" class="headerlink" title="2.使用 CDN 方法"></a>2.使用 CDN 方法</h2><p>以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p>
<ul>
<li><strong>Staticfile CDN（国内）</strong> : <a target="_blank" rel="noopener" href="https://cdn.staticfile.org/vue/3.0.5/vue.global.js">https://cdn.staticfile.org/vue/3.0.5/vue.global.js</a></li>
<li><strong>unpkg</strong>：<a target="_blank" rel="noopener" href="https://unpkg.com/vue@next">https://unpkg.com/vue@next</a>, 会保持和 npm 发布的最新的版本一致。</li>
<li><strong>cdnjs</strong> : <a target="_blank" rel="noopener" href="https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.5/vue.global.js">https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.5/vue.global.js</a></li>
</ul>
<h2 id="3-NPM-方法"><a href="#3-NPM-方法" class="headerlink" title="3.NPM 方法"></a>3.NPM 方法</h2><p>因为需要使用 npm 安装 Vue CLI，而 npm 是集成在 Node.js 中的，所以第一步我们需要安装 Node.js。在官网下载安装完node.js后，查看node版本。同时npm也安装好了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br><span class="line">2.3.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将 npm 更新至最新版本</span></span><br><span class="line">npm -g install npm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装cnpm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级或安装 cnpm</span></span><br><span class="line">npm install cnpm -g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">升级 npm</span></span><br><span class="line">cnpm install npm -g</span><br></pre></td></tr></table></figure>

<p>在用 Vue.js 构建大型应用时推荐使用 cnpm 安装，cnpm 能很好地和 Webpack 或 Browserify 模块打包器配合使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 最新稳定版</span><br><span class="line">$ cnpm install vue@next</span><br></pre></td></tr></table></figure>

<p>命令行工具</p>
<p>Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">$ cnpm install -g @vue&#x2F;cli</span><br><span class="line">npm install -g vue-cli</span><br><span class="line"></span><br><span class="line"># 安装完后查看版本</span><br><span class="line">$ vue --version</span><br><span class="line">@vue&#x2F;cli 4.5.11</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>vue-cli 3.x 和 vue-cli 2.x 使用了相同的 vue 命令，如果你之前已经安装了 vue-cli 2.x，它会被替换为 Vue-cli 3.x。</p>
<p>安装 @vue/cli-int：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm i -g @vue&#x2F;cli-init</span><br></pre></td></tr></table></figure>





<p>node版本</p>
<p>npm版本</p>
<p>vue版本</p>
<p>vue-cli版本</p>
<p>前端版本会有不兼容问题</p>
<p>注意：Vue.js 不支持 IE8 及其以下 IE 版本。</p>
<h2 id="4-安装yarn"><a href="#4-安装yarn" class="headerlink" title="4.安装yarn"></a>4.安装yarn</h2><p>1.使用msi安装：</p>
<p>首先进入yarn的官网 <a target="_blank" rel="noopener" href="https://yarn.bootcss.com/docs/install/#windows-stable%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%89%E6%8B%A9%E7%A8%B3%E5%AE%9A%E7%89%88%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E3%80%82%E7%84%B6%E5%90%8E%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85%E5%8D%B3%E5%8F%AF">https://yarn.bootcss.com/docs/install/#windows-stable，然后选择稳定版进行下载。然后双击安装即可</a></p>
<p>2.通过npm命令进行安装：</p>
<p>执行命令<code>npm install yarn -g</code> （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到C:\Users\用户名\AppData\Roaming\npm路径中。</p>
<p>yarn和npm都是包管理工具，但是yarn是崭新的，经过重新设计的npm客户端，于2016年10月发布，相比于npm，yarn在运行速度上有显著的提升，安装时间变少，功能上也有很多改进</p>
<h1 id="创建VUE项目"><a href="#创建VUE项目" class="headerlink" title="创建VUE项目"></a>创建VUE项目</h1><h3 id="直接使用命令行构建项目"><a href="#直接使用命令行构建项目" class="headerlink" title="直接使用命令行构建项目"></a>直接使用命令行构建项目</h3><p>1.新建一个文件夹，自行选择位置。</p>
<p>2.文件夹里打开cmd，输入 <code>vue init webpack 项目名字</code>  （这里 webpack 是以 webpack 为模板指生成项目，还可以替换为 pwa、simple 等参数）</p>
<p>接下来会让你确认项目名字，描述，作者，build，是否安装vue-router（选是Y），是否安装es-lint（代码质量）</p>
<p>3.可以看到文件夹里生成了VUE项目</p>
<p>4.在项目里打开命令行，执行命令 <code>npm run dev</code></p>
<h3 id="使用webstorm"><a href="#使用webstorm" class="headerlink" title="使用webstorm"></a>使用webstorm</h3><p>按步骤新建项目。可以在控制台上输入命令。也可以在package.json 文件上点击右键，选择 show npm scripts，双击命令运行。也可以在右上角选择npm命令运行。</p>
<h1 id="VUE的文件"><a href="#VUE的文件" class="headerlink" title="VUE的文件"></a>VUE的文件</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">vue-cource // 项目名称</span><br><span class="line">    |__ node_modules // 项目中的node依赖包</span><br><span class="line">    |__ public // public文件夹放公共文件</span><br><span class="line">    |    |__ favicon.ico // 标签栏的小图标</span><br><span class="line">    |    |__ index.html // 模板文件，最后打包后的index.html模板就是这个文件</span><br><span class="line">    |    </span><br><span class="line">    |__ src // 项目主文件</span><br><span class="line">    |    |__ api // api文件夹，项目的接口js文件都可以写在这里</span><br><span class="line">    |    |__ assets // 静态资源（图片、字体图标文件）</span><br><span class="line">    |    |    |__ img // 图片文件夹</span><br><span class="line">    |    |    |__ font // 字体图标文件夹</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ components // 组件</span><br><span class="line">    |    |__ config // 项目的配置（全局变量js文件）</span><br><span class="line">    |    |    |__ index.js     </span><br><span class="line">    |    |</span><br><span class="line">    |    |__ directive // vue的自定义指令文件夹</span><br><span class="line">    |    |    |__ index.js     </span><br><span class="line">    |    |</span><br><span class="line">    |    |__ lib // 全局方法放在这里</span><br><span class="line">    |    |    |__ util.js // 与业务结合的工具方法</span><br><span class="line">    |    |    |__ tools.js // 与业务无关的工具方法(例如日期转换时间戳方法)</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ mock // 模拟数据文件夹</span><br><span class="line">    |    |    |__ index.js</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ router // 路由文件夹</span><br><span class="line">    |    |    |__ index.js // 路由配置文件</span><br><span class="line">    |    |    |__ router.js // 拆分出来的routes数组</span><br><span class="line">    |    |__ store // Vuex配置文件夹</span><br><span class="line">    |    |    |__ module          // 模块文件夹</span><br><span class="line">    |    |    |__ plugin          // Vuex插件文件夹</span><br><span class="line">    |    |    |__ actions.js      // 异步调用接口方法都写在这里</span><br><span class="line">    |    |    |__ getters.js      // Vuex的计算属性都写在这里</span><br><span class="line">    |    |    |__ index.js        // Vuex主要配置管理文件</span><br><span class="line">    |    |    |__ mutations.js    // Vuex中的修改state的方法，都写在这里</span><br><span class="line">    |    |    |__ state.js        // Vuex的变量文件夹</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ views // 页面都写在这个文件夹中</span><br><span class="line">    |    |__ App.vue // 基础组件。项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。</span><br><span class="line">    |    |__ main.js // 项目入口文件（项目引入全局插件都在这里引入）项目的核心文件</span><br><span class="line">    |    </span><br><span class="line">    |__ .browserslistrc // 浏览器兼容</span><br><span class="line">    |__ .editorconfig // 编译器配置文件</span><br><span class="line">    |__ .eslintrc.js // 配置ESlint规则文件</span><br><span class="line">    |__ .gitignore // git提交的忽略文件</span><br><span class="line">    |__ babel.config.js // babel的配置文件，babel可以将es6、es7等等装换成es5兼容的代码</span><br><span class="line">    |__ package-lock.json // 锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致</span><br><span class="line">    |__ package.json // 项目名称、项目版本、项目描述、项目运行的一些脚本（依赖）</span><br><span class="line">    |__ postcss.config.js // css自动补充一些兼容性代码的配置（-webkit-、-moz-、-ms-之类的）</span><br><span class="line">    |__ README.en.md // 英文版项目说明</span><br><span class="line">    |__ README.md // 中文版项目说明</span><br><span class="line">    |__ vue.config.js // 配置文件</span><br></pre></td></tr></table></figure>

<h3 id="public-index-html"><a href="#public-index-html" class="headerlink" title="public/index.html"></a>public/index.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就是一个普普通通的 html 文件，让它不平凡的是 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> ，下面有一行注释，构建的文件将会被自动注入，也就是说我们编写的其它的内容都将在这个 div 中展示。</p>
<p>还有不普通的一点是，整个项目只有这一个 html 文件，所以这是一个 单页面应用，当我们打开这个应用，表面上可以有很多页面，实际上它们都只不过在一个 div 中。</p>
<h3 id="src-App-vue"><a href="#src-App-vue" class="headerlink" title="src/App.vue"></a>src/App.vue</h3><p>这个文件称为“根组件”，因为其它的组件又都包含在这个组件中</p>
<p>vue 文件是一种自定义文件类型，在结构上类似 html，一个 .vue 文件即是一个 vue 组件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-wechat-title</span>=<span class="string">&quot;$route.meta.title&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">		-webkit-<span class="attribute">font</span>-smoothing: antialiased;</span></span><br><span class="line"><span class="css">		<span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">font-family</span>: <span class="string">&#x27;PingFang SC&#x27;</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	#app &#123;</span><br><span class="line"><span class="css">		<span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>&lt;div id=&quot;app&quot;&gt;</code>,<code>id=app</code> 只是跟下面的 css 对应.</p>
<script>标签里的内容即该组件的脚本，也就是 js 代码，export default 是 ES6 的语法，意思是将这个组件整体导出，之后就可以使用 import 导入组件了。大括号里的内容是这个组件的相关属性

`<router-view/>`，是一个容器，名字叫“路由视图”，意思是当前路由（ URL）指向的内容将显示在这个容器中。也就是说，其它的组件即使拥有自己的路由（URL，需要在 router 文件夹的 index.js 文件里定义），也只不过表面上是一个单独的页面，实际上只是在根组件 App.vue 中。

### src/main.js

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置反向代理，前端请求默认发送到 http:&#x2F;&#x2F;localhost:8443&#x2F;api</span><br><span class="line">var axios &#x3D; require(&#39;axios&#39;)</span><br><span class="line">axios.defaults.baseURL &#x3D; &#39;http:&#x2F;&#x2F;localhost:8443&#x2F;api&#39;</span><br><span class="line">&#x2F;&#x2F; 全局注册，之后可在其他组件中通过 this.$axios 发送数据</span><br><span class="line">Vue.prototype.$axios &#x3D; axios</span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

没有分号（;），因为是 ES6 的语法，不这么写反而会提示错误，也可以把 es-lint 改了或者关了

最上面 import 了几个模块，其中 vue 模块在 node_modules 中，App 即 App.vue 里定义的组件，router 即 router 文件夹里定义的路由。

Vue.config.productionTip = false ,作用是阻止vue 在启动时生成生产提示。如果没有这行代码，或者设置为true，控制台就会多出这么一段代码：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You are running Vue in development mode.</span><br><span class="line">Make sure to turn on production mode when deploying for production.</span><br></pre></td></tr></table></figure>

在这个 js 文件中，我们创建了一个 Vue 对象（实例），el 属性提供一个在页面上已存在的 DOM 元素作为 Vue 对象的挂载目标，router 代表该对象包含 Vue Router，并使用项目中定义的路由。components 表示该对象包含的 Vue 组件，template 是用一个字符串模板作为 Vue 实例的标识使用，类似于定义一个 html 标签。



### **src/config/index.js**

**当前项目的配置**

**config/index.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面使用 **ES6** 的 **模块** 导出一个对象，如果有 **全局变量** 都可以写在这里，在需要用到的地方直接这么写：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  config  from  &#39;@&#x2F;config&#39;  &#x2F;&#x2F; nodejs就会自动找到他下面的index.js文件</span><br></pre></td></tr></table></figure>

或者这样也可以找到这个 **index** 文件，

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  config  from  &#39;@&#x2F;config&#x2F;index&#39; </span><br></pre></td></tr></table></figure>



### src/router

分为**正常路由结构** 和 **封装好的路由结构**

**正常路由**：创建项目初始化路由 会在 src文件夹 下生成一个 router.js 文件。

**router.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import  Home  from  &#39;.&#x2F;views&#x2F;Home&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;,</span><br><span class="line">    name: &#39;home&#39;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;about&#39;,</span><br><span class="line">    name: &#39;about&#39;,</span><br><span class="line">    &#x2F;&#x2F; route level code-splitting</span><br><span class="line">    &#x2F;&#x2F; this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    &#x2F;&#x2F; which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;.&#x2F;views&#x2F;About.vue&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

这种只是 **简单的路由（搭建项目初始化自动生成的路由文件）** ，如果以后 **复杂** 起来会**难以维护**。

**封装路由**

1. 在 **src目录** 下创建一个 **router文件夹** ，这里的思想是把 **routes数组** 拆分成一个 **单独的js文件**，这样看着简洁也**方便维护**。

![img](https://img.kancloud.cn/76/ee/76ee106ff5e570f4235eba358b6cbb6c_348x87.png)

1. **router文件夹**

**index.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import routes from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes &#x2F;&#x2F; 这里使用ES6的简写写法，正常应该是这样写&#39;routes : routes &#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**router.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import  Home  from  &#39;@&#x2F;views&#x2F;Home&#39;</span><br><span class="line"></span><br><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;,</span><br><span class="line">    name: &#39;home&#39;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;about&#39;,</span><br><span class="line">    name: &#39;about&#39;,</span><br><span class="line">    &#x2F;&#x2F; route level code-splitting</span><br><span class="line">    &#x2F;&#x2F; this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    &#x2F;&#x2F; which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;@&#x2F;views&#x2F;About.vue&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

### src/store

分为**正常vuex结构** 和 **封装好的vuex结构**

**正常vuex**

**创建项目** 初始化路由会在 **src文件夹** 下生成一个 **store.js** 文件。

**store.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

这种结构 **看似简单** ，后期项目 **维护麻烦** 。

**封装vuex**

**封装后** 的结构，在 **src目录** 下创建一个 **store文件夹**

![img](https://img.kancloud.cn/cd/c3/cdc31f614c6e19e0bbb0d9f705b05276_351x185.png)

module文件夹

首先讲一下为什么会有 **module文件夹** ，因为项目如果有 **好多vuex的状态** ，如果都写在 **sore.js** 中，看起来会 **杂乱无章** ，都不知道哪个 **vuex** 的 **状态** 是哪个 **模块** 中使用的，所以有了 **module文件夹** ，例如我有一个 **user模块** 我只需要在 **module文件夹** 中创建一个 **user.js**

**user.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">const mutations &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">const actions &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

使用时只需要在 **store文件夹** 下的 **index.js** 中这样 **引入** 即可：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import state from &#39;.&#x2F;state&#39; &#x2F;&#x2F; state.js文件可以不写.js结尾，这样写也会自动找到state.js文件</span><br><span class="line">import mutations from &#39;.&#x2F;mutations&#39;</span><br><span class="line">import actions from &#39;.&#x2F;actions&#39;</span><br><span class="line">import user from &#39;.&#x2F;module&#x2F;user&#39; &#x2F;&#x2F; 引入模块文件</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state,  &#x2F;&#x2F; ES6对象简写的形式，state: state 等同与 state</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  modules: &#123; &#x2F;&#x2F; 模块引用</span><br><span class="line">    user</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**plugin文件夹**

**plugin文件夹** 是存放 **Vuex插件** 的文件夹，假如我们这里有个持久化插件

**plugin/saveiInLocal.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 持久化储存插件：这个函数会在每次store实例初始化时调用。刷新浏览器后第一次要做的操作可以定义在这里</span><br><span class="line"> * @param store </span><br><span class="line"> *&#x2F;</span><br><span class="line">export default store &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果本地存储了state，就把这个stateJSON字符串转换成对象，替换到当前store实例的state</span><br><span class="line">    if(localStorage.state) store.replaceState(JSON.parse(localStorage.state))</span><br><span class="line">    store.subscribe((mutation, state) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 提交commit提交mutation之后执行这里，把state转换成JSON字符串储存到localStorage的state中</span><br><span class="line">        localStorage.state &#x3D; JSON.stringify(state)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**actions.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">export default actions</span><br></pre></td></tr></table></figure>

**index.js**

**index.js** 属于 **根级别的Vuex** 可以用来管理 **根级别** 的 **actions** 、 **state** 、 **mutations** 、 **getters** ，同样可以管理 **模块（module）** 中的 **actions** 、 **state** 、 **mutations**、 **getter**。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import state from &#39;.&#x2F;state&#39; &#x2F;&#x2F; state.js文件可以不写.js结尾，这样写也会自动找到state.js文件</span><br><span class="line">import getters from &#39;.&#x2F;getters&#39;</span><br><span class="line">import mutations from &#39;.&#x2F;mutations&#39;</span><br><span class="line">import actions from &#39;.&#x2F;actions&#39;</span><br><span class="line">import user from &#39;.&#x2F;module&#x2F;user&#39; &#x2F;&#x2F; 引入模块文件</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state,  &#x2F;&#x2F; ES6对象简写的形式，state: state 等同与 state</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  modules: &#123; &#x2F;&#x2F; 模块引用</span><br><span class="line">    user</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**mutations.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const mutations &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br><span class="line">export default mutations</span><br></pre></td></tr></table></figure>

**state.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 状态写这里</span><br><span class="line">&#125;</span><br><span class="line">export default state</span><br></pre></td></tr></table></figure>

**getters.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const getters &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default getters</span><br></pre></td></tr></table></figure>



### package.json

**package.json** 文件主要是 **项目名称** 、 **项目版本** 、 **项目描述** 、 **项目运行的一些脚本（依赖）**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;vue-cource&quot;, &#x2F;&#x2F; 项目名称</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;, &#x2F;&#x2F; 项目版本</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &#x2F;&#x2F; 运行指令</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;, &#x2F;&#x2F; 打包指令</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123; &#x2F;&#x2F; 项目打包后用到的依赖（运行依赖）</span><br><span class="line">    &quot;core-js&quot;: &quot;^2.6.5&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^2.6.10&quot;,</span><br><span class="line">    &quot;vue-router&quot;: &quot;^3.0.3&quot;,</span><br><span class="line">    &quot;vuex&quot;: &quot;^3.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123; &#x2F;&#x2F; 开发阶段用到的依赖（开发依赖）</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-babel&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-eslint&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-service&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;eslint-config-standard&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;babel-eslint&quot;: &quot;^10.0.1&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;^5.16.0&quot;,</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;node-sass&quot;: &quot;^4.9.0&quot;,</span><br><span class="line">    &quot;sass-loader&quot;: &quot;^7.1.0&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





### vue.config.js

**vue.config.js** 是 **vue** 的 **配置文件**

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 引入nodejs的path模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir) <span class="comment">// resolve方法用来加载路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_URL = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/iview-admin/&#x27;</span> : <span class="string">&#x27;/&#x27;</span> </span><br><span class="line"><span class="comment">// 判断当前为开发环境还是打包环境, &#x27;/&#x27;意思是代表指定在域名的根目录下，如果要指定到iview-admin下就这样写&#x27;/iview-admin/&#x27;, production为生产坏境，development为开发环境</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,                          <span class="comment">// 取消每次保存时都进行一次&#x27; ESLint &#x27;检测</span></span><br><span class="line">  publicPath: BASE_URL,                       <span class="comment">// 项目的基本路径,vuecli2.0时打包经常静态文件找不到，就是需要配置这个属性为&#x27;./&#x27;</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;                   <span class="comment">// 配置Webpack</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">    .set(<span class="string">&#x27;@&#x27;</span>, resolve(<span class="string">&#x27;src&#x27;</span>))                 <span class="comment">// 引入文件时候“ @ ”符号就代表src</span></span><br><span class="line">    .set(<span class="string">&#x27;_c&#x27;</span>, resolve(<span class="string">&#x27;src/components&#x27;</span>))     <span class="comment">// 引入组件文件夹中的文件就可以用“ _c ”代替src/components</span></span><br><span class="line">  &#125;,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,                 <span class="comment">// 打包时不生成.map文件，会减少打包体积，同时加快打包速度</span></span><br><span class="line">  devServer: &#123;                                <span class="comment">// 跨域有2种解决方案： 1. 在后端的header中配置， 2. 使用devServer来配置代理解决跨域</span></span><br><span class="line">    proxy: &#123;<span class="comment">// 这里写需要代理的URL,这里会告诉开发服务器，将任何未知请求匹配不到静态文件的请求，都代理到这个URL来满足跨域</span></span><br><span class="line">			<span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//api是为了把前端路由和后端路由区分开，没前缀的是前端路由，有前缀的是后端路由</span></span><br><span class="line">				target:process.env.VUE_APP_API_URL, <span class="comment">//这里后台的地址模拟的;应该填写你们真实的后台接口</span></span><br><span class="line">				changOrigin: <span class="literal">true</span>, <span class="comment">//允许跨域</span></span><br><span class="line">				pathRewrite: &#123;</span><br><span class="line">					<span class="comment">// &#x27;^/api&#x27;: &#x27;/api&#x27;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





# ESLint

ESLint是个管理代码风格的工具 统一代码风格 在多人协作的项目都会用到



# VUEX

当我们的应用遇到多个组件共享状态时，会需要多个组件依赖于同一状态抑或是来自不同视图的行为需要变更同一状态。以前的解决办法：

**a.将数据以及操作数据的行为都定义在父组件;**

**b.将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)**

传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。在搭建下面页面时，你可能会对 vue 组件之间的通信感到崩溃 ，特别是非父子组件之间通信。此时就应该使用vuex，轻松可以搞定组件间通信问题。

![组件间通信](https://user-gold-cdn.xitu.io/2018/5/23/1638b38a08088b12?w=1194&h=486&f=png&s=133255)

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。这里的关键在于集中式存储管理。**简单来说,对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)**。

原理

![img](8.6.VUE/1656f2b9277ece19)

Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。

#### 2.简要介绍各模块在流程中的主要功能：

- Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。
- dispatch：操作行为触发方法，是唯一能执行action的方法。
- actions：**操作行为处理模块,由组件中的`$store.dispatch('action 名称', data1)`来触发。然后由commit()来触发mutation的调用 , 间接更新 state**。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。
- commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。
- mutations：**状态改变操作方法，由actions中的`commit('mutation 名称')`来触发**。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。
- state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。
- getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。



如果您的应用够简单，您最好不要使用 Vuex,因为使用 Vuex 可能是繁琐冗余的。一个简单的 [global event bus](https://cn.vuejs.org/v2/guide/components.html#非父子组件通信) 就足够您所需了。但是，**如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。**






每一个 **Vuex** 应用的核心就是 **store（仓库）** 。**store** 基本上就是一个 **容器** ，它包含着你的 **应用中大部分的状态 (state)** 。**Vuex** 和 **单纯的全局对象** 有以下 **两点不同**：

1. **Vuex** 的 **状态** 存储是 **响应式** 的。当 **Vue 组件** 从 **store** 中 **读取状态** 的时候，若 **store** 中的**状态发生变化** ，那么 **相应的组件也会得到更新** 。
2. 你 **不能直接改变 store 中的状态**。改变 **store** 中的 **状态** 的 **唯一途径就是通过mutation** 。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

## Bus

**Vuex** 适合 **大型复杂项目** 中使用，进行 **状态管理**，我们的项目如果不是很复杂可以使用 **Bus** 来满足需求。

## state 与 getter

![img](https://img.kancloud.cn/b3/f9/b3f994c71d894b582bae15b4a1df8ebb_701x551.png)

上图就是 **Vuex** 状态管理的 **流程** ，在 **Vue Components（组件）** 里可以触发一个 **Actions（Actions里可以做异步接口请求）** ， **请求完成** 后触发一个 **Mutations** ，通过 **Mutations** 修改 **State** 的状态值，**State** 修改之后会触发 **vue组件视图的渲染** 。

**getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工**。getters就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。



## mutation 与 action / module

![img](https://img.kancloud.cn/b3/f9/b3f994c71d894b582bae15b4a1df8ebb_701x551.png)

上图是 **Vuex** 状态管理的 **流程**，描述了从 **Vue Components（组件）** 执行 **异步操作** 的一个 **环形流程** ，实际上如果 **没有异步操作的需求** 就不用走 **Actions** 的这个步骤， **2种操作（同步、异步操作）** 的流程如下：

1. **异步操作**： **Vue Components（组件）** > **Actions（请求接口操作写这里）** > **Mutations（接口成功返回值后在这里修改State的值）** > **State状态更新** > **Vue Components（组件）视图更新**
2. **同步操作** ： **Vue Components（组件）** > **Mutations（修改State的值）** > **State状态更新** > **Vue Components（组件）视图更新**



actions和上面的Mutations功能基本一样，不同点是，**actions是异步的改变state状态，而Mutations是同步改变状态**。

同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态----尤雨溪







# AJAX

**Ajax** 用来 **请求后端接口** 并且 **取得返回数据** ， 在 **Vue** 中 使用的是 **Vue** 官方推荐的 **axios** 库来作为 **异步接口请求** 的工具

**跨域** 是受到 **浏览器** 的 **同源策略** 的影响，在一些情况下是 **不允许通信的** 。

在下面表格中列出了 **跨域** 的案例：

| URL                                                         | 说明                           | 是否允许通信                            |
| :---------------------------------------------------------- | :----------------------------- | :-------------------------------------- |
| http://www.d.com/d.js <br />http://www.d.com/w.js           | 同一域名下                     | 允许                                    |
| http://www.d.com/lab/a.js <br />http://www.d.com/src/b.js   | 同一域名下不同文件夹           | 允许                                    |
| http://www.d.com:3333/a.js <br />http://www.d.com:4444/b.js | 同一域名不同端口               | 不允许                                  |
| http://www.d.com/a.js <br />http://46.33.22.44/b.js         | **域名和域名对应 IP**          | 不允许                                  |
| http://www.d.com/a.js <br />http://scipt.d.com/b.js         | 主域相同，子域不同             | 不允许                                  |
| http://www.d.com/a.js <br />http://d.com/b.js               | 同一域名，不同二级域名（同上） | 不允许（cookie 这种情况下也不允许访问） |
| http://www.d.com/a.js <br />http://www.v.com/b.js           | 不同域名                       | 不允许                                  |

### 前端解决跨域

**前端** 需要在 **vue.config.js** 文件中通过 **devServer** 中的 **proxy** 来 **配置代理** 。

**原理** ：我们在 **本地开发** 的时候，通过 **vueServe** 起一个 **本地的开发服务** ，这个 **服务的地址** 一般是 **localhost** ， **端口** 一般是 **8080** ，如果我们在 **本地起一个 node 服务** ，那么它的 **端口** 肯定是跟我们的 **前端服务的端口** 是不一样的，刚才在 上面表格中讲过 **同一域名不同端口** 也是 **存在跨域问题** ，是 **不在同一个域下** ，这个时候 **调用接口** 的话，受到 **同源策略** 影响，是 **无法调取成功** 的，我们可以用 **proxy** 来 **设置代理** ， **它会把我们所有的接口，代理到目标URL下** ，比如接口是 **/api/getUserInfo** ，我们 **设置代理** 是 **[http://localhost:4000](http://localhost:4000/)** ，这样的话请求的接口就会被代理到 **[http://localhost:4000](http://localhost:4000/)** 下，代理后请求接口时的**URL** ： **http://localhost:4000/#/api/getUserInfo** ， 例子如下：

**vue.config.js**

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 引入nodejs的path模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir) <span class="comment">// resolve方法用来加载路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_URL = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/iview-admin/&#x27;</span> : <span class="string">&#x27;/&#x27;</span> <span class="comment">// 判断当前为开发环境还是打包环境, &#x27;/&#x27;意思是代表指定在域名的根目录下，如果要指定到iview-admin下就这样写&#x27;/iview-admin/&#x27;, production为生产坏境，development为开发环境</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,                          <span class="comment">// 取消每次保存时都进行一次&#x27; ESLint &#x27;检测</span></span><br><span class="line">  publicPath: BASE_URL,                       <span class="comment">// 项目的基本路径,vuecli2.0时打包经常静态文件找不到，就是需要配置这个属性为&#x27;./&#x27;</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;                   <span class="comment">// 配置Webpack</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">    .set(<span class="string">&#x27;@&#x27;</span>, resolve(<span class="string">&#x27;src&#x27;</span>))                 <span class="comment">// 引入文件时候“ @ ”符号就代表src</span></span><br><span class="line">    .set(<span class="string">&#x27;_c&#x27;</span>, resolve(<span class="string">&#x27;src/components&#x27;</span>))     <span class="comment">// 引入组件文件夹中的文件就可以用“ _c ”代替src/components</span></span><br><span class="line">  &#125;,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,                 <span class="comment">// 打包时不生成.map文件，会减少打包体积，同时加快打包速度</span></span><br><span class="line">  devServer: &#123;                                <span class="comment">// 跨域有2种解决方案： 1. 在后端的header中配置， 2. 使用devServer来配置代理解决跨域</span></span><br><span class="line">    proxy: <span class="string">&#x27;http://localhost:4000&#x27;</span>            <span class="comment">// 这里写需要代理的URL,这里会告诉开发服务器，将任何未知请求匹配不到静态文件的请求，都代理到这个URL来满足跨域</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

这里的代理的 **URL地址** 以及 **端口号** 一定要与服务端 **一致** 。

### 注意

1. **前端配置代理** 只是在 **开发环境（develop）** 好用，便于开发，在 **生产环境（prod）** 还是 **需要由服务端解决跨域** 。

2. 这里需要注意，如果在 **前端配置代理** ，需要在 **src/config/index.js（接下来的axios封装中用到了这个文件）** 中添加一个 **逻辑判断** 如下：

   **src/config/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果当前是生产环境用生产环境地址，如果是开发环境并且在vue.config.js中配置了代理，就用空字符串【&#39;&#39;】，如果未配置代理就用开发环境地址</span><br><span class="line">export const baseURL&#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;http:&#x2F;&#x2F;production.com&#39; : &#39;http:&#x2F;&#x2F;develop.com&#39;</span><br></pre></td></tr></table></figure>

### 后端解决跨域

如果不在 **设置代理** ，可以在 **后端设置header** 来 **解决跨域问题** ，这里 **后端** 用的是 **nodejs** ，在**express（nodejs的框架）** 里使用 **app.all** 为 **所有请求** 都添加这 **3 个 header** 即可。

**app.js**

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createError = <span class="built_in">require</span>(<span class="string">&#x27;http-errors&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;colors&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;morgan&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indexRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> usersRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/users&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// view engine setup</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="string">&#x27;views&#x27;</span>))</span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;jade&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(logger(<span class="string">&#x27;dev&#x27;</span>))</span><br><span class="line">app.use(express.json())</span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.use(cookieParser())</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123; <span class="comment">// 设置header</span></span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;X-Requested-With,Content-Type&#x27;</span>)</span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="string">&#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;</span>)</span><br><span class="line">	next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, indexRouter)</span><br><span class="line">app.use(<span class="string">&#x27;/users&#x27;</span>, usersRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// catch 404 and forward to error handler</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">	next(createError(<span class="number">404</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error handler</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// set locals, only providing error in development</span></span><br><span class="line">	res.locals.message = err.message</span><br><span class="line">	res.locals.error = req.app.get(<span class="string">&#x27;env&#x27;</span>) === <span class="string">&#x27;development&#x27;</span> ? err : &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// render the error page</span></span><br><span class="line">	res.status(err.status || <span class="number">500</span>)</span><br><span class="line">	res.render(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br></pre></td></tr></table></figure>

## 封装axios

1. 首先在 **src文件夹** 下的 **lib文件夹** 中创建 **axios.js**

   **src/lib/axios.js**

   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; baseURL &#125; <span class="keyword">from</span> <span class="string">&#x27;@/config&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/lib/util&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">baseUrl = baseURL</span>)</span>&#123; <span class="comment">// baseUrl = baseURL 是ES6的默认值写法等同于 baseUrl = baseUrl || baseURL</span></span><br><span class="line">        <span class="built_in">this</span>.baseUrl = baseUrl <span class="comment">// this指向创建的实例，当你使用new HttpRequest创建实例时候，它会把this中定义的变量返回给你</span></span><br><span class="line">        <span class="built_in">this</span>.queue = &#123;&#125; <span class="comment">// 创建队列，每次请求都会向里面添加一个key:value，请求成功后就会去掉这个key:value，直到this.queue中没有属性值时，loading关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认options配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">getInsideConfig</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> config = &#123;</span><br><span class="line">            baseURL: <span class="built_in">this</span>.baseUrl,</span><br><span class="line">            headers: &#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;</span><br><span class="line">    distroy (url) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.queue[url]</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.queue).length) &#123;</span><br><span class="line">          <span class="comment">// Spin.hide()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">instance</span></span> - 通过axios创建的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">url</span></span> - 接口地址</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="function"><span class="title">interceptors</span>(<span class="params">instance, url</span>)</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求拦截器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">config</span></span> - 请求前的控制</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">error</span></span> - 出现错误的时候会提供一个错误信息</span></span><br><span class="line"><span class="comment">         */</span>    </span><br><span class="line">        instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 添加全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.queue).length)&#123;</span><br><span class="line">                <span class="comment">// Spin.show()</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">this</span>.queue[url] = <span class="literal">true</span></span><br><span class="line">            config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = getToken()</span><br><span class="line">            <span class="keyword">return</span> config</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 响应拦截器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">res</span></span> - 服务端返回的东西</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">error</span></span> - 出现错误的时候会提供一个错误信息</span></span><br><span class="line"><span class="comment">         */</span>            </span><br><span class="line">        instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.distroy(url) <span class="comment">// 关闭全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">const</span> &#123; data &#125; = res</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.distroy(url) <span class="comment">// 关闭全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error.response.data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">request</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create()</span><br><span class="line">        options = <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.getInsideConfig(), options) <span class="comment">//  Object.assign会将2个对象合并成1个对象，相同属性值会被后者覆盖</span></span><br><span class="line">        <span class="built_in">this</span>.interceptors(instance, options.url) <span class="comment">// 拦截器</span></span><br><span class="line">        <span class="keyword">return</span> instance(options)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HttpRequest</span><br></pre></td></tr></table></figure>

   **constructor方法** 是 **每一个类必须有的方法** ，如果我们不定义这个 **constructor方法** ， **class类** 会默认添加一个 **空的constructor方法（例如：constructor(){}）** ，在 **constructor方法** 中可以 **接收传入的参数** ， 在我们 **创建实例 new HttpRequest('参数')** 时候可以 **在括号内传入参数** ， 然后我们可以在 **constructor方法** 中 **对参数做一些操作** 。

2. 上面把 **baseUrl** 抽离到了 **config文件夹** 里的 **index.js 全局变量** 中

   **src/config/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果当前是生产环境用生产环境地址，如果是开发环境并且在vue.config.js中配置了代理，就用空字符串【&#39;&#39;】，如果未配置代理就用开发环境地址</span><br><span class="line">export const baseURL&#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;http:&#x2F;&#x2F;production.com&#39; : &#39;http:&#x2F;&#x2F;develop.com&#39;</span><br></pre></td></tr></table></figure>

### 使用方法

1. 在 **api文件夹** 中创建 **index.js**

   **src/api/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import HttpRequest from &#39;@&#x2F;lib&#x2F;axios&#39;</span><br><span class="line">const axios &#x3D; new HttpRequest()</span><br><span class="line">export default axios</span><br></pre></td></tr></table></figure>

   在使用时候：我们创建一个储存用户接口的 **uesr.js** 文件

   **src/api/user.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;.&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取用户信息接口</span><br><span class="line">export const getUserInfo &#x3D; (&#123; userId &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return axios.request(&#123;</span><br><span class="line">        url: &#39;&#x2F;getUserInfo&#39;,</span><br><span class="line">        method: &#39;post&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            userId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   然后在 **Home.vue** 页面组件中这样 **调用接口**

   **Home.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;getInfo&quot;&gt;请求数据&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; getUserInfo &#125; from &#39;@&#x2F;api&#x2F;user&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getInfo()&#123;</span><br><span class="line">      getUserInfo(&#123; userId: 21 &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">      &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



ajax.js`中配置了axios.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";`

在jquery的ajax中，如果没加contentType:"application/json"，那么data就应该对应的是json对象，反之，如果加了contentType:"application/json"，那么ajax发送的就必须是字符串

contentType参数指定的是浏览器将发送什么样类型的编码

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">text&#x2F;html ： HTML格式</span><br><span class="line"></span><br><span class="line">    text&#x2F;plain ：纯文本格式      </span><br><span class="line"></span><br><span class="line">    text&#x2F;xml ：  XML格式</span><br><span class="line"></span><br><span class="line">    mage&#x2F;gif ：gif图片</span><br><span class="line"></span><br><span class="line">    image&#x2F;jpeg ：jpg图片格式 </span><br><span class="line"></span><br><span class="line">    image&#x2F;png：png图片格式</span><br><span class="line"></span><br><span class="line">    application&#x2F;json  ：json数据格式</span><br><span class="line"></span><br><span class="line">    application&#x2F;pdf   ：pdf格式  </span><br><span class="line"></span><br><span class="line">    application&#x2F;octet-stream ： 二进制流数据</span><br></pre></td></tr></table></figure>

不指定contentType则代表为默认的application/x-www-form-urlencoded（表单）类型，这种类型有一个好处，它可以支持很多种情况，并能配合查询字符串（key1=value1&key2=vlaue2）的形式发送到服务器。而且这种默认类型可以很好地配合参数processData（默认为true，可以不用管他），该参数为true的时候，开启自动转化功能，**只要是一个合法对象**，都能将该对象**自动地转化成查询字符串**的形式

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data: &#123; &quot;username&quot; : &quot;ccc&quot; &#125; ,  &#x2F;&#x2F;查询字符串的映射形式（即对象），在默认模式下提交时会自动地转化成查询字符串</span><br><span class="line"> data: &quot;username&#x3D;ccc&quot;,   &#x2F;&#x2F;查询字符串形式</span><br></pre></td></tr></table></figure>

指定了contentType : "application/json"后，data就只能是字符串而且必须是json字符串了，首先你指定json格式，那提交格式肯定与json有关，再一个，因为你指定了"application/json"就意味着你放弃了"application/x-www-form-urlencoded"这种默认模式，默认模式虽可以自动地转化对象，不见得"application/json"这种格式就会自动帮你转，而事实证明，它确实不会帮你自动转

@RequestBody这个注解就是专门用来处理**非默认模式**下的请求的。该注解会提取你传过来的**json字符串**(注意是**json字符串**,不是查询字符串)，并将提取到的信息绑定到对象中

有些  关键的属性在Mvc层中反射失败，会导致其他所有属性都为null：比如joindate对应的pojo是Date，本来input框里的值是 Thu Dec 30 00:00:00 CST 1999 ，传到后台用Date接收，但是显然格式不对，于是Date合成出了错，然后坑爹的就来了，因为这个特殊的属性反射失败，Mvc层就将请求打回去然后导致浏览器报错400 bad request ，从而导致其他所有属性都为null。最后把joindate属性注释掉，后台什么属性的值都收到了

总结：在"application/json"的时候，ajax请求对跨域支持似乎不好，默认模式下的ajax成功跨域请求一旦改成了"application/json"就会报跨域请求的错，需要用@RequestBody在请求的参数中才能正常。

在非特殊情况下会有些更倾向application/x-www-form-urlencoded了，**跨域问题**既没有application/json那么多，安全问题也不像application/json那样会有一定概率被一些植入**恶意的回调代码**，而且能**很方便的传输和接受**复杂而又多重嵌套的对象

要调用别人的接口，那么就很可能要指定application/json格式，因为接口提供方就是这么规定的，json的数据格式**传输时带宽会更小**，尤其是在传输数组时，如果数组元素很多，那么application/json传输的数据量就会比application/x-www-form-urlencoded**要少很多**，同时，json的解析速度也会更快



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">在请求或响应被 then 或 <span class="keyword">catch</span> 处理前拦截它们。</span><br><span class="line"><span class="comment">// axios 配置</span></span><br><span class="line">axios.defaults.timeout = <span class="number">10000</span>; <span class="comment">// 设置请求超时为10秒</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;/api&#x27;</span>; <span class="comment">// 默认请求地址前都加/api</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;</span>; <span class="comment">// 请求头的设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置跨域携带用户凭证</span></span><br><span class="line"><span class="comment">//axios.defaults.withCredentials = true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    (config) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">        Toast.loading(&#123;</span><br><span class="line">            message: <span class="string">&quot;加载中...&quot;</span>,</span><br><span class="line">            loadingType: <span class="string">&quot;spinner&quot;</span>,</span><br><span class="line">            forbidClick: <span class="literal">true</span>,</span><br><span class="line">            duration: <span class="number">0</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> openid = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">        config.headers[<span class="string">&quot;openid&quot;</span>] = openid;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">        Toast.clear();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;请求出错&quot;</span> + error)</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;http://elinktech.cn/#/error&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">        Toast.clear(); <span class="comment">//在网络不好时清除加载中</span></span><br><span class="line">        <span class="keyword">const</span> responseCode = res.status;</span><br><span class="line">        <span class="comment">// 拦截器配置</span></span><br><span class="line">        <span class="keyword">if</span> (responseCode === <span class="number">200</span>) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (res.data.code === -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;返回出错了&quot;</span> + res)</span><br><span class="line">                <span class="built_in">window</span>.location.href = <span class="string">&#x27;http://elinktech.cn/#/error&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">                ok: <span class="literal">true</span>,</span><br><span class="line">                data: res.data,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.fail(&#123;</span><br><span class="line">                message: <span class="string">&quot;服务器开小差了，请稍后重试&quot;</span>,</span><br><span class="line">                duration: <span class="number">3000</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">        Toast.clear();</span><br><span class="line">        <span class="keyword">if</span> (error.response?.data?.code === <span class="number">401</span>) &#123;</span><br><span class="line">            <span class="comment">//  localStorage.removeItem(&quot;token&quot;);</span></span><br><span class="line">            <span class="comment">// localStorage.removeItem(&quot;userId&quot;);</span></span><br><span class="line">            <span class="comment">// window.location.reload();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求失败</span></span><br><span class="line">        Toast.fail(&#123;</span><br><span class="line">            message: <span class="string">&quot;请求超时！&quot;</span>,</span><br><span class="line">            duration: <span class="number">3000</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;返回出错&quot;</span> + error)</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;http://elinktech.cn/#/error&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



# 渲染函数（render函数）

在 **Vue** 中使用 **渲染函数** 来 **创建视图模板** ，并且会讲解 **JSX** 的 **语法** ，同时会补充2个内容，第一是 **函数式组件** ，第二是 **作用域插槽** 。

## render函数

**render函数** ：可以用 **函数的方式** 渲染 **dom元素** 到页面中。

下面会讲解2种使用场景：

1. 在 **main.js** 中如何使用
2. 在 **.vue** 文件中使用

### render函数在main.js中使用

**src/main.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39; &#x2F;&#x2F; app组件</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">import Bus from &#39;.&#x2F;lib&#x2F;bus&#39; &#x2F;&#x2F; 引入Bus</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line">Vue.prototype.$bus &#x3D; Bus &#x2F;&#x2F; 挂载Bus到Vue原型链（全局挂载Bus）</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(App) &#x2F;&#x2F; 渲染app组件</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

我们首先在 **main.js** 中学习 **render函数** ， **render** 的 **属性值** 是一个 **回调函数** ，它的参数可以用括号包裹起来，例如这样： **render: (h) => h(App)** ，如果 **只有一个参数就可以不用括号包裹** ， **h这个参数是一个方法** ，这个方法能 **创建一个虚拟节点** ，**这个函数 return 返回一个结果** 。

| 方法名                              | 参数                                                         | 是否必填 |
| :---------------------------------- | :----------------------------------------------------------- | :------- |
| **render函数：render: h => h(App)** | **h函数的第1个参数**：**要渲染的组件，或者一个标签字符串，或者也可以是一个函数** | **是**   |
|                                     | **h函数的第2个参数**： 该参数是一个 **配置对象**，可以 **通过该对象给元素设置属性** ，例如 **div** 标签的 **id、class 等等** | **否**   |
|                                     | **h函数的第3个参数**：该 **参数可以是字符串或者数组**，主要作用是 **给元素添加内容** | **否**   |

1. **h函数的参数1**

   **说明** ： **第1个参数** 是用来传入 **元素标签** 或者 **组件** 。

   1.1. **传入组件** ：**main.js** 中 **h函数** 默认传入的是 **app.vue页面组件**，所以就会 **渲染该组件** ，下面引入之前封装的 **CountTo 组件**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">import Bus from &#39;.&#x2F;lib&#x2F;bus&#39;</span><br><span class="line">import CountTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入CountTo 组件</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line">Vue.prototype.$bus &#x3D; Bus</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(CountTo, &#123;</span><br><span class="line">    &#x2F;&#x2F; &#39;class&#39;: &#39;count-to&#39;, &#x2F;&#x2F; 给组件最外层盒子添加class类名</span><br><span class="line">    &#x2F;&#x2F; 或者这样写</span><br><span class="line">    &#x2F;&#x2F; &#39;class&#39;: [&#39;count-to&#39;, true ? &#39;count-to2&#39; : &#39;&#39;], </span><br><span class="line">    &#x2F;&#x2F; 或者这样写</span><br><span class="line">    &#39;class&#39;: &#123;</span><br><span class="line">      &#39;count-to&#39;: true,</span><br><span class="line">      &#39;count-to2&#39;: 1 &#x3D;&#x3D;&#x3D; 1,</span><br><span class="line">    &#125;, </span><br><span class="line">    attrs: &#123;&#125;, &#x2F;&#x2F; 定义属性id等等</span><br><span class="line">    style: &#123;&#125;, &#x2F;&#x2F; 定义样式</span><br><span class="line">    props: &#123; &#x2F;&#x2F; 添加属性 这里可以理解为就是&lt;count-to :endValue&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">      endValue: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; domProps: &#123; &#x2F;&#x2F; dom的一些属性</span><br><span class="line">    &#x2F;&#x2F;   innerHTML: &#39;11&#39; &#x2F;&#x2F; 可以设置标签的一些内容</span><br><span class="line">    &#x2F;&#x2F; &#125;,</span><br><span class="line">    on: &#123; &#x2F;&#x2F; 添加事件</span><br><span class="line">      &#39;on-animation-end&#39;: (val) &#x3D;&gt; &#123; &#x2F;&#x2F; 事件名</span><br><span class="line">        console.log(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    nativeOn: &#123; &#x2F;&#x2F; 组件内没有定义click事件时，给组件最外层元素绑定一个click事件</span><br><span class="line">      &#39;click&#39;: () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;click&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    directives: [], &#x2F;&#x2F; 可以定义自定义指令</span><br><span class="line">    scopedSlots: &#123;&#125;,</span><br><span class="line">    slot: &#39;&#39;, &#x2F;&#x2F; 插槽</span><br><span class="line">    key: &#39;&#39;, &#x2F;&#x2F; 设置一个值让每个组件的key不相等</span><br><span class="line">    ref: &#39;&#39; &#x2F;&#x2F; ref</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   1.2. **传入字符串** ：也可以像下面写，这样页面中就 **渲染** 出一个 **div标签** 。

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   1.3. **传入函数** ：

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let func &#x3D; ()&#x3D;&gt; &#39;h3&#39;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(func())</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

2. **h函数的参数2**

   **说明** ： **h函数** 的 **第2个参数是个对象** ，用来 **定义元素的一些属性** 。

   2.1. **给元素设置属性** ：

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#123;</span><br><span class="line">    attrs: &#123; &#x2F;&#x2F; 添加属性</span><br><span class="line">      id: &#39;box&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    style: &#123; &#x2F;&#x2F; 添加样式</span><br><span class="line">      color: &#39;red&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

3. **h函数的参数3**

   **说明** ： **h函数的第3个参数可以是字符串或者数组** ，用来 **定义元素的内容** 。

   3.1. **传入字符串**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#123;</span><br><span class="line">    attrs: &#123; &#x2F;&#x2F; 添加属性</span><br><span class="line">      id: &#39;box&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    style: &#123; &#x2F;&#x2F; 添加样式</span><br><span class="line">      color: &#39;red&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#39;我是div的内容&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   **如果不设置样式可以直接忽略h函数的第2个参数** , 直接写内容

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#39;123&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   3.2. **传入数组**

   如果想让内容是 **多个标签** ，就需要 **传入数组**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, [</span><br><span class="line">    h(&#39;span&#39;, &#39;111&#39;),</span><br><span class="line">    h(&#39;span&#39;, &#39;222&#39;)</span><br><span class="line">  ])</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   3.3. **循环传入标签**

   如果想实现一个类似 **v-for** 的效果，首先先看 **正常循环列表写法**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul @click&#x3D;&quot;handleClick&quot;&gt;</span><br><span class="line">        &lt;li @click.stop&#x3D;&quot;handleClick&quot; v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;list_item_$&#123;index&#125;&#96;&quot;&gt;&#123;&#123; item.name &#125;&#125; &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default&#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                list: [</span><br><span class="line">                    &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                    &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleClick(event)&#123;</span><br><span class="line">                console.log(event)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   接下来使用 **render函数** 实现上面的 **循环列表跟点击事件**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 点击事件</span><br><span class="line">const handleClick &#x3D; event &#x3D;&gt; &#123;</span><br><span class="line">  console.log(event)</span><br><span class="line">  event.stopPropagation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">let list &#x3D; [</span><br><span class="line">  &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">  &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 循环生成li</span><br><span class="line">const getLiEleArr &#x3D; (h) &#x3D;&gt; &#123;</span><br><span class="line">  return list.map((item, index) &#x3D;&gt; h(&#39;li&#39;, &#123;</span><br><span class="line">    on: &#123;</span><br><span class="line">      &#39;click&#39;: handleClick</span><br><span class="line">    &#125;,</span><br><span class="line">    key: &#96;list_item_$&#123;index&#125;&#96;</span><br><span class="line">  &#125;, item.name))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最终渲染</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;,[</span><br><span class="line">    h(&#39;ul&#39;, &#123;</span><br><span class="line">      on: &#123;</span><br><span class="line">        &#39;click&#39;: handleClick</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, getLiEleArr(h))</span><br><span class="line">  ])</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

### render函数在.vue中使用

有时 **即使你封装好了组件，但是想根据自己的方式去定制组件内的元素以及内容**，这时候就需要 **给组件传入一个render函数**

1. **父组件**

   首先在 **路由列表** 的 **路由对象** 中添加新创建的 **render-page** 页面配置路由

   **src/router/router.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;render-page&#39;,</span><br><span class="line">    name: &#39;&#x2F;render_page&#39;,</span><br><span class="line">    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;render-page&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

   然后在 **src/views/render-page.vue** 页面 **引入list组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, name)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            return h(&#39;i&#39;, &#123;</span><br><span class="line">                style: &#123;</span><br><span class="line">                    color: &#39;pink&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

2. **子组件**

   **src/components/list/list.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">          &lt;!-- 如果未传入render函数就span标签内容 --&gt;</span><br><span class="line">          &lt;span v-if&#x3D;&quot;!render&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">          </span><br><span class="line">          &lt;!-- 如果传入了render函数，就使用render函数自定义dom的节点来渲染 --&gt;</span><br><span class="line">          &lt;render-dom v-else :render-func&#x3D;&quot;render&quot; :name&#x3D;&quot;item.name&quot;&gt;&lt;&#x2F;render-dom&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 引入函数式组件</span><br><span class="line">import RenderDom from &#39;_c&#x2F;render-dom&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        RenderDom &#x2F;&#x2F; 注册函数式组件</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;,</span><br><span class="line">        render: &#123; &#x2F;&#x2F; render 函数</span><br><span class="line">            type: Function,</span><br><span class="line">            default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   定义一个 **index.js 方便父组件引用**

   **src/components/list/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import List from &#39;.&#x2F;list.vue&#39;</span><br><span class="line">export default List</span><br></pre></td></tr></table></figure>

   在上面的组件中使用到了 **函数式组件** ，这里写的 **函数式组件** 就是使用 **reder函数 自定义一些想要的标签** 然后 **return** 返回一个 **虚拟节点** ， **最终渲染在使用函数式组件的地方** ，**函数式组件详解看下方的文档介绍**。

   **src/components/render-dom.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        name: String, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 函数式组件

**函数式组件** ： **只给它传入数据，它不做任何响应式的操作， 不监听传递给它的状态** ，这个组件 **没有生命周期和钩子函数**，它 **只是作为一个接收参数的函数** ， 当 **functional 设置为 true** 时候，证明 **它是一个没有状态的组件，也没有实例，就是一个对象** ， 当 **把这个对象引入到其他页面，当做一个组件去使用的时候，vue会把它做一个处理，会把 【render函数】里面逻辑返回的【虚拟节点】做一个渲染** 。

**src/components/render-dom.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        name: String, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## JSX

**JSX** ：**JSX** 最先是 **react** 提出的， **通过一种形式，在 js 里面写 html 标签，还有一些特定的语法** ，最后会把这个 **字符串** 转译成 **js** ，去用 **render函数** 来做渲染。

### JSX渲染标签字符串

1. **父组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, name)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * render函数方式</span><br><span class="line">             *&#x2F;</span><br><span class="line">            &#x2F;&#x2F; return h(&#39;i&#39;, &#123;</span><br><span class="line">            &#x2F;&#x2F;     style: &#123;</span><br><span class="line">            &#x2F;&#x2F;         color: &#39;pink&#39;</span><br><span class="line">            &#x2F;&#x2F;     &#125;</span><br><span class="line">            &#x2F;&#x2F; &#125;, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * JSX方式</span><br><span class="line">             * JSX与template模板对比</span><br><span class="line">             *   style:</span><br><span class="line">             *      template的标签中写法:style&#x3D;&quot;&#123; color: &#39;pink&#39; &#125;&quot;</span><br><span class="line">             *      JSX写法:style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;</span><br><span class="line">             *      JSX中style不需要添加双引号，属性都需要用&#123;&#125;包裹</span><br><span class="line">             * </span><br><span class="line">             *   事件:</span><br><span class="line">             *      template的标签中写法v-click&#x3D;&quot;handleClick&quot; 或者 @click&#x3D;&quot;handleClick&quot;</span><br><span class="line">             *      JSX写法on-click&#x3D;&#123; this.handleClick &#125;</span><br><span class="line">             *&#x2F;</span><br><span class="line">            return (</span><br><span class="line">                &lt;i on-click&#x3D;&#123; this.handleClick &#125; style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;&gt;&#123; name &#125;&lt;&#x2F;i&gt; </span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        handleClick(event)&#123;</span><br><span class="line">            console.log(event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   使用 **JSX** 时 **render函数** 的 **形参必须是 h** ，不可以改成其他的（例如 **createElement**）。以上代码中引入的 **List组件** 在上面的 **render函数** 文档中有写过，在此处就不再过多陈述。

### JSX渲染组件

1. **父组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line">import CountTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入组件</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123; number: 100 &#125;,</span><br><span class="line">                &#123; number: 45 &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, number)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            return (</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 这里可以引入组件进行渲染，而且不用在components对象中注册</span><br><span class="line">                 * 事件分为2种：原生事件、自定义事件</span><br><span class="line">                 *  html标签：支持原生事件</span><br><span class="line">                 *  组件：支持原生事件(给下面的CountTo组件绑定一个原生click事件,就相当于给组件内的最外层元素绑定了一个click事件，</span><br><span class="line">                 *  写法：nativeOn-事件名称&#x3D;&#123;方法&#125;)、</span><br><span class="line">                 *  自定义事件(写法：on-自定义事件名称&#x3D;&#123;方法&#125;)</span><br><span class="line">                 *  template模板中的事件修饰符在JSX跟render函数中用到需要看文档</span><br><span class="line">                 * *&#x2F; </span><br><span class="line">                &lt;CountTo nativeOn-click&#x3D;&#123;this.handleClick&#125; on-on-animation-end&#x3D;&#123;this.handleEnd&#125; endValue&#x3D;&#123;number&#125; style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;&gt;&lt;&#x2F;CountTo&gt; </span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        handleClick(event)&#123;</span><br><span class="line">            console.log(event)</span><br><span class="line">        &#125;,</span><br><span class="line">        handleEnd()&#123;</span><br><span class="line">            console.log(&#39;end!&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   父组件中引入的 **[CountTo组件](https://www.kancloud.cn/wangjiachong/vue_notes/1971966)**

2. **子组件**

   **src/components/list.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li @mousemove&#x3D;&quot;handleMove&quot; v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">          &lt;!-- 如果未传入render函数就span标签内容 --&gt;</span><br><span class="line">          &lt;span v-if&#x3D;&quot;!render&quot;&gt;&#123;&#123; item.number &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">          </span><br><span class="line">          &lt;!-- 如果传入了render函数，就使用render函数自定义dom的节点来渲染 --&gt;</span><br><span class="line">          &lt;render-dom v-else :render-func&#x3D;&quot;render&quot; :number&#x3D;&quot;item.number&quot;&gt;&lt;&#x2F;render-dom&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 引入函数式组件</span><br><span class="line">import RenderDom from &#39;_c&#x2F;render-dom&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        RenderDom &#x2F;&#x2F; 注册函数式组件</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;,</span><br><span class="line">        render: &#123; &#x2F;&#x2F; render 函数</span><br><span class="line">            type: Function,</span><br><span class="line">            default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleMove(event)&#123;</span><br><span class="line">            &#x2F;&#x2F; 阻止默认行为（文字不可以选中复制）</span><br><span class="line">            event.preventDefault()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   **list组件** 对应的 **index.js**，用于 **父组件方便引用**

   **src/components/list/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import List from &#39;.&#x2F;list.vue&#39;</span><br><span class="line">export default List</span><br></pre></td></tr></table></figure>

   **子组件** 中用到的 **函数式组件 render-dom.js**

   **src/components/render-dom.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        number: Number, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.number)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 作用域插槽

**定制组件内的元素以及内容** ，用 **render函数** 以及 **JSX** 都比较繁琐，接下来用 **作用域插槽** 来实现这个需求。

1. **父组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot;&gt;</span><br><span class="line">            &lt;h3 slot&#x3D;&quot;aa&quot;&gt;我是小明&lt;&#x2F;h3&gt;</span><br><span class="line">            &lt;coun-to slot-scope&#x3D;&quot;count&quot; :end-value&#x3D;&quot;count.number&quot;&gt;&lt;&#x2F;coun-to&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line">import CounTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入组件</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123; number: 100 &#125;,</span><br><span class="line">                &#123; number: 45 &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List,</span><br><span class="line">        CounTo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

2. **子组件**

   **src/components/list.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">            &lt;!-- 默认插槽 --&gt;</span><br><span class="line">            &lt;!-- &lt;slot&gt;&lt;&#x2F;slot&gt; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &lt;!-- 具名插槽 --&gt;</span><br><span class="line">            &lt;slot name&#x3D;&quot;aa&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        </span><br><span class="line">            &lt;!-- 作用域插槽 --&gt;</span><br><span class="line">            &lt;slot :number&#x3D;&quot;item.number&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

3. **插槽总结**

   3.1 **匿名插槽** 应用场景：**组件内** 只需要一个 **插槽** 的情况，可以使用 **匿名插槽** 。

   3.2 **具名插槽** 应用场景：**组件内** 需要多个 **插槽** 的情况，可以使用 **具名插槽** 。

   3.3 **作用域插槽**应用场景：**父组件插槽插入的内容中** 使用到了 **组件内的数据** 。



# render: h => h(App)

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//createElement就是h,一个形参，没有具体意义，可以随意改变书写</span></span><br><span class="line">render:(<span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(App);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

render是一个方法，自带一个形参createElement，这个参数也是一个方法，是用来创建vue 节点的，也就是html模板的，然后渲染(render)到指定的节点上



# VUE的配置



# VUE的路由：Vue Router

vue-router中经常会操作的两个对象route和router两个

## $route对象

表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等

**1.**  **$route.path**   字符串，对应当前路由的路径，总是解析为绝对路径，如"/foo/bar"。

  **2.**  **$route.params**   一个 key/value 对象，包含了 动态片段 和 全匹配片段，   如果没有路由参数，就是一个空对象。

  **3.**  **$route.query**   一个 key/value 对象，表示 URL 查询参数。   例如，对于路径 /foo?user=1，则有$route.query.user == 1，   如果没有查询参数，则是个空对象。

  **4.**  **$route.hash**   当前路由的hash值 (不带#) ，如果没有 hash 值，则为空字符串。锚点*

  **5.**  **$route.fullPath**   完成解析后的 URL，包含查询参数和hash的完整路径。

  **6.**  **$route.matched**   数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。

  **7.**  **$route.name**  当前路径名字

  **8.**  **$route.meta** 路由元信息

  导航钩子的参数：

  router.beforeEach((to,from, next)=>{//to 和from都是 路由信息对象,后面使用路由的钩子函数就容易理解了})

## **$router对象**

$router对象是全局路由的实例，是router构造方法的实例

**路由实例方法：**

#### **1、push**

  1.字符串this.$router.push('home')

2. 对象this.$router.push({path:'home'})

3. 命名的路由this.$router.push({name:'user',params:{userId:123}}) 

  4.带查询参数，变成 /register?plan=123this.$router.push({path:'register',query:{plan:'123'}})

  push方法其实和`<router-link :to="...">`是等同的。

  注意：push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。

使用name，必须使用params，刷新页面，参数会丢失。而使用path，必须使用query，刷新页面不会丢失参数。

#### **2、go**

   页面路由跳转 

   前进或者后退this.$router.go(-1) // 后退

#### 3、replace

  push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，

  不会向 history 栈添加一个新的记录

#### 4.一般使用replace来做404页面

  this.$router.replace('/')

  配置路由时path有时候会加 '/' 有时候不加,以'/'开头的会被当作根路径，就不会一直嵌套之前的路径。

$router对象是全局路由的实例，是router构造方法的实例。



**Vue Router** 是 **Vue** 官方提供的 **路由管理器** ，可以进行 **路由跳转**，以及 **页面之间跳转时传值**，以及 **路由拦截** 等等操作



这里的路由并不是指我们平时所说的硬件路由器，**这里的路由就是SPA（单页应用）的路径管理器**。再通俗的说，vue-router就是[WebApp](https://coding.imooc.com/?c=webapp)的链接路径管理系统。
vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。**路由模块的本质 就是建立起url和页面之间的映射关系**。

至于我们为啥不能用a标签，这是因为用Vue做的都是单页应用（**当你的项目准备打包时，运行`npm run build`时，就会生成dist文件夹，这里面只有静态资源和一个index.html页面**），所以你写的`<a></a>`标签是不起作用的，你必须使用vue-router来进行管理。


实现原理

SPA(single page application):单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。**单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面**;vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。

#### 1、Hash模式：

**vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。** hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说**Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据**

vue Router的跳转问题，就是如果引入了vue-router，例如给一个这样的链接https:www.app/index.html，但是真正在浏览器中输入后执行的时候就变成了 https:www.app/index.html#/

引入了vue-router，引入vue-router后，再点开链接的时候，会自动加上#/，因为vue-router是根据锚点来进行定位的,也就是根据hash值来跳转的（单页面应用）。只要程序中引入了vue-router，跳转的时候会自动加上#/的

#### 2、History模式：

由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入"mode: 'history'",这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main.js文件中</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

当你使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，比较好看！
不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。
所以呢，**你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const routes &#x3D; [ </span><br><span class="line"> &#123;path: &quot;&#x2F;&quot;, name: &quot;homeLink&quot;, component:Home&#125;</span><br><span class="line"> &#123;path: &quot;&#x2F;register&quot;, name: &quot;registerLink&quot;, component: Register&#125;,</span><br><span class="line"> &#123;path: &quot;&#x2F;login&quot;, name: &quot;loginLink&quot;, component: Login&#125;,</span><br><span class="line"> &#123;path: &quot;*&quot;, redirect: &quot;&#x2F;&quot;&#125;]</span><br></pre></td></tr></table></figure>

此处就设置如果URL输入错误或者是URL 匹配不到任何静态资源，就自动跳到到Home页面

#### 3、使用路由模块来实现页面跳转的方式

方式1：直接修改地址栏

方式2：this.$router.push(‘路由地址’)

方式3：`<router-link to="路由地址"></router-link>`










一、验证用户身份

大部分项目，除了登录页、重置密码页、用户协议页以外，页面都需要验证用户身份进行访问。使用 Vue Router 可以配合后端进行双重验证

给需要验证的路由对象添加 meta 字段，里面自定义一个代表验证的字段

（登录）验证身份方法：

1、给需要验证的路由对象添加 meta 字段，里面自定义一个代表验证的字段：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">	  name:&#39;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#39;bar&#39;,</span><br><span class="line">          component: Bar,</span><br><span class="line">          meta: &#123; </span><br><span class="line">              requiresAuth: true &#x2F;&#x2F; 添加该字段，表示进入这个路由是需要登录的</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

2、在全局导航钩子里验证 requiresAuth 字段：

注意事项：

- 使用 beforeEach 在路由变化前验证。验证原理是在跳转前，访问目标路由对象的 requiresAuth 字段判断是否需要验证用户身份，如为是，检测是否有保存用户信息（即用户登录成功后前端保存的信息，例如 token）
- 每个路由都有一个 $route.matched 数组，包含当前路由的父级路由对象和当前路由对象，在组件中可以通过 this.$route.matched 访问
- beforeEach 的 to 参数即目标路由对象 $route，to.matched 即是它的路由数组
- 因此，使用 some 方法，只要路由数组里的任意路由对象需要验证身份，即进行验证
- 验证成功跳转正确页面；失败则跳到登录页，将目标地址附在 url 的 query 里，登录成功就跳转到目标地址

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  if (to.matched.some(record &#x3D;&gt; record.meta.requiresAuth)) &#123;</span><br><span class="line">    if (!auth.loggedIn()) &#123;  &#x2F;&#x2F; 没登录</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: &#39;&#x2F;login&#39;,</span><br><span class="line">        query: &#123; redirect: to.fullPath &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()  &#x2F;&#x2F; 确保一定要调用 next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next() &#x2F;&#x2F; 确保一定要调用 next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

3、拦截 http 请求，验证用户身份

为了防止本地保存的 token 过期，需要拦截 http 请求，为每次请求头加上 token ，然后拦截 http 响应，根据响应内容判断是否需要跳回登录页面重新登录。使用 axios 的方法如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; http request 拦截器</span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    config &#x3D;&gt; &#123;</span><br><span class="line">        if (auth.loggedIn()) &#123; &#x2F;&#x2F; 判断是否存在token，如果存在的话，则每个http header都加上token</span><br><span class="line">            config.headers.Authorization &#x3D; &#96;token $&#123;auth.loggedIn()&#125;&#96;;</span><br><span class="line">        &#125;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;,</span><br><span class="line">    err &#x3D;&gt; &#123;</span><br><span class="line">        return Promise.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http response 拦截器</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    response &#x3D;&gt; &#123;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;,</span><br><span class="line">    error &#x3D;&gt; &#123;</span><br><span class="line">        if (error.response) &#123;</span><br><span class="line">            switch (error.response.status) &#123;</span><br><span class="line">                case 401:</span><br><span class="line">                    &#x2F;&#x2F; Unauthorized</span><br><span class="line">                    &#x2F;&#x2F; 返回 401 清除token信息并跳转到登录页面</span><br><span class="line">                    auth.clear();</span><br><span class="line">                    router.replace(&#123;</span><br><span class="line">                        path: &#39;login&#39;,</span><br><span class="line">                        query: &#123;</span><br><span class="line">                            redirect: router.currentRoute.fullPath</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error.response.data) &#x2F;&#x2F; 返回接口返回的错误信息</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

二、定义用户权限能访问的页面

前端查看权限，也是配合后端进行某些页面的隐藏显示功能。一般应用于综合的办公系统，由 IT 部分配账号，不同部门的人只能看到自己负责的内容，例如行政部不会看到财务数据页面。

实现方法：

1. 与后端商定每个用户角色对应的 level 级别，以数值表示
2. 前端路由每个页面的 meta 对象添加 level 字段，值为数组，里面是有权限访问页面的 level 数值
3. 登录成功，后台返回用户 token 的同时，返回其所属的 level 字段
4. 组件代码比较目标页面的 level 与用户 level，只显示包含在目标 level 数组里的页面
5. 全局导航钩子 beforeEach 里比较目标页面的 level 与用户 level，包含在目标 level 数组里则正确跳转，反之取消跳转并提示权限不足

> 上面第5步是为了防止用户直接在浏览器输入目标地址

三、其他内容控制

可以控制显示路由固定的搭配，例如某个路由地址的 title 是固定的字符串、固定的欢迎语、固定的 favicon 等。在组件里通过 this.$route.meta.xxx 访问。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#39;bar&#39;,</span><br><span class="line">          component: Bar,</span><br><span class="line">          meta: &#123; </span><br><span class="line">              title: &#39;标题&#39;,</span><br><span class="line">              message: &#39;欢迎您&#39;,</span><br><span class="line">              requiresAuth: true &#x2F;&#x2F; 添加该字段，表示进入这个路由是需要登录的</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



动态路由匹配是用于把某种模式匹配到的所有路由，全都映射到同个组件。通过给路由路径一个变量，即变成动态路由，把变化的内容赋值给变量即可。

例如文章详情页是一个组件，只有一个路由，从文章列表页点进来，变化的只是文章 id 而已。将其赋予给设定的变量，然后通过在组件里 watch $route 或者使用 beforeRouteUpdate 导航守卫监测路由变化，传递新的文章 id 获取文章详情即可。在组件里，可以通过`this.$route.params.xx`获取当前文章 id。

一个路由地址可以设置多个变量，适合有分叉情况的内容。例如 path: '/params/:foo/:bar'

> 从文章列表页点进来即传递路由变量，有三种方法：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）&lt;router-link to&#x3D;&quot;&#x2F;params&#x2F;list&#x2F;1&quot;&gt;跳转到 &#x2F;params&#x2F;list&#x2F;1&lt;&#x2F;router-link&gt;&#96;</span><br><span class="line">（2）this.$router.push(&#123; name: &#39;articles&#39;, params: &#123; foo: &#39;list&#39;, bar: 1 &#125; &#125;)&#96;</span><br><span class="line">（3）this.$router.push(&#123; path: &#39;&#x2F;params&#x2F;list&#x2F;1&#39; &#125;) &#x2F;&#x2F; path 不能与 params 同时使用</span><br></pre></td></tr></table></figure>



高级匹配模式

这里主要研究的是动态路由匹配的高级匹配模式，以达到合并差异不大的路由、减少路由数量的目的。

高级匹配即结合简单的正则匹配方法，给予路由更多的限制和操作空间。

1、可选路由参数

路由参数可选，添加与否都对应同一个组件。可以在组件里使用 v-if / v-show 结合 $route.params.xx 展现不同的内容

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a param can be made optional by adding &quot;?&quot;</span><br><span class="line">&#123; path: &#39;&#x2F;optional-params&#x2F;:foo?&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个链接都对应同个组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-params&quot;&gt;&#x2F;optional-params&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-params&#x2F;foo&quot;&gt;&#x2F;optional-params&#x2F;foo&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

2、精确匹配参数

只有参数通过正则匹配，完全符合格式，才能会跳转。例如只有参数是数字/手机号才允许跳转。适用于对第三方不规范格式的数据进行筛选。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a param can be followed by a regex pattern in parens</span><br><span class="line">&#x2F;&#x2F; this route will only be matched if :id is all numbers</span><br><span class="line">&#123; path: &#39;&#x2F;params-with-regex&#x2F;:id(\\d+)&#39; &#125;</span><br><span class="line">&#x2F;&#x2F; 只匹配数字</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;params-with-regex&#x2F;123&quot;&gt;&#x2F;params-with-regex&#x2F;123&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只匹配手机号</span><br><span class="line">&#123; path: &#39;&#x2F;params-with-regex&#x2F;:id(^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$)&#39; &#125;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;params-with-regex&#x2F;13800138000&quot;&gt;&#x2F;params-with-regex&#x2F;13800138000&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

3、匹配任意参数

不对参数格式、数量进行限制，任意参数都可。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; asterisk can match anything</span><br><span class="line">&#123; path: &#39;&#x2F;asterisk&#x2F;*&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个都是同一组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;asterisk&#x2F;foo&quot;&gt;&#x2F;asterisk&#x2F;foo&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;asterisk&#x2F;foo&#x2F;bar&quot;&gt;&#x2F;asterisk&#x2F;foo&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

4、部分可选参数

结合可选路由参数与多路由参数，其中一部分参数可选。适用于分叉情况下不确定参数数量的情况。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; make part of the path optional by wrapping with parens and add &quot;?&quot;</span><br><span class="line">&#123; path: &#39;&#x2F;optional-group&#x2F;(foo&#x2F;)?bar&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个都是同一组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-group&#x2F;bar&quot;&gt;&#x2F;optional-group&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-group&#x2F;foo&#x2F;bar&quot;&gt;&#x2F;optional-group&#x2F;foo&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>





### 路由的跳转

1、router-link （声明式路由）

 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 不带参数</span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;&#125;&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;</span>&gt;</span> //name,path都行, 建议用name  </span><br><span class="line">   // 注意：router-link中链接如果是&#x27;/&#x27;开始就是从根路由开始，如果开始不带&#x27;/&#x27;，则从当前路由开始。</span><br><span class="line"></span><br><span class="line">2.带参数</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;, params: &#123;id:1&#125;&#125;&quot;</span>&gt;</span>  </span><br><span class="line">// params传参数 (类似post)</span><br><span class="line">// 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot; </span><br><span class="line">// 不配置path ,第一次可请求,刷新页面id会消失</span><br><span class="line">// 配置path,刷新页面id会保留</span><br><span class="line"></span><br><span class="line">// html 取参  $route.params.id</span><br><span class="line">// script 取参  this.$route.params.id</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;, query: &#123;id:1&#125;&#125;&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>

  

   2、router.push(编程式路由)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">router.push(&#39;home&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象</span><br><span class="line">router.push(&#123; path: &#39;home&#39; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命名的路由</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 带查询参数，变成 &#x2F;register?plan&#x3D;private</span><br><span class="line">router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</span><br></pre></td></tr></table></figure>

注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userId &#x3D; &#39;123&#39;</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">router.push(&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user</span><br></pre></td></tr></table></figure>

3、this.$router.push() (函数里面调用)

 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.  不带参数</span><br><span class="line"></span><br><span class="line">this.$router.push(&#39;&#x2F;home&#39;)</span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;&#125;)</span><br><span class="line">this.$router.push(&#123;path:&#39;&#x2F;home&#39;&#125;)</span><br><span class="line"></span><br><span class="line">2. query传参 </span><br><span class="line"></span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;)</span><br><span class="line">this.$router.push(&#123;path:&#39;&#x2F;home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; html 取参  $route.query.id</span><br><span class="line">&#x2F;&#x2F; script 取参  this.$route.query.id</span><br><span class="line"></span><br><span class="line">3. params传参</span><br><span class="line"></span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;,params: &#123;id:&#39;1&#39;&#125;&#125;)  &#x2F;&#x2F; 只能用 name</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 路由配置 path: &quot;&#x2F;home&#x2F;:id&quot; 或者 path: &quot;&#x2F;home:id&quot; ,</span><br><span class="line">&#x2F;&#x2F; 不配置path ,第一次可请求,刷新页面id会消失</span><br><span class="line">&#x2F;&#x2F; 配置path,刷新页面id会保留</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; html 取参  $route.params.id</span><br><span class="line">&#x2F;&#x2F; script 取参  this.$route.params.id</span><br><span class="line"></span><br><span class="line">4. query和params区别</span><br><span class="line">   query类似 get, 跳转之后页面 url后面会拼接参数,类似?id&#x3D;1, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在</span><br><span class="line"></span><br><span class="line">params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失</span><br></pre></td></tr></table></figure>

   

4. this.$router.replace() (用法同上,push)

5. this.$router.go(n) ()


  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$router.go(n)</span><br><span class="line">   向前或者向后跳转n个页面，n可为正整数或负整数</span><br></pre></td></tr></table></figure>

  

  ps : 区别

  this.$router.push
  跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面
  this.$router.replace
  跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)

  this.$router.go(n)
  向前或者向后跳转n个页面，n可为正整数或负整数

  

注意：获取路由上面的参数，用的是$route，后面没有r
params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。
params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。
params、query不设置也可以传参，但是params不设置的时候，刷新页面或者返回参数会丢失，

两者都可以传递参数，区别是什么？
query 传参配置的是path，而params传参配置的是name，在params中配置path无效
query在路由配置不需要设置参数，而params必须设置
query传递的参数会显示在地址栏中
params传参刷新会无效，但是query会保存传递过来的值，刷新不变



**Vue router的query对象里的值的问题**

在使用 $router.push() 时，如果使用了query，则可以在跳转后从query中获取到对应的参数。如果传的是字符串自然没问题，但是如果传的其他类型的数据，在跳转之后是正常的，而跳转之后再刷新一遍页面的话，query里面的属性的值都会变成字符串。例如：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123; name:&#39;product&#39;, query: &#123;canSee: false&#125; &#125;);</span><br></pre></td></tr></table></figure>

　　最初跳转之后，this.$route.query.canSee打印的值是Boolean类型的。然后刷新一下，值就变成了String类型了。个人猜测是因为刷新后query的值是直接从页面URL中取的，而在页面URL上的参数的类型只能是字符串类型。

**解决方法**：

　　1. 在传值之前把要传的参数单独放到一个对象里，在放到query里面，然后进行JSON.stringify()处理，到了目标页面后再进行JSON.parse()处理，还原对象。这种方法的好处是可以一次性处理多个参数，而且适用度高，建议使用这种方法。

　　2. 传值前不做处理，到了目标页面后再单独对原本为非字符串的数据进行JSON.parse()处理。缺点是字符串类型的数据不能如此处理，要确保该数据不是字符串类型的。局限性大，不推荐适用。



### vue项目中跳转到外部链接方法

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;goPage(&#x27;http://www.chao99.top&#x27;)&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    goPage (url) &#123;</span><br><span class="line">            window.location.href = url</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

如果用.push的路由跳转，会在路径外面再加一个基本的url导致出错，例如本地项目：会在外部链接前面加上了http://localhost:8080/#/

一定要注意, 外部链接要加上 http:// , 不然跳转还是当前域名下



## VUE的图片路径

一般都是通过相对路径取到图片然后加载

官方文档没有存放静态的asset 文件了 ,静态现在存放在public 的里面. 但是在public里面去创建一个img 的文件,去放置图片,依然不可以. 

所以 三种办法里面 只有require 使用vuecli3 ,

1、在模板中直接引入图片资源（这种一般是@ 或者./ 去引入）

2、将图片资源放在static文件夹下

3、图片资源在assets文件夹下，data中必须用require加载，否则会当成字符串来处理
(我自己目前就是放在assets 里面. 因为是本地上传的 在做假数据的时候准备做一个预览,或者说以后的默认图片就是它了)
第二种，只要给图片放在static文件夹下即可：原因如下

这里在使用vuecli脚手脚构建工具，目录下会生成一个static目录，表示的是静态目录，推荐大家将img 存放在这个目录下，那么在webpack编译以后，依旧是可以获取到这个目录下的路径，这样就解决了路径不符而导致图片加载不出来的问题！当然项目中用的一般都是绝对路径，少数图片的话，这种方式挺好
但是 重点: vuecli3 没有static 啊!!!



# VUE的模板语法

Vue 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。

Vue 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。

结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上



### 插值

#### 文本

数据绑定最常见的形式就是使用 `{ {...} }`（双大括号）的文本插值：

##### 文本插值

`<div id="app">   <p></p> </div>`

`{ {...} }` 标签的内容将会被替代为对应组件实例中 **message** 属性的值，如果 **message** 属性的值发生了改变，`{ {...} }` 标签内容也会更新。

如果不想改变标签的内容，可以通过使用 **v-once** 指令执行一次性地插值，当数据改变时，插值处的内容不会更新。

`<span v-once>这个将不会改变: { { message } }</span>`

##### Html

使用 v-html 指令用于输出 html 代码：

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v-html 指令</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用双大括号的文本插值: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用 v-html 指令: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> RenderHtmlApp = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      rawHtml: &#x27;<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>这里会显示红色！<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(RenderHtmlApp).mount(<span class="string">&#x27;#example1&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

##### 属性

HTML 属性中的值应使用 v-bind 指令。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

对于布尔属性，常规值为 true 或 false，如果属性值为 null 或 undefined，则该属性不会显示出来。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-bind:disabled&#x3D;&quot;isButtonDisabled&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

以上代码中如果 isButtonDisabled 的值是 null 或 undefined，则 disabled 属性甚至不会被包含在渲染出来的 `<button> `元素中。

以下实例判断 use 的值，如果为 true 使用 class1 类的样式，否则不使用该类：

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v-bind 指令</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;r1&quot;</span>&gt;</span>修改颜色<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;use&quot;</span> <span class="attr">id</span>=<span class="string">&quot;r1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123;&#x27;class1&#x27;: use&#125;&quot;</span>&gt;</span></span><br><span class="line">    v-bind:class 指令</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      use: <span class="literal">false</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(app).mount(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

##### 表达式

Vue.js 都提供了完全的 JavaScript 表达式支持。

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 表达式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;5+5&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span>菜鸟教程<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> HelloVueApp = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      ok: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;RUNOOB!!&#x27;</span>,</span></span><br><span class="line">      id: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(HelloVueApp).mount(<span class="string">&#x27;#hello-vue&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  这是语句，不是表达式：--&gt;</span><br><span class="line">&#123;&#123; var a &#x3D; 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>

### 指令

指令是带有 v- 前缀的特殊属性。

指令用于在表达式的值改变时，将某些行为应用到 DOM 上。如下例子：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-if&#x3D;&quot;seen&quot;&gt;现在你看到我了&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      seen: true  &#x2F;* 改为false，信息就无法显示 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

这里， v-if 指令将根据表达式 seen 的值( true 或 false )来决定是否插入 p 元素。

另外还有其它很多指令，每个都有特殊的功能。例如，v-for 指令可以绑定数组的数据来渲染一个项目列表：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;ol&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;site in sites&quot;&gt;</span><br><span class="line">      &#123;&#123; site.text &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      sites: [</span><br><span class="line">        &#123; text: &#39;Google&#39; &#125;,</span><br><span class="line">        &#123; text: &#39;Runoob&#39; &#125;,</span><br><span class="line">        &#123; text: &#39;Taobao&#39; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

##### 参数

参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;菜鸟教程&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const HelloVueApp &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      url: &#39;https:&#x2F;&#x2F;www.runoob.com&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(HelloVueApp).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。

另一个例子是 v-on 指令，它用于监听 DOM 事件：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a @[event]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

在这里参数是监听的事件名。

##### 修饰符

修饰符是以半角句号 **.** 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，**.prevent** 修饰符告诉 **v-on** 指令对于触发的事件调用 **event.preventDefault()**：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

### 用户输入

在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">双向数据绑定</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Runoob!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

**v-model** 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。

按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。

以下实例在用户点击按钮后对字符串进行反转操作：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">字符串反转</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;&#x2F;title&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue@next&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;reverseMessage&quot;&gt;反转字符串&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Runoob!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage() &#123;</span><br><span class="line">      this.message &#x3D; this.message</span><br><span class="line">        .split(&#39;&#39;)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

### 缩写

#### v-bind 缩写

Vue.js 为两个最为常用的指令提供了特别的缩写：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

#### v-on 缩写

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

# VUE的条件语句



# VUE的循环语句



# VUE的组件



# VUE的计算属性



# VUE的监听属性



# VUE的样式绑定



# VUE的事件处理

### VUE的方法

方法名: async function () {}

async 方法名() {}



# VUE中用到的一些关键字

### let、var和const

ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。

1. var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。可以修改，如果不初始化会输出undefined，不会报错
2. let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不可在声明之前调用，必须先定义再使用，否则会报错。不能定义同名变量。
3. const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。

**let和const属于局部变量，不会出现变量提升的情况，全局定义的let和const变量，不属于顶层变量，不属于window的属性**。let和const不允许重复声明，let和const不会绑定全局作用域

变量提升：可以在变量定义前使用定义过的变量。

暂时性死区（TDZ）：在运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。常见于：let、const、import、class、typeof等

**let和const定义的变量都会被提升，但是不会被初始化，不能被引用**



### fullPath和path

- $route.fullPath

  - type: `string`
    The full resolved URL including query and hash.

- $route.path

  - type: `string`
    A string that equals the path of the current route, always resolved as an absolute path. e.g. “/foo/bar”.

fullPath能缓存路由跳转后面携带的参数，刷新后依旧存在， 在PC端能起作用

而 path则不能缓存路由跳转后面携带的参数，所以path  能在`只有两层数据结构的`移动端起作用
   原因：

一般，移动端App 只能往里面走，表面和切换的页面是第一层， 点击功能按钮进去的是第二层。
这种层级的关系其实 是具有跳转作用，所以在第一层获取的数据，与第二层来回切换没问题。但是你第二层到第三层一来回切换，路由跳转携带的参数就丢失了。

fullPath匹配路由，path匹配路径。

例如：

路由是：`/path/one`
真正路径是：`/path/true`

那么此时path为`/path/true`，而fullPath为`/path/one`



### this和that

在Vue中this始终指向Vue，但axios中this为undefined

![这里写图片描述](https://img-blog.csdn.net/20171102210352732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzgyMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

若需要赋值给变量用以渲染数据，可以通过=>函数，这时this为Vue

![这里写图片描述](https://img-blog.csdn.net/20171102210527538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzgyMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

或者可以直接通过： 
let that = this 
将this保存在that中，再在函数中使用that均可 



个人理解：一般情况下，this就是此vue的页面，可以调用此页面的函数。但是涉及到异步axios时，this没有指向了。需要（）=>{}，在{}里this才会指代vue。

如果不使用（）=>{}方法，可以进行双向绑定：let that = this  ，将this保存在that中，再在函数中使用that均就可以了



async和await分别表示异步和等待，语义更加明确



解决异步调用：从最早的回调函数，到 Promise 对象，再到 Generator 函数，再到async





### return

return不论是什么，都是直接返回，即使是语句或者函数也不会执行的！是函数就返回该函数！

下面从一个例子来加深对return用法的理解：

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(‘xxxx’)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; <span class="keyword">return</span> res.data.result.info &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在axios和ajax中经常会用到return，从上面的代码可以看到有两个return，每个return的作用都需要理解：

第一个return后面跟的是axios配置，这个return就是将整个axios返回出来；

第二个return是在axios请求成功后将响应数据返回出来，即第二个return就是将axios异步请求的数据返回出来。



函数中有ajax和axios调用的有异步和同步，是异步的话里面如果有return，在函数外层（函数是指getTable()）调用的时候会取不到数据，除非换成同步。如果想异步取到数据，就需要在函数外层也加个return，相当于把ajax或者axios 整个配置返回出来，返回出来的数据格式是[object,promise]，所以函数执行获得的数据格式就是[object,promise]，然后使用.then()的形式将里面返回的数据拿出来!

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> getTable().then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="built_in">this</span>.tableData = res&#125;) <span class="comment">//此出先调用getTable()拿到axios的数据，然后在.then()出来结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

此段代码的目的是将axios异步请求的结果返回出来，因为是异步所以不能直接在axios里return数据，所以需要在axios外层也加个return，这样就可以拿到了。









### set：this.$set

由于JavaScript的限制，Vue不能检测以下变动的数组,页面不会刷新：

1.当你利用索引值直接设置一个项时。`vm.items[indexOfItem]=newValue`

2.当你修改数组的长度时。`vm.items.length=newLength`

使用Vue.set、vm.$set()或者数组的splice方法。使数值改变后，页面进行刷新后的效果展示

注：$set()方法调用时，页面会全部更新一遍



# VUE定义全局变量

在项目中，经常会复用一些变量和函数，比如用户的登录token，用户信息等。这时需要将它们设为全局，全局变量和全局函数之间有一些相通之处。

## 定义全局变量

原理：使用模块（.js或.vue文件）来管理全局变量，最后使用`export`暴露出去 （最好导出的格式为对象，方便在其他地方调用），当其它地方需要使用时，用`import`导入该模块

1、使用全局变量专用模块，挂载到main.js文件上面

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">全局变量模块Global.vue定义如下：</span><br><span class="line"><span class="keyword">const</span> token=<span class="string">&#x27;12345678&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> userStatus=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    token, <span class="comment">// 用户token身份</span></span><br><span class="line">    userStatus <span class="comment">// 用户登录状态</span></span><br><span class="line">&#125;</span><br><span class="line">模块里的变量用<span class="keyword">export</span>暴露出去，当其它地方需要使用时，引入模块便可。</span><br><span class="line"></span><br><span class="line">使用全局变量：</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">global</span> <span class="keyword">from</span> <span class="string">&#x27;../../components/Global&#x27;</span><span class="comment">//引用模块进来</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">         token:<span class="built_in">global</span>.token,<span class="comment">//将全局变量赋值到data里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2、全局变量模块挂载到Vue.prototype上

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Global.vue文件同上，在项目入口的main.js里配置：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">global</span> <span class="keyword">from</span> <span class="string">&#x27;../../components/Global&#x27;</span></span><br><span class="line">Vue.prototype.GLOBAL = <span class="built_in">global</span></span><br><span class="line">挂载之后，在需要引用全局变量的模块处，不需再导入全局变量模块，而是直接用<span class="built_in">this</span>就可以引用了，如下:</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">     token: <span class="built_in">this</span>.GLOBAL.token,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

方法一跟方法二的主要区别是，方法二全局只需要导入一次就可以，简单方便。

3、使用vuex定义全局变量

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态。因此可以存放着全局量。</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js文件里定义vuex</span></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// state.js里面存放全局变量，并且暴露出去</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  token：<span class="string">&#x27;12345678&#x27;</span>,</span><br><span class="line">  language: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> state</span><br><span class="line"></span><br><span class="line">使用的时候，在需要引用全局变量的模块处直接使用<span class="built_in">this</span>.$store调用</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">getInternation</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$store.state.language === <span class="string">&#x27;en&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.internation = <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.$store.state.language === <span class="string">&#x27;zh_CN&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.internation = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

因为Vuex有点繁琐，有点杀鸡用牛刀的感觉。因此认为并没有必要使用它。

## 定义全局函数

原理：在main.js里面通过Vue.prototype将函数挂载到Vue实例上面，通过this.函数名，来运行函数。

1、在main.js文件直接定义方法

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">简单的函数可以直接写在main.js文件里定义。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将方法挂载到vue原型上</span></span><br><span class="line">Vue.prototype.changeData = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;执行成功&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用的时候组件里直接调用。</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接通过this运行函数，这里this是vue实例对象</span></span><br><span class="line"><span class="built_in">this</span>.changeData();</span><br></pre></td></tr></table></figure>

2、使用全局函数专用模块，挂载到main.js上面

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">base.js文件，文件位置可以放在跟main.js同一级，方便引用（这点可以依据个人习惯决定）。</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">    Vue.prototype.changeData = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;执行成功&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main.js引入并使用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base <span class="keyword">from</span> <span class="string">&#x27;./base&#x27;</span></span><br><span class="line">Vue.use(base);</span><br><span class="line">所有的组件里就可以调用该函数。</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.changeData();</span><br></pre></td></tr></table></figure>



# VUE的生命周期

生命周期：

​    beforecreate : 一般使用场景是在加 loading事件 的时候
​    created ：处于loading结束后，还做一些初始化，实现函数自执行（data数据已经初始化，但是DOM结构渲染完成，组件没有加载）
​    beforemount：处于组件创建完成，但未开始执行操作
​    mounted (安装)：处于发起后端请求，获取数据，配合路由钩子执行操作（DOM渲染完成，组件挂载完成 ）
​    beforeupdate、updated：处于数据更新的前后
​    beforeDestroy：当前组件还在的时候，想删除组件
​    destroyed ：当前组件已被销毁，清空相关内容

![clipboard.png](8.6.VUE/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVjlSR1A_dz0xMjAwJmg9MzAzOQ)

created 与 mounted 的区别

created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

mounted 与 methods 的区别

mounted 是生命周期方法之一，会在对应生命周期时执行。

methods 是Vue实例对象上绑定的方法，供当前Vue组件作用域内使用，未调用不会执行，只执行逻辑，返回值可有可无。

computed 与 watched 的区别

computed 是计算属性，也可以理解为一个方法。其中计算的结果如果不发生改变就不会触发，且必须返回一个值并在DOM中绑定的才能取得值。他可以自动获取数据的改变。

watched 属性是手动定义的所需监听的值，不同的数据可以在其中多次定义监听值，这时会消耗一定性能，他并不能像computed那样自动改变。



activated 生命周期在keep-alive 组件激活时调用（在挂载后和更新前被调用的）。被`<keep-alive>`包裹的组件其会被缓存

服务器端渲染期间不调用该生命周期

通常和deactivated周期一起使用

`<keep-alive>`包裹动态组件的时候，会缓存不活动的组件实例，而不是摧毁他们。其是一个抽象的组件，自身不会渲染一个DOM元素，也不会出现在父组件链中。

activated()函数就是一个页面激活后的钩子函数，一进入页面就触发；

所以当我们运用了组件缓存时，如果想每次切换都发送一次请求的话，需要把请求函数写在activated中，而写在created或mounted中其只会在首次加载该组件的时候起作用

按自己的话说：actived相当于是一个缓存，当为false的时候，相当于没有actived，不会起任何作用。当为true时，第一次加载时会执行created，mounted，actived函数，当之后再执行的时候，不会执行created，mounted，只会执行actived

keep-alive组件除了actived，还有deactived函数钩子：

actived是keep-alive组件激活时使用

deactived是keep-alive组件停用时调用

使用：

1.在router中设置需要缓存的组件

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meta: &#123;</span><br><span class="line">        keepAlive : true </span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

2.`<keep-alive>`包裹需要缓存组件

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--app.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;!--需要缓存组件--&gt;</span><br><span class="line">        &lt;keep-alive&gt;</span><br><span class="line">            &lt;!--router-view组件是一个 functional 组件，渲染路径匹配到的视图组件--&gt;</span><br><span class="line">          &lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">        &lt;&#x2F;keep-alive&gt;</span><br><span class="line">        &lt;!--不需要缓存组件--&gt;</span><br><span class="line">        &lt;router-view v-if&#x3D;&quot;!$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">        &lt;moduleFooter&gt;&lt;&#x2F;moduleFooter&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

3.vue页面使用：第一次进入，钩子的触发顺序created-> mounted-> activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated
4.还可以动态控制是否缓存组件，代码如下：

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 设置下一个路由的 meta</span></span><br><span class="line">  to.meta.keepAlive = <span class="literal">false</span>; <span class="comment">// 不缓存，即刷新</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



# `==`和`===`的区别

1`==`'1';这个等式是成立的；
1`===`'1';这个等式是不成立的。
`==`只判断数值，`===`既判断数值，也判断类型。



# 对象的拷贝

Object.assign()对象的拷贝

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span><br><span class="line">Object.assign(target, ...sources)    【target：目标对象】，【souce：源对象（可多个）】</span><br><span class="line">举个栗子：</span><br><span class="line">const object1 &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 &#x3D; Object.assign(&#123;c: 4, d: 5&#125;, object1);</span><br><span class="line"></span><br><span class="line">console.log(object2.c, object2.d);</span><br><span class="line">console.log(object1)  &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(object2)  &#x2F;&#x2F; &#123; c: 3, d: 5, a: 1, b: 2 &#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性</span><br><span class="line">2.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标</span><br><span class="line">对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如</span><br><span class="line">果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到</span><br><span class="line">原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</span><br></pre></td></tr></table></figure>

Object.assign()对象的深拷贝

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。</span><br><span class="line">let obj1 &#x3D; &#123; a: 0 , b: &#123; c: 0&#125;&#125;; </span><br><span class="line">let obj2 &#x3D; Object.assign(&#123;&#125;, obj1); </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 0, b: &#123; c: 0&#125;&#125; </span><br><span class="line"></span><br><span class="line">obj1.a &#x3D; 1; </span><br><span class="line">console.log(JSON.stringify(obj1)); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 0&#125;&#125; </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 0, b: &#123; c: 0&#125;&#125; </span><br><span class="line"></span><br><span class="line">obj2.a &#x3D; 2; </span><br><span class="line">console.log(JSON.stringify(obj1)); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 0&#125;&#125; </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 2, b: &#123; c: 0&#125;&#125;</span><br><span class="line"> </span><br><span class="line">obj2.b.c &#x3D; 3; </span><br><span class="line">console.log(JSON.stringify(obj1)); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 3&#125;&#125; </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 2, b: &#123; c: 3&#125;&#125; </span><br><span class="line">最后一次赋值的时候，b是值是对象的引用，只要修改任意一个，其他的也会受影响</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deep Clone （深拷贝）</span><br><span class="line">obj1 &#x3D; &#123; a: 0 , b: &#123; c: 0&#125;&#125;; </span><br><span class="line">let obj3 &#x3D; JSON.parse(JSON.stringify(obj1)); </span><br><span class="line">obj1.a &#x3D; 4; </span><br><span class="line">obj1.b.c &#x3D; 4; </span><br><span class="line">console.log(JSON.stringify(obj3)); &#x2F;&#x2F; &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br></pre></td></tr></table></figure>

对象的合并

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const o1 &#x3D; &#123; a: 1 &#125;;</span><br><span class="line">const o2 &#x3D; &#123; b: 2 &#125;;</span><br><span class="line">const o3 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Object.assign(o1, o2, o3);</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(o1);  &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span><br><span class="line">其实就是对象的拷贝，o1就是目标对象，后面的是源对象，后面的属性等会拷贝到目标对象</span><br></pre></td></tr></table></figure>

合并具有相同属性的对象

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const o1 &#x3D; &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class="line">const o2 &#x3D; &#123; b: 2, c: 2 &#125;;</span><br><span class="line">const o3 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Object.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">1.属性被后续参数中具有相同属性的其他对象覆盖。</span><br><span class="line">2.目标对象的属性与源对象的属性相同，源的会覆盖目标的属性</span><br></pre></td></tr></table></figure>

继承属性和不可枚举属性是不能拷贝

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; Object.create(&#123;foo: 1&#125;, &#123; &#x2F;&#x2F; foo 是个继承属性。</span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: 2  &#x2F;&#x2F; bar 是个不可枚举属性。</span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        enumerable: true  &#x2F;&#x2F; baz 是个自身可枚举属性。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">创建对象时，如果没有设置enumerable的值，默认为false（不可枚举属性），设置为true，则为可枚举属性</span><br><span class="line">const copy &#x3D; Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); &#x2F;&#x2F; &#123; baz: 3 &#125;</span><br></pre></td></tr></table></figure>

原始类型会被包装为对象

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const v1 &#x3D; &quot;abc&quot;;</span><br><span class="line">const v2 &#x3D; true;</span><br><span class="line">const v3 &#x3D; 10;</span><br><span class="line">const v4 &#x3D; Symbol(&quot;foo&quot;)</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); </span><br><span class="line">&#x2F;&#x2F; 原始类型会被包装，null 和 undefined 会被忽略。</span><br><span class="line">&#x2F;&#x2F; 注意，只有字符串的包装对象才可能有自身可枚举属性。</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure>

异常会打断后续拷贝任务

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    writable: false</span><br><span class="line">&#125;); &#x2F;&#x2F; target 的 foo 属性是个只读属性。</span><br><span class="line"></span><br><span class="line">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class="line">&#x2F;&#x2F; TypeError: &quot;foo&quot; is read-only</span><br><span class="line">&#x2F;&#x2F; 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class="line"></span><br><span class="line">console.log(target.bar);  &#x2F;&#x2F; 2，说明第一个源对象拷贝成功了。</span><br><span class="line">console.log(target.foo2); &#x2F;&#x2F; 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class="line">console.log(target.foo);  &#x2F;&#x2F; 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class="line">console.log(target.foo3); &#x2F;&#x2F; undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class="line">console.log(target.baz);  &#x2F;&#x2F; undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure>



# rules方法

用于前端校验数据，校验表单，可以用rules模块





# 关于VUE的data里的数据问题

Vue 不允许在已经创建的实例上动态添加新的根级响应式属性。也就是说创建过后，data中不允许添加根数据

## 1. 对对象处理

- Vue可以检测到对象属性的修改，不能检测到对象属性的添加和删除，也就是说这种方式处理后，vue不能检察到数据变化，不能进行渲染更新，Vue可以使用Vue.set 和 Vue.delete实现

1. **Vue.set**
   Vue.set 方法用于设置对象的属性，它可以解决 Vue 无法检测添加属性的限制，语法格式如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set( target, key, value )</span><br></pre></td></tr></table></figure>

1. **Vue.delete**
   Vue.delete 用于删除动态添加的属性 语法格式：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.delete( target, key )</span><br></pre></td></tr></table></figure>

## 2. 对数组的处理

- vue中的被包装的观察数组能够触发视图更新
- 有push(),pop(),shift(),unshift(),splice(),sort(),reverse()
- 不能检测到下面数组变化：
  1）直接用索引设置属性，如 vm.item[0] = { }
  2）修改数组长度，如vm.items.length = 0
- 用$set
  Vue 包含一组观察数组的变异方法，它们将会触发视图更新，包含以下方法：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">push() 接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度</span><br><span class="line">pop() 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项</span><br><span class="line">shift() 移除数组中的第一个项并返回该项，同时数组的长度减1</span><br><span class="line">unshift() 在数组前端添加任意个项并返回新数组长度</span><br><span class="line">splice() 删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员</span><br><span class="line">sort() 调用每个数组项的toString()方法，然后比较得到的字符串排序，返回经过排序之后的数组</span><br><span class="line">reverse() 用于反转数组的顺序，返回经过排序之后的数组</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123;message: &#39;Foo&#39; &#125;,</span><br><span class="line">      &#123;message: &#39;Bar&#39; &#125;,</span><br><span class="line">      &#123;message: &#39;Baz&#39; &#125;</span><br><span class="line">    ],</span><br><span class="line">    addValue:&#123;message:&#39;zyb&#39;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    push()&#123;</span><br><span class="line">      this.items.push(this.addValue)</span><br><span class="line">    &#125;,</span><br><span class="line">    pop()&#123;</span><br><span class="line">      this.items.pop()</span><br><span class="line">    &#125;,</span><br><span class="line">    shift()&#123;</span><br><span class="line">      this.items.shift()</span><br><span class="line">    &#125;,</span><br><span class="line">    unshift()&#123;</span><br><span class="line">      this.items.unshift(this.addValue)</span><br><span class="line">    &#125;,</span><br><span class="line">    splice()&#123;</span><br><span class="line">      this.items.splice(0,1)</span><br><span class="line">    &#125;,</span><br><span class="line">    sort()&#123;</span><br><span class="line">     this.items.sort()</span><br><span class="line">    &#125;,</span><br><span class="line">    reverse()&#123;</span><br><span class="line">      this.items.reverse()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

### 变异方法与非变异方法

变异方法(mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异(non-mutating method)方法，例如：map(), filter(), concat(), slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组。同样页面会重新渲染
以下两种方式都可以实现和vm.items[indexOfItem]=newValue相同的效果， 同时也将触发状态更新

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">concat() 先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</span><br><span class="line">slice() 基于当前数组中一个或多个项创建一个新数组，接受一个或两个参数，即要返回项的起始和结束位置，最后返回新数组。</span><br><span class="line">map() 对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组、</span><br><span class="line">filter() 对数组中的每一项运行给定函数，该函数会返回true的项组成的数组</span><br></pre></td></tr></table></figure>

## 3.注意

$set()方法更新时，页面会全部更新一遍，包括其他数据
某个数据更新，会更新渲染所有数据



# 刷新页面

1、this.$router.go(0)

这种方法页面会一瞬间的白屏，体验不是很好，虽然只是一行代码的事

2、location.reload()

这种也是一样，画面一闪，效果总不是很好

3、跳转空白页再跳回原页面

在需要页面刷新的地方写上：this.$router.push('/emptyPage')，跳转到一个空白页。在emptyPage.vue里beforeRouteEnter 钩子里控制页面跳转，从而达到刷新的效果

beforeRouteEnter (to, from, next) {
   next(vm => {
    vm.$router.replace(from.path)
   })
}。

这种画面虽不会一闪，但是能看见路由快速变化。

4、控制`<router-view>`的显示隐藏

默认`<router-view v-if="isRouterAlive" />`isRouterAlive肯定是true，在需要刷新的时候把这个值设为false，接着再重新设为true：

this.isRouterAlive = false
this.$nextTick(function () {
 this.isRouterAlive = true
})
这种方法从画面上是看不出破绽的。也可以搭配provide、inject使用。例如：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;router-view v-if&#x3D;&quot;isRouterAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"> &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">  name: &#39;app&#39;,</span><br><span class="line">  provide()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      reload:this.reload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      isRouterAlive:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    reload()&#123;</span><br><span class="line">      this.isRouterAlive &#x3D;false;</span><br><span class="line">      this.$nextTick(function()&#123;</span><br><span class="line">        this.isRouterAlive&#x3D;true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>


然后在需要刷新的页面引入依赖：inject: ['reload'],

在需要执行的地方直接调用方法即可：this.reload()。

我的业务需求是在home里，页面右上角，在我的里面点击修改个人资料成功后，页面1就要刷新一下，如果是在app里面搭配provide、inject这样用的话，会出现一个问题，就是所有的弹窗以及menu部分就都不见了。还没有找到为什么，，

后来发现，我的需求不通过刷新页面也可以解决，就是利用VUE组件通信，监听事件发生，然后重新调一下获取数据的接口就行。

也就是说：

1、给Vue的原型上添加一个bus属性

main.js：Vue.prototype.$bus = new Vue()

2、home页面进行修改个人资料操作时触发事件，

home.vue： changeProfile （） {this.$bus.$emit('change')}

3、页面1里监听如果执行了操作，就调取页面1需要重新加载的数据接口。

mounted () {
 this.$bus.$on('change', ()=> {
  this.doSomething()
 })
},
对于我的需求来说，页面刷新的第四种方法和利用组件通信都能解决我的问题，前者更简单后者更专业，也更强大




# VUE项目的运行

1.先加载依赖包：控制台直接输入` npm install`

也可以webstorm软件进去右下角会出现一个` npm install`，直接点击

install的意思是安装前端用到的依赖包，运行之后，会生成一个node_modules文件。

2.本地运行项目可以控制台执行命令: `npm run serve`代表执行本地运行项目，此时运行的端口号默认为8080，后端的接口配置为.env.development（测试环境）文件下的端口号。

也可以使用webstorm自带的工具：右上角选“+”，找到npm，在npm的edit界面：Command设置为`run`，Scripts为 ` serve`，（记得选当前文件的package.json）默认端口号为8080，也可以在Environment里自己写，port=XXXX（端口号自己随便设置）

![image-20210412195648588](C:\Users\swx\AppData\Roaming\Typora\typora-user-images\image-20210412195648588.png)

运行后出现localhost：8080一般就成功了。

3.打包时控制台输入命令：`npm run build`，代表打包，完成后会生成一个dist文件夹，就是打包后的项目，部署到服务器即发布成功。build会执行.env.production（生产环境）下的配置

dist文件夹：

css文件夹下的.css文件是项目要用到的css文件,当你做webpack打包的时候，会把所有的css样式打包到这里
css文件夹下的.css.map文件是一个Source map文件，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。目的是帮助我们调试被压缩过的css代码，只是方便我们开发的时候做调试使用。
js文件夹下的.js.map依然是Source map文件，方便我们开发时调试js代码使用。
app.js文件里放的是项目中各个页面的逻辑代码
manifest.js文件可以理解为webpack打包生成的一个配置文件，我们一般不需要关心它
vendor.js放的是各个页面各个组件公用的一些代码
index.html使我们前端代码入口的一个html文件




      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/8.6.VUE/" data-id="ckw61se0i007moswd8pw112z0" data-title="VUE" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2.1.Typora使用快捷键" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/2.1.Typora%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:04:13.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/2.1.Typora%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/">Typora使用快捷键</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#+空格</td>
<td align="left">标题（几个#就是几级标题）</td>
</tr>
<tr>
<td align="left">ctrl+数字</td>
<td align="left">数字是几就是几级标题</td>
</tr>
<tr>
<td align="left">```+代码格式英文</td>
<td align="left">相应的代码块</td>
</tr>
<tr>
<td align="left">Ctrl+Shift+K</td>
<td align="left">插入代码块(```xxx)</td>
</tr>
<tr>
<td align="left">左下角启用源代码格式</td>
<td align="left">加```可以修改代码块的位置</td>
</tr>
<tr>
<td align="left">Ctrl + /</td>
<td align="left">源代码模式</td>
</tr>
<tr>
<td align="left">``中间放要引用的东西</td>
<td align="left">相应的代码片</td>
</tr>
<tr>
<td align="left">Ctrl+Shift+`</td>
<td align="left">插入代码片(<code>xxx</code>)</td>
</tr>
<tr>
<td align="left">—</td>
<td align="left">分隔符</td>
</tr>
<tr>
<td align="left">-+空格</td>
<td align="left">例举的圆点</td>
</tr>
<tr>
<td align="left">ctrl+b</td>
<td align="left">加粗</td>
</tr>
<tr>
<td align="left">Ctrl+U</td>
<td align="left">下划线</td>
</tr>
<tr>
<td align="left">Ctrl+I</td>
<td align="left">倾斜</td>
</tr>
<tr>
<td align="left">Ctrl+[</td>
<td align="left">减少缩进</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + V</td>
<td align="left">粘贴为纯文本</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ctrl+t</td>
<td align="left">插入一个表格</td>
</tr>
<tr>
<td align="left">表格里ctrl+回车</td>
<td align="left">下面新加一行</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Backspace</td>
<td align="left">删除行（在表中）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新</td>
<td align="left">Ctrl + N.</td>
<td align="left">Command + N.</td>
</tr>
<tr>
<td align="left">新窗户</td>
<td align="left">Ctrl + Shift + N.</td>
<td align="left">Command + Shift + N.</td>
</tr>
<tr>
<td align="left">打开</td>
<td align="left">Ctrl + O.</td>
<td align="left">Command + O.</td>
</tr>
<tr>
<td align="left">快速打开</td>
<td align="left">Ctrl + P.</td>
<td align="left">Command + Shift + O.</td>
</tr>
<tr>
<td align="left">重新打开已关闭的文件</td>
<td align="left">Ctrl + Shift + T.</td>
<td align="left">Command + Shift + T.</td>
</tr>
<tr>
<td align="left">另存为/重复</td>
<td align="left">Ctrl + Shift + S.</td>
<td align="left">Command + Shift + S.</td>
</tr>
<tr>
<td align="left">偏爱/偏好设置</td>
<td align="left">Ctrl +，</td>
<td align="left">Command +，</td>
</tr>
<tr>
<td align="left">关</td>
<td align="left">Ctrl + W</td>
<td align="left">Command + W</td>
</tr>
</tbody></table>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新段落</td>
<td align="left">输入</td>
<td align="left">输入</td>
</tr>
<tr>
<td align="left">新队</td>
<td align="left">Shift + Enter</td>
<td align="left">Shift + Enter</td>
</tr>
<tr>
<td align="left">复制为Markdown</td>
<td align="left">Ctrl + Shift + C.</td>
<td align="left">Command + Shift + C.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">Command + Shift + V.</td>
</tr>
<tr>
<td align="left">全选</td>
<td align="left">Ctrl + A.</td>
<td align="left">Command + A.</td>
</tr>
<tr>
<td align="left">选择行/句子 选择行（在表格中）</td>
<td align="left">Ctrl + L.</td>
<td align="left">Command + L.</td>
</tr>
<tr>
<td align="left">选择样式范围 选择单元格（在表格中）</td>
<td align="left">Ctrl + E.</td>
<td align="left">Command + E.</td>
</tr>
<tr>
<td align="left">选择Word</td>
<td align="left">Ctrl + D.</td>
<td align="left">Command + D.</td>
</tr>
<tr>
<td align="left">删除Word</td>
<td align="left">Ctrl + Shift + D.</td>
<td align="left">Command + Shift + D.</td>
</tr>
<tr>
<td align="left">跳到顶部</td>
<td align="left">Ctrl + Home</td>
<td align="left">Command +↑</td>
</tr>
<tr>
<td align="left">跳转到选择</td>
<td align="left">Ctrl + J</td>
<td align="left">Command + J</td>
</tr>
<tr>
<td align="left">跳到Buttom</td>
<td align="left">Ctrl + End</td>
<td align="left">Command +↓</td>
</tr>
<tr>
<td align="left">找</td>
<td align="left">Ctrl + F.</td>
<td align="left">Command + F.</td>
</tr>
<tr>
<td align="left">找下一个</td>
<td align="left">F3 /回车</td>
<td align="left">Command + G / Enter</td>
</tr>
<tr>
<td align="left">找到上一个</td>
<td align="left">Shift + F3 / Shift + Enter</td>
<td align="left">Command + Shift + G / Shift + Enter</td>
</tr>
<tr>
<td align="left">更换</td>
<td align="left">Ctrl + H.</td>
<td align="left">Command + H.</td>
</tr>
</tbody></table>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">段</td>
<td align="left">Ctrl + 0</td>
<td align="left">命令+ 0</td>
</tr>
<tr>
<td align="left">提高标题级别</td>
<td align="left">Ctrl + =</td>
<td align="left">命令+ =</td>
</tr>
<tr>
<td align="left">降低标题级别</td>
<td align="left">Ctrl + -</td>
<td align="left">命令+ -</td>
</tr>
<tr>
<td align="left">表</td>
<td align="left">Ctrl + T.</td>
<td align="left">Command + Option + T.</td>
</tr>
<tr>
<td align="left">代码围栏</td>
<td align="left">Ctrl + Shift + K.</td>
<td align="left">Command + Option + C.</td>
</tr>
<tr>
<td align="left">数学块</td>
<td align="left">Ctrl + Shift + M.</td>
<td align="left">Command + Option + B.</td>
</tr>
<tr>
<td align="left">引用</td>
<td align="left">Ctrl + Shift + Q.</td>
<td align="left">Command + Option + Q.</td>
</tr>
<tr>
<td align="left">订购清单</td>
<td align="left">Ctrl + Shift + [</td>
<td align="left">Command + Option + O.</td>
</tr>
<tr>
<td align="left">无序列表</td>
<td align="left">Ctrl + Shift +]</td>
<td align="left">Command + Option + U.</td>
</tr>
<tr>
<td align="left">减少缩进</td>
<td align="left">Ctrl +] / Shift + Tab</td>
<td align="left">Command +] / Shift + Tab</td>
</tr>
</tbody></table>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">罢工</td>
<td align="left">Alt + Shift + 5</td>
<td align="left">Control + Shift +`</td>
</tr>
<tr>
<td align="left">超链接</td>
<td align="left">Ctrl + K.</td>
<td align="left">Command + K.</td>
</tr>
<tr>
<td align="left">图片</td>
<td align="left">Ctrl + Shift + I</td>
<td align="left">Command + Control + I</td>
</tr>
<tr>
<td align="left">清除格式</td>
<td align="left">Ctrl + \</td>
<td align="left">命令+</td>
</tr>
</tbody></table>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">切换补充工具栏</td>
<td align="left">Ctrl + Shift + L.</td>
<td align="left">Command + Shift + L.</td>
</tr>
<tr>
<td align="left">大纲</td>
<td align="left">Ctrl + Shift + 1</td>
<td align="left">Command + Control + 1</td>
</tr>
<tr>
<td align="left">用品</td>
<td align="left">Ctrl + Shift + 2</td>
<td align="left">Command + Control + 2</td>
</tr>
<tr>
<td align="left">文件树</td>
<td align="left">Ctrl + Shift + 3</td>
<td align="left">Command + Control + 3</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Fouus模式</td>
<td align="left">F8</td>
<td align="left">F8</td>
</tr>
<tr>
<td align="left">打字机模式</td>
<td align="left">F9</td>
<td align="left">F9</td>
</tr>
<tr>
<td align="left">Toggler全屏</td>
<td align="left">F11</td>
<td align="left">Command + Option + F.</td>
</tr>
<tr>
<td align="left">真实大小</td>
<td align="left">Ctrl + Shift + 0</td>
<td align="left"><em>（不支持）</em></td>
</tr>
<tr>
<td align="left">放大</td>
<td align="left">Ctrl + Shift + =</td>
<td align="left"><em>（不支持）</em></td>
</tr>
<tr>
<td align="left">缩小</td>
<td align="left">Ctrl + Shift + -</td>
<td align="left"><em>（不支持）</em></td>
</tr>
<tr>
<td align="left">在打开的Documnets之间切换</td>
<td align="left">Ctrl + Tab</td>
<td align="left">命令+`</td>
</tr>
<tr>
<td align="left">切换DevTools</td>
<td align="left">Ctrl + Shift + I</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>基本功能快捷键</p>
<p>字体操作快捷键<br>功能    快捷键</p>
<p>删除线    Alt+Shift+5</p>
<p>插入功能快键键<br>功能    快键键<br>插入图片(本地图片可直接拖入)    Ctrl+Shift+I</p>
<p>插入有序列表    Ctrl+Shift+[<br>插入无序列表    Ctrl+Shift+]<br>插入超链接    Ctrl+K</p>
<p>插入公式块    Ctrl+Shift+M<br>插入引用块    Ctrl+Shift+Q</p>
<p>标题段落快捷键<br>MarkDown支持六级标题，可以使用Ctrl+数字 指定不同层次的标题和段落</p>
<p>功能    快捷键<br>段落（正文）    Ctrl+0</p>
<p>提升标题级别    Ctrl+‘+’<br>降低标题级别    Ctrl+‘-’</p>
<p>功能    快捷键</p>
<p>上移该行    Alt+↑<br>下移该行    Alt+↓<br>左移该列    Win键+←<br>右移该列    Win键+→<br>删除该行    Ctrl+退格键(BackSpace)<br>左右移动表格列的快捷键与WinDows系统自带的快捷键冲突，导致失效</p>
<p>删除行快捷键，不知道为什么没有生效</p>
<p>视图操作快捷键<br>侧边栏<br>功能    快捷键<br>大纲视图    Ctrl+Shift+1<br>文件列表视图    Ctrl+Shift+2<br>文件树视图<br>显示/隐藏侧边栏<br>放大视图    Ctrl+Shift+‘+’<br>缩小视图    Ctrl+Shift+‘-’<br>恢复原来大小视图    Ctrl+Shift+9</p>
<p>编辑模式<br>功能    快捷键<br>源代码模式    Ctrl+/<br>专注模式(当前编辑行为黑，其他行为灰色)    F8<br>打字机模式(光标始终在屏幕中央位置)    F9<br>其他<br>功能    快捷键<br>全屏    F11<br>应用内窗口切换    Ctrl+Tab<br>开发者工具    Shift+F12</p>
<p>搜索扩展快捷键<br>功能    快捷键</p>
<p>替换    Ctrl+H<br>查找下一个    F3<br>查找上一个    Shift+F3</p>
<p>基本操作快键键<br>选择操作<br>功能    快捷键<br>全选    Ctrl+A<br>选择当前行/句    Ctrl+L<br>选择当前格式文本    Ctrl+E<br>选择当前单词    Ctrl+D<br>删除当前单词    Ctrl+Shift+D</p>
<p>跳转操作<br>功能    快捷键<br>跳转到文首    Ctrl+Home<br>跳转到所选内容    Ctrl+J<br>跳转到文末    Ctrl+End</p>
<p>粘贴复制操作<br>功能    快捷键</p>
<p>复制为MarkDown标记语法    Ctrl+Shift+C<br>粘贴为纯文本    Ctrl+Shift+V</p>
<p>文件操作<br>功能    快捷键<br>新建    Ctrl+N<br>新建窗口(在Windows中，这两个作用一样)    Ctrl+Shift+N<br>打开文件    Ctrl+O<br>快速打开(在最近打开中打开)    Ctrl+P</p>
<p>偏好设置    Ctrl+，<br>关闭    Ctrl+W<br>重新打开关闭的文件    Ctrl+Shift+T</p>
<p>其他<br>功能    快捷键<br>清楚样式    Ctrl+<br>增加缩进    Ctrl+]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/2.1.Typora%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" data-id="ckw61sduu000noswdc2smd68c" data-title="Typora使用快捷键" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-10.3.项目编写文档" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/10.3.%E9%A1%B9%E7%9B%AE%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T08:57:29.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/10.3.%E9%A1%B9%E7%9B%AE%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3/">编写文档</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>项目开发过程中为了增加程序的可读性和程序的健壮性， 方便后期程序的调试和维护，所以需要在开发过程中统一技术规范，一般会在项目初期确定好相关文档作为这一统一的规范。不同公司会对文档做不同要求，划不同的分类，但一般来说大致可以分为需求文档、接口文档、流程图（可以单独作为一份文件可以作为附件附在文档中）、变更文件等。</p>
<h1 id="需求文档"><a href="#需求文档" class="headerlink" title="需求文档"></a>需求文档</h1><p>在项目启动之后，项目的目标已经明确了，那么就要开始着手干活了，但是在干活之前，需要对整个项目分析透彻。</p>
<p>首先，开发人员要有随意转换身份的意识和能力。</p>
<p>1.明确产品功能</p>
<p>在分析业务时，站在用户的角度上，思考要做的产品能实现什么功能。把所有的功能点列出来！</p>
<p>2.分析某一功能点的流程</p>
<p>在罗列了所有的功能之后，需要站在开发者的角度分析每一个功能点，考虑从客户端到后台操作数据库的整个流程，可以从是什么、为什么、在哪、怎么做、谁来做、做完如何反馈、反馈给谁、上传到哪、服务器用什么数据库、数据库需要什么表、表里有什么字段、每个字段的属性及意义等等。</p>
<p>比如，我要要做一个软件中个人头像上传的功能，首先明确我做的是上传功能；为什么要上传？因为个人资料需要头像；怎么做上传？通过网络I/O实现；这个功能在什么位置？软件有个个人中心模块，个人中心里有个个人信息子模块，在这个模块里可以上传头像；谁上传？已经登录的用户；上传完之后如何反馈？弹窗提示上传成功；反馈给谁？客户端已登录的用户；上传到哪？服务器上；用什么数据库？MySQL;需要什么表？（存到）用户表；表里有什么字段？用户信息的基本字段；每个字段的属性及意义？略。在思考完这些问题之后，可以把一个功能点串成一条完整的从前端到数据库的线。</p>
<p>3.整合各个功能点–明确分工</p>
<p>在串完所有的功能点之后，站在一个高一层次的角度，把每个功能点之间的联系理清楚，按照相互的联系分工合作，优化其中的细节问题。</p>
<p>4.撰写需求文档</p>
<p>分工完成之后，按照第二步分析的内容，每个人把自己负责的功能整理成文档，最后合并文档，作为统一的需求文档。</p>
<p>5.绘制业务流程图</p>
<p>需求文档确定之后，绘制整个项目的业务流程图，这时候的流程图只需要包含前端的业务流程，后台实现的流程图不需要在需求文档中体现，而是放在后面的接口文档中。</p>
<h1 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h1><p>不同公司对接口文档的要求也不尽相同，但包括的内容却是大同小异的。封面、标题、审批页、修订历史以及格式字体等等是次要内容，主要内容包括：</p>
<p>1.请求地址</p>
<p>需要哪个线上地址就写哪个。注意不要犯低级错误，比如写错某个字母或者大小写问题。</p>
<p>2.接口信息</p>
<p>说明请求方式，是POST还是GET。</p>
<p>3.功能描述</p>
<p>清晰地描述接口功能，要求言简意赅，不要写太多废话，也不要遗漏任何细节。</p>
<p>4.接口参数说明</p>
<p>声明参数的名称，严格要求与调用一致，包括大小写；</p>
<p>简单说明参数的含义；</p>
<p>参数的数据类型，是string 、int 还是long等（例如参数为@RequestParam(“appKey”)  String appKey,  @RequestParam(“randomId”)  Integer randomId）；</p>
<p>备注部分，说明参数值是需要哪个公司提供，并详细说明参数怎么生成的，例如时间戳，是哪个时间段的；参数是否必填，一些参数是必须要有的，有些是可选参数，一定要注意写清晰。</p>
<p>5.返回值说明</p>
<p>有一个模板返回值，并说明每个返回参数的意义。提供一个真实的调用接口，真实的返回值。</p>
<p>6.接口调用限制</p>
<p>为了安全，双方采用一个一致的加密算法，保证接口调用的安全。</p>
<p>7.文档维护</p>
<p>文档维护时，修改内容部分需要有修改人、修改日期、版本号的信息。</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>流程图可以单独作为一份文件，也可以作为附件附在对应的文档中，具体执行按要求来。</p>
<p>1.业务流程图</p>
<p>2.程序结构图</p>
<p>3.程序流程图</p>
<h1 id="变更文件"><a href="#变更文件" class="headerlink" title="变更文件"></a>变更文件</h1><p>在开发过程中如果出现与预期计划、文档不一致的地方，则视为发生变更，此时大致需要提供以下信息：</p>
<p>1.版本历史（版本号、基本信息）</p>
<p>2.变更前现状</p>
<p>3.变更内容</p>
<p>4.影响评估</p>
<p>5.审批</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/10.3.%E9%A1%B9%E7%9B%AE%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3/" data-id="ckw61sduo0007oswda7en0spw" data-title="编写文档" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-5.2.MySQL进阶" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/5.2.MySQL%E8%BF%9B%E9%98%B6/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:43:51.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/5.2.MySQL%E8%BF%9B%E9%98%B6/">MySQL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引，类似书籍的目录，可以根据目录的某个页码立即找到对应的内容。</p>
<p>索引的优点：1. 天生排序。2. 快速查找。<br>索引的缺点：1. 占用空间。2. 降低更新表的速度。</p>
<p>注意点：小表使用全表扫描更快，中大表才使用索引。超级大表索引基本无效。</p>
<p>索引从实现上说，分成 2 种：聚集索引和辅助索引（也叫二级索引或者非聚集索引）</p>
<p>从功能上说，分为 6 种：普通索引，唯一索引，主键索引，复合索引，外键索引，全文索引。</p>
<p>详细说说 6 种索引：</p>
<p>1、普通索引：最基本的索引，没有任何约束。<br>2、唯一索引：与普通索引类似，但具有唯一性约束。<br>3、主键索引：<strong>特殊的唯一索引，不允许有空值</strong>。<br>4、复合索引：将多个列组合在一起创建索引，可以覆盖多个列。<br>5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。<br>6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎（ES，Solr）。</p>
<ul>
<li><code>注意：主键就是唯一索引，但是唯一索引不一定是主键，唯一索引可以为空，但是空值只能有一个，主键不能为空。</code></li>
</ul>
<p>另外，InnoDB 通过主键聚簇数据，如果没有定义主键且没有定义聚集索引， MySql 会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个 6 字节的主键作为聚簇索引，用户不能查看或访问。</p>
<p>简单点说：</p>
<ol>
<li>设置主键时，会自动生成一个唯一索引，如果<strong>之前</strong>没有聚集索引，那么主键就是聚集索引。</li>
<li>没有设置主键时，会选择一个不为空的唯一索引作为聚集索引，如果还没有，那就生成一个隐式的 6 字节的索引。</li>
</ol>
<p>MySql 将数据按照页来存储，默认一页为 16kb，当你在查询时，不会只加载某一条数据，而是将这个数据所在的页都加载到 pageCache 中，这个其实和 OS 的就近访问原理类似。</p>
<p>MySql 的索引使用 B+ 树结构。在说 B+ 树之前，先说说 B 树，B 树是一个多路平衡查找树，相较于普通的二叉树，不会发生极度不平衡的状况，同时也是多路的。</p>
<p>B 树的特点是：他会将数据也保存在非页子节点。</p>
<p>看图可知：</p>
<p><img src="https://pic1.zhimg.com/80/v2-05f597852f53aef1e74cc2f5b5ba4d10_720w.png" alt="img"></p>
<p>而这个特点会导致非页子节点不能存储大量的索引。</p>
<p>而 B+ Tree 就是针对这个对 B tree 做了优化。如下图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-b5a1c7f34e65044a08cdb213f55295fd_720w.png" alt="img"></p>
<p>我们看到，B+ Tree 将所有的 data 数据都保存到了叶子节点中，非也子节点只保存索引和指针。</p>
<p>我们假设一个非页子节点是 16kb，每个索引，即主键是 bigint，即 8b，指针为 8b。那么每页能存储大约 1000 个索引（16kb/ 8b + 8b）.</p>
<p>而一颗 3 层的 B+树能够存储多少索引呢？如下图：</p>
<p><img src="https://pic3.zhimg.com/80/v2-38209d49a486354414b2358f2e88558a_720w.png" alt="img"></p>
<p>大约能够存储 10 亿个索引。通常 B+ 树的高度在 2-4 层，由于 MySql 在运行时，根节点是常驻内存的，因此每次查找只需要大约 2 -3 次 IO。可以说，B+ 树的设计，就是根据机械磁盘的特性来进行设计的。</p>
<p>知道了索引的设计，我们能够知道另外一些信息：</p>
<ol>
<li>MySql 的主键不能太大，如果使用 UUID 这种，将会浪费 B+ 树的非叶子节点。</li>
<li>MySql 的主键最好是自增的，如果使用 UUID 这种，每次插入都会调整 B+树，从而导致页分裂，严重影响性能。</li>
</ol>
<p>那么，如果项目中使用了分库分表，我们通常都会需要一个主键进行 sharding，那怎么办呢？在实现上，我们可以保留自增主键，而逻辑主键用来作为唯一索引即可。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h3 id="2-锁机制"><a href="#2-锁机制" class="headerlink" title="2. 锁机制"></a>2. 锁机制</h3><p>关于 Mysql 的锁，各种概念就会喷涌而出，事实上，锁有好几种维度，我们来解释一下。</p>
<h3 id="1-类型维度"><a href="#1-类型维度" class="headerlink" title="1. 类型维度"></a>1. 类型维度</h3><ul>
<li><p>共享锁（读锁 / S 锁）</p>
</li>
<li><p>排它锁（写锁 / X 锁）<br>类型细分：</p>
</li>
<li><ul>
<li>意向共享锁</li>
<li>意向排他（互斥）锁</li>
</ul>
</li>
</ul>
<ul>
<li>悲观锁（使用锁，即 for update）</li>
<li>乐观锁（使用版本号字段，类似 CAS 机制，即用户自己控制。缺点：并发很高的时候，多了很多无用的重试）</li>
</ul>
<h3 id="2-锁的粒度（粒度维度）"><a href="#2-锁的粒度（粒度维度）" class="headerlink" title="2. 锁的粒度（粒度维度）"></a>2. 锁的粒度（粒度维度）</h3><ul>
<li>表锁</li>
<li>页锁（Mysql BerkeleyDB 引擎）</li>
<li>行锁（InnoDB）</li>
</ul>
<h3 id="3-锁的算法（算法维度）"><a href="#3-锁的算法（算法维度）" class="headerlink" title="3. 锁的算法（算法维度）"></a>3. 锁的算法（算法维度）</h3><ul>
<li>Record Lock（单行记录）</li>
<li>Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）</li>
<li>Next-Key Lock（Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身， MySql 防止幻读，就是使用此锁实现）</li>
</ul>
<h3 id="4-默认的读操作，上锁吗？"><a href="#4-默认的读操作，上锁吗？" class="headerlink" title="4. 默认的读操作，上锁吗？"></a>4. 默认的读操作，上锁吗？</h3><ul>
<li>默认是 MVCC 机制（“一致性非锁定读”）保证 RR 级别的隔离正确性，是不上锁的。</li>
</ul>
<p>可以选择手动上锁：select xxxx for update (排他锁); select xxxx lock in share mode(共享锁)，称之为“一致性锁定读”。</p>
<p>使用锁之后，就能在 RR 级别下，避免幻读。当然，默认的 MVCC 读，也能避免幻读。</p>
<p>既然 RR 能够防止幻读，那么，SERIALIZABLE 有啥用呢？</p>
<p>防止丢失更新。例如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-1917d61efc5d3ab35029004d3eae7dc8_720w.png" alt="img"></p>
<p>这个时候，我们必须使用 SERIALIZABLE 级别进行串行读取。</p>
<p>最后，行锁的实现原理就是锁住聚集索引，如果你查询的时候，没有正确地击中索引，MySql 优化器将会抛弃行锁，使用表锁。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是数据库永恒不变的话题， ACID：原子性，一致性，隔离性，持久性。</p>
<p>四个特性，最重要的就是一致性。而<strong>一致性</strong>（（由DBMS的<strong>完整性子系统</strong>执行测试任务））由原子性，隔离性，持久性来保证。</p>
<ul>
<li>原子性由 Undo log 保证。Undo Log 会保存每次变更之前的记录，从而在发生错误时进行回滚。（由DBMS的<strong>事务管理子系统</strong>来实现）</li>
<li>隔离性由 MVCC 和 Lock 保证。这个后面说。（由DBMS的<strong>并发控制子系统</strong>来实现）</li>
<li>持久性由 Redo Log 保证。每次真正修改数据之前，都会将记录写到 Redo Log 中，只有 Redo Log 写入成功，才会真正的写入到 B+ 树中，如果提交之前断电，就可以通过 Redo Log 恢复记录。（由DBMS的<strong>恢复管理子系统</strong>来实现）</li>
</ul>
<p>然后再说隔离性。</p>
<p>隔离级别：</p>
<ol>
<li>未提交读（RU）</li>
<li>已提交读（RC）</li>
<li>可重复读（RR）</li>
<li>串行化（serializable）</li>
</ol>
<p>每个级别都会解决不同的问题，通常是3 个问题：脏读，不可重复读，幻读。一张经典的图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e4a89f7012dd6511edd7d970ffd0f659_720w.png" alt="img"></p>
<p>这里有个注意点，关于幻读，在数据库规范里，RR 级别会导致幻读，但是，由于 Mysql 的优化，MySql 的 RR 级别不会导致幻读：在使用默认的 select 时，MySql 使用 MVCC 机制保证不会幻读；你也可以使用锁，在使用锁时，例如 for update（X 锁），lock in share mode（S 锁），MySql 会使用 Next-Key Lock 来保证不会发生幻读。前者称为快照读，后者称为当前读。</p>
<p>原理剖析：</p>
<ul>
<li>RU 发生脏读的原因：RU 原理是对每个更新语句的行记录进行加锁，而不是对整个事务进行加锁，所以会发生脏读。而 RC 和 RR 会对整个事务加锁。</li>
<li>RC 不能重复读的原因：RC 每次执行 SQL 语句都会生成一个新的 Read View，每次读到的都是不同的。而 RR 的事务从始至终都是使用同一个 Read View。</li>
<li>RR 不会发生幻读的原因： 上面说过了。</li>
</ul>
<p>那 RR 和 Serializble 有什么区别呢？答：丢失更新。本文关于锁的部分已经提到。</p>
<p>MVCC 介绍：全称多版本并发控制。</p>
<p>innoDB 每个聚集索引都有 4 个隐藏字段，分别是主键（RowID），最近更改的事务 ID（MVCC 核心），Undo Log 的指针（隔离核心），索引删除标记（当删除时，不会立即删除，而是打标记，然后异步删除）；</p>
<p>本质上，MVCC 就是用 Undo Log 链表实现。</p>
<p>MVCC 的实现方式：事务以排它锁的方式修改原始数据，把修改前的数据存放于 Undo Log，通过回滚指针与数据关联，如果修改成功，什么都不做，如果修改失败，则恢复 Undo Log 中的数据。</p>
<p>多说一句，通常我们认为 MVCC 是类似乐观锁的方式，即使用版本号，而实际上，innoDB 不是这么实现的。当然，这不影响我们使用 MySql。</p>
<h1 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h1><p>事务：指的是逻辑上的一组操作，组成这组操作的各个逻辑单元，要么全都成功，要么全都失败。</p>
<p>开启事务：start transaction;</p>
<p>提交事务：commit;</p>
<p>回滚事务：rollback; //恢复到事务开启之前的状态（也相当于提交了事务）</p>
<p>事务的特性：</p>
<p>原子性：事务的不可分割，组成事务的各个逻辑单元不可分割。</p>
<p>一致性：事务执行的前后，数据完整性保持一致。（总和前后相等）</p>
<p>隔离性：事务执行不应该受到其他事务的干扰。</p>
<p>持久性：事务一旦结束，数据就持久化到数据库中。</p>
<p>如果不考虑隔离性（一个事务执行受到其他的事务的干扰），引发一些安全问题，主要体现在读取数据上：</p>
<p>l 脏读：一个事务读到了另一个事务未提交的数据，导致查询结果不一致</p>
<p>l 不可重复读：一个事务读到了另一个事务已经提交的update的数据，导致多次查询结果不一致。</p>
<p>l 虚读/幻读：一个事务读到了另一个事务已经提交的insert的数据，导致多次查询结果不一致。</p>
<p>设置事务的隔离级别：安全性越高的效率越低，一般使用中间两种</p>
<p>read uncommitted（未提交读）：脏读，不可重复读，虚读都有可能发生</p>
<p>read committed（已提交读）：避免脏读。但是不可重复读和虚读是有可能发生</p>
<p>repeatable read（重复读，默认）：避免脏读和不可重复读，但是虚读有可能发生。</p>
<p>serializable（串行化读（一个事务得接着另一个事务执行，禁止并发存在））：避免脏读，不可重复读，虚读。</p>
<p>设置事务的隔离级别： set session transaction isolation level 隔离级别</p>
<p>查看当前的隔离级别：  select @@tx_isolation;</p>
<p>演示脏读：</p>
<p>\1. 开启两个窗口A,B</p>
<p>\2. 设置A窗口的隔离级别为read uncommitted;</p>
<p>\3. 在A，B两个窗口中开启事务</p>
<p>\4. 在B窗口中完成转账的功能，但是不提交事务</p>
<p>\5. 在A窗口中进行查询：查询到已经转账成功了。（这就发生了脏读）</p>
<p>演示不可重复读：</p>
<p>\1. 开启两个窗口A,B</p>
<p>\2. 设置A窗口的隔离级别为read committed;</p>
<p>\3. 分别在两个窗口中开启事务</p>
<p>\4. 在B窗口中完成转账，不提交事务</p>
<p>\5. 在A窗口中进行查询：仍然是未到账（这就避免了脏读）</p>
<p><strong>6.</strong> <em><strong>*在B窗口中提交事务*</strong></em></p>
<p>\7. 在A窗口查询：发现到账了（两次A窗口的查询结果不同，这就是不可重复读）</p>
<p>避免不可重复读：将2中的隔离级别设置为repeatable read；（一个事务中的多次查询结果一致，跳出这个事务才能出现改变后的结果）</p>
<p>（虚读只是概率发生，无法演示）</p>
<p>演示串行化：</p>
<p>\1. 开启两个窗口A,B</p>
<p>\2. 设置A窗口的隔离级别：serializable</p>
<p>\3. 分别在两个窗口中开启事务</p>
<p>\4. 在B窗口中插入一条记录</p>
<p>\5. 在A窗口中进行查询：发现无反应，但是当B窗口提交事务的时候，A窗口会立马输出结果。（说明事务不允许吹袭案并发，A窗口需要等B窗口事务执行完成以后，才会执行A窗口的事务）</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h1 id="解释器explain"><a href="#解释器explain" class="headerlink" title="解释器explain"></a>解释器explain</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>select 查询的序列号，包含一组可以重复的数字，表示查询中执行sql语句的顺序。一般有三种情况：  第一种：id全部相同，sql的执行顺序是由上至下；  第二种：id全部不同，sql的执行顺序是根据id大的优先执行；  第三种：id既存在相同，又存在不同的。先根据id大的优先执行，再根据相同id从上至下的执行。</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select 查询的类型，主要是用于区别普通查询，联合查询，嵌套的复杂查询  </p>
<p>simple：简单的select 查询，查询中不包含子查询或者union  </p>
<p>primary：查询中若包含任何复杂的子查询，最外层查询则被标记为primary  </p>
<p>subquery：在select或where 列表中包含了子查询  </p>
<p>derived：在from列表中包含的子查询被标记为derived（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。 </p>
<p>union：若第二个select出现在union之后，则被标记为union，若union包含在from子句的子查询中，外层select将被标记为：derived  union </p>
<p>result：从union表获取结果的select</p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>显示这一行的数据是关于哪张表的</p>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>表所使用的分区，如果要统计十年公司订单的金额，可以把数据分为十个区，每一年代表一个区。这样可以大大的提高查询效率。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>这是一个非常重要的参数，连接类型，常见的有：all , index , range , ref , eq_ref , const , system , null 八个级别。  </p>
<p>性能从最优到最差的排序：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all  </p>
<p>对java程序员来说，若保证查询至少达到range级别或者最好能达到ref则算是一个优秀而又负责的程序员。 </p>
<p>all：（full table scan）全表扫描无疑是最差，若是百万千万级数据量，全表扫描会非常慢。  </p>
<p>index：（full index scan）全索引文件扫描比all好很多，毕竟从索引树中找数据，比从全表中找数据要快。  </p>
<p>range：只检索给定范围的行，使用索引来匹配行。范围缩小了，当然比全表扫描和全索引文件扫描要快。sql语句中一般会有between，in，&gt;，&lt; 等查询。  </p>
<p>ref：非唯一性索引扫描，本质上也是一种索引访问，返回所有匹配某个单独值的行。比如查询公司所有属于研发团队的同事，匹配的结果是多个并非唯一值。  eq_ref：唯一性索引扫描，对于每个索引键，表中有一条记录与之匹配。比如查询公司的CEO，匹配的结果只可能是一条记录，  </p>
<p>const：表示通过索引一次就可以找到，const用于比较primary key 或者unique索引。因为只匹配一行数据，所以很快，若将主键至于where列表中，MySQL就能将该查询转换为一个常量。  </p>
<p>system：表只有一条记录（等于系统表），这是const类型的特列，平时不会出现，了解即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type中包含的值：</span><br><span class="line">system、const： 可以将查询的变量转为常量. 如id&#x3D;1; id为 主键或唯一键.</span><br><span class="line">eq_ref： 访问索引,返回某单一行的数据.(通常在联接时出现，查询使用的索引为主键或惟一键)</span><br><span class="line">ref： 访问索引,返回某个值的数据.(可以返回多行) 通常使用&#x3D;时发生 </span><br><span class="line">range： 这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西，并且该字段上建有索引时发生的情况(注:不一定好于index) </span><br><span class="line">index： 以索引的顺序进行全表扫描，优点是不用排序,缺点是还要全表扫描 </span><br><span class="line">ALL： 全表扫描，应该尽量避免</span><br></pre></td></tr></table></figure>

<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>显示查询语句可能用到的索引(一个或多个或为null)，不一定被查询实际使用。仅供参考使用。如果为空，表示没有可能应用的索引</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>显示查询语句实际使用的索引。若为null，则表示没有使用索引。</p>
<p>MySQL很少会选择优化不足的索引，此时可以在SELECT语句中使用FORCE INDEX（index_name）来强制使用一个索引或者用IGNORE INDEX（index_name）来强制忽略索引</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>显示索引中使用的字节数，可通过key_len计算查询中使用的索引长度。在不损失精确性的情况下索引长度越短越好。</p>
<p>key_len 显示的值为索引字段的最可能长度，并非实际使用长度，即key_len是根据表定义计算而得，并不是通过表内检索出的。</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>显示索引的哪一列或常量被用于查找索引列上的值。</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，值越大越不好。</p>
<h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>关于MySQL如何解析查询的额外信息</p>
<p>Using filesort： 说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序” 。出现这个就要立刻优化sql。  </p>
<p>Using temporary： 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序 order by 和 分组查询 group by。 出现这个更要立刻优化sql。  </p>
<p>Using index： 表示相应的select 操作中使用了覆盖索引（Covering index），避免访问了表的数据行，效果不错！如果同时出现Using where，表明索引被用来执行索引键值的查找。如果没有同时出现Using where，表示索引用来读取数据而非执行查找动作。  </p>
<p>覆盖索引（Covering Index） ：也叫索引覆盖，就是select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select 列表中的字段，而不必根据索引再次读取数据文件。  </p>
<p>Using index condition： 在5.6版本后加入的新特性，优化器会在索引存在的情况下，通过符合RANGE范围的条数 和 总数的比例来选择是使用索引还是进行全表遍历。  </p>
<p>Using where： 表明使用了where 过滤  </p>
<p>Using join buffer： 表明使用了连接缓存  </p>
<p>impossible where： where 语句的值总是false，不可用，不能用来获取任何元素  </p>
<p>distinct： 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Extra中包含的值：using index： 只用到索引,可以避免访问表，性能很高。 </span><br><span class="line">using where： 使用到where来过滤数据， 不是所有的where clause都要显示using where. 如以&#x3D;方式访问索引。</span><br><span class="line">using tmporary： 用到临时表去处理当前的查询。</span><br><span class="line">using filesort： 用到额外的排序，此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行。(当使用order by v1,而没用到索引时,就会使用额外的排序)。</span><br><span class="line">range checked for eache record(index map:N)： 没有好的索引可以使用。Using index for group-by：表明可以在索引中找到分组所需的所有数据，不需要查询实际的表。explain select user_id from t_order group by user_id;</span><br></pre></td></tr></table></figure>

<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>一个百分比的值，和rows 列的值一起使用，可以估计出查询执行计划(QEP)中的前一个表的结果集，从而确定join操作的循环次数。小表驱动大表，减轻连接的次数</p>
<p>见到Using temporary和Using filesort，就意味着MySQL根本不能使用索引，结果是检索会很慢，需要优化sql了。</p>
<p>MySQL本身的功能架构分为三个部分，分别是 应用层、逻辑层、物理层，不只是MySQL ，其他大多数数据库产品都是按这种架构来进行划分的。</p>
<ul>
<li>应用层，主要负责与客户端进行交互，建立链接，记住链接状态，返回数据，响应请求，这一层是和客户端打交道的。</li>
<li>逻辑层，主要负责查询处理、事务管理等其他数据库功能处理，以查询为例。</li>
</ul>
<p>​    </p>
<p>首先接收到查询SQL之后，数据库会立即分配一个线程对其进行处理，第一步查询处理器会对SQL查询进行优化，优化后会生成执行计划，然后交由计划执行器来执行。</p>
<p>​    </p>
<p>计划执行器需要访问更底层的事务管理器，存储管理器来操作数据，他们各自的分工各有不同，最终通过调用物理层的文件获取到查询结构信息，将最终结果响应给应用层。</p>
<ul>
<li>物理层，实际物理磁盘上存储的文件，主要有分文数据文件，日志文件。</li>
</ul>
<p>通过上面的描述，生成执行计划是执行一条SQL必不可少的步骤，一条SQL性能的好坏，可以通过查看执行计划很直观的看出来，执行计划提供了各种查询类型与级别，方便我们进行查看以及为作为性能分析的依据。</p>
<p>MySQL为我们提供了 explain 关键字来直观的查看一条SQL的执行计划。</p>
<p>explain显示了MySQL如何使用索引来处理select语句以及连接表，可以帮助选择更好的索引和写出更优化的查询语句。</p>
<p>下面我们使用 explain 做一个查询，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/DmibiaFiaAI4B2X3HLg3LCH4kOawemn0jK92f2UQNa6MzDzMSHF0kiaG8icDGUwjkyq4oZzflDzjhDqiaZXe9CXdhVfA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>查询结构中有12列，理解每一列的含义，对理解执行计划至关重要，下面进行说明。</p>
<p><strong>id</strong></p>
<p>SELECT识别符，这是SELECT的查询序列号。</p>
<p><strong>select_type</strong></p>
<p>SELECT类型,可以为以下任何一种:</p>
<ul>
<li>SIMPLE:简单SELECT(不使用UNION或子查询)</li>
<li>PRIMARY:最外面的SELECT</li>
<li>UNION:UNION中的第二个或后面的SELECT语句</li>
<li>DEPENDENT UNION:UNION中的第二个或后面的SELECT语句,取决于外面的查询</li>
<li>UNION RESULT:UNION 的结果</li>
<li>SUBQUERY:子查询中的第一个SELECT</li>
<li>DEPENDENT SUBQUERY:子查询中的第一个SELECT,取决于外面的查询</li>
<li>DERIVED:导出表的SELECT(FROM子句的子查询)</li>
</ul>
<p><strong>table</strong></p>
<p>输出的行所引用的表</p>
<p><strong>partitions</strong></p>
<p>如果查询是基于分区表的话，显示查询将访问的分区。</p>
<p><strong>type</strong></p>
<p>联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:</p>
<ul>
<li>system:表仅有一行(=系统表)。这是const联接类型的一个特例。</li>
<li>const:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!</li>
<li>eq_ref:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。</li>
<li>ref:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。</li>
<li>ref_or_:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。</li>
<li>index_merge:该联接类型表示使用了索引合并优化方法。</li>
<li>unique_subquery:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。</li>
<li>index_subquery:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)</li>
<li>range:只检索给定范围的行,使用一个索引来选择行。</li>
<li>index:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。</li>
<li>ALL:对于每个来自于先前的表的行组合,进行完整的表扫描，说明查询就需要优化了。</li>
</ul>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<p><strong>possible_keys</strong></p>
<p>指出MySQL能使用哪个索引在该表中找到行</p>
<p><strong>key</strong></p>
<p>显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。</p>
<p><strong>key_len</strong></p>
<p>显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。在不损失精确性的情况下，长度越短越好</p>
<p><strong>ref</strong></p>
<p>显示使用哪个列或常数与key一起从表中选择行。</p>
<p><strong>rows</strong></p>
<p>显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。</p>
<p><strong>filtered</strong></p>
<p>显示了通过条件过滤出的行数的百分比估计值。</p>
<p><strong>Extra</strong></p>
<p>该列包含MySQL解决查询的详细信息</p>
<ul>
<li>Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。</li>
<li>Select tables optimized away MySQL根本没有遍历表或索引就返回数据了，表示已经优化到不能再优化了</li>
<li>Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。</li>
<li>range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。</li>
<li>Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行，说明查询就需要优化了。</li>
<li>Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。</li>
<li>Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果，说明查询就需要优化了。</li>
<li>Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。</li>
<li>Using sort_union(…), Using union(…), Using intersect(…):这些函数说明如何为index_merge联接类型合并索引扫描。</li>
<li>Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。</li>
</ul>
<h1 id="mysql添加用户并设置权限"><a href="#mysql添加用户并设置权限" class="headerlink" title="mysql添加用户并设置权限"></a>mysql添加用户并设置权限</h1><p>1.登录本地用户</p>
<p>命令：[root@elk mysql]# mysql -uroot -p123456</p>
<p>登录外网用户（需要注意服务器可能只允许本地登录，需要修改响应的配置文件）</p>
<p>配置文件是/etc/mysql/my.cnf</p>
<p>命令：vim   /etc/mysql/my.cnf</p>
<p>修改bind-address  =127.0.0.1  将其注释掉；//作用是使得不再只允许本地访问</p>
<p>重启mysql：/etc/init.d/mysql restart  </p>
<p>然后登录</p>
<p>2.创建用户</p>
<p>命令：mysql&gt; CREATE USER ‘username’@’host’ IDENTIFIED BY ‘password’;</p>
<p>username:用户名；</p>
<p>host：指定在哪个主机上可以登录，本机可用localhost，%通配所有远程主机；</p>
<p>password：用户登录密码；</p>
<p>3.设置权限</p>
<p>命令：<strong>GRANT ALL PRIVILEGES ON  <em>.</em> TO ‘username’@‘%’ IDENTIFIED BY ‘password’；</strong></p>
<p>刷新权限：FLUSH PRIVILEGES;            #刷新之后才会生效，重启也可以</p>
<p>格式：grant 权限 on 库名.表名 to 用户@登录主机 identified by “用户密码”；*.*代表所有权；</p>
<p>@ 后面是访问的是客户端IP地址（或是 主机名） % 代表任意的客户端，如果填写 localhost 为本地访问（那此用户就不能远程访问该mysql数据库了）</p>
<p>一般情况下，修改MySQL密码，授权，是需要有mysql里的root权限的。 </p>
<p>注：本操作是在WIN命令提示符下，phpMyAdmin同样适用。     </p>
<p>用户：phplamp  用户数据库：phplampDB </p>
<p>1.新建用户。 </p>
<p>//登录MYSQL </p>
<p>@&gt;mysql -u root -p </p>
<p>@&gt;密码 </p>
<p>//创建用户 </p>
<p>mysql&gt; insert into mysql.user(Host,User,Password) values(“localhost”,”phplamp”,password(“1234”)); </p>
<p>//刷新系统权限表 </p>
<p>mysql&gt;flush privileges; </p>
<p>这样就创建了一个名为：phplamp  密码为：1234  的用户。 </p>
<p>然后登录一下。 </p>
<p>mysql&gt;exit; </p>
<p>@&gt;mysql -u phplamp -p </p>
<p>@&gt;输入密码 </p>
<p>mysql&gt;登录成功 </p>
<p>2.为用户授权。 </p>
<p>//登录MYSQL(有ROOT权限)。我以ROOT身份登录. </p>
<p>@&gt;mysql -u root -p </p>
<p>@&gt;密码 </p>
<p>//首先为用户创建一个数据库(phplampDB) </p>
<p>mysql&gt;create database phplampDB; </p>
<p>/授权phplamp用户拥有phplamp数据库的所有权限。 </p>
<p>mysql&gt;<em><em>grant all privileges on phplampDB.</em> to phplamp@localhost identified by ‘1234’;</em>* </p>
<p>//刷新系统权限表 </p>
<p>mysql&gt;flush privileges; </p>
<p>mysql&gt;其它操作 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 如果想指定部分权限给一用户，可以这样来写: </span><br><span class="line">mysql&gt;grant select,update on phplampDB.* to phplamp@localhost identified by &#39;1234&#39;; </span><br><span class="line">&#x2F;&#x2F;刷新系统权限表。 </span><br><span class="line">mysql&gt;flush privileges; *&#x2F; </span><br></pre></td></tr></table></figure>

<p>3.删除用户。 </p>
<p>@&gt;mysql -u root -p </p>
<p>@&gt;密码 </p>
<p>mysql&gt;DELETE FROM user WHERE User=”phplamp” and Host=”localhost”; </p>
<p>mysql&gt;flush privileges; </p>
<p>//删除用户的数据库 mysql&gt;drop database phplampDB; </p>
<p>4.修改指定用户密码。 </p>
<p>@&gt;mysql -u root -p </p>
<p>@&gt;密码 </p>
<p>mysql&gt;update mysql.user set password=password(‘新密码’) where User=”phplamp” and Host=”localhost”; </p>
<p>mysql&gt;flush privileges;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/06/5.2.MySQL%E8%BF%9B%E9%98%B6/" data-id="ckw61sdwa004uoswd4rzr61e2" data-title="MySQL" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-8.1.前端概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/05/8.1.%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2021-04-05T07:42:57.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/05/8.1.%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0/">前端概述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>网页主要是做前端样式，而现在的前端的框架越来越多：bootstrap，layui，基于Vue的elementui、iview。以前开发网页需要写html代码，css样式和js方法。现在用了框架之后，我们只需要将其中的示例改为自己的信息，将相应的css和js放在对应的路径下即可。</p>
<p>前端适配的问题：在css的样式下</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/05/8.1.%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0/" data-id="ckw61sdvh002foswd3xp4a389" data-title="前端概述" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-8.3.网页前端之CSS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/05/8.3.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/" class="article-date">
  <time class="dt-published" datetime="2021-04-05T05:37:52.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/05/8.3.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/">网页前端之CSS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTML是页面的结构，CSS是美化页面</p>
<p>CSS（Cascading Style Sheets）：层叠样式表  </p>
<p>样式表：存储样式的地方，多个样式</p>
<p>CSS通常称为CSS样式或层叠样式表，主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等），图片的外形（高宽、边框样式、边距等）以及版面的布局等外观显示样式。</p>
<p>作用：修饰HTML页面，更丰富多彩的展示超文本信息</p>
<p>因为HTML在单独使用设置属性会有一定的局限性，所以用CSS样式。</p>
<h1 id="样式类型"><a href="#样式类型" class="headerlink" title="样式类型"></a>样式类型</h1><p>1.行内样式表（内联样式）:<code>&lt;div style=&quot;width:400px;height:200px;background-color:#FFF&quot;&gt;&lt;/div&gt;</code></p>
<p>一般写在标签头部</p>
<p>放置规范：在<code>&lt;style&gt;</code>标签内容体中书写css样式代码<code>&lt;/style&gt;</code>      <code>&lt;style&gt;</code>标签放置在<code>&lt;head&gt;</code>标签之中</p>
<p>格式规范：选择器名称｛属性名1：属性值1； 属性名2：属性值2；……｝</p>
<p>代码规范：属性名和属性值之间是键值对关系    <code>：</code>连接   <code>；</code>结尾  </p>
<p>如果一个属性名有多个值，多个值之间用空格隔开：border:1px solid red;</p>
<p>CSS注释：<code>/*注释内容*/ </code> 等同于java的多行注释</p>
<p>缺点:样式只能操作某一个标签 优点:十分灵活，可以进行细节的调节,更加针对性修改某个标签的样式</p>
<p>2.嵌入式样式表（嵌入样式）:<code>&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;</code></p>
<p>一般写在<code>&lt;head&gt;&lt;/head&gt;</code>标签内。可以通过一条语句操作多个标签或类，但是仅限本页面内</p>
<p>3.引用式样式表（外联样式）:<code>&lt;link href=&quot;css文件路径&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code></p>
<p>​    rel=”stylesheet” 固定值，表示样式表</p>
<p>​    type=”text/css” 固定值，表示css类型</p>
<p>​    href表示css文件位置</p>
<p>(能用引用式样式表的地方就尽量用引用式)<br>一般写在<code>&lt;head&gt;&lt;/head&gt;</code>标签内。(多个HTML文件可以引用一个CSS样式表文件) </p>
<p>优点:占用空间资源少，修改方便，只要修改CSS文件就可以修改多个HTML页面的属性，适合不同页面进行样式复用</p>
<p>CSS注释写法:<code>/* */</code>   HTML注释写法:<code>&lt;!--  --&gt;</code></p>
<p>当三种样式表操作同一元素时，优先级依次为:行内样式表，嵌入式样式表，引用式样式表。 即后出现的先应用。引用式样式表一般放在嵌入式样式表的前面</p>
<h1 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h1><p>不要忘记每条属性的“;”结尾<br>如果缺少符号或者书写错误则样式表失效<br>需要单位的值要加上单位，例如:px(像素单位)</p>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>选择器：指定CSS样式作用在哪些HTML标签上</p>
<p>1.标签选择器：HTML标签又名html元素，就是以HTML标签名作为选择器名称。</p>
<p>作用：选择CSS样式代码，对应标签名的标签上。</p>
<p>格式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标签名｛</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CSS样式代码*/</span></span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>适用范围：适用于将相同样式，作用在多个同名标签上</p>
<p>2.类选择器：以HTML的类名（class属性值）作为选择器名称</p>
<p>每个HTML标签都有一个class属性，class属性即为类名。</p>
<p>作用：选择CSS样式代码作用于对应类名的HTML标签上。</p>
<p>格式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.类名｛</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CSS样式代码*/</span></span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>使用范围：适用于将样式一次作用在相同类名的标签上（即使标签名不同）。</p>
<p>3.id选择器：以HTML的id（id属性值）作为选择器名称</p>
<p>每个HTML标签都有一个id属性，这个id属性值必须在本页面是唯一的</p>
<p>作用：选择CSS样式代码作用于某个规定id值的html标签上</p>
<p>格式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>值｛</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CSS样式代码*/</span></span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>适用范围：适用于将样式作用某个标签上（更有针对性）</p>
<p>4.属性选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[href&#x3D;&quot;segmentfault.com&quot;]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.伪类选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:hover&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.伪元素选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::before&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.通配选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>所有 CSS 的选择符由上述 7 种基础的选择器或者组合而成，组合的方式有 3 种：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">后代选择符： </span><br><span class="line"><span class="selector-class">.father</span> <span class="selector-class">.child</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子选择符： </span><br><span class="line"><span class="selector-class">.father</span> &gt; <span class="selector-class">.child</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">相邻选择符: </span><br><span class="line">.bro1 + .bro2&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="CSS样式的优先级"><a href="#CSS样式的优先级" class="headerlink" title="CSS样式的优先级"></a>CSS样式的优先级</h1><h2 id="CSS-的继承性"><a href="#CSS-的继承性" class="headerlink" title="CSS 的继承性"></a>CSS 的继承性</h2><p>1.最近的祖先样式比其他祖先样式优先级高</p>
<p>2.”直接样式”比”祖先样式”优先级高</p>
<p>（总结就是看最近的元素的样式）</p>
<h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><p>3.优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML</span><br><span class="line">&lt;div class&#x3D;&quot;content-class&quot; id&#x3D;&quot;content-id&quot; style&#x3D;&quot;color: black&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; CSS</span><br><span class="line">#content-id &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">.content-class &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">    color: grey;</span><br><span class="line">&#125;</span><br><span class="line">最终的 color 为 black，因为内联样式比其他选择器的优先级高</span><br></pre></td></tr></table></figure>

<p>4.计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照”就近原则”来判断</p>
<p>如果外部样式表和内部样式表中的样式发生冲突会出现什么情况呢？这与样式表在 HTML 文件中所处的位置有关。样式被应用的位置越在下面则优先级越高，其实这仍然可以用规则 4 来解释</p>
<p>5.属性后插有 <strong>!important</strong> 的属性拥有最高优先级。若同时插有 <strong>!important</strong>，则再利用规则 3、4 判断优先级</p>
<h1 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h1><h2 id="字体属性：-font"><a href="#字体属性：-font" class="headerlink" title="字体属性：(font)"></a>字体属性：(font)</h2><p>样式：</p>
<p>​    color : #999999;   文字颜色</p>
<p>​    font-family : sans-serif;   字体类型  “Courier New”, Courier, monospace, “Times New Roman”, Times, serif, Arial, Helvetica, sans-serif, Verdana</p>
<p>​    font-size:  字体大小 inherit| medium| large| larger| x-large| xx-large| small| smaller| x-small| xx-small |数值  单位：pt，px</p>
<p>​    font-weight:  字体粗细 bold,bolder; (文字粗体）   lighter;(细体) normal;(正常)  100-900</p>
<p>​    font-style:  字体风格  itelic; (文字斜体）  normal;(正常) oblique;(偏斜体)   inherit(继承)</p>
<p>​    letter-spacing :  字间距离  数值|inherit|normal</p>
<p>​    word-spacing: 单词间距  数值|inherit|normal</p>
<p>​    line-height :  设置行高   normal;(正常)   inherit(继承)  数值 单位：PX、PD、EM  </p>
<p>​    text-shadow: 阴影颜色 {16位色值}</p>
<p>​    font-variant: 字体变形  {inherit|normal|small-cps（小字体，小型大写字母） }</p>
<p>​    font-size-adjust:字体变形 {inherit|none}</p>
<p>​    font-stretch:字体 {condensed|expanded|extra-condensed|extra-expanded|inherit|narrower|normal| semi-condensed|semi-expanded|ultra-condensed|ultra-expanded|wider}</p>
<p>修饰：inherit|none|underline|overline|line-through|blink</p>
<p>​    text-decoration:line-through; 加删除线</p>
<p>​    text-decoration: overline; 加顶线（上划线）</p>
<p>​    text-decoration:underline; 加下划线</p>
<p>​    text-decoration:none; 删除链接下划线</p>
<p>​    text-decoration:blink; 闪烁</p>
<p>大小写：</p>
<p>text-transform:inherit|none|capitalize|uppercase|lowercase</p>
<p>​    text-transform : capitalize; 首字大写</p>
<p>​    text-transform : uppercase; 英文大写</p>
<p>​    text-transform : lowercase; 英文小写</p>
<h2 id="背景属性：-background"><a href="#背景属性：-background" class="headerlink" title="背景属性： (background)"></a>背景属性： (background)</h2><p>色彩：</p>
<p>​    background-color:#F5E2EC; 背景颜色  </p>
<p>两种方式：</p>
<p>​    ①英文单词</p>
<p>​    ②颜色代码  格式：#红绿蓝，每一个颜色用两个16进制位数表示  例如：#ff1100 红色ff 绿色11 蓝色00 红色颜色最重，绿色其次，没有蓝色  （数值代表每个颜色的色重）</p>
<p>​    background:transparent; 透视背景</p>
<p>图片：</p>
<p>​    background-image : url(/image/bg.gif); 背景图片  url(URL)|none</p>
<p>重复： inherit|no-repeat|repeat|repeat-x|repeat-y</p>
<p>​    background-repeat : repeat; 重复排列-网页默认</p>
<p>​    background-repeat : no-repeat; 不重复排列</p>
<p>​    background-repeat : repeat-x; 在x轴重复排列</p>
<p>​    background-repeat : repeat-y; 在y轴重复排列</p>
<p>滚动：</p>
<p>​    background-attachment : fixed; 浮水印固定背景   scroll;(滚动)</p>
<p>位置：</p>
<p>​    background-position : 90% 90%; 背景图片x与y轴的位置</p>
<p>​    background-position : top; 向上对齐</p>
<p>​    background-position : buttom; 向下对齐</p>
<p>​    background-position : left; 向左对齐</p>
<p>​    background-position : right; 向右对齐</p>
<p>​    background-position : center; 居中对齐</p>
<p>简写：  背影样式 {background:背景颜色|背景图象|背景重复|背景附件|背景位置}</p>
<p>例： {background:#000 url(..) repeat fixed left top;}</p>
<h2 id="区块属性：-Block"><a href="#区块属性：-Block" class="headerlink" title="区块属性： (Block)"></a>区块属性： (Block)</h2><p>排列方式：</p>
<p>​    text-align:right; 文字右对齐</p>
<p>​    text-align:left; 文字左对齐</p>
<p>​    text-align:center; 文字居中对齐</p>
<p>​    text-align:justify; 文字分散对齐（两端对齐）</p>
<p>​    vertical-align:baseline; 基线</p>
<p>​    vertical-align:top; 垂直向上对齐</p>
<p>​    vertical-align:bottom; 垂直向下对齐</p>
<p>​    vertical-align:middle; 垂直居中对齐</p>
<p>​    vertical-align:text-top; 文字垂直向上对齐</p>
<p>​    vertical-align:text-bottom; 文字垂直向下对齐</p>
<p>​    vertical-align:sub; 下标字</p>
<p>​    vertical-align:super; 上标字</p>
<h2 id="显示属性：（display）"><a href="#显示属性：（display）" class="headerlink" title="显示属性：（display）"></a>显示属性：（display）</h2><p>display属性可以使得元素在行内元素和块元素之间相互转换</p>
<p>格式：  选择器{display:属性值 }</p>
<p>属性值：block：此元素显示为块元素（块元素默认的display属性值）</p>
<p>​    inline：此元素显示为行内元素（行内元素默认的display属性值）</p>
<p>​    none：此元素将被隐藏，不显示，也不占用页面空间</p>
<p>display: 显示  {block;}(块) inline;(内嵌) list-item;(列表项) run-in;(追加部分) compact;(紧凑) marker;(标记) table; inline-table; table-raw-group; table-header-group; table-footer-group; table-raw; table-column-group; table-column; table-cell; table-caption;(表格标题)</p>
<p>​    text-indent: 缩进，段首空格 { 数值px; inherit}</p>
<p>​    white-space: 空格；控制空白  pre;(保留) nowrap;(不换行) normal</p>
<p>​    writing-mode: 书写方式 {lr-tb（从左到右，从上到下）|tb-rl（从上到下，从右到左）}</p>
<p>​    visibility: 是否可见 inherit; visible; hidden;collapse</p>
<p>即使不可见的元素也会占据页面上的空间。使用 “display” 属性来创建不占据页面空间的不可见元素</p>
<p>​    overflow:  当内容溢出元素框时发生的事情</p>
<pre><code>     visible:默认值。内容不会被修剪，会呈现在元素框之外。
</code></pre>
<p>​         hidden:内容会被修剪，并且其余内容是不可见的。</p>
<p>​         scroll:内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</p>
<p>​        auto:如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容</p>
<p>​    clip:  (裁切)剪裁绝对定位元素:这个属性用于定义一个剪裁矩形。对于一个绝对定义元素，在这个矩形内的内容才可见。出了这个剪裁区域的内容会根据 overflow 的值来处理。剪裁区域可能比元素的内容区大，也可能比内容区小</p>
<p>​        rect (<em>top</em>, <em>right</em>, <em>bottom</em>, <em>left</em>)</p>
<p>​        auto:默认值。不应用任何剪裁</p>
<h2 id="方框属性：-Box"><a href="#方框属性：-Box" class="headerlink" title="方框属性： (Box)"></a>方框属性： (Box)</h2><p>CSS盒子模型：所有的HTML元素，都可以看作一个四边形，即一个盒子。</p>
<p>用CSS来设置元素盒子的内边距（padding）、边框(border)和外边距(margin)的样式的方式相当于设置盒子的样式，我们称之为盒子模型。</p>
<p>边框：（HTML元素盒子的框体）简写：<code>border:1px solid red;</code></p>
<p>宽度：宽度值： thin|medium|thick|数值  </p>
<p>​    width:长度|百分比| auto</p>
<p>​    border-top-width </p>
<p>​    border-right-width </p>
<p>​    border-bottom-width </p>
<p>​    border-left-width</p>
<p>高度：</p>
<p>​    height:数值|auto</p>
<p>颜色：</p>
<p>​    border-color:数值 数值 数值 数值；　数值：分别代表top、right、bottom、left颜色值</p>
<p>风格： </p>
<p>​    border-style:none|hidden|inherit|dashed|solid|double|inset|outset|ridge|groove</p>
<p>漂浮：</p>
<p>​    float:left|right|none</p>
<p>​    通常默认的排版方式，将页面的元素从上到下一一罗列，而实际开发中，需要左右方式进行排版，所以需要使用到浮动属性：float</p>
<p>格式： 选择器{float：属性值；}</p>
<p>常用属性值：none：元素不浮动（默认值）</p>
<p>​    left：元素向左浮动</p>
<p>​    right：元素向右浮动</p>
<p>因为元素设置浮动属性后，会脱离原有文档流（会脱离原有的板式），从而会影响其他元素的样式，所以设置浮动以后，页面样式需要重新调整。</p>
<p>清除：规定元素的哪一侧不允许其他浮动元素</p>
<p>​    clear:none|left|right|both</p>
<p>注：这个规则只能影响使用清除的元素本身，不能影响其他元素。这个元素与float对应</p>
<p>外边距，边界留白：HTML元素边框到其他元素边框的距离</p>
<p>​    margin-top:10px; 上边界</p>
<p>​    margin-right:10px; 右边界值</p>
<p>​    margin-bottom:10px; 下边界值</p>
<p>​    margin-left:10px; 左边界值</p>
<p>通用性设置：margin: 10px;</p>
<p>内边距，补白：HTML元素里的内容体到HTML元素边框的距离</p>
<p>​    padding-top:10px; 上边框留空白</p>
<p>​    padding-right:10px; 右边框留空白</p>
<p>​    padding-bottom:10px; 下边框留空白</p>
<p>​    padding-left:10px; 左边框留空白</p>
<p>通用性设置：padding: 10px;</p>
<h2 id="边框属性：-Border"><a href="#边框属性：-Border" class="headerlink" title="边框属性： (Border)"></a>边框属性： (Border)</h2><p>所有的HTML标签都有边框，默认边框不可见</p>
<p>简写：    格式：宽度 样式 颜色</p>
<p>​    border：width style color; </p>
<p>​    border-top : 1px solid #6699cc; 上框线</p>
<p>​    border-bottom : 1px solid #6699cc; 下框线</p>
<p>​    border-left : 1px solid #6699cc; 左框线</p>
<p>​    border-right : 1px solid #6699cc; 右框线</p>
<p>也可以使用常规的方式 如下:</p>
<p>​    border-top-color : #369 设置上框线top颜色</p>
<p>​    border-top-width :1px设置上框线top宽度</p>
<p>​    border-top-style : solid设置上框线top样式</p>
<p>其他框线样式：</p>
<p>​    solid 实线框</p>
<p>​    dotted 虚线框（点线）</p>
<p>​    double 双线框</p>
<p>​    groove 立体内凸框 (槽线)</p>
<p>​    ridge 立体浮雕框 (脊状)</p>
<p>​    inset 凹框</p>
<p>​    outset 凸框</p>
<p>width：边框的宽度</p>
<p>height：边框的高度（只是边框，不是字体）</p>
<h2 id="列表属性：-List-style"><a href="#列表属性：-List-style" class="headerlink" title="列表属性： (List-style)"></a>列表属性： (List-style)</h2><p>符号列表： disc|circle|square|decimal|lower-roman|upper-roman|lower-alpha|upper-alpha|none</p>
<p>​    list-style-type:none; 不编号</p>
<p>​    list-style-type:decimal; 阿拉伯数字</p>
<p>​    list-style-type:lower-roman; 小写罗马数字</p>
<p>​    list-style-type:upper-roman; 大写罗马数字</p>
<p>​    list-style-type:lower-alpha; 小写英文字母</p>
<p>​    list-style-type:upper-alpha; 大写英文字母</p>
<p>​    list-style-type:disc; 实心圆形符号</p>
<p>​    list-style-type:circle; 空心圆形符号</p>
<p>​    list-style-type:square; 实心方形符</p>
<p>图像：</p>
<p>​    list-style-image:url(/dot.gif); 图片式符号</p>
<p>位置：</p>
<p>​    list-style-position: outside; 凸排</p>
<p>​    list-style-position:inside; 缩进</p>
<h2 id="定位属性：-Position"><a href="#定位属性：-Position" class="headerlink" title="定位属性： (Position)"></a>定位属性： (Position)</h2><p>这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。</p>
<p>​    position: absolute;   生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p>
<p>​    position: fixed;  生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定</p>
<p>​    position:relative; 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素</p>
<p>​    position:static; 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）</p>
<p>​    position:inherit;规定应该从父元素继承 position 属性的值</p>
<p>Z-index仅能在定位元素上奏效，可被用于将在一个元素放置于另一元素之后,拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。</p>
<h2 id="连接属性：（a）"><a href="#连接属性：（a）" class="headerlink" title="连接属性：（a）"></a>连接属性：（a）</h2><p>a /<em>所有超链接</em>/</p>
<p>​    a:link 超链接文字格式</p>
<p>​    a:visited 浏览过的链接文字格式</p>
<p>​    a:active 按下链接的格式</p>
<p>​    a:hover 鼠标转到链接</p>
<p>鼠标光标样式： hand|crosshair|text|wait|move|help|e-resize|nw-resize|w-resize|s-resize|se-resize|sw-resize</p>
<p>​    链接手指 cursor: hand</p>
<p>​    十字体 cursor:crosshair</p>
<p>​    箭头朝下 cursor:s-resize</p>
<p>​    十字箭头 cursor:move</p>
<p>​    箭头朝右 cursor:move</p>
<p>​    加一问号 cursor:help</p>
<p>​    箭头朝左 cursor:w-resize</p>
<p>​    箭头朝上 cursor:n-resize</p>
<p>​    箭头朝右上 cursor:ne-resize</p>
<p>​    箭头朝左上 cursor:nw-resize</p>
<p>​    文字I型 cursor:text</p>
<p>​    箭头斜右下 cursor:se-resize</p>
<p>​    箭头斜左下 cursor:sw-resize</p>
<p>​    漏斗 cursor:wait</p>
<p>​    光标图案(IE6) p {cursor:url(“光标文件名.cur”),text;}</p>
<h2 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h2><p>文字方块</p>
<p>按钮</p>
<p>复选框</p>
<p>选择钮</p>
<p>多行文字方块</p>
<p>下拉式菜单 选项1选项2</p>
<h2 id="伪元素-after和-before"><a href="#伪元素-after和-before" class="headerlink" title="伪元素::after和::before"></a>伪元素::after和::before</h2><p>::before和::after匹配一个虚拟元素，主要被用于为当前元素增加装饰性内容的。它显示的内容是其自身的“<code>content</code>”属性，默认是内联元素。</p>
<h2 id="兼容问题-important"><a href="#兼容问题-important" class="headerlink" title="兼容问题!important"></a>兼容问题!important</h2><p>​    CSS中的!important一般都是用于对低版本的除了iE 6 ，用来做hack的，后面缀上了!important的css语句，让浏览器首选执行这个语句，因为css有继承的样式，加上!importanrt可以覆盖父级的样式。 IE6不认识它的，IE7和别的浏览器中可以用，用来处理浏览器的兼容性。</p>
<h2 id="让两个组件变为一行"><a href="#让两个组件变为一行" class="headerlink" title="让两个组件变为一行"></a>让两个组件变为一行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;left&quot; style&#x3D;&quot;float:left&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;leftButton&quot; οnclick&#x3D;&quot;login()&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div align&#x3D;&quot;right&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;rightButton&quot; οnclick&#x3D;&quot;cancle()&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<h1 id="vue的样式"><a href="#vue的样式" class="headerlink" title="vue的样式"></a>vue的样式</h1><h3 id="lt-style-scoped-gt"><a href="#lt-style-scoped-gt" class="headerlink" title="&lt;style scoped&gt;"></a><code>&lt;style scoped&gt;</code></h3><p>在vue中，我们为了避免父组件的样式影响到子组件的样式，会在style中加<code>&lt;style scoped&gt;</code>，这样父组件中如果有跟子组件相同的class名称或者使用选择器的时候，就不会影响到子组件的样式。</p>
<h3 id="deep-gt-gt-gt"><a href="#deep-gt-gt-gt" class="headerlink" title="/deep/    &gt;&gt;&gt;"></a>/deep/    &gt;&gt;&gt;</h3><p>vue组件中，在style设置为scoped的时候，里面在写样式对子组件是不生效的，如果想让某些样式对所有子组件都生效，可以使用 /deep/ 深度选择器</p>
<p>把 /deep/ 换成 &gt;&gt;&gt;，也可以达到同样的效果</p>
<h3 id="lang-”scss”"><a href="#lang-”scss”" class="headerlink" title="lang=”scss”"></a>lang=”scss”</h3><p>SCSS是一种CSS预处理语言。定义了一种新的专门的编程语言，编译后形成正常的css文件，为css增加一些编程特性，无需考虑浏览器的兼容性（完全兼容css3），让css更加简洁、适应性更强，可读性更佳，更易于代码的维护等诸多好处。CSS预处理语言有SCSS (SASS) 和LESS、POSTCSS</p>
<p>SCSS和SASS有什么区别：</p>
<p>· 文件扩展名不同，文件后缀分别是“.scss”和“.sass”</p>
<p>· sass是以严格缩进语法规则来编写代码的，不包括大括号和分号，而scss的语法和css书写语法类似；</p>
<p>· scss是sass3.0引入的语法，可以理解scss是sass的一个升级版本，是一种SCSS-like语言，弥补了sass和css之间的鸿沟；</p>
<p>注释分为三种：/* */css中显示，//css中不显示，/<em>重要注释!</em>/压缩不会被删掉</p>
<p>@import 命令导入外部sass、scss、css文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt; style lang &#x3D; &quot;scss&quot; &gt;</span><br><span class="line">@import &#39;.&#x2F;test.scss&#39; ; &#x2F;&#x2F;导入外部scss文件</span><br><span class="line">.myText &#123;</span><br><span class="line">   border : 1px solid red ;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F; style &gt;</span><br></pre></td></tr></table></figure>

<p>声明变量：语法是：$+变量名+：+变量值；</p>
<p><code>$color : red ; //声明变量 $color</code></p>
<p>默认变量只需要在变量值后加上 !default , 用来设置默认值 ，对默认变量进行重新声明可以实现覆盖默认值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$color : red !default ; &#x2F;&#x2F;声明默认变量 $color</span><br><span class="line">$color : purple ; &#x2F;&#x2F;根据需求覆盖默认变量</span><br><span class="line">.father01 &#123;</span><br><span class="line">   color : $color ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区分全局变量和局部变量</p>
<p>全局变量是元素外声明的变量，局部变量是在元素里声明的变量，重复声明时局部变量会覆盖全局变量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$height : 200px ; &#x2F;&#x2F;全局变量声明不在大花括号内</span><br><span class="line">$bgcolor : blue ;</span><br><span class="line">body &#123;</span><br><span class="line">   .father01 &#123;  &#x2F;&#x2F;嵌套</span><br><span class="line">      width : $width ;</span><br><span class="line">      height : $height ;</span><br><span class="line">      $border : 1px solid red ; &#x2F;&#x2F;局部变量是声明在元素内的</span><br><span class="line">      border : $border ;</span><br><span class="line">      $bgcolor : purple ; &#x2F;&#x2F;全局变量和局部变量名一致时，调用局部变量进行覆盖</span><br><span class="line">      background-color : $bgcolor ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>局部变量值后加上 !global 关键词可以使得局部变量变成全局变量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">   .father01 &#123;</span><br><span class="line">      width : 200px ;</span><br><span class="line">      height : 200px ;</span><br><span class="line">      $border : 1px solid red !global; &#x2F;&#x2F;使用global关键词将$border变为了全局变量</span><br><span class="line">      border : $border ;</span><br><span class="line">   &#125;</span><br><span class="line">   .father02 &#123;</span><br><span class="line">      width : 300px ;</span><br><span class="line">      height : 300px ;</span><br><span class="line">      border : $border ; &#x2F;&#x2F;使用全局变量</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·变量嵌套引用：即字符串插值，需要使用 #{} 来进行包裹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$left : left ;</span><br><span class="line">.father02 &#123;</span><br><span class="line">   width : 300px ;</span><br><span class="line">   height : 300px ;</span><br><span class="line">   border : $border ; &#x2F;&#x2F;使用全局变量</span><br><span class="line">border- #&#123;$left&#125; : 2px solid purple ; &#x2F;&#x2F;使用字符串插值之前必须先声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·变量计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$left : left ;</span><br><span class="line">.father02 &#123;</span><br><span class="line">   width : 300px ;</span><br><span class="line">   height : 300px ;</span><br><span class="line">   border : $border ; &#x2F;&#x2F;使用全局变量</span><br><span class="line">border- #&#123;$left&#125; : 2px solid purple ; &#x2F;&#x2F;使用字符串插值之前必须先声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·嵌套</p>
<p>  选择器嵌套不多说了</p>
<p>属性嵌套（有相同属性前缀）如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">border:&#123;</span><br><span class="line">   color : red ;</span><br><span class="line">   width : 5px ;</span><br><span class="line">   style : solid ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在嵌套时候可以使用 &amp; 来引用父元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   &amp; &gt; p &#123;   &#x2F;&#x2F;可以编译成CSS的 .container&gt;p &#123;&#125; 效果</span><br><span class="line">      color : purple ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·继承</p>
<p> 继承 .class 使用 @extend</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   color : purple ;</span><br><span class="line">   border : 2px dashed purple ;</span><br><span class="line">&#125;</span><br><span class="line">.myText &#123;</span><br><span class="line">   @extend .container; &#x2F;&#x2F;这里将继承.container类的所有样式</span><br><span class="line">   font-size : 22px ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·SCSS占位符 %</p>
<p>使用% 声明的代码块，如果不被@extend调用的话就不会被编译。编译出来的代码会将相同的代码合并在一起，代码变得十分简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%m5 &#123; background-color : lightblue ;&#125;</span><br><span class="line">.P1 &#123; @extend %m5 ; &#125;</span><br></pre></td></tr></table></figure>

<p>·重复代码块，使用混合@mixin命令定义，以及使用@include调用该mixin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@mixin normalStyle &#123;</span><br><span class="line">   &#x2F;&#x2F;使用@mixin命令定义可重复使用的代码块</span><br><span class="line">   width : 300px ;</span><br><span class="line">   height : 100px ;</span><br><span class="line">   color : black ;</span><br><span class="line">   background-color : lightblue ;</span><br><span class="line">&#125;</span><br><span class="line">.container &#123;</span><br><span class="line">   @include normalStyle ;</span><br><span class="line">   &#x2F;&#x2F;使用@include 命令引用@mixin定义的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 在使用@mixin和@include时，传入参数和默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@mixin normalStyle ( $width , $height , $color , $defaultValue : orange ) &#123;</span><br><span class="line">   width : $width ;</span><br><span class="line">   height : $height ;</span><br><span class="line">   color : $color ;</span><br><span class="line">   background-color : $defaultValue ;</span><br><span class="line">&#125;</span><br><span class="line">.container &#123;</span><br><span class="line">   @include normalStyle ( 300px , 100px , green , lightgray );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>SCSS使用编程式方法 </p>
<p>·条件语句 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   p &#123;</span><br><span class="line">      @if 1 + 1 &lt; 3 &#123;</span><br><span class="line">         border : 1px solid blue ;</span><br><span class="line">      &#125; @else &#123;</span><br><span class="line">         border : 1 ps dashed palevioletred ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·SCSS中的三种循环</p>
<p>1.for循环</p>
<p>在sass中的@for循环有两种方式：</p>
<p>①@for $i from <start> through <end></p>
<p>②@for $i from <start> to <end></p>
<p>其中$i表示变量，start表示开始值，end表示结束值；</p>
<p>through表示包括end这个数值；to表示不包括end这个数值；</p>
<p>2.while循环</p>
<p>只要@while后面的条件为true就会执行，直到表达式值为false时停止循环；</p>
<p>3.each  in循环</p>
<p>就是去遍历一个列表，然后从列表中取出对用值；他的指令形式为：@each $var in <list>($var为变量值，list为sassscript表达式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;for 循环</span><br><span class="line">@for $i from 1 to 5 &#123;</span><br><span class="line">   .item- #&#123;$i&#125; &#123;</span><br><span class="line">      border : #&#123;$i&#125; px solid ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;while 循环</span><br><span class="line">$m : 8 ;</span><br><span class="line">@while $m &gt; 0 &#123;</span><br><span class="line">   .items- #&#123;$m&#125; &#123;</span><br><span class="line">      width : 2em * $m ;</span><br><span class="line">   &#125;</span><br><span class="line">   $m : $m - 2 ;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;这里可以对$m进行运算 让它每次都减去2</span><br><span class="line">&#x2F;&#x2F;each 语法</span><br><span class="line">@each $item in class01 , class02 &#123; &#x2F;&#x2F;$item就是遍历了in关键词后面的类名列</span><br><span class="line">   . #&#123;$item&#125; &#123;</span><br><span class="line">      background-color : purple ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;会编译成 .class01 , .class02 &#123;background-color:purple;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>·使用@function 自定义函数及使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@function double ( $sn )&#123; &#x2F;&#x2F;SCSS允许自定义函数</span><br><span class="line">   @return $sn * 2 ;</span><br><span class="line">&#125;</span><br><span class="line">.myText &#123;</span><br><span class="line">   border : 1px solid red ;</span><br><span class="line">   width : double ( 200px ); &#x2F;&#x2F;使用在SCSS中自定义的函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·可以直接使用SCSS内置的颜色函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.myText &#123;</span><br><span class="line">   color : black ;</span><br><span class="line">   &amp; :hover &#123;</span><br><span class="line">      &#x2F;&#x2F;以下的lighten()、darken()等是SCSS内置的颜色函数</span><br><span class="line">      color : lighten ( #cc3 , 10% ); &#x2F;&#x2F; #d6d65c颜色变浅</span><br><span class="line">      color : darken ( #cc3 , 10% ); &#x2F;&#x2F; #a3a329颜色加深</span><br><span class="line">      color : grayscale ( #cc3 ); &#x2F;&#x2F; #d6d65c</span><br><span class="line">      color : complement ( #cc3 ); &#x2F;&#x2F; #a3a329</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一、IE边框若显若无，须注意，定是高度设置已忘记；<br>二、浮动产生有缘故，若要父层包含住，紧跟浮动要清除，容器自然显其中；<br>三、三像素文本慢移不必慌，高度设置帮你忙；<br>四、兼容各个浏览须注意，默认设置行高可能是隐患；<br>五、独立清除浮动须铭记，行高设无，高设零，设计效果兼浏览；<br>六、学布局须思路，路随布局原理自然直，轻松驾驭html，流水布局少hack，代码清爽，兼容好，友好引擎喜欢迎。<br>七、所有标签皆有源，只是默认各不同，span是无极，无极生两仪—内联和块级，img较特殊，但也遵法理，其他只是改造各不同，一个*号全归原，层叠样式理须多练习，万物皆规律。<br>八、图片链接排版须小心，图片链接文字链接若对齐，padding和vertical-align:middle要设定，虽差微细倒无妨。<br>九、IE浮动双边距，请用display：inline拘。</p>
<p>css三大特性</p>
<p>层叠性：css样式冲突采取的原则(后者覆盖前者)</p>
<p>继承性：对于部分属性样式会有天生的继承</p>
<p>优先级：选择器优先级算法</p>
<p>选择器</p>
<p>在讲这三个特性之前我们需要来全面了解下选择器。</p>
<p>种类</p>
<p>下面我将选择进行划分为三大部分，对于基本选择器我就不说了，主要讲下伪类选择器，组合选择器及它们各自的使用场景。</p>
<p>基本选择器</p>
<p>类名：.box</p>
<p>标签: div</p>
<p>属性: input[type=“eamil”] | a[href*=“<a href="http://www.beige.world”]">http://www.beige.world”]</a></p>
<p>ID: #box</p>
<p>伪类选择器</p>
<p>结构伪类: :nth-child(n) | :nth-of-type(n) | :hover</p>
<p>伪元素: ::before | ::after</p>
<p>组合选择器</p>
<p>相邻兄弟 A + B</p>
<p>普通兄弟 A ~ B</p>
<p>子选择器 A &gt; B</p>
<p>后代选择器 A B</p>
<p>基本选择器</p>
<p>算了还是讲下属性选择器吧🤔，这个选择器我在项目开发中还是用到过的</p>
<p>直接看例子：</p>
<p>/* 匹配包含title属性的a标签 =&gt; */</p>
<p>a[title] {color: purple;}</p>
<p>/* 存在href属性并且属性值为”<a target="_blank" rel="noopener" href="http://beige.world&quot;的标签*/">http://beige.world&quot;的标签*/</a></p>
<p>/* */</p>
<p>a[href=“<a href="http://beige.world”]">http://beige.world”]</a> {color: green;}</p>
<p>/* 存在href属性并且属性值包含”baidu”的标签*/</p>
<p>/*</p>
<p>*/</p>
<p>a[href*=“baidu”] {font-size: 20px;}</p>
<p>/* 存在id属性并且属性值结尾是”-wrapper”的</p>
<p>标签 */</p>
<p>/*</p>
<p>*/</p>
<p>div[id$=”-wrapper”] {display: flex;}</p>
<p>/* 存在class属性并且属性值包含以空格分隔的”logo”的</p>
<p>元素 */</p>
<p>/*</p>
<p>*/</p>
<p>div[class~=“logo”] { padding: 2px; }</p>
<p>复制代码</p>
<p>伪类选择器</p>
<p>结构伪类</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>先讲这两比较作用类似的：nth-child(n) | nth-of-type(n)</p>
<p>结构</p>
<p>1</p>
<p>a1</p>
<p>b1</p>
<p>a2</p>
<p>b2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>复制代码</p>
<p>CSS</p>
<p>// 第一个li =&gt;</p>
<p>1</p>
<p>ul li:first-child { background-color: lightseagreen;}</p>
<p>// 最后一个li =&gt;</p>
<p>5</p>
<p>ul li:last-child { background-color: lightcoral;}</p>
<p>// 第三个li =&gt;</p>
<p>3</p>
<p>ul li:nth-child(3) { background-color: aqua; }</p>
<p>// 第二个li下的第一个div(不是div标签的都不算) =&gt;</p>
<p>b1</p>
<p>ul li:nth-child(2) &gt; div:nth-of-type(1) {background-color: red}</p>
<p>复制代码</p>
<p>它俩的区别</p>
<p>nth-child 选择父元素里面的第几个子元素，不管是第几个类型</p>
<p>nth-of-type 选择指定类型的元素</p>
<p>下面讲讲nth-child()括号中的公式，这个算是这个选择器的亮点了。</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>注意⚠：本质上就是选中第几个子元素</p>
<p>n 可以是数字、关键字、公式</p>
<p>n 如果是数字，就是选中第几个</p>
<p>常见的关键字有 even 偶数、odd 奇数</p>
<p>常见的公式如下(如果 n 是公式，则从 0 开始计算)</p>
<p>但是第 0 个元素或者超出了元素的个数会被忽略</p>
<p>对于这里面的公式平常也用不到太复杂的，我说下我的技巧：nth-child(3n + 3); 这里的n可以看做几个为一组，3可以看做选这组的第几个。</p>
<p>例： nth-child(5n + 3) ：5个为一组，选一组中的第三个。 对于”-“号就表示选择的是前面的。</p>
<p>组合选择器</p>
<p>组合选择器本质上就是通过连接符来对两个选择器进行组合</p>
<p>子选择器 A &gt; B</p>
<p>后代选择器 A B</p>
<p>上面这两我就不说了，相信大家都用烂了。主要说说下面这两个。</p>
<p>相邻兄弟 A + B</p>
<p>普通兄弟 A ~ B</p>
<p>结构</p>
<p>One</p>
<p>Two!</p>
<p>Three</p>
<p>pppp</p>
<p>One2</p>
<p>pppp1</p>
<p>Two2!</p>
<p>pppp2</p>
<p>复制代码</p>
<p>选择器解析</p>
<p>复制代码</p>
<p>好了，在讲完这些选择器之后我们来看看它们的使用场景。</p>
<p>组合选择器可以用于：hover伪类操纵自己包含的子元素及以外的元素。举个例子</p>
<p>元素1</p>
<p>元素2</p>
<p>元素3</p>
<p>元素2</p>
<p>同级元素1</p>
<p>同级元素2</p>
<p>同级元素3</p>
<p>复制代码</p>
<p>#a:hover &gt; #b{…}</p>
<p>#a:hover ~ div{…} // 鼠标停留在a元素的时候让所有同层级元素有某某样式</p>
<p>// 防止选择器层级替换了下面的样式</p>
<p>#a:hover + #c{…} // 鼠标停留在a元素的时候让同层级中的c元素有某某样式</p>
<p>#a:hover + #c &gt; #b{…} // 鼠标停留在a元素的时候让同层级中的c元素下的b元素有某某样式</p>
<p>复制代码</p>
<p>上面这两选择器在做一些特效页的时候应该是会用到的。</p>
<p>综合例子</p>
<p>效果</p>
<p>结构</p>
<p>标题名称</p>
<p>Bei Ge</p>
<p>这里放内容简介，内容简介,这里放内容简介，内容简介,这里放内容简介，内容简介</p>
<p>…</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>复制代码</p>
<p>样式</p>
<p>布局样式</p>
<p>复制代码</p>
<p>定义了一个animation动画</p>
<p>@keyframes textAnimation {<br>/* 0% {<br>transform: translateX(150%);</p>
<p>} */</p>
<p>100% {<br>transform: translateX(0);</p>
<p>}</p>
<p>}</p>
<p>复制代码</p>
<p>悬浮在盒子设置样式</p>
<p>.img-box:hover {<br>transform: scale(1.1);</p>
<p>box-shadow: 2px 2px 13px 3px #ccc;</p>
<p>}</p>
<p>.img-box:hover img {<br>opacity: .5;</p>
<p>}</p>
<p>.img-box:hover .cover h3 {<br>opacity: 1;</p>
<p>}</p>
<p>.img-box:hover p {<br>animation: textAnimation .6s ease-out forwards;</p>
<p>/* forwards让动画停留在最后一帧 */</p>
<p>}</p>
<p>.img-box:hover .cover .handle {<br>bottom: 5px;</p>
<p>}</p>
<p>.enter-box:hover ~ .img-box {<br>background-color: transparent;</p>
<p>color: wheat;</p>
<p>}</p>
<p>.enter-box:hover + .img-box {<br>color: red;</p>
<p>}</p>
<p>复制代码</p>
<p>上面这个例子有些还没有讲，但是相信大家之前也都学过，后文中也会说。主要会说些细节方面的东西。</p>
<p>flex(弹性布局)</p>
<p>transform: translate3D rodate3D</p>
<p>animation(设定动画)</p>
<p>3D or 透视(perspective)</p>
<p>这里需要注意在使用伪类Hover的注意点，在使用他影响子级元素的时候尽量将选择器写全。例：</p>
<p>先看下效果😗</p>
<p>上面的效果相信大家都能写出来，所以我要讲的肯定不是怎么去实现这个效果，我要说下使用Hover时的一些细节。</p>
<p>结构比较简单</p>
<p>flex类名用于布局实现重置和水平居中，box: 绿色盒子;center: 紫色盒子 inner: 橙黄色盒子</p>
<p>复制代码</p>
<p>我们用了一个:hover让鼠标虚浮的时候让盒子变红</p>
<p>.box:hover div {<br>background-color: red;</p>
<p>}</p>
<p>复制代码</p>
<p>这里有一个问题不知道大家想过没有，为什么我这段代码只让center盒子变红了，inner为什么没有变红呢???</p>
<p>展开查看</p>
<p>因为CSS选择器的优先级!复制代码</p>
<p>我们在实现的时候一般都会像下面这样写吧，这个时候使用伪类选择器改变元素样式的时候就要注意选择器优先级的问题了。</p>
<p>.box .center {<br>width: 150px;</p>
<p>height: 150px;</p>
<p>background-color: blueviolet;</p>
<p>}</p>
<p>.box .center .inner {<br>width: 100px;</p>
<p>height: 100px;</p>
<p>background-color: coral;</p>
<p>}</p>
<p>复制代码</p>
<p>这段代码的优先级比 .box .center高，所以他也就只能覆盖它了。</p>
<p>.box:hover div {<br>background-color: red;</p>
<p>}</p>
<p>复制代码</p>
<p>相信我们很多人如果在写鼠标悬浮大盒子让最里面的inner盒子变色的时候，都会这么写吧：</p>
<p>.box:hover .inner {<br>background-color: red;</p>
<p>}</p>
<p>复制代码</p>
<p>有用吗?没用!</p>
<p>注意⚠: 优先级还是没有.box .center .inner高。</p>
<p>层叠性</p>
<p>所谓层叠性是指多种CSS样式的叠加。是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</p>
<p>原则：</p>
<p>样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。</p>
<p>样式不冲突，不会层叠</p>
<p>CSS层叠性最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。</p>
<p>复制代码</p>
<p>继承性</p>
<p>：子标签会继承父标签的某些样式，如文本颜色和字号。 想要设置一个可继承的属性，只需将它应用于父元素即可。简单的理解就是： 子承父业</p>
<p>CSS继承性口诀： 龙生龙，凤生凤，老鼠生的孩子会打洞</p>
<p>复制代码</p>
<p>我们恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多后代元素都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。</p>
<p>注意点：在CSS的继承中不仅仅是儿子可以继承, 只要是后代都可以继承</p>
<p>可继承的属性</p>
<p>控制继承</p>
<p>注意点: 对于天生自带的继承属性我们可以控制它是否需要继承</p>
<p>四个属性</p>
<p>inherit: 被应用属性继承父级的该属性(默认就是该值)</p>
<p>initial初始化，把应用属性初始为它默认的样式，并且排除继承的干扰(默认会继承的属性也不在默认继承，而是表现出没有任何设置时候的默认样式)</p>
<p>unset：意思是恢复其原本的继承方式。对color属性而言，就相当于inherit;而对于诸如border这样默认不继承的属性，就相当于initial。</p>
<p>revert: 效果等同于unset且浏览器支持有限，这里不做演示</p>
<p>效果图</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>演示</p>
<p>Default link color</p>
<p>Inherit the link color</p>
<p>Reset the link color</p>
<p>Unset the link color</p>
<p>复制代码</p>
<p>default中的a标签没有写默认为inherit属性，但是使用了浏览器预设样式表：可以理解为浏览器帮我们为写了个style，其优先级自然就高于其父元素了。</p>
<p>inherit中的a标签在行内写了inherit，于是使用其父(或祖父，etc)元素的颜色值，在这里是绿色;</p>
<p>initial中的a标签使用color属性初始值(黑色), 注意不要混淆属性初始值和浏览器样式表指定值，样式预设表是浏览器事先写好的样式，但是我color默认值就是黑色啊。</p>
<p>unset，意思是恢复其原本的继承方式。对color属性而言，就相当于inherit;而对于诸如border这样默认不继承的属性，就相当于initial。</p>
<p>如果我们需要控制元素所有属性的继承使用all属性</p>
<p>.inherit a {<br>all: initial;</p>
<p>/* 将所有的属性都恢复成默认值(天生继承也不再继承) */</p>
<p>/* 行内设置过的除外：你的层级干不过人家 */</p>
<p>}</p>
<p>复制代码</p>
<p>继承的权重是0</p>
<p>这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。</p>
<p>(1) 如果选中了，那么以上面的公式来计权重。谁大听谁的。(2) 如果没有选中，那么权重是0，因为继承的权重为0.</p>
<p>控制继承在我们封装自己的组件的时候是会用到的，我们在封装组件需要沿用样式，有些默认情况下不可继承父元素的属性：box-sizing，这个其实用的就很多。</p>
<p>优先级</p>
<p>要想了解优先级，肯定得了解选择器;但是选择器非常多的，前面列举的是日常开发用的比较多，其他的你可能一辈子都用不到，这里贴出C1~C4的选择器，感兴趣的同学可以看看。</p>
<p>定义CSS样式时，经常出现两个或更多选择器应用在同一元素上，此时，</p>
<p>选择器相同，则执行层叠性(后者覆盖前者)</p>
<p>选择器不同，就会出现优先级的问题。</p>
<p>权重计算公式</p>
<p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity(特殊性)</p>
<p>标签选择器计算权重公式</p>
<p>继承或者 *0,0,0,0</p>
<p>每个元素(标签选择器)0,0,0,1</p>
<p>每个类，结构伪类(如:hover),属性选择器[type=“number”]0,0,1,0</p>
<p>每个ID0,1,0,0</p>
<p>每个行内样式 style=””1,0,0,0</p>
<p>h1 + p::first-line0,0,0,3</p>
<p>li &gt; a[href*=“beige.world”] &gt; .inline-warning0,0,2,2</p>
<p>每个!important 重要的∞ 无穷大</p>
<p>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</p>
<p>常用的选择器记法：</p>
<p>行内: 1,0,0,0</p>
<p>#id: 0,1,0,0</p>
<p>.class | :hover | :nth-child(): 0,0,1,0 (:hover这种一个冒号叫结构伪类)</p>
<p>::after | ::before | ::first-line: 0,0,0,1 (这种两冒号的叫伪元素，在书写的时候虽然你可以写一个冒号但是浏览器还是给你补上去了，本质上就是两冒号)</p>
<p>权重叠加</p>
<p>我们经常用组合选择器，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。</p>
<p>就是一个简单的加法计算</p>
<p>div ul li ——&gt; 0,0,0,3</p>
<p>.nav ul li ——&gt; 0,0,1,2</p>
<p>a:hover —–—&gt; 0,0,1,1</p>
<p>.nav a ——&gt; 0,0,1,1</p>
<p>注意⚠: 数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 = 0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</p>
<p>important适用优先级💡</p>
<p>#id .box div {<br>color: red !important;</p>
<p>}</p>
<p>#id div.box div {<br>color: green !important; // 使用这个选择器中的颜色</p>
<p>}</p>
<p>复制代码</p>
<p>通关答题</p>
<p>下面来几道题，全对才算通过了噢😗</p>
<p>文字</p>
<p>复制代码</p>
<p>什么颜色??</p>
<p>展开查看答案</p>
<p>yellow 上面两选择器的层级都是一样的, 后者覆盖前者 复制代码</p>
<p>试问这行字体是什么颜色的?</p>
<p>复制代码</p>
<p>展开查看答案</p>
<p>blue 复制代码</p>
<p>123</p>
<p>复制代码</p>
<p>展开查看答案</p>
<p>字体：80，有文字阴影，真实内容的宽：290px 高190px复制代码</p>
<p>讲下这最后一题</p>
<p>文字阴影有：因为从父元素中继承到了,字体: 80px;</p>
<p>真实内容宽290px, 高190px</p>
<p>常问的属性flex(弹性布局)</p>
<p>transform: translate3D rodate3D</p>
<p>animation(设定动画)</p>
<p>3D or 透视(perspective)</p>
<p>flex</p>
<p>flex布局相信大家也都用烂了，用来让盒子垂直和水平居中好用的一批</p>
<p>父项常用属性</p>
<p>flex-direction：设置主轴的方向</p>
<p>justify-content：设置主轴上的子元素排列方式</p>
<p>flex-wrap：设置子元素是否换行</p>
<p>align-content：设置侧轴上的子元素的排列方式(多行)</p>
<p>align-items：设置侧轴上的子元素排列方式(单行)</p>
<p>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</p>
<p>flex-direction</p>
<p>在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴</p>
<p>默认主轴方向就是 x 轴方向，水平向右</p>
<p>默认侧轴方向就是 y 轴方向，水平向下</p>
<p>&lt;img src=</p>
<p>“ width=“185” height=“30” align=””&gt;</p>
<p>： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</p>
<p>flex-wrap设置是否换行</p>
<p>默认情况下，项目都排在一条线(又称”轴线”)上。flex-wrap属性定义，flex布局中默认是不换行的。</p>
<p>nowrap 不换行</p>
<p>wrap 换行</p>
<p>justify-content 设置主轴上的子元素排列方式</p>
<p>&lt;img src=</p>
<p>“ width=“185” height=“30” align=””&gt;</p>
<p>效果图</p>
<p>： 这里讲下space-around和space-evenly</p>
<p>space-around：项目之间的间距为左右两侧项目到容器间距的2倍。</p>
<p>space-evenly：项目两侧之间的间距与项目与容器两侧的间距相等，相当于除去项目宽度和容器和项目的两侧间距，剩下的平均分配了剩余宽度作为项目左右margin。</p>
<p>**设置侧轴上的子元素排列方式：align-items(单行)/align-content(多行) **</p>
<p>上图写能设置多行只能用于子项出现 换行 的情况(多行)，在单行下是没有效果的。</p>
<p>效果跟上面是一样的只不过是方向换了，上面是元素在主轴上排列，这个是在侧抽上，至于侧轴是不是Y轴就看你的flex-direciton怎么设置的了</p>
<p>子项常见属性</p>
<p>flex(复合属性): 默认: flex: 0 1 auto;</p>
<p>flex-grow</p>
<p>flex-shrink</p>
<p>flex-basis</p>
<p>align-self：控制子项自己在侧轴的排列方式</p>
<p>order：定义子项的排列顺序(前后顺序), 0是第一个</p>
<p>flex-grow</p>
<p>默认0，用于决定项目在有剩余空间的情况下是否放大，默认不放大;注意，即便设置了固定宽度，也会放大。</p>
<p>假设第一个项目默认为0，第二个项目为flex-grow:2，最后一个项目为1，则第二个项目在放大时所占空间是最后项目的两倍。</p>
<p>可以这么理解:</p>
<p>flex: 1 =&gt; 在剩余的空间里我就占一份</p>
<p>flex: 2 =&gt; 在剩余的空间里我就占两份</p>
<p>flex: 3 =&gt; 在剩余的空间里我就占三份</p>
<p>假设三个盒子分别都设置了上面的属性: 那就将剩余空间分成6份, 各占自己的份数</p>
<p>假设前两个没有设置, 就最后一个设置了flex: 3 === flex: 1, 那就将剩余空间都给它</p>
<p>复制代码</p>
<p>flex-shrink</p>
<p>默认1，用于决定项目在空间不足时是否缩小，默认项目都是1，即空间不足时大家一起等比缩小;注意，即便设置了固定宽度，也会缩小。但如果某个项目flex-shrink设置为0，则即便空间不够，自身也不缩小。</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>上图中第二个项目flex-shrink为0，所以自身不会缩小。</p>
<p>flex-basis</p>
<p>默认auto，用于设置项目宽度，默认auto时，项目会保持默认宽度，或者以width为自身的宽度，但如果设置了flex-basis，权重会width属性高，因此会覆盖widtn属性。</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>上图中先设置了flex-basis属性，后设置了width属性，但宽度依旧以flex-basis属性为准。</p>
<p>注意⚠: 如果当容器中有多个盒子并且还宽度100%, flex-basis会被影响, 如下图</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>解决办法就是在我们设置flex-basis宽度时, 最好给他设置flex-shrink为0不缩放</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>transform</p>
<p>2D的属性相信大家都会用了, 本文主要深究transform的3D属性</p>
<p>透视：perspctive</p>
<p>3D呈现：transfrom-style</p>
<p>3D 位移：translate3d(x, y, z)</p>
<p>3D旋转：rotate3d(x, y, z)</p>
<p>透视(perspective)</p>
<p>在讲3D之间先来了解一下透视(视距)，只有了解了透视我们才能理解3D的物体投影在2D平面上</p>
<p>透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离</p>
<p>实际上模仿人类的视觉位置，可视为安排一直眼睛去看</p>
<p>距离透视点越近的在电脑平面成像越大，越远成像越小</p>
<p>透视的单位是像素</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>注意: 透视需要写在被视察元素的父盒子上面</p>
<p>拿图说话👇</p>
<p>d：就是视距，视距就是指人的眼睛到屏幕的距离</p>
<p>z：就是 z 轴，z 轴越大(正值)，我们看到的物体就越大</p>
<p>来个栗子🌰</p>
<p>给实例的父元素设置: perspective: 200px;</p>
<p>复制代码</p>
<p>上面我们在div的父盒子上设置了perspective，也就是说从3D成像的角度来讲我们人眼距离屏幕div是200的视距，translate3D设置Z轴让div往前挪了100，视距变小距离我们人眼距离也就越小，所以看到的div也就变大了。 (可以想像成在500米远看见的人， 和5米看见的人。)</p>
<p>translate3d(x, y, z)</p>
<p>3D的特点</p>
<p>近大远小</p>
<p>物体和面遮挡不可见</p>
<p>三维坐标系</p>
<p>x 轴：水平向右 – 注意：x 轴右边是正值，左边是负值</p>
<p>y 轴：垂直向下 – 注意：y 轴下面是正值，上面是负值</p>
<p>z 轴：垂直屏幕 – 注意：往外边的是正值，往里面的是负值</p>
<p>“ alt=” “ width=“35” height=“30” align=””&gt;</p>
<p>3D 呈现 transform-style</p>
<p>transform-style：控制子元素是否开启三维立体环境，代码写给父级，但是影响的是子盒子</p>
<p>transform-style: flat 代表子元素不开启 3D 立体空间，默认的</p>
<p>transform-style: preserve-3d 子元素开启立体空间</p>
<p>效果图</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>body {<br>perspective: 500px;</p>
<p>}</p>
<p>.box {<br>position: relative;</p>
<p>width: 200px;</p>
<p>height: 200px;</p>
<p>margin: 100px auto;</p>
<p>transition: all 2s;</p>
<p>/* 让子元素保持3d立体空间环境 */</p>
<p>transform-style: preserve-3d;</p>
<p>}</p>
<p>.box:hover {<br>transform: rotateY(60deg);</p>
<p>}</p>
<p>.box div {<br>position: absolute;</p>
<p>top: 0;</p>
<p>left: 0;</p>
<p>width: 100%;</p>
<p>height: 100%;</p>
<p>background-color: pink;</p>
<p>}</p>
<p>.box div:last-child {<br>background-color: purple;</p>
<p>transform: rotateX(60deg);</p>
<p>}</p>
<p>复制代码</p>
<p>rotate3d(x, y, z)</p>
<p>3D 旋转指可以让元素在三维平面内沿着 x 轴、y 轴、z 轴 或者自定义轴进行旋转</p>
<p>transform: rotate3d(x, y, z, 45deg)` – 沿着自定义轴旋转 45 deg 为角度</p>
<p>例子：</p>
<p>公众号:</p>
<p>前端自学驿站</p>
<p>复制代码</p>
<p>ul li {<br>float: left;</p>
<p>margin: 0 5px;</p>
<p>width: 120px;</p>
<p>height: 35px;</p>
<p>list-style: none;</p>
<p>/* 一会我们需要给box 旋转 也需要透视 干脆给li加 里面的子盒子都有透视效果 */</p>
<p>perspective: 500px;</p>
<p>}</p>
<p>.box {<br>position: relative;</p>
<p>width: 100%;</p>
<p>height: 100%;</p>
<p>transform-style: preserve-3d;</p>
<p>transition: all .4s;</p>
<p>}</p>
<p>.box:hover {<br>transform: rotateX(90deg);</p>
<p>}</p>
<p>.front,</p>
<p>.bottom {<br>position: absolute;</p>
<p>left: 0;</p>
<p>top: 0;</p>
<p>width: 100%;</p>
<p>height: 100%;</p>
<p>}</p>
<p>.front {<br>background-color: pink;</p>
<p>z-index: 1;</p>
<p>transform: translateZ(17.5px);</p>
<p>}</p>
<p>.bottom {<br>background-color: purple;</p>
<p>/* 这个x轴一定是负值 */</p>
<p>/* 我们如果有移动 或者其他样式，必须先写我们的移动 */</p>
<p>transform: translateY(17.5px) rotateX(-90deg);</p>
<p>}</p>
<p>复制代码</p>
<p>animation</p>
<p>动画(animation)是 CSS3 中最具颠覆性的特征之一，可通过设置多个节点来精确的控制一个或者一组动画，从而实现复杂的动画效果, 先定义动画在调用定义好的动画</p>
<p>动画序列</p>
<p>0% 是动画的开始，100 % 是动画的完成，这样的规则就是动画序列</p>
<p>在 @keyframs 中规定某项 CSS 样式，就由创建当前样式逐渐改为新样式的动画效果</p>
<p>动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数</p>
<p>用百分比来规定变化发生的时间，或用 from 和 to，等同于 0% 和 100%</p>
<p>@keyframes move{<br>0% {<br>transform: translate(0px)</p>
<p>}</p>
<p>form {<br>transform: translate(0px)</p>
<p>}</p>
<p>100% {<br>transform: translate(500px, 0)</p>
<p>}</p>
<p>to {<br>transform: translate(500px, 0)</p>
<p>}</p>
<p>}</p>
<p>复制代码</p>
<p>动画常见属性</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>动画简写方式</p>
<p>/* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */</p>
<p>animation: name duration timing-function delay iteration-count direction fill-mode</p>
<p>复制代码</p>
<p>除了名字，持续时间，何时开始有严格顺序要求其它随意</p>
<p>CSS实现扫描二维码</p>
<p>效果</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>代码篇幅过长我放到gitHub仓库了，大家可以pull下来自行研究。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/it-beige/blog">https://github.com/it-beige/blog</a></p>
<p>面试常问题BFC相关</p>
<p>BFC(Block formatting context)直译为”块级格式化上下文”。</p>
<p>在讲BFC之前得先说下display的属性值，只有它符合成为条件才资格触发BFC机制</p>
<p>“ alt=“display属性值” width=“113” height=“30” align=””&gt;</p>
<p>那些属性值会具有BFC的条件</p>
<p>不是所有的元素模式都能产生BFC，w3c 规范： display 属性为 block, list-item, table 的元素，会产生BFC.</p>
<p>大家有没有发现这个三个都是用来布局最为合理的元素，因为他们就是用来可视化布局。注意其他的，display属性，比如 line 等等，他们创建的是 IFC ，我们下面研究。</p>
<p>这个BFC 有着具体的布局特性：</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>有宽度和高度，有 外边距margin 有内边距padding 有边框 border。就好比，你有了练习武术的体格了。 有潜力，有资质。</p>
<p>什么情况下可以让元素产生BFC</p>
<p>以上盒子具有BFC条件了，就是说有资质了，但是怎样触发才会产生BFC，从而创造这个封闭的环境呢?</p>
<p>就好比，你光有资质还不行，你需要一定额外效果才能出发的武学潜力，要么你掉到悬崖下面，捡到了一本九阴真经，要么你学习葵花宝典，欲练此功必先…</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>同样，要给这些元素添加如下属性就可以触发BFC。</p>
<p>float属性不为none</p>
<p>position为absolute或fixed</p>
<p>display为inline-block, table-cell, table-caption, flex, inline-flex</p>
<p>overflow不为visible。</p>
<p>BFC元素所具有的特性</p>
<p>BFC布局规则特性：</p>
<p>在BFC中，盒子从顶端开始垂直地一个接一个地排列</p>
<p>盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</p>
<p>在BFC中，每一个盒子的左外边缘(margin-left)会触碰到容器的左边缘(border-left)(对于从右到左的格式来说，则触碰到右边缘)。</p>
<p>BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</p>
<p>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度</p>
<p>它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<p>白话文： 孩子在家里愿意怎么折腾都行，但是出了家门口，你就的乖乖的，不能影响外面的任何人。</p>
<p>复制代码</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>BFC的主要用途</p>
<p>(1) 清除元素内部浮动</p>
<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式</p>
<p>主要用到</p>
<p>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</p>
<p>复制代码</p>
<p>(2) 解决外边距合并(塌陷)问题</p>
<p>主要用到</p>
<p>盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</p>
<p>复制代码</p>
<p>属于同一个sBFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>(3) 制作右侧自适应的盒子问题</p>
<p>主要用到</p>
<p>普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文</p>
<p>复制代码</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>BFC 总结</p>
<p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等，因此，有了这个特性，我们布局的时候就不会出现意外情况了。</p>
<p>IFC相关</p>
<p>IFC(inline Formatting Context)叫做“行级格式化上下”相对BFC比较简单且问的也不是很多，这里大该做个了解</p>
<p>布局规则如下：</p>
<p>内部的盒子会在水平方向，一个个地放置(默认就是IFC);</p>
<p>IFC的高度，由里面最高盒子的高度决定(里面的内容会撑开父盒子);</p>
<p>当一行不够放置的时候会自动切换到下一行;</p>
<p>哪些属性开启了性能加速</p>
<p>何为硬件加速：就是将浏览器的渲染过程交给GPU(Graphics Processing Unit)处理，而不是使用自带的比较慢的渲染器。这样就可以使得animation与transition更加顺畅</p>
<p>我们可以在浏览器中用CSS开启硬件加速，使GPU发挥功能，从而提升性能</p>
<p>所谓GPU，就是图形处理器的缩写，相当于PC中的显卡。手机中的GPU也是为了对图形、图像处理而存在的，所谓强制渲染，就是hwa(hardware acceleration硬件加载)的一种，其存在的意义就是为了分担cpu的负担，其原理是通过GPU对软件图形的处理来减轻CPU的负担。从而使应用软件能够以更快的速度被处理，以达到提速的目的。</p>
<p>硬件加速的原理</p>
<p>浏览器接收到页面文档后，会将文档中的标记语言解析为DOM树。DOM树和CSS结合后形成浏览器构建页面的渲染树。渲染树中包含大量的渲染元素，每个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理，而图层在GPU中transform是不会触发repaint的，最终这些使用transform的图层都会由独立的合成器进程进行处理, CSS transform会创建了一个新的复合图层，可以被GPU直接用来执行transform操作。</p>
<p>浏览器什么时候会创建一个独立的复合图层呢?事实上一般是在以下几种情况下：</p>
<p>3D或者CSS transform</p>
<p>和标签</p>
<p>css filters(滤镜效果)</p>
<p>元素覆盖时，比如使用了z-index属性</p>
<p>为什么硬件加速会使页面流畅</p>
<p>因为transform属性不会触发浏览器的repaint(重绘)，而绝对定位absolute中的left和top则会一直触发repaint(重绘)。</p>
<p>为什么transform没有触发repaint呢?</p>
<p>简而言之，transform动画由GPU控制，支持硬件加载，并不需要软件方面的渲染。并不是所有的CSS属性都能触发GPU的硬件加载，事实上只有少数的属性可以，比如transform、opacity、filter</p>
<p>如何用CSS开启硬件加速</p>
<p>CSS animation、transform以及transition不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行，那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。</p>
<p>当浏览器检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素是3D变化。</p>
<p>.cube{<br>translate3d(250px,250px,250px);</p>
<p>rotate3d(250px,250px,250px,-120deg)</p>
<p>scale3d(0.5,0.5,0.5);</p>
<p>}</p>
<p>复制代码</p>
<p>可能在一些情况下，我们并不需要对元素应用3D变幻的效果，那怎么办呢?这时候我们可以使用“欺骗”浏览器来开启硬件加速。虽然我们可能不想对元素应用3D变幻，可我们一样可以开启3D引擎。例如我们可以用transform:translateZ(0);来开启硬件加速</p>
<p>.cube{<br>transform: translateZ(0);</p>
<p>}</p>
<p>复制代码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/05/8.3.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/" data-id="ckw61sdx8006yoswdcrkye0qw" data-title="网页前端之CSS" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-8.2.网页前端之HTML" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/03/8.2.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BHTML/" class="article-date">
  <time class="dt-published" datetime="2021-04-03T01:43:19.000Z" itemprop="datePublished">2021-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/03/8.2.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BHTML/">网页前端之HTML</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lt-HTML-gt"><a href="#lt-HTML-gt" class="headerlink" title="&lt;HTML&gt;"></a><code>&lt;HTML&gt;</code></h1><p><code>&lt;html&gt;</code>标签相当于java类的大括号</p>
<p>HTML：(Hyper Text Markup Language)超文本标记语言,是用来写网页的，是设计页面的基础。</p>
<p>HTML是由标签所组成的语言，能展示超文本效果,由头和体组成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>需要展示给用户看的信息内容<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTML文件的扩展名为html或者htm:htm是老的命名规范，html是新的</p>
<p>HTML文件由浏览器直接解析运行，无需编译，直接由上到下依次解析执行</p>
<p>HTML标签通常由开始标签和结束标签组成，开始标签和结束标签之间的内容叫做内容体。</p>
<p>没有内容体的标签叫做空标签。仅由一个标签组成，例如：<code>&lt;br/&gt;</code> 自关闭</p>
<p>HTML标签不区分大小写，为了方便阅读，建议小写</p>
<p>HTML标签是有属性的，格式为属性名=“属性值”，属性值用引号引起来(单引号双引号都可以，建议双引号)</p>
<p>HTML标签建议包裹嵌套，不建议交叉嵌套</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p><code>&lt;!--HTML注释内容--&gt;</code>用于注释HTML源码，不在HTML效果中展示</p>
<h1 id="lt-head-gt"><a href="#lt-head-gt" class="headerlink" title="&lt;head&gt;"></a><code>&lt;head&gt;</code></h1><p><code>&lt;head&gt;</code>中存放的是网页的说明性内容</p>
<h2 id="lt-meta-gt"><a href="#lt-meta-gt" class="headerlink" title="&lt;meta&gt;"></a><code>&lt;meta&gt;</code></h2><p>是 HTML 语言头部的一个辅助性标签，我们可以定义页面编码语言、搜索引擎优化、自动刷新并指向新的页面、控制页面缓冲、响应式视窗等。·</p>
<p><code>&lt;meta&gt;</code> 元素可提供有关页面的元信息（meta-information,元数据总是以名称/值的形式被成对传递的），比如针对搜索引擎和更新频度的描述和关键词。</p>
<p><code>&lt;meta&gt;</code> 标签位于文档的头部，不包含任何内容。</p>
<p><code>&lt;meta&gt;</code> 标签的属性定义了与文档相关联的名称/值对。</p>
<p>整体来看，HTML5之前，meta标签只有两个主要属性，分别是 name 属性和 http-equiv 属性。 HTML5新添加”charset”</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;参数&quot;</span> <span class="attr">content</span>=<span class="string">&quot;参数值&quot;</span> /&gt;</span>  </span><br><span class="line">//name属性主要用于描述网页，对应属性是 content ，以便于搜索引擎机器人查找、分类（目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类）</span><br><span class="line">这里的name参数可以是多种值，对应不同效果：</span><br><span class="line">Keywords（关键字）</span><br><span class="line">Description（简介）</span><br><span class="line">robots（机器人向导）   用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引</span><br><span class="line">参数为 all ：默认值，文件将被检索，且页面上的链接可以被查询； 参数为 none ：文件将不被检索，且页面上的链接不可以被查询； 参数为 index ：文件将被检索； 参数为 follow ：页面上的链接可以被查询； 参数为 noindex ：文件将不被检索，但页面上的链接可以被查询； 参数为 nofollow ：文件将被检索，但页面上的链接不可以被查询；</span><br><span class="line">author（作者）</span><br><span class="line">copyright（版权）</span><br><span class="line">generator（编辑器）</span><br><span class="line">revisit-after（网站重访）</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;参数&quot;</span>  <span class="attr">content</span>=<span class="string">&quot;参数值&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;参数&quot;</span>  <span class="attr">content</span>=<span class="string">&quot;参数值&quot;</span>/&gt;</span></span><br><span class="line">//http-equiv类似于HTTP的头部协议，它回应给浏览器一些有用的信息，以帮助正确和精确地显示网页内容。与之对应的属性值为content，content中的内容其实就是各个参数的变量值</span><br><span class="line">Expires（期限）  指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新传输  必须使用GMT的时间格式，或者直接设为0（数字表示多久后过期）</span><br><span class="line">Pragma（cache模式） 禁止浏览器从本地计算机的缓存中访问页面内容   网页不保存在缓存中，每次访问都刷新页面。这样设定，访问者将无法脱机浏览</span><br><span class="line">Refresh（刷新）自动刷新并指向新页面 `<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span><span class="attr">content</span>=<span class="string">&quot;5; url=http://www.baidu.com/&quot;</span>/&gt;</span>`</span><br><span class="line">Set-Cookie（cookie设定）</span><br><span class="line">Window-target（显示窗口的设定） 强制页面在当前窗口以独立页面显示,可以用来防止别人在框架里调用你的页面</span><br><span class="line">content-Type（显示字符集的设定）设定页面使用的字符集，一般不用</span><br><span class="line">content-Language（显示语言的设定）</span><br><span class="line">http-equiv=&quot;imagetoolbar&quot; 指定是否显示图片工具栏，当为false代表不显示，当为true代表显示</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="&lt;link&gt;"></a><code>&lt;link&gt;</code></h2><p><code>&lt;link&gt;</code> 标签定义该文档与外部资源的关系。最常见的用途是链接样式表，也可以被用来创建站点图标(比如PC端的“favicon”图标和移动设备上用以显示在主屏幕的图标)</p>
<p>网站站点的小图标：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;images/logo.png&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/png&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;1651*1024&quot;</span>/&gt;</span>  指定格式为icon，然后类型指定图片，href放资源位置，可以设置大小</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span> /&gt;</span>  指定格式为icon，类型指定为ico，href放资源位置</span><br></pre></td></tr></table></figure>

<h2 id="lt-script-gt"><a href="#lt-script-gt" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h2><p>1、async  表示立即下载该脚本，但不妨碍页面中的其他操作(比如：下载其他资源或等待加载其他脚本)，只对外部文件有效。<br>2、charset 属性与 src 属性一起使用，告诉浏览器用来编码这个 javascript 程序的字符集。它的值是任何一个 ISO 标准字符集编码的名称。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。</p>
<p>3、defer 表示脚本可以延迟到文档完全被解析和显示后再执行。只对外部文件有效。<br>4、language 已废弃。 原来用于表示编写代码用的脚本语言，因大多数浏览器都会忽略这个属性，因此也没必要再用了。<br>5、src 表示包含要执行代码的外部文件。</p>
<p>6、type 可以看成language的替代属性；表示编写代码使用的脚本语言的内容类型。默认值为text/javascript</p>
<p>注意：<br>1、传统做法是将所有的<code>&lt;script&gt;</code>元素都放在页面的<code>&lt;head&gt;</code>元素中，但是这样页面响应就会比较慢（必须等到全部的Javascript代码都被下载、解析和执行完后，才能呈现页面内容）。现在的做法一般都是将Javascript引用放在<code>&lt;body&gt;</code>元素中页面内容的后面。</p>
<p>2、defer和asyncd的作用基本相似。定义defer=“defer”的脚本将延迟到浏览器遇到<code>&lt;/html&gt;</code>标签后再执行，原则上是延迟脚本还是按照原来的顺序执行，但是实际上执行的顺序不一定按照指定顺序执行。但是HTML5（以后称为H5）中已经明确规定,defer属性只使用于外部脚本文件，因此支持H5的实现会忽略给嵌入脚本设置的defer属性。async也只适用于外部脚本文件，并告诉浏览器立即下载脚本文件。但与defer不同的是，它并不保证按照指定顺序执行，又称为异步脚本标签（各脚本文件相互独立，互不依赖）</p>
<h1 id="lt-body-gt"><a href="#lt-body-gt" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h1><p>分类：</p>
<p>1.单标签：在⾃身标签标识结束，主要应⽤场景为<strong>功能性</strong>标签</p>
<p>双标签：有成对的结束标识，主要应⽤场景为<strong>内容性</strong>标签</p>
<p>2.行标签：⼜名<strong>内联标签</strong>，内联标签⾃身不具备宽⾼，可以和其他元素保持在同一行。根据内容多少来占用行内空间，不会自动换行。例：<code>&lt;br&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;，&lt;span&gt;</code>strong，u（下划线），em(强调)，i(斜体)，sub(下标),sup(上标)</p>
<p>块标签：又名<strong>块级标签</strong>，块标签可以设置宽⾼，不可以和其他元素保持在同一行，通常独⾃占据⼀⾏。以区域块方式出现，每个块标签独自占据一整行或多整行，块结束会自动换行。例：<code>&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;，&lt;div&gt;</code>li，dl，dt，dd,form,hr,pre</p>
<p>行内块级标签：可以和其他元素保持在在一行，还能能设置宽高。例：textarea，input，img，button</p>
<p>所谓的行级标签，块级标签，其实可以根据需要，在开发中通过css样式互相转换。即通过设置display属性，它的属性值中，inline（元素以行内标签进行展示），block（元素以块级标签进行展示），inline-block（元素以行内块级标签进行展示）</p>
<p>3.单一标签：单独出现，表示具体的功能或展示具体的内容</p>
<p>组合标签：配合使⽤，才能产⽣相应的内容与效果</p>
<h2 id="lt-h-gt-标题"><a href="#lt-h-gt-标题" class="headerlink" title="&lt;h&gt;标题"></a><code>&lt;h&gt;</code>标题</h2><p>标题（Heading）是通过 <code>&lt;h1&gt; - &lt;h6&gt;</code> 等标签进行定义的。</p>
<p><code>&lt;h1&gt;</code> 定义最大的标题    <code>&lt;h6&gt;</code> 定义最小的标题</p>
<p>注意：</p>
<ol>
<li>浏览器会自动地在标题的前后添加空行。</li>
<li>默认情况下，HTML 会自动地在块级元素前后添加一个额外的空行，比如段落、标题元素前后</li>
</ol>
<h2 id="lt-p-gt-段落"><a href="#lt-p-gt-段落" class="headerlink" title="&lt;p&gt;段落"></a><code>&lt;p&gt;</code>段落</h2><p>用于展示效果中划分段落，并且自动在段前和段后自动加空行</p>
<p>align：段落内容的对齐方式，默认是left，内容居左；right，右；center，居中。</p>
<p>（这个将要分段的内容放在<code>&lt;p&gt;&lt;/p&gt;</code>中即可）</p>
<p>注意：</p>
<ol>
<li><p>浏览器会自动地在段落的前后添加空行。（<code>&lt;p&gt;</code> 是块级元素）</p>
</li>
<li><p>使用空的段落标记 <code>&lt;p&gt;&lt;/p&gt; </code>去插入一个空行是个坏习惯。用 <code>&lt;br /&gt;</code> 标签代替它！（但是不要用 <code>&lt;br /&gt;</code> 标签去创建列表。）</p>
</li>
</ol>
<h2 id="lt-br-gt-换行"><a href="#lt-br-gt-换行" class="headerlink" title="&lt;br /&gt;换行"></a><code>&lt;br /&gt;</code>换行</h2><p>用于展示效果中换行 </p>
<p>HTML源码中换行，浏览器解析时会自动忽略</p>
<p>（这个放在要换行的地方就行）</p>
<h2 id="lt-font-gt-字体"><a href="#lt-font-gt-字体" class="headerlink" title="&lt;font&gt;字体"></a><code>&lt;font&gt;</code>字体</h2><p>用于展示效果中修饰文字样式</p>
<p><code>&lt;font 属性名=”属性值”&gt; 文字&lt;/font&gt;</code></p>
<p>size:控制字体大小。最小1~最大7</p>
<p>color:控制字体颜色.使用英文设置</p>
<p>face:控制字体类型。只能设置系统字库中存在的字体类型<br>这个font可以加载在文字中间，不一定非要在开始，从哪开始的字就是从哪变化）</p>
<h2 id="lt-hr-gt-分割线"><a href="#lt-hr-gt-分割线" class="headerlink" title="&lt;hr /&gt;分割线"></a><code>&lt;hr /&gt;</code>分割线</h2><p>水平线，多用于段落之间的分割</p>
<h2 id="lt-pre-gt-原样标签"><a href="#lt-pre-gt-原样标签" class="headerlink" title="&lt;pre&gt;原样标签"></a><code>&lt;pre&gt;</code>原样标签</h2><p>原样标签会保留空格和换行符，显示原文本文字。格式化文本。预定义格式文本。</p>
<p>在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。(紧跟在 <code>&lt;pre&gt; </code>开始标签后的换行符也会被省略)</p>
<h2 id="lt-section-gt-段落标签"><a href="#lt-section-gt-段落标签" class="headerlink" title="&lt;section&gt;段落标签"></a><code>&lt;section&gt;</code>段落标签</h2><p>和p同为块标签，自动换行显示每一段，但是section不存在行距，p自带行距</p>
<p>注：section和P放在一起，p优先，使用行距</p>
<h2 id="lt-div-gt-块级的块标签"><a href="#lt-div-gt-块级的块标签" class="headerlink" title="&lt;div&gt;块级的块标签"></a><code>&lt;div&gt;</code>块级的块标签</h2><p>用于在效果中 定义一块，默认占满一行，进行内容的显示  （会自动换行，默认占满一行 适用于大量信息展示）</p>
<p>是块级元素，内容会独立占一行。它是可用于组合其他 HTML 元素的容器。<code>&lt;div&gt;</code> 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。</p>
<p>如果与 CSS 一同使用，<code>&lt;div&gt; </code>元素可用于对大的内容块设置样式属性。</p>
<p><code>&lt;div&gt; </code>元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 <code>&lt;table&gt;</code> 元素进行文档布局不是表格的正确用法。<code>&lt;table&gt;</code> 元素的作用是显示表格化的数据</p>
<h2 id="lt-span-gt-行级的块标签"><a href="#lt-span-gt-行级的块标签" class="headerlink" title="&lt;span&gt;行级的块标签"></a><code>&lt;span&gt;</code>行级的块标签</h2><p>用于在效果中 一行上定义一个块，进行内容显示  （有多少内容就会占用多大空间 span不会自动换行 适用于少量信息展示，比如提示密码错误）</p>
<p>HTML <code>&lt;span&gt; </code>元素是内联元素，行内标签，可用作文本的容器。</p>
<p><code>&lt;span&gt; </code>元素也没有特定的含义。</p>
<p>当与 CSS 一同使用时，<code>&lt;span&gt; </code>元素可用于为部分文本设置样式属性</p>
<h2 id="lt-ol-gt-lt-li-gt-有序的列表标签"><a href="#lt-ol-gt-lt-li-gt-有序的列表标签" class="headerlink" title="&lt;ol&gt; &lt;li&gt; 有序的列表标签"></a><code>&lt;ol&gt; &lt;li&gt;</code> 有序的列表标签</h2><p><code>&lt;ol&gt;&lt;/ol&gt;</code> 用于在效果中定义一个有序列表  （会表明每个条目的顺序）</p>
<p>列表条项目标签：<code>&lt;li&gt;&lt;/li&gt; </code>用于在效果中定义一个列表的项目</p>
<h2 id="lt-ul-gt-lt-li-gt-无序的列表标签"><a href="#lt-ul-gt-lt-li-gt-无序的列表标签" class="headerlink" title="&lt;ul&gt; &lt;li&gt; 无序的列表标签"></a><code>&lt;ul&gt; &lt;li&gt; </code>无序的列表标签</h2><p><code>&lt;ul&gt;&lt;/ul&gt; </code>用于在效果中定义一个无序列表  （使用最多）</p>
<h2 id="lt-dl-gt-lt-dt-gt-lt-dd-gt-项目列表标签"><a href="#lt-dl-gt-lt-dt-gt-lt-dd-gt-项目列表标签" class="headerlink" title="&lt;dl&gt;&lt;dt&gt;&lt;dd&gt;项目列表标签"></a><code>&lt;dl&gt;&lt;dt&gt;&lt;dd&gt;</code>项目列表标签</h2><p>dl（定义列表，跟ul…li类似），dt（定义了定义列表中的项目），dd（定义描述项目的内容，跟dt一起搭配）</p>
<h2 id="lt-sub-gt-下标"><a href="#lt-sub-gt-下标" class="headerlink" title="&lt;sub&gt; 下标"></a><code>&lt;sub&gt; </code>下标</h2><h2 id="lt-sup-gt-上标"><a href="#lt-sup-gt-上标" class="headerlink" title="&lt;sup&gt; 上标"></a><code>&lt;sup&gt;</code> 上标</h2><h2 id="实体标签-转义字符"><a href="#实体标签-转义字符" class="headerlink" title="实体标签(转义字符)"></a>实体标签(转义字符)</h2><p>空格 <code>&amp;nbsp;</code>   HTML源码中的多个空格，效果中最终会合并成一个</p>
<p>小于号 <code>&amp;lt;</code></p>
<p>大于号 <code>&amp;gt;</code></p>
<p>人民币<code> &amp;yen;</code>&yen;</p>
<p>版权 <code>&amp;copy;</code>&copy;</p>
<p>商标<code> &amp;reg;</code>&reg;</p>
<h2 id="lt-embed-gt-lt-embed-gt-媒体标签"><a href="#lt-embed-gt-lt-embed-gt-媒体标签" class="headerlink" title="&lt;embed&gt;&lt;/embed&gt;媒体标签"></a><code>&lt;embed&gt;&lt;/embed&gt;</code>媒体标签</h2><p>hidden ： 设置隐藏插件是否隐藏</p>
<p>src ：用于指定音乐的路径    例：<code>&lt;embed src=&quot;1.mp3&quot; &gt;&lt;/embed&gt;</code></p>
<h2 id="lt-marquee-gt-滚动标签-（已废弃）"><a href="#lt-marquee-gt-滚动标签-（已废弃）" class="headerlink" title="&lt;marquee&gt; 滚动标签  （已废弃）"></a><code>&lt;marquee&gt;</code> 滚动标签  （已废弃）</h2><p>用来插入一段滚动的文字。可以使用它的属性控制当文本到达容器边缘发生的事情</p>
<p>direction : 指定滚动的方向</p>
<p>scrollamount : 指定滚动的速度。</p>
<p>loop :指定滚动的次数</p>
<h2 id="lt-a-gt-超链接标签"><a href="#lt-a-gt-超链接标签" class="headerlink" title="&lt;a&gt; 超链接标签"></a><code>&lt;a&gt;</code> 超链接标签</h2><p><code>&lt;a&gt;&lt;/a&gt;</code>用于在效果中定义一个可以点击跳转的链接<br>href：超链接跳转的路径</p>
<p>​    内网本机路径：相对路径和绝对路径</p>
<p>​    互联网路径：http://地址</p>
<p>​    本页：默认跳转到本页</p>
<p>href : 用于指定链接的资源</p>
<p>target: 设置打开新资源的目标</p>
<p>_Blank 在独立的窗口上打开新资源</p>
<p>_self 在当前窗口打开新资源</p>
<p>file: file协议（文件协议）这种协议主要是用于搜索本地机器的资源文件的。      格式：file:///f:/图片/1.jpg</p>
<p>邮件 的协议： mailTo</p>
<p>迅雷的协议： thunder</p>
<p>超链接标签的作用：</p>
<ol>
<li><p>可以用于链接资源。</p>
</li>
<li><p>锚点点位:首先编写一个锚点 ,锚点的格式：<code> &lt;a name=&quot;锚点名字&quot;&gt; 数据&lt;/a&gt;</code> ,再使用a标签 的herf属性连接到锚点出。 href=”#锚点的名字“</p>
</li>
</ol>
<p>超链接正常工作：1. a标签中必须有内容     2.a标签必须有href属性</p>
<p>注意：a标签内容体，不仅仅是文字，也可以是其他内容，例如图片</p>
<p>a标签的href属性，不仅仅可以链接到html上，也可以链接到其他文件上。例如图片</p>
<h2 id="lt-img-gt-图片标签"><a href="#lt-img-gt-图片标签" class="headerlink" title="&lt;img&gt; 图片标签"></a><code>&lt;img&gt;</code> 图片标签</h2><p><code>&lt;img /&gt; </code>用于在页面效果中展示一张图片<br>    src：图片的路径。（必有属性）</p>
<p>路径的写法：内网路径：绝对路径：C:\javaweb001_html\img\c_1.jpg文件在硬盘上的具体位置  （不建议使用）</p>
<p>相对路径：../img/c_1.jpg  从引入者所在目录出发 ../表示上一层目录 ./表示当前目录  （建议使用）</p>
<p>互联网路径：<code>http://www.baidu.com/xxx.jpg </code>必须在前面加上http://</p>
<p>​    width： 设置图片宽度</p>
<p>​    height： 设置图片高度</p>
<p>​    宽度和高度的设置：</p>
<p>​        默认单位是px，像素  “400” 固定的</p>
<p>​        百分比设置：是父标签的百分比  “50%” 动态改变的</p>
<p>​    alt: 如果图片资源无法找到，那么就显示对应的文字对图片进行说明。</p>
<p>​        （这些属性放在img和/之间）</p>
<h2 id="lt-table-gt-表格标签"><a href="#lt-table-gt-表格标签" class="headerlink" title="&lt;table&gt;表格标签"></a><code>&lt;table&gt;</code>表格标签</h2><p>表格使用到的标签：</p>
<p><code>&lt;table&gt;</code> 表格</p>
<p><code>&lt;tr&gt;</code> 定义表格中的一行</p>
<p><code>&lt;td&gt; </code>在表格一行中定义单元格</p>
<p><code>&lt;th&gt;</code> 表头 。默认的样式是居中，加粗。区别于普通单元格标签，里面的内容居中加粗了</p>
<p><code>&lt;caption&gt; </code>表格的标题</p>
<p>表格常用的属性：</p>
<p>​    border ：设置表格的边框</p>
<p>​    width : 设置表格的宽度</p>
<p>​    height: 设置表格的高度</p>
<p>单元格合并：<code>&lt;td&gt;</code> <code>&lt;th&gt;</code>都有这个合并属性<br>colspan：    设置单元格占据指定的列数;跨列合并单元格  colspan=”n”</p>
<p>rowspan： 设置单元格占据指定的行数; 跨行合并单元格  rowspan=”n”</p>
<p>合并步骤：A：确定合并哪几个单元格，确定是跨行合并还是跨列合并</p>
<p>B：在第一个出现的单元格上书写合并单元格属性</p>
<p>C：合并几个单元格，属性值就写几</p>
<p>D：被合并的单元格必须删掉</p>
<p><code>&lt;thead&gt; </code>标签用于组合 HTML 表格的表头内容。</p>
<p><code>&lt;thead&gt;</code> 元素应该与<code>&lt;tbody&gt;</code>和<code>&lt;tfoot&gt;</code>元素结合起来使用，用来规定表格的各个部分（表头、主体、页脚）。</p>
<p>通过使用这些元素，使浏览器有能力支持独立于表格表头和表格页脚的表格主体滚动。当包含多个页面的长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。</p>
<p><code>&lt;thead&gt; </code>标签必须被用在以下情境中：作为 <code>&lt;table&gt; </code>元素的子元素，出现在 <code>&lt;caption&gt;、&lt;colgroup&gt; </code>元素之后，<code>&lt;tbody&gt;、 &lt;tfoot&gt; 和 &lt;tr&gt; </code>元素之前。</p>
<h2 id="lt-form-gt-表单标签"><a href="#lt-form-gt-表单标签" class="headerlink" title="&lt;form&gt;表单标签"></a><code>&lt;form&gt;</code>表单标签</h2><p>表单标签的根标签是<code>&lt;form&gt;</code>标签</p>
<p>用来将用户输入的数据提交给服务器的程序  相当于一个WEB程序的入口</p>
<p>1.定义一个表单 <code>&lt;form&gt;</code>表单内容<code>&lt;/form&gt;</code></p>
<p>2.在表单中定义对应的表单输入项<br>    <code>&lt;input /&gt; </code>是一种自关闭的标签，用户可以在该标签上通过填写和选择进行数据的输入</p>
<p>​    type：设置该标签的种类</p>
<p>​    text：文本框  默认  不一定需要指定value值</p>
<p>​    password：密码框  内容为非明文</p>
<p>​    radio：单选框  在同一组内才具有单选效果（分组需要用到name属性，将name设置成相同的就变为一组）（单选框只能选择，不能输入 需要指定value属性，否则提交的都是on）（可以checked设置默认选中）</p>
<p>​    checkbox：复选框  在同一组内才具有复选效果</p>
<p>​    submit：提交按钮  用于控制表单提交数据（当表单提交后，会出现  ？参数列表  参数列表格式：参数1=参数值1&amp;参数2=参数值2&amp;参数3=参数值3 这些参数都是之前设置的name，参数值是value）</p>
<p>​    rest：重置按钮  用于将表单输入项恢复到默认状态</p>
<p>​    file：附件框  用于文件上传</p>
<p>​    hidden：隐藏域 一般用于提交时，服务器需要拿到，但是用户不需要看到的数据</p>
<p>​    button：普通按钮  需要和js的事件一起使用</p>
<p>​    name：单选框、复选框进行数据的分组；设置该标签对应的参数名</p>
<p>​    value：设置该标签对应的参数值；作为按钮的名字</p>
<p>​    checked：设置单选框/复选框的默认选中状态  值就是”cheked”</p>
<p>​    readonly：设置该标签的参数值只读，用户无法手动更改，但是数据可以正常提交 readonly=“readonly”</p>
<p>​    disabled：设置该标签不可用，参数值无法更改且参数值也无法提交</p>
<p>​    <code>&lt;select&gt;&lt;/select&gt;</code>选择框标签  定义一个选择框</p>
<p>​    name：设置该标签对应的参数名</p>
<p>​    multiple：设置该标签选项全部显示，并且可以进行多选提交，默认为单选</p>
<p>​    <code>&lt;option&gt;&lt;/option&gt;</code>选项标签  用于为一个选择添加一个选项</p>
<p>​    value：设置需要提交的参数值（一般选择的东西都需要指定的返回值value）</p>
<p>​    selected：设置选项的默认选中状态</p>
<p>注意事项：option的内容体一般是用来展示的  参数值应该是option的value属性值</p>
<p>​    <code>&lt;textarea&gt;&lt;/textarea&gt;</code>文本域标签</p>
<p>表单输入项标签之一，用户可以在该标签上通过输入进行数据的输入</p>
<p>name：设置该标签对应的参数名</p>
<p>文本域和文本框的区别：文本框不能换行，文本域可以</p>
<p>文本框参数值是value属性，文本域参数值是标签的内容体</p>
<p>提交表单</p>
<p>action：指定提交数据的地址.将数据提交到何处（提交的地方其实是？前面的地址）  默认提交到本页</p>
<p>​    本机内网路径：相对路径:      绝对路径：</p>
<p>​    互联网路径：http：//</p>
<p>method：指定表单的提交方式.将数据以何种方式提交  默认为get  提交方式可定义为get或者post</p>
<p>get提交方式的特点：把数据拼接到地址栏上</p>
<p>post提交方式的特点：没有把数据拼接到地址栏上。请求体</p>
<p>get和post的区别：</p>
<p>​    get会把提交的参数列表拼接到了地址栏后面，post不会</p>
<p>​    get方式提交的数据敏感信息不安全，post提交的数据相对安全</p>
<p>​    get方式提交的数据量是有限的，post方式从理论上提交的数据量是无限大的。所以尽量使用post方式提交表单</p>
<p>提交表单的注意事项：</p>
<p>提交中文问题：为什么要用URL编码：（因为你可能提交的数据中包含&amp;符号，后台无法正确切割）</p>
<p>URL编码解决方式：对特殊符号，中文进行编码，为了保证表单数据传递时能更好区分出name和value，保证数据传递的完整性</p>
<p>例子：中文的你好进行URL编码：</p>
<p>（1）你好，进行普通的编码，编码成字节数组（使用的是页面规定的字符集，例如utf-8）</p>
<p>（2）字节数组中的每一个元素都会从10进制转为16进制</p>
<p>（3）把已经转为16进制的字节数组，以%进行拼接，拼接出的字符串，就是URL编码后的结果</p>
<p>注意： 表单项的数据如果需要提交到服务器上面，那么表单项必须要有name的属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; method&#x3D;&quot;post&quot;&gt; &lt;!-- 文本输入框 单 行- -&gt; 用户名：&lt;input name&#x3D;&quot;userName&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;!-- 密码框 --&gt;</span><br><span class="line">密码：&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;!-- 单选框 --&gt;</span><br><span class="line">性别： 男&lt;input checked&#x3D;&quot;true&quot; value&#x3D;&quot;man&quot; name&#x3D;&quot;sex&quot; type&#x3D;&quot;radio&quot;&#x2F;&gt;</span><br><span class="line">女&lt;input name&#x3D;&quot;sex&quot; value&#x3D;&quot;woman&quot; type&#x3D;&quot;radio&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt; !-- 下拉框 --&gt;</span><br><span class="line">来自的城市：&lt;select name&#x3D;&quot;city&quot;&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;BJ&quot;&gt;北京&lt;&#x2F;option&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;SH&quot;&gt;上海&lt;&#x2F;option&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;GZ&quot;&gt;广州&lt;&#x2F;option&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;SZ&quot;&gt;深圳&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;!-- 复选框 同一组的复选框name的属性值要一致 --&gt;</span><br><span class="line">兴趣爱好：java &lt;input value&#x3D;&quot;java&quot; name&#x3D;&quot;hobit&quot; checked&#x3D;&quot;checked&quot; type &#x3D;&quot;checkbox&quot; &#x2F;&gt;</span><br><span class="line">javascript &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;javascript&quot; name&#x3D;&quot;hobit&quot; &#x2F;&gt;</span><br><span class="line">android &lt;input value&#x3D;&quot;android&quot; name&#x3D;&quot;hobit&quot; type&#x3D;&quot;checkbox&quot; &#x2F;&gt;&lt;br&#x2F;&gt; &lt;!-- 文件上传框--&gt;</span><br><span class="line">大头照：&lt;input name&#x3D;&quot;image&quot; type&#x3D;&quot;file&quot; &#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">个人简介:</span><br><span class="line">&lt;!-- 文本域 --&gt;</span><br><span class="line">&lt;textarea name&#x3D;&quot;intro&quot; rows&#x3D;&quot;10&quot; cols&#x3D;&quot;30&quot;&gt;&lt;&#x2F;textarea&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;!-- 提交按钮 --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&#x2F;&gt;</span><br><span class="line">&lt;!-- 重置按钮 --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;reset&quot; value&#x3D;&quot;重置&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="lt-figure-gt-标签"><a href="#lt-figure-gt-标签" class="headerlink" title="&lt;figure&gt; 标签"></a><code>&lt;figure&gt; </code>标签</h2><p>代表一段独立的内容, 经常与说明（caption）<code> &lt;figcaption&gt;</code> 配合使用, 并且作为一个独立的引用单元。当它属于主内容流（main flow）时，它的位置独立于主体。这个标签经常是在主文中引用的图片，插图，表格，代码段等等，当这部分转移到附录中或者其他页面时不会影响到主体</p>
<h2 id="lt-template-gt-标签"><a href="#lt-template-gt-标签" class="headerlink" title="&lt;template&gt;标签"></a><code>&lt;template&gt;</code>标签</h2><p>模板元素</p>
<p>1.标签内容隐藏性:   自带display:none</p>
<p>2.标签位置任意性：类似<code>&lt;script&gt;</code>或者<code>&lt;style&gt;</code>标签，可以在<code>&lt;head&gt;</code>中，也可以在<code>&lt;body&gt;</code>或者<code>&lt;frameset&gt;</code>中</p>
<p>3.childNodes无效性:肉眼看上去是<code>&lt;template&gt;</code>标签里面还有很多子标签,但是template.childNodes无效，可以使用template.innerHTML获取完整的HTML片段。template.content会返回一个文档片段，可以理解为另外一个document，然后，使用document下的一些查询API就可以获得<code>&lt;template&gt;</code>标签里面的“伪子元素”了</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#fh5co-menu &#123;</span><br><span class="line">  background: ;</span><br><span class="line">  position: absolute;   绝对的</span><br><span class="line">  top: 0;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  width: 100%;</span><br><span class="line">  padding-bottom: 20px;</span><br><span class="line">  -webkit-transition: 0.5s;</span><br><span class="line">  -o-transition: 0.5s;</span><br><span class="line">  transition: 0.5s;</span><br><span class="line">  -webkit-border-radius: 0px;</span><br><span class="line">  -moz-border-radius: 0px;</span><br><span class="line">  -ms-border-radius: 0px;</span><br><span class="line">  border-radius: 0px;</span><br><span class="line">  margin-top: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//控制背景随动</span><br><span class="line">#fh5co-clients &#123;</span><br><span class="line">  padding: 2em 0;</span><br><span class="line">  background: #4fd2c2;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#fh5co-clients1 &#123;</span><br><span class="line">  padding: 2em 0;</span><br><span class="line">  background: #4fd2c2;</span><br><span class="line">  position: relative;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 992px) &#123;</span><br><span class="line">  #fh5co-clients1 .fh5co-client &#123;</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 768px) &#123;</span><br><span class="line">  #fh5co-clients1 .fh5co-client &#123;</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 480px) &#123;</span><br><span class="line">  #fh5co-clients1 .fh5co-client img &#123;</span><br><span class="line">    max-width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>长度单位</p>
<p>px 像素（Pixel），相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br>em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</p>
<p>ex 相对长度单位。相对于字符“x”的高度。此高度通常为字体尺寸的一半。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>% 相对长度单位。相对于浏览器窗口的大小</p>
<p>CSS绝对长度单位 说明<br>in 英寸Inches (1 英寸 = 2.54 厘米)<br>cm 厘米Centimeters<br>mm 毫米Millimeters<br>pt 点Points (1点 = 1/72英寸)<br>pc 皮卡Picas (1 皮卡 = 12 点)</p>
<p><strong>PX和PT转换的公式： pt=px乘以3/4。</strong>比如12px×3/4=9pt大小。<br><strong>PX和em转换的公式： em=16乘以px</strong>，也就是说1.5em=1.5×16=24px</p>
<p>用px来定义字体，就无法用浏览器字体放大的功能。</p>
<p>任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合:1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为16px*62.5%=10px,这样12px=1.2em,10px=1em,也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。<br>◆CSS中em属性有如下特点</p>
<p>1.em的值并不是固定的；</p>
<p>2.em会继承父级元素的字体大小。</p>
<p>◆所以我们在写CSS的时候，需要注意</p>
<p>1.body选择器中声明Font-size=62.5%；</p>
<p>2.将你的原来的px数值除以10，然后换上em作为单位；</p>
<p>3.重新计算那些被放大的字体的em数值。避免字体大小的重复声明。</p>
<p>也就是避免1.2*1.2=1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em,因为此em非彼em，它因继承#content的字体高而变为了1em=12px。</p>
<p>但是12px汉字例外，就是由以上方法得到的12px(1.2em)大小的汉字在IE中并不等于直接用12px定义的字体大小，而是稍大一点。这个问题Jorux已经解决，只需在body选择器中把62.5%换成63%就能正常显示了。原因可能是IE处理汉字时，对于浮点的取值精确度有限。不知道有没有其他的解释</p>
<p><strong>position</strong>: absolute;的元素会相对于第一个设置了position: relative;的祖先元素进行定位，将assistor设置为position: reletive;，滚动条是在parent中的，position: fixed;和parent内的内容滚动就都实现了。</p>
<p><strong>z-index</strong> 属性来控制这些框的堆放次序</p>
<h1 id="响应式布局（PC端适配手机端）"><a href="#响应式布局（PC端适配手机端）" class="headerlink" title="响应式布局（PC端适配手机端）"></a>响应式布局（PC端适配手机端）</h1><p>只开发一个网页，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。可以适配任何设备，兼容多个终端。</p>
<p>响应式开发的原理是使用CSS3中的Media Query（媒体查询）针对不同宽度的设备设置不同的布局和样式，从而适配不同的设备</p>
<p>使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面</p>
<p>设备的划分情况为：</p>
<ul>
<li>小于768的为超小屏幕（手机）</li>
<li>768~992之间的为小屏设备（平板）</li>
<li>992~1200的中等屏幕（桌面显示器）</li>
<li>大于1200的宽屏设备（大桌面显示器）</li>
</ul>
<p>屏幕宽度低于480像素的设备（如iPhone等）</p>
<p>1.在网站HTML文件的开头，增加viewport meta标签告诉浏览器视口宽度等于设备屏幕宽度，且不进行初始缩放：</p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; </code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。 </span><br><span class="line">height：和 width 相对应，指定高度。</span><br><span class="line">initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</span><br><span class="line">maximum-scale：允许用户缩放到的最大比例。 </span><br><span class="line">minimum-scale：允许用户缩放到的最小比例。</span><br><span class="line">user-scalable：用户是否可以手动缩放。</span><br></pre></td></tr></table></figure>

<p>2.在CSS文件尾部增加针对不同屏幕分辨率的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-device-width: 720px) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">media&#x3D;”screenand(max-device-width:400px)” href&#x3D;”tinyScreen.css”&#x2F;&gt;</span><br><span class="line">如果屏幕宽度小于400像素(max-device-width:400px)，就加载tinyScreen.css文件　</span><br><span class="line">media&#x3D;”screenand(min-width:400px)and(max-device-width:600px)” href&#x3D;”smallScreen.css”&#x2F;&gt;</span><br><span class="line">如果屏幕宽度在400像素到600像素之间，则加载smallScreen.css文件　　</span><br></pre></td></tr></table></figure>

<p>3.<strong>布局宽度使用相对宽度。</strong>网页总体框架可以使用绝对宽度，但往下的内容框架、侧栏等最好使用相对宽度，这样针对不同分辨率进行修改就方便。当然也可以不用相对宽度，那就需要在 @media screen and (max-device-width: 480px) 里面增加各个div的针对小屏幕的宽度，实际上更麻烦</p>
<p>4.在HTML页面上不要使用绝对字体（px），而要使用相对字体（em），对于大多数浏览器来说，通常用 em = px/16 换算，例如16px就等于1em</p>
<p>PC站和手机站匹配最常用的几种方法是移动适配、<a target="_blank" rel="noopener" href="http://www.w3cschool.cn/lwp2e2/hqky12kg.html">JS跳转</a>、<a target="_blank" rel="noopener" href="http://www.w3cschool.cn/htmltags/tag-meta.html">Meta声明</a>、302规则等等</p>
<p><strong>1、移动适配</strong></p>
<p>现在很多搜索引擎都提供移动适配的功能，例如百度的开放适配和360的移动适配，利用<a target="_blank" rel="noopener" href="http://www.w3cschool.cn/ycx23r">百度站长工具</a>提交PC页-手机页对应关系Sitemap，或者利用<a target="_blank" rel="noopener" href="http://www.w3cschool.cn/seoyh/gwyrpf.html">360站长工具</a>提交PC页-手机页对应关系txt就能实现PC站内容和手机站一一适配。 这样做的优点是只需要在搜索引擎工具提交资料，无需对站点本事做改动，而且网站内容一一对应，并不只局限于网站首页。 缺点就是只能在百度或者360移动搜索中生效，其他没用提交适配文件的搜索中就无效了。</p>
<p><strong>2、JS跳转</strong></p>
<p><a target="_blank" rel="noopener" href="http://www.w3cschool.cn/lwp2e2/hqky12kg.html">JS跳转</a>对于某些行业来说有着重要的作用，尤其是对于用户转换率网站首页较高的网站，只需要在网站的头部加一段JS代码判定是否是移动端访问，然后所有的流量就会全部流向手机站的主页。 JS跳转的优点是适用于所以的移动搜索，并不局限于百度和360，可以提高用户的转换率。 缺点是难以实现每个页面的一一对应，而且容易被某些搜索引擎判定作弊，从而受到惩罚。</p>
<p><strong>3、Meta声明</strong></p>
<p><a target="_blank" rel="noopener" href="http://www.w3cschool.cn/htmltags/tag-meta.html">Meta声明</a>的格式一般为，站长可以将这段代码加在PC站的头部，由Meta信息来指明该PC页对应的手机页的<a target="_blank" rel="noopener" href="http://www.w3cschool.cn/html/html-url.html">URL</a>，以及该URL对应页面的格式。 Meta声明的优点是代码简单易懂，操作方便。 缺点是只能在百度移动搜索中生效，对于其他搜索引擎无效。</p>
<p><strong>4、302规则</strong></p>
<p>302规则指的是，当判定移动端访问网站时，302临时跳转到一个网址(手机站)，例如可以在htaccess文件里加上一段判定手机的代码，做个302重定向。 这样做的好处是，不需要再额外在网站的前端代码中加任何东西，也不需要向搜索引擎提交规则，可是据测试，有可能会导致PC站被降权。 虽然302是暂时性的重定向，但过于频繁的302是很有可能给网站带来不利的影响的，具体的尺度需要站长自己去把握。</p>
<p>以上4种适配方法是最为常见的操作方法，通常PC站做了以上处理后，一段时间以后移动端搜索出来的结果，下面匹配的网址就变成了移动站网址，不过标题还是PC站标题。 至于到底哪种方法更好，更倾向于第一种，毕竟百度移动搜索占据着网站的大部分流量，而且用户体验度也最好。</p>
<h1 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h1><p>轮播图的样式有很多,可以选择一个框架，然后将代码复制下来，将用到的样式放到自己的文件夹里，这样就可以做成一个轮播图。</p>
<p>在layui中，如果想让轮播图完成在放大缩小的过程中保证图片随动，目前解除了两种方法：</p>
<p>1.写一个响应式布局的css样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#fh5co-clients &#123;</span><br><span class="line">  padding: 2em 0;</span><br><span class="line">  background: #4fd2c2;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">#fh5co-clients &#123;</span><br><span class="line">  margin-bottom: 0px;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 992px) &#123;</span><br><span class="line">  #fh5co-clients &#123;</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 768px) &#123;</span><br><span class="line">  #fh5co-clients&#123;</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 480px) &#123;</span><br><span class="line">  #fh5co-clients img &#123;</span><br><span class="line">    max-width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.写一个js方法，会不断刷新，影响体验</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> b = <span class="number">1768</span>/<span class="number">881</span>;<span class="comment">//这里的图片数值是根据自己的图片指定</span></span><br><span class="line">    <span class="comment">//获取浏览器宽度</span></span><br><span class="line">    <span class="keyword">var</span> W = $(<span class="built_in">window</span>).width();</span><br><span class="line">    <span class="keyword">var</span> H = $(<span class="built_in">window</span>).height();</span><br><span class="line">    layui.use(<span class="string">&#x27;carousel&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> carousel = layui.carousel;</span><br><span class="line">        <span class="comment">//建造实例</span></span><br><span class="line">        carousel.render(&#123;</span><br><span class="line">            elem: <span class="string">&#x27;#test1&#x27;</span></span><br><span class="line">            ,<span class="attr">width</span>: <span class="string">&#x27;100%&#x27;</span> <span class="comment">//设置容器宽度</span></span><br><span class="line">            ,<span class="attr">height</span>: (W/b).toString()+<span class="string">&quot;px&quot;</span>  <span class="comment">//按比例和浏览器可视页面宽度来获取高度</span></span><br><span class="line">            <span class="comment">// ,arrow: &#x27;always&#x27; //始终显示箭头</span></span><br><span class="line">            <span class="comment">//,anim: &#x27;updown&#x27; //切换动画方式</span></span><br><span class="line">            ,<span class="attr">indicator</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// setBanner();</span></span><br><span class="line">        <span class="built_in">window</span>.location.reload()  <span class="comment">//每当设置后，进行刷新</span></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="网页调试技巧"><a href="#网页调试技巧" class="headerlink" title="网页调试技巧"></a>网页调试技巧</h1><p>1.F12开发模式，左上角图标有两个：箭头图标可以选择元素，就会指示当前指向的元素，可以注意数值多大，方便知道这个标签管辖的范围。手机图标，点击之后可以模拟手机端查看网页，也可以通过拖动浏览器大小模拟查看。</p>
<p>2.开发者模式下，elements中选择了某一行后，可以在style中查看生效的样式，不生效的样式被划掉了，没有写过的样式不会显示。可以在样式中手动编辑数值模拟调试（比改一处看一处方便一点）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/03/8.2.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BHTML/" data-id="ckw61sdws006doswd1zx096xy" data-title="网页前端之HTML" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-6.1.nginx配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/30/6.1.nginx%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2021-03-30T06:47:54.000Z" itemprop="datePublished">2021-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/30/6.1.nginx%E9%85%8D%E7%BD%AE/">nginx配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。</p>
<p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p><code>Nginx</code> 是开源、高性能、高可靠的 <code>Web</code> 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 <code>Nginx</code> 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， <code>Nginx</code> 是免费的并可以商业化，配置使用也比较简单</p>
<p>优点：Nginx 可以在大多数 UnixLinux OS 上编译运行，并有 Windows 移植版。 Nginx 的1.4.0稳定版已经于2013年4月24日发布，一般情况下，对于新建站点，建议使用最新稳定版作为生产版本，已有站点的升级急迫性不高。Nginx 的源代码使用 2-clause BSD-like license。</p>
<p>Nginx 是一个很强大的高性能Web和反向代理服务器，它具有很多非常优越的特性：</p>
<p>在连接高并发的情况下，Nginx是Apache服务器不错的替代品：Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一。能够支持高达 50,000 个并发连接数的响应，感谢Nginx为我们选择了 epoll and kqueue作为开发模型。</p>
<ul>
<li>高并发、高性能；</li>
<li>模块化架构使得它的扩展性非常好；</li>
<li>异步非阻塞的事件驱动模型这点和 <code>Node.js</code> 相似；</li>
<li>相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器使得它具有高可靠性；</li>
<li>热部署、平滑升级；</li>
<li>完全开源，生态繁荣</li>
</ul>
<p>意义：互联网飞速发展的今天,大用户量高并发已经成为互联网的主体.怎样能让一个网站能够承载几万个或几十万个用户的持续访问呢？这是一些中小网站急需解决的问题。用单机tomcat搭建的网站，在比较理想的状态下能够承受的并发访问量在150到200左右。按照并发访问量占总用户数量的5%到10%这样计算，单点tomcat网站的用户人数在1500到4000左右。对于一个为全国范围提供服务的网站显然是不够用的，为了解决这个问题引入了负载均衡方法。负载均衡就是一个web服务器解决不了的问题可以通过多个web服务器来平均分担压力来解决，并发过来的请求被平均分配到多个后台web服务器来处理，这样压力就被分解开来。</p>
<p>负载均衡服务器分为两种:一种是通过硬件实现的负载均衡服务器，简称硬负载例如：f5。另一种是通过软件来实现的负载均衡，简称软负载:例如apache和nginx。硬负载和软负载相比前者作用的网络层次比较多可以作用到socket接口的数据链路层对发出的请求进行分组转发但是价格成本比较贵，而软负载作用的层次在http协议层之上可以对http请求进行分组转发并且因为是开源的所以几乎是0成本，并且阿里巴巴，京东等电商网站使用的都是Nginx服务器。</p>
<p>应用场景：</p>
<p>1.http服务器，可以做静态网页的http服务器。</p>
<p>2.配置虚拟机。一个域名可以被多个ip绑定。可以根据域名的不同请求转发给运行在不同端口的服务器。</p>
<p>3.反向代理，负载均衡。把请求转发给不同的服务器。</p>
<p>Nginx 的最重要的几个使用场景：</p>
<ol>
<li>静态资源服务，通过本地文件系统提供服务；</li>
<li>反向代理服务，延伸出包括缓存、负载均衡等；</li>
<li><code>API</code> 服务， <code>OpenResty</code> ；</li>
</ol>
<p>对于前端来说 <code>Node.js</code> 并不陌生， <code>Nginx</code> 和 <code>Node.js</code> 的很多理念类似， <code>HTTP</code> 服务器、事件驱动、异步非阻塞等，且 <code>Nginx</code> 的大部分功能使用 <code>Node.js</code> 也可以实现，但 <code>Nginx</code> 和<code>Node.js</code> 并不冲突，都有自己擅长的领域。<code>Nginx</code> 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等）， <code>Node.js</code> 更擅长上层具体业务逻辑的处理，两者可以完美组合</p>
<p>正向代理隐藏的是客户端</p>
<p>反向代理隐藏的是服务器端</p>
<h1 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h1><p>官方网站：<a target="_blank" rel="noopener" href="http://nginx.org/">http://nginx.org/</a></p>
<p>Nginx在windows下安装：</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps1.jpg" alt="img"> </p>
<p>执行exe文件，在浏览器中访问localhost:80</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps2.jpg" alt="img"> </p>
<p>Nginx在linux下安装：</p>
<p>1.环境要求：</p>
<p>nginx是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。</p>
<p>l gcc</p>
<p>​    安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：</p>
<p><em><strong>*yum install gcc-c++*</strong></em> </p>
<p>l PCRE</p>
<p>​    PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。</p>
<p><em><strong>*yum install -y pcre pcre-devel*</strong></em></p>
<p>注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。</p>
<p>l zlib</p>
<p>​    zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</p>
<p><em><strong>*yum install -y zlib zlib-devel*</strong></em></p>
<p>l openssl</p>
<p>​    OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。</p>
<p>​    nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。</p>
<p><em><strong>*yum install -y openssl openssl-devel*</strong></em></p>
<p>****2.****编译及安装</p>
<p>第一步：把nginx的源码包上传至linux服务器</p>
<p>第二步：解压源码包。 tar -zxf nginx-1.8.0.tar.gz </p>
<p>第三步：进入nginx-1.8.0文件夹。</p>
<p>第四步：使用configure命令创建makefile。参数设置如下：</p>
<p>./configure \</p>
<p>–prefix=/usr/local/nginx \</p>
<p>–pid-path=/var/run/nginx/nginx.pid \</p>
<p>–lock-path=/var/lock/nginx.lock \</p>
<p>–error-log-path=/var/log/nginx/error.log \</p>
<p>–http-log-path=/var/log/nginx/access.log \</p>
<p>–with-http_gzip_static_module \</p>
<p>–http-client-body-temp-path=/var/temp/nginx/client \</p>
<p>–http-proxy-temp-path=/var/temp/nginx/proxy \</p>
<p>–http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</p>
<p>–http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</p>
<p>–http-scgi-temp-path=/var/temp/nginx/scgi</p>
<p><em><strong>*注意：上边将临时文件目录指定为*</strong>***</em>*/var/temp/nginx*<strong><strong><strong>*，需要在*</strong></strong></strong>*/var*<strong><strong><strong>*下创建*</strong></strong></strong>*temp*<strong><strong><strong>*及*</strong></strong></strong>*nginx****<em><strong>*目录*</strong></em></p>
<p><em><strong>*mkdir  -p  /var/temp/nginx*</strong></em></p>
<p>第五步：make</p>
<p>第六步: make install</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps3.jpg" alt="img"> </p>
<p>以上操作完成后，进入/usr/local/nginx目录,ll</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps4.jpg" alt="img"> </p>
<p>conf它里面装入的是nginx相关的配置文件</p>
<p>html目录 它里面装入的html代码</p>
<p>sbin目录它里面有一个nginx (这个nginx其实就相当于是windows系统的exe)</p>
<p>想要启动nginx只需要执行bin目录下的nginx命令就可以</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps5.jpg" alt="img"> </p>
<p>Nginx服务在启动时会启动两个服务</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps6.jpg" alt="img">此时如果想检测访问的话，去浏览器输入：192.168.19.128：80</p>
<p>使用 <code>yum</code> 安装 <code>Nginx</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure>

<p>安装完成后，通过 <code>rpm \-ql nginx</code> 命令查看 <code>Nginx</code> 的安装信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Nginx配置文件</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf # nginx 主配置文件</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf.default</span><br><span class="line"></span><br><span class="line"># 可执行程序文件</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;nginx-upgrade</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx</span><br><span class="line"></span><br><span class="line"># nginx库文件</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service # 用于配置系统守护进程</span><br><span class="line">&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules # Nginx模块目录</span><br><span class="line"></span><br><span class="line"># 帮助文档</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;CHANGES</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;README</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;README.dynamic</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;UPGRADE-NOTES-1.6-to-1.10</span><br><span class="line"></span><br><span class="line"># 静态资源目录</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;404.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line"></span><br><span class="line"># 存放Nginx日志文件</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;nginx</span><br></pre></td></tr></table></figure>

<p>主要关注的文件夹有两个：</p>
<p><code>1. /etc/nginx/conf.d/</code> 是子配置项存放处， <code>/etc/nginx/nginx.conf</code> 主配置文件会默认把这个文件夹中所有子配置项都引入；</p>
<p><code>2. /usr/share/nginx/html/</code> 静态文件都放在这个文件夹，也可以根据你自己的习惯放在其他地方；</p>
<p>Nginx常用命令：</p>
<p>l 关闭nginx需要使用:（暴力）</p>
<p>nginx -s stop 相当于找到nginx进程kill。</p>
<p>l 退出命令：（温和）</p>
<p>nginx -s quit</p>
<p>等程序执行完毕后关闭，建议使用此命令。</p>
<p>l 重新加载配置文件:（重启）</p>
<p>nginx -s reload 可以不关闭nginx的情况下更新配置文件</p>
<p><code>systemctl</code> 系统命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 开机配置</span><br><span class="line">systemctl enable nginx # 开机自动启动</span><br><span class="line">systemctl disable nginx # 关闭开机自动启动</span><br><span class="line"></span><br><span class="line"># 启动Nginx</span><br><span class="line">systemctl start nginx # 启动Nginx成功后，可以直接访问主机IP，此时会展示Nginx默认页面</span><br><span class="line"></span><br><span class="line"># 停止Nginx</span><br><span class="line">systemctl stop nginx</span><br><span class="line"></span><br><span class="line"># 重启Nginx</span><br><span class="line">systemctl restart nginx</span><br><span class="line"></span><br><span class="line"># 重新加载Nginx</span><br><span class="line">systemctl reload nginx</span><br><span class="line"></span><br><span class="line"># 查看 Nginx 运行状态</span><br><span class="line">systemctl status nginx</span><br><span class="line"></span><br><span class="line"># 查看Nginx进程</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line"># 杀死Nginx进程</span><br><span class="line">kill -9 pid # 根据上面查看到的Nginx进程号，杀死Nginx进程，-9 表示强制结束进程</span><br></pre></td></tr></table></figure>

<p><code>Nginx</code> 应用程序命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload # 向主进程发送信号，重新加载配置文件，热重启</span><br><span class="line">nginx -s reopen # 重启 Nginx</span><br><span class="line">nginx -s stop # 快速关闭</span><br><span class="line">nginx -s quit # 等待工作进程处理完成后关闭</span><br><span class="line">nginx -T # 查看当前 Nginx 最终的配置</span><br><span class="line">nginx -t # 检查配置是否有问题</span><br></pre></td></tr></table></figure>



<h1 id="Nginx配置与应用"><a href="#Nginx配置与应用" class="headerlink" title="Nginx配置与应用"></a>Nginx配置与应用</h1><p>1.Nginx虚拟机配置</p>
<p>主要是在描述nginx它是一个http服务器。它是apache的一个替代品。</p>
<p>对于nginx虚拟机配置主要可以从三个方面入手:</p>
<p>\1. ip配置</p>
<p>\2. 域名配置</p>
<p>\3. 端口配置</p>
<p>它的配置主要体现在nginx/conf/nginx.conf，这个文件中#都是注释</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps7.jpg" alt="img"> </p>
<p>测试针对ip地址进行配置：复制一个server，将其中的server-name改为自己电脑的ip地址，可以选择性的对location中内容进行修改，实现不同的ip地址和域名访问不同的资源的效果。重启nginx</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps8.jpg" alt="img"> </p>
<p>测试针对于域名进行配置</p>
<p>域名作用:可以方便记忆。</p>
<p>问题:为什么通过域名可以访问到网站。</p>
<p>答：DNS服务器—-域名解析服务器。</p>
<p>在windows或linux上都有一个hosts文件，它是一个本地域名解析文件。</p>
<p>windows上在c：\Windows\System32\drivers\etc</p>
<p>linux上在/etc/hosts</p>
<p>linux系统中nginx/conf/nginx.conf，或者windows中config下的nginx.conf文件。修改server-name为一个域名。重启nginx</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps9.jpg" alt="img"> </p>
<p>测试针对于端口进行配置</p>
<p>改变listen为8001，就可以根据不同的端口访问不同的资源</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps10.jpg" alt="img"> </p>
<p>2.Nginx作反向代理</p>
<p>需要在conf文件中添加反向代理的配置（当访问localhost时，默认端口为80，会跳转到server_list进而访问到tomcat的localhost：8080）如果出错了，可以查看nginx的logs文件，每次改完配置文件后，都需要重启nginx服务器。</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps11.jpg" alt="img"> </p>
<p>完成简单的tomcat集群（这个配置有很多错误）：在server_list中继续添加tomcat服务器（这里的8081是修改端口号的tomcat文件的副本）</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps12.jpg" alt="img"> </p>
<p>3.Nginx负载均衡</p>
<p>所谓的负载均衡简单说就是将一台服务原来承受的压力由多台服务器来分配，可以在nginx中实现tomcat集群，因为不同服务器的性能可能不一样，所以可以通过weight来分配权重，权重越大代表使用的越多</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps13.jpg" alt="img"> </p>
<p>4.Nginx+tomcat集群+redis实现session共享</p>
<p>Session共享问题演示：</p>
<p>1）在tomcat中创建项目myweb，这个网页中得到sessionid值</p>
<p>2）分别启动两个tomcat,查看sessionid值</p>
<p>Tomcat_main</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps14.jpg" alt="img"> </p>
<p>Tomcat_back</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps15.jpg" alt="img"> </p>
<p>Session共享问题解决：</p>
<p>思想:将原来由每一个tomcat管理的session统一存储到redis中管理</p>
<p>1）下载nginx+tomcat集群+redis实现session共享工具jar包</p>
<p><a target="_blank" rel="noopener" href="https://github.com/jcoleman/tomcat-redis-session-manager/downloads">https://github.com/jcoleman/tomcat-redis-session-manager/downloads</a></p>
<p>其它依赖包</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps16.jpg" alt="img"> </p>
<p>最好使用这四个jar包，因为其他版本的jar包可能会存在冲突</p>
<p>将以上四个包copy到tomcat的lib目录下(集群中的所有Tomcat都需要有这四个jar)</p>
<p>2）在tomcat/conf/context.xml文件中添加配置(集群中的所有Tomcat都需要配置)</p>
<Valve className="com.radiadesign.catalina.session.RedisSessionHandlerValve"/>

<p>  &lt;Manager className=”com.radiadesign.catalina.session.RedisSessionManager”</p>
<p>​    host=”192.168.19.128”</p>
<p>​    port=”6379”</p>
<p>​    database=”0”</p>
<p>​     maxInactiveInterval=”60”</p>
<p>​         </p>
<p>​         password=”admin”</p>
<p>​         /&gt;</p>
<p>重启tomcat，nginx，启动redis数据库</p>
<p>3）查看myweb工具中sessionid</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps17.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps18.jpg" alt="img"> </p>
<p>Redis帮助我们存储了session</p>
<p><img src="file:///C:\Users\swx\AppData\Local\Temp\ksohtml3720\wps19.jpg" alt="img"> </p>
<p> <em><strong>*配置Tomcat的session共享可以有三种解决方案:*</strong></em></p>
<p>1.以负载均衡服务器本身提供的session共享策略，每种服务器的配置是不一样的并且nginx本身是没有的</p>
<p>2.利用web容器本身的session共享策略来配置共享。针对于weblogic这种方式还是靠谱的。但是针对于tomcat这种方式存在很大的缺陷，主要因为是依靠广播方式来实现的session复制，会浪费很多带宽导致整个网络反映缓慢。官网也建议这种方式最好不要超过4台tomcat,具体的内容可参考/webapps/docs/cluster-howto.html里面有详细的说明</p>
<p>3.<em><strong>*Tomcat集群+redis的Session共享配置方法*</strong></em></p>
<p><em><strong>*配置tomcat中的session共享：*</strong></em></p>
<p><em><strong>*步骤一:修改server.xml文件，最简单的集群配置只需要将节点中注释掉的下面这句取消注释即可：*</strong></em></p>
<p>Xml代码：</p>
  <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/>  

<p>使用这样方法配置的集群会将Session同步到所在网段上的所有配置了集群属性的实例上(此处讲所在网段可能不准确，是使用Membership 的address和port来区分的。tomcat集群的实例如果在Membership配置中有相同的address和port值的tomcat被分到同一个集群里边。他们的session是相互共享的，同一个session的集群被称为一个cluster。可以配置多个cluster，但是cluster和cluster之间的session是不共享的)。也就是说如果该广播地址下的所有Tomcat实例都会共享Session，那么假如有几个互不相关的集群，就可能造成Session复制浪费，所以为了避免浪费就需要对节点多做点设置了，如下：</p>
<p>Xml代码</p>
  <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster">   

<p>​    <Channel className="org.apache.catalina.tribes.group.GroupChannel">   </p>
<p>​      &lt;Membership className=”org.apache.catalina.tribes.membership.McastService”   </p>
<p>​        address=”228.0.0.4”   </p>
<p>​        port=”45564”   </p>
<p>​        frequency=”500”   </p>
<p>​        dropTime=”3000”/&gt;   </p>
<p>​    </Channel>   </p>
  </Cluster>  

<p>加了一个Channel，里面包了个Membership，咱们要关注的就是membership的port属性和address属性，不同的集群设置不同的port值或address值，从目前的使用来看，基本上是隔离开了。</p>
<p><em><strong>*步骤二:修改项目的web.xml文件：*</strong></em></p>
<p>web.xml文件的修改很简单：只需要在节点中添加这个节点<distributable/>就可以了。</p>
<p>OK，有了这二步就实现了Tomcat的集群和Session的共享了</p>
<h1 id="nginx的配置"><a href="#nginx的配置" class="headerlink" title="nginx的配置"></a>nginx的配置</h1><p>main（全局设置）、server（主机设置）、upstream（负载均衡服务器设置）和 location（URL匹配特定位置的设置）。</p>
<p>main块设置的指令将影响其他所有设置；<br>server块的指令主要用于指定主机和端口；<br>upstream指令主要用于负载均衡，设置一系列的后端服务器；<br>location块用于匹配网页位置。</p>
<p>这四者之间的关系式：server继承main，location继承server，upstream既不会继承其他设置也不会被继承。<br>在这四个部分当中，每个部分都包含若干指令，这些指令主要包含Nginx的主模块指令、事件模块指令、HTTP核心模块指令，同时每个部分还可以使用其他HTTP模块指令，例如Http SSL模块、HttpGzip Static模块和Http Addition模块等。</p>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nobody nobody;  <span class="comment">#用户及组：用户 组   windows下不指定</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">2</span>;  </span><br><span class="line"><span class="comment">#worker_processes是个主模块指令，指定了Nginx要开启的进程数。每个Nginx进程平均耗费10M~12M内存。建议指定和CPU的数量一致即可，根据硬件调整，通常等于CPU数量或者2倍于CPU</span></span><br><span class="line"><span class="attribute">error_log</span> logs/error.log <span class="literal">notice</span>;  </span><br><span class="line"><span class="comment">#error_log是个主模块指令，用来定义全局错误日志文件存放路径。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少</span></span><br><span class="line"><span class="attribute">pid</span> logs/nginx.pid;  <span class="comment">#pid是个主模块指令，pid（进程标识符）用来指定进程pid的存储文件位置</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;  </span><br><span class="line"><span class="comment">#worker_rlimit_nofile用于绑定worker进程和CPU， Linux内核2.4以上可用。指定进程可以打开的最大描述符：数目。这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span></span><br></pre></td></tr></table></figure>



<h2 id="events事件"><a href="#events事件" class="headerlink" title="events事件"></a>events事件</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设定Nginx的工作模式及连接数上限：</span></span><br><span class="line">events&#123;</span><br><span class="line"><span class="attribute">use</span> <span class="literal">epoll</span>; </span><br><span class="line"><span class="comment">#use是个事件模块指令，用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在FreeBSD系统中。对于Linux系统，epoll工作模式是首选。window下不指定</span></span><br><span class="line"><span class="attribute">worker_connections</span> <span class="number">65536</span>;  </span><br><span class="line"><span class="comment">#worker_connections也是个事件模块指令，用于定义Nginx每个进程的最大连接数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定，即Max_client=worker_processes*worker_connections。在作为反向代理时，max_clients变为：max_clients = worker_processes * worker_connections/4。进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效</span></span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">60</span>;  <span class="comment">#keepalive超时时间</span></span><br><span class="line"><span class="attribute">client_header_buffer_size</span> <span class="number">4k</span>;</span><br><span class="line"><span class="comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令`getconf PAGESIZE` 取得。但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数</span></span><br><span class="line"><span class="attribute">open_file_cache</span> max=<span class="number">65535</span> inactive=<span class="number">60s</span>;</span><br><span class="line"><span class="comment">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span></span><br><span class="line"><span class="attribute">open_file_cache_valid</span> <span class="number">80s</span>;</span><br><span class="line"><span class="comment">#这个是指多长时间检查一次缓存的有效信息。</span></span><br><span class="line"><span class="attribute">open_file_cache_min_uses</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HTTP服务器配置"><a href="#HTTP服务器配置" class="headerlink" title="HTTP服务器配置"></a>HTTP服务器配置</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line"><span class="attribute">include</span> conf/mime.types;  </span><br><span class="line"><span class="comment">#include是个主模块指令，实现对配置文件所包含的文件的设定，可以减少主配置文件的复杂度。类似于Apache中的include方法。设定mime类型,类型由mime.type文件定义</span></span><br><span class="line"><span class="attribute">default_type</span> application/octet-stream;  </span><br><span class="line"><span class="comment">#default_type属于HTTP核心模块指令，这里设定默认类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置PHP环境时，Nginx是不予解析的，此时，用浏览器访问PHP文件就会出现下载窗口</span></span><br><span class="line"><span class="attribute">log_format</span> main <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &#x27;</span>  用以记录客户端的ip地址  用来记录客户端用户名称  用来记录访问时间与时区</span><br><span class="line"><span class="string">&#x27;&quot;$request&quot; $status $bytes_sent &#x27;</span>     用来记录请求的url与http协议  用来记录请求状态；成功是<span class="number">200</span>  记录发送给客户端文件主体内容大小</span><br><span class="line"><span class="string">&#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &#x27;</span>  用来记录从那个页面链接访问过来的  记录客户浏览器的相关信息</span><br><span class="line"><span class="string">&#x27;&quot;$gzip_ratio&quot;&#x27;</span>;</span><br><span class="line"><span class="attribute">log_format</span> download <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;$request&quot; $status $bytes_sent &#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;$http_range&quot; &quot;$sent_http_content_range&quot;&#x27;</span>;</span><br><span class="line">    <span class="comment">##通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址</span></span><br><span class="line"><span class="comment">#log_format是Nginx的HttpLog模块指令，用于指定Nginx日志的输出格式。main为此日志输出格式的名称，用了log_format指令设置了日志格式之后，需要用access_log指令指定日志文件的存放路径。</span></span><br><span class="line"><span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"><span class="attribute">access_log</span>  logs/host.access.<span class="number">404</span>.log  log404;</span><br><span class="line"></span><br><span class="line"><span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>;</span><br><span class="line"><span class="comment">#保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">20m</span>;  <span class="comment">#client_max_body_size用来设置允许客户端请求的最大的单个文件字节数；设定通过nginx上传文件的大小</span></span><br><span class="line"><span class="attribute">client_header_buffer_size</span> <span class="number">32K</span>;  <span class="comment">#client_header_buffer_size用于指定来自客户端请求头的headerbuffer大小。对于大多数请求，1K的缓冲区大小已经足够，如果自定义了消息头或有更大的Cookie，可以增加缓冲区大小。这里设置为32K</span></span><br><span class="line"><span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;  <span class="comment">#large_client_header_buffers用来指定客户端请求中较大的消息头的缓存最大数量和大小， “4”为个数，“128K”为大小，最大缓存量为4个128K</span></span><br><span class="line"><span class="attribute">Sendfile</span> <span class="literal">on</span>;  <span class="comment">#sendfile参数用于开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞</span></span><br><span class="line"><span class="attribute">tcp_nopush</span> <span class="literal">on</span>;  <span class="comment">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span></span><br><span class="line"><span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;  </span><br><span class="line">    </span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">60</span>;  <span class="comment">#keepalive_timeout设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接</span></span><br><span class="line"><span class="attribute">client_header_timeout</span> <span class="number">10</span>;  <span class="comment">#client_header_timeout设置客户端请求头读取超时时间。如果超过这个时间，客户端还没有发送任何数据，Nginx将返回“Request time out（408）”错误</span></span><br><span class="line"><span class="attribute">client_body_timeout</span> <span class="number">10</span>;  <span class="comment">#client_body_timeout设置客户端请求主体读取超时时间。如果超过这个时间，客户端还没有发送任何数据，Nginx将返回“Request time out（408）”错误，默认值是60</span></span><br><span class="line"><span class="attribute">send_timeout</span> <span class="number">10</span>;  <span class="comment">#send_timeout指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx将会关闭连接</span></span><br></pre></td></tr></table></figure>

<h2 id="HttpGzip模块"><a href="#HttpGzip模块" class="headerlink" title="HttpGzip模块"></a>HttpGzip模块</h2><p>这个模块支持在线实时压缩输出数据流。通过<code>/opt/nginx/sbin/nginx -V</code>命令可以查看安装Nginx时的编译选项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]# /opt/nginx/sbin/nginx  -V</span><br><span class="line">nginx version: nginx/1.0.14</span><br><span class="line">built by gcc 4.4.6 20110731 (Red Hat 4.4.6-3) (GCC)</span><br><span class="line">configure arguments: --with-http_stub_status_module --with-http_gzip_static_module --prefix=/opt/nginx</span><br><span class="line">                   </span><br><span class="line">gzip on;   #gzip用于设置开启或者关闭gzip模块，“gzip on”表示开启GZIP压缩，实时压缩输出数据流</span><br><span class="line">gzip_min_length 1k;  #gzip_min_length设置允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取。默认值是0，不管页面多大都进行压缩。建议设置成大于1K的字节数，小于1K可能会越压越大</span><br><span class="line">gzip_buffers 4 16k;  #gzip_buffers表示申请4个单位为16K的内存作为压缩结果流缓存，默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果</span><br><span class="line">gzip_http_version 1.1;  #gzip_http_version用于设置识别HTTP协议版本，默认是1.1，目前大部分浏览器已经支持GZIP解压，使用默认即可</span><br><span class="line">gzip_comp_level 2;  #gzip_comp_level用来指定GZIP压缩比，1 压缩比最小，处理速度最快；9 压缩比最大，传输速度快，但处理最慢，也比较消耗cpu资源</span><br><span class="line">gzip_types text/plain application/x-javascript text/css application/xml;  </span><br><span class="line"><span class="meta">#</span><span class="bash">gzip_types用来指定压缩的类型，无论是否指定，“text/html”类型总是会被压缩的</span></span><br><span class="line">gzip_vary on;  #gzip_vary选项可以让前端的缓存服务器缓存经过GZIP压缩的页面，例如用Squid缓存经过Nginx压缩的数据</span><br></pre></td></tr></table></figure>



<h2 id="负载均衡设置"><a href="#负载均衡设置" class="headerlink" title="负载均衡设置"></a>负载均衡设置</h2><p>Nginx的负载均衡模块目前支持4种调度算法:</p>
<p>1.轮询(默认):每个请求按时间顺序逐一分配到不同的后端服务器。指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">#设定负载均衡服务器列表</span></span><br><span class="line">  <span class="attribute">upstream</span> roundrobin &#123;</span><br><span class="line">       <span class="comment">#后端服务器访问规则</span></span><br><span class="line">      <span class="attribute">server</span> <span class="number">192.168.1.115:8080</span>  weight=<span class="number">1</span>;       <span class="comment">#server1</span></span><br><span class="line">      <span class="attribute">server</span> <span class="number">192.168.1.131:8081</span>  weight=<span class="number">1</span>;       <span class="comment">#server1</span></span><br><span class="line">      <span class="attribute">server</span> <span class="number">192.168.1.94:8090</span>   weight=<span class="number">1</span>;       <span class="comment">#server3</span></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">          <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">          <span class="attribute">server_name</span> <span class="number">192.168.1.131</span>;</span><br><span class="line">          <span class="attribute">location</span> / &#123;</span><br><span class="line">                  <span class="attribute">proxy_pass</span> http://roundrobin;</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">当访问 http://192.168.131 的时候，会把这个请求负载到 192.168.1.115 的 8080 端口、192.168.1.115 的 8080 端口、192.168.1.115 的 8080 端口。负载的权重由 weight 来决定，默认为 1 ，weight 越大，权重就越大</span><br></pre></td></tr></table></figure>

<p>  2.ip_hash:每个请求按访问IP的hash结果分配，同一个IP客户端固定访问一个后端服务器。可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设定负载均衡服务器列表</span></span><br><span class="line"><span class="attribute">upstream</span> roundrobin &#123;</span><br><span class="line">     <span class="comment">#后端服务器访问规则</span></span><br><span class="line">    	ip_hash;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.1.134</span> weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.1.131</span> weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> <span class="number">192.168.1.131</span>;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://roundrobin;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">设置后端负载均衡服务器的状态:</span><br><span class="line">down，表示当前的server暂时不参与负载均衡。</span><br><span class="line">backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</span><br><span class="line">max_fails：允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</span><br><span class="line">fail_timeout：在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</span><br><span class="line">注意：backup不能和ip_hash同时配置。因为ip_hash只能访问同一台服务器，而backup是在只有所有参与负载均衡的服务器出现故障时，才会请求备份机。当所有负载均衡的服务器出现故障了，ip_hash的将无法请求了</span><br><span class="line"><span class="comment">#设定负载均衡服务器列表</span></span><br><span class="line"><span class="attribute">upstream</span> roundrobin &#123;</span><br><span class="line">    <span class="comment">#后端服务器访问规则</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.115:8080</span>  weight=<span class="number">1</span>;       <span class="comment">#server1</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.131:8080</span>  down;           <span class="comment">#server2 不参与负载</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.94:8090</span>   backup;         <span class="comment">#server3 备份机   </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> <span class="number">192.168.1.131</span>;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://roundrobin;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.url_hash（第三方）:访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend &#123;</span><br><span class="line"><span class="attribute">server</span> squid1:<span class="number">3128</span>;</span><br><span class="line"><span class="attribute">server</span> squid2:<span class="number">3128</span>;</span><br><span class="line"><span class="attribute">hash</span> $request_uri;</span><br><span class="line"><span class="attribute">hash_method</span> crc32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.fair（第三方）:这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持 fair的，如果需要使用这种调度算法，必须下载Nginx的 upstream_fair模块</p>
<p>upstream是Nginx的HTTP Upstream模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend &#123;</span><br><span class="line"><span class="attribute">server</span> server1;</span><br><span class="line"><span class="attribute">server</span> server2;</span><br><span class="line">fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</p>
<h2 id="server虚拟主机配置"><a href="#server虚拟主机配置" class="headerlink" title="server虚拟主机配置"></a>server虚拟主机配置</h2><p>建议将对虚拟主机进行配置的内容写进另外一个文件，然后通过include指令包含进来，这样更便于维护和管理</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server&#123;    #server标志定义虚拟主机开始</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;   <span class="comment">#listen用于指定虚拟主机的服务端口</span></span><br><span class="line"><span class="attribute">server_name</span> <span class="number">192.168.8.18</span> cszhi.com;  <span class="comment">#server_name用来指定访问的IP地址或者域名，多个域名之间用空格分开</span></span><br><span class="line"><span class="attribute">index</span> index.html index.htm index.php;  <span class="comment">#index用于设定访问的默认首页地址</span></span><br><span class="line"><span class="attribute">root</span> /wwwroot/www.cszhi.com  <span class="comment">#root指令用于指定虚拟主机的网页根目录，这个目录可以是相对路径，也可以是绝对路径</span></span><br><span class="line">charset gb2312;  <span class="comment">#charset用于 设置网页的默认编码格式</span></span><br><span class="line"><span class="attribute">access_log</span> logs/www.ixdba.net.access.log main;  <span class="comment">#access_log用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式</span></span><br><span class="line"><span class="attribute">proxy_pass</span> http://img_relay$request_uri;  <span class="comment">#设置被代理服务器的端口或套接字，以及URL</span></span><br><span class="line"><span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;  </span><br><span class="line"><span class="comment">#以上三行，目的是将代理服务器收到的用户的信息传到真实服务器上</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="location-URL匹配配置"><a href="#location-URL匹配配置" class="headerlink" title="location URL匹配配置"></a>location URL匹配配置</h2><p>URL地址匹配是进行Nginx配置中最灵活的部分。 location支持正则表达式匹配，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。使用location URL匹配配置还可以实现反向代理，用于实现PHP动态解析或者负载负载均衡</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这段设置是通过location指令来对网页URL进行分析处理，所有扩展名以.gif、.jpg、.jpeg、.png、.bmp、.swf结尾的静态文件都交给nginx进行负载均衡</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span> &#123;</span><br><span class="line"><span class="attribute">root</span> /wwwroot/www.cszhi.com;</span><br><span class="line"><span class="attribute">expires</span> <span class="number">30d</span>;   <span class="comment">#expires用来指定静态文件的过期时间，这里是30天</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#这段设置中，location是对此虚拟主机下动态网页的过滤处理，也就是将所有以.jsp为后缀的文件都交给本机的8080端口处理</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*.php$</span> &#123;</span><br><span class="line"><span class="attribute">index</span> index.php;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>root和alias的区别：</p>
<h2 id="StubStatus模块配置"><a href="#StubStatus模块配置" class="headerlink" title="StubStatus模块配置"></a>StubStatus模块配置</h2><p>StubStatus模块能够获取Nginx自上次启动以来的工作状态，此模块非核心模块，需要在Nginx编译安装时手工指定才能使用此功能。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以下指令是指定启用获取Nginx工作状态的功能</span></span><br><span class="line"><span class="attribute">location</span> /NginxStatus &#123;</span><br><span class="line"><span class="attribute">stub_status</span> <span class="literal">on</span>;  <span class="comment">#stub_status设置为“on”表示启用StubStatus的工作状态统计功能</span></span><br><span class="line"><span class="attribute">access_log</span> logs/NginxStatus.log;  <span class="comment">#access_log 用来指定StubStatus模块的访问日志文件</span></span><br><span class="line"><span class="attribute">auth_basic</span> <span class="string">&quot;NginxStatus&quot;</span>;  <span class="comment">#auth_basic是Nginx的一种认证机制</span></span><br><span class="line"><span class="attribute">auth_basic_user_file</span> ../htpasswd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>auth_basic_user_file用来指定认证的密码文件，由于Nginx的auth_basic认证采用的是与Apache兼容的密码文件，因此需要用Apache的htpasswd命令来生成密码文件，例如要添加一个test用户，可以使用下面方式生成密码文件<br><code>/usr/local/apache/bin/htpasswd -c  /opt/nginx/conf/htpasswd test</code><br>然后输入两次密码后确认之后添加用户成功。</p>
<p>要查看Nginx的运行状态，可以输入<a target="_blank" rel="noopener" href="http://ip/NginxStatus%EF%BC%8C%E8%BE%93%E5%85%A5%E5%88%9B%E5%BB%BA%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0Nginx%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81">http://ip/NginxStatus，输入创建的用户名和密码就可以看到Nginx的运行状态</a></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Active</span> connections: <span class="number">1</span>  <span class="comment">#Active connections表示当前活跃的连接数</span></span><br><span class="line">server accepts handled requests</span><br><span class="line"><span class="number">34561</span> <span class="number">35731</span> <span class="number">354399</span>  <span class="comment">#表示Nginx当前总共处理了34561个连接， 成功创建次握手， 总共处理了354399个请求</span></span><br><span class="line">Reading: <span class="number">0</span> Writing: <span class="number">3</span> Waiting: <span class="number">0</span>  <span class="comment">#Reading表示Nginx读取到客户端Header信息数， Writing表示Nginx返回给客户端的Header信息数，“Waiting”表示Nginx已经处理完，正在等候下一次请求指令时的驻留连接数</span></span><br></pre></td></tr></table></figure>



<h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p>这段设置中，设置了虚拟主机的错误信息返回页面，通过error_page指令可以定制各种错误信息的返回页面。在默认情况下，Nginx会在主目录的html目录中查找指定的返回页面，特别需要注意的是，这些错误信息的返回页面大小一定要超过512K，否者会被ie浏览器替换为ie默认的错误页面</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line"><span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line"><span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line"><span class="attribute">root</span> html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>Nginx</code> 的典型配置示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># main段配置信息</span><br><span class="line">user  nginx; # 运行用户，默认即是nginx，可以不进行设置</span><br><span class="line">worker_processes  auto; # Nginx 进程数，一般设置为和 CPU 核数一样</span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn; # Nginx 的错误日志存放目录</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid; # Nginx 服务启动时的 pid 存放位置</span><br><span class="line"></span><br><span class="line"># events段配置信息</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll; # 使用epoll的I&#x2F;O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)</span><br><span class="line">    worker_connections 1024; # 每个进程允许最大并发数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># http段配置信息</span><br><span class="line"># 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置</span><br><span class="line">http &#123; </span><br><span class="line">    # 设置日志模式</span><br><span class="line">    log_format  main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main; # Nginx访问日志存放位置</span><br><span class="line"></span><br><span class="line">    sendfile            on; # 开启高效传输模式</span><br><span class="line">    tcp_nopush          on; # 减少网络报文段的数量</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65; # 保持连接的时间，也叫超时时间，单位秒</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             &#x2F;etc&#x2F;nginx&#x2F;mime.types; # 文件扩展名与类型映射表</span><br><span class="line">    default_type        application&#x2F;octet-stream; # 默认文件类型</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; # 加载子配置项</span><br><span class="line">    </span><br><span class="line">    # server段配置信息</span><br><span class="line">    server &#123;</span><br><span class="line">     listen       80; # 配置监听的端口</span><br><span class="line">     server_name  localhost; # 配置的域名</span><br><span class="line">      </span><br><span class="line">     # location段配置信息</span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">      root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; # 网站根目录</span><br><span class="line">      index  index.html index.htm; # 默认首页文件</span><br><span class="line">      deny 172.168.22.11; # 禁止访问的ip地址，可以为all</span><br><span class="line">      allow 172.168.33.44；# 允许访问的ip地址，可以为all</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     error_page 500 502 503 504 &#x2F;50x.html; # 默认50x对应的访问页面</span><br><span class="line">     error_page 400 404 error.html; # 同上</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 全局配置，对全局生效；</li>
<li><code>events</code> 配置影响 <code>Nginx</code> 服务器与用户的网络连接；</li>
<li><code>http</code> 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置；</li>
<li><code>server</code> 配置虚拟主机的相关参数，一个 <code>http</code> 块中可以有多个 <code>server</code> 块；</li>
<li><code>location</code> 用于配置匹配的 <code>uri</code> ；</li>
<li><code>upstream</code> 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</li>
</ul>
<p>用一张图清晰的展示它的层级结构：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZttVadvjianCuG5VVd2nuiauWV2p6XTtSHiaIfjlNg8LuO8NYddOlj5iceJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="配置文件-main-段核心参数"><a href="#配置文件-main-段核心参数" class="headerlink" title="配置文件 main 段核心参数"></a>配置文件 main 段核心参数</h2><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>指定运行 <code>Nginx</code> 的 <code>woker</code> 子进程的属主和属组，其中组可以不指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user USERNAME [GROUP]</span><br><span class="line"></span><br><span class="line">user nginx lion; # 用户是nginx;组是lion</span><br></pre></td></tr></table></figure>



<p><strong>pid</strong></p>
<p>指定运行 <code>Nginx</code> <code>master</code> 主进程的 <code>pid</code> 文件存放路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid &#x2F;opt&#x2F;nginx&#x2F;logs&#x2F;nginx.pid # master主进程的的pid存放在nginx.pid的文件</span><br></pre></td></tr></table></figure>

<h3 id="worker-rlimit-nofile-number"><a href="#worker-rlimit-nofile-number" class="headerlink" title="worker_rlimit_nofile_number"></a>worker_rlimit_nofile_number</h3><p>指定 <code>worker</code> 子进程可以打开的最大文件句柄数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile 20480; # 可以理解成每个worker子进程的最大连接数量。</span><br></pre></td></tr></table></figure>



<p><strong>worker_rlimit_core</strong></p>
<p>指定 <code>worker</code> 子进程异常终止后的 <code>core</code> 文件，用于记录分析问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_core 50M; # 存放大小限制</span><br><span class="line">working_directory &#x2F;opt&#x2F;nginx&#x2F;tmp; # 存放目录</span><br></pre></td></tr></table></figure>

<h3 id="worker-processes-number"><a href="#worker-processes-number" class="headerlink" title="worker_processes_number"></a>worker_processes_number</h3><p>指定 <code>Nginx</code> 启动的 <code>worker</code> 子进程数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 4; # 指定具体子进程数量</span><br><span class="line">worker_processes auto; # 与当前cpu物理核心数一致</span><br></pre></td></tr></table></figure>

<h3 id="worker-cpu-affinity"><a href="#worker-cpu-affinity" class="headerlink" title="worker_cpu_affinity"></a>worker_cpu_affinity</h3><p>将每个 <code>worker</code> 子进程与我们的 <code>cpu</code> 物理核心绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_cpu_affinity 0001 0010 0100 1000; # 4个物理核心，4个worker子进程</span><br></pre></td></tr></table></figure>



<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZtZIGmia42mZYtFicgicRtCKBCJYbon4trM52w2f8sqtXqSzUM2eZvm2tSw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>将每个 <code>worker</code> 子进程与特定 <code>CPU</code> 物理核心绑定，优势在于，避免同一个 <code>worker</code> 子进程在不同的 <code>CPU</code> 核心上切换，缓存失效，降低性能。但其并不能真正的避免进程切换。</p>
<p><strong>worker_priority</strong></p>
<p>指定 <code>worker</code> 子进程的 <code>nice</code> 值，以调整运行 <code>Nginx</code> 的优先级，通常设定为负值，以优先调用<code>Nginx</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_priority -10; # 120-10&#x3D;110，110就是最终的优先级</span><br></pre></td></tr></table></figure>

<p><code>Linux</code> 默认进程的优先级值是120，值越小越优先；<code>nice</code> 定范围为 <code>-20</code> 到 <code>+19</code> 。</p>
<p>[备注] 应用的默认优先级值是120加上 <code>nice</code> 值等于它最终的值，这个值越小，优先级越高。</p>
<h3 id="worker-shutdown-timeout"><a href="#worker-shutdown-timeout" class="headerlink" title="worker_shutdown_timeout"></a>worker_shutdown_timeout</h3><p>指定 <code>worker</code> 子进程优雅退出时的超时时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_shutdown_timeout 5s;</span><br></pre></td></tr></table></figure>

<h3 id="timer-resolution"><a href="#timer-resolution" class="headerlink" title="timer_resolution"></a>timer_resolution</h3><p><code>worker</code> 子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_resolution 100ms;</span><br></pre></td></tr></table></figure>

<p>在 <code>Linux</code> 系统中，用户需要获取计时器时需要向操作系统内核发送请求，有请求就必然会有开销，因此这个间隔越大开销就越小。</p>
<p><strong>daemon</strong></p>
<p>指定 <code>Nginx</code> 的运行方式，前台还是后台，前台用于调试，后台用于生产。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemon off; # 默认是on，后台运行模式</span><br></pre></td></tr></table></figure>

<h2 id="配置文件-events-段核心参数"><a href="#配置文件-events-段核心参数" class="headerlink" title="配置文件 events 段核心参数"></a>配置文件 events 段核心参数</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p><code>Nginx</code> 使用何种事件驱动模型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use method; # 不推荐配置它，让nginx自己选择</span><br><span class="line"></span><br><span class="line">method 可选值为：select、poll、kqueue、epoll、&#x2F;dev&#x2F;poll、eventport</span><br></pre></td></tr></table></figure>

<h3 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h3><p><code>worker</code> 子进程能够处理的最大并发连接数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_connections 1024 # 每个子进程的最大连接数为1024</span><br></pre></td></tr></table></figure>

<p><strong>accept_mutex</strong></p>
<p>是否打开负载均衡互斥锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept_mutex on # 默认是off关闭的，这里推荐打开</span><br></pre></td></tr></table></figure>

<p><strong>server_name 指令</strong></p>
<p>指定虚拟主机域名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_name name1 name2 name3</span><br><span class="line"></span><br><span class="line"># 示例：</span><br><span class="line">server_name www.nginx.com;</span><br></pre></td></tr></table></figure>

<p>域名匹配的四种写法：</p>
<ul>
<li>精确匹配：<code>server_name www.nginx.com</code> ;</li>
<li>左侧通配：<code>server_name *.nginx.com</code> ;</li>
<li>右侧统配：<code>server_name www.nginx.*</code> ;</li>
<li>正则匹配：<code>server_name ~^www\.nginx\.*$</code> ;</li>
</ul>
<p>匹配优先级：<strong>精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配</strong></p>
<p><code>server_name</code> 配置实例：</p>
<p>1、配置本地 <code>DNS</code> 解析 <code>vim /etc/hosts</code> （ <code>macOS</code> 系统）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加如下内容，其中 121.42.11.34 是阿里云服务器IP地址</span><br><span class="line">121.42.11.34 www.nginx-test.com</span><br><span class="line">121.42.11.34 mail.nginx-test.com</span><br><span class="line">121.42.11.34 www.nginx-test.org</span><br><span class="line">121.42.11.34 doc.nginx-test.com</span><br><span class="line">121.42.11.34 www.nginx-test.cn</span><br><span class="line">121.42.11.34 fe.nginx-test.club</span><br></pre></td></tr></table></figure>

<p>[注意] 这里使用的是虚拟域名进行测试，因此需要配置本地 <code>DNS</code> 解析，如果使用阿里云上购买的域名，则需要在阿里云上设置好域名解析。</p>
<p>2、配置阿里云 <code>Nginx</code> ，<code>vim /etc/nginx/nginx.conf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 这里只列举了http端中的sever端配置</span><br><span class="line"></span><br><span class="line"># 左匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name *.nginx-test.com;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;left-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 正则匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name ~^.*\.nginx-test\..*$;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;reg-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 右匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name www.nginx-test.*;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;right-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 完全匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name www.nginx-test.com;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;all-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、访问分析</p>
<ul>
<li>当访问 <code>www.nginx-test.com</code> 时，都可以被匹配上，因此选择优先级最高的“完全匹配”；</li>
<li>当访问 <code>mail.nginx-test.com</code> 时，会进行“左匹配”；</li>
<li>当访问 <code>www.nginx-test.org</code> 时，会进行“右匹配”；</li>
<li>当访问 <code>doc.nginx-test.com</code> 时，会进行“左匹配”；</li>
<li>当访问 <code>www.nginx-test.cn</code> 时，会进行“右匹配”；</li>
<li>当访问 <code>fe.nginx-test.club</code> 时，会进行“正则匹配”；</li>
</ul>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>指定静态资源目录位置，它可以写在 <code>http</code> 、 <code>server</code> 、 <code>location</code> 等配置中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root path</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location &#x2F;image &#123;</span><br><span class="line"> root &#x2F;opt&#x2F;nginx&#x2F;static;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当用户访问 www.test.com&#x2F;image&#x2F;1.png 时，实际在服务器找的路径是 &#x2F;opt&#x2F;nginx&#x2F;static&#x2F;image&#x2F;1.png</span><br></pre></td></tr></table></figure>

<p>[注意] <code>root</code> 会将定义路径与 <code>URI</code> 叠加， <code>alias</code> 则只取定义路径。</p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>它也是指定静态资源目录位置，它只能写在 <code>location</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;image &#123;</span><br><span class="line"> alias &#x2F;opt&#x2F;nginx&#x2F;static&#x2F;image&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当用户访问 www.test.com&#x2F;image&#x2F;1.png 时，实际在服务器找的路径是 &#x2F;opt&#x2F;nginx&#x2F;static&#x2F;image&#x2F;1.png</span><br></pre></td></tr></table></figure>

<p>[注意] 使用 alias 末尾一定要添加 <code>/</code> ，并且它只能位于 <code>location</code> 中。</p>
<p><strong>location</strong></p>
<p>配置路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location [ &#x3D; | ~ | ~* | ^~ ] uri &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配规则：</p>
<ul>
<li><code>=</code> 精确匹配；</li>
<li><code>~</code> 正则匹配，区分大小写；</li>
<li><code>~*</code> 正则匹配，不区分大小写；</li>
<li><code>^~</code> 匹配到即停止搜索；</li>
</ul>
<p>匹配优先级：<code>=</code> &gt; <code>^~</code> &gt; <code>~</code> &gt; <code>~*</code> &gt; 不带任何字符。</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name www.nginx-test.com;</span><br><span class="line">  </span><br><span class="line">  # 只有当访问 www.nginx-test.com&#x2F;match_all&#x2F; 时才会匹配到&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;match_all&#x2F;index.html</span><br><span class="line">  location &#x3D; &#x2F;match_all&#x2F; &#123;</span><br><span class="line">      root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">      index index.html</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 当访问 www.nginx-test.com&#x2F;1.jpg 等路径时会去 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;images&#x2F;1.jpg 找对应的资源</span><br><span class="line">  location ~ \.(jpeg|jpg|png|svg)$ &#123;</span><br><span class="line">   root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;images;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 当访问 www.nginx-test.com&#x2F;bbs&#x2F; 时会匹配上 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;bbs&#x2F;index.html</span><br><span class="line">  location ^~ &#x2F;bbs&#x2F; &#123;</span><br><span class="line">   root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>location 中的反斜线</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;test &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;test&#x2F; &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找 <code>test</code> 目录下的 <code>index.html</code> ；如果没有 <code>test</code> 目录， <code>nginx</code> 则会找是否有 <code>test</code> 文件。</li>
<li>带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找<code>test</code> 目录下的 <code>index.html</code> ，如果没有它也不会去找是否存在 <code>test</code> 文件。</li>
</ul>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>停止处理请求，直接返回响应码或重定向到其他 <code>URL</code> ；执行 <code>return</code> 指令后， <code>location</code> 中后续指令将不会被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">return code [text];</span><br><span class="line">return code URL;</span><br><span class="line">return URL;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return 404; # 直接返回状态码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return 404 &quot;pages not found&quot;; # 返回状态码 + 一段文本</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return 302 &#x2F;bbs ; # 返回状态码 + 重定向地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return https:&#x2F;&#x2F;www.baidu.com ; # 返回重定向地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>根据指定正则表达式匹配规则，重写 <code>URL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：rewrite 正则表达式 要替换的内容 [flag];</span><br><span class="line"></span><br><span class="line">上下文：server、location、if</span><br><span class="line"></span><br><span class="line">示例：rewirte &#x2F;images&#x2F;(.*\.jpg)$ &#x2F;pic&#x2F;$1; # $1是前面括号(.*\.jpg)的反向引用</span><br></pre></td></tr></table></figure>

<p><code>flag</code> 可选值的含义：</p>
<ul>
<li><code>last</code> 重写后的 <code>URL</code> 发起新请求，再次进入 <code>server</code> 段，重试 <code>location</code> 的中的匹配；</li>
<li><code>break</code> 直接使用重写后的 <code>URL</code> ，不再匹配其它 <code>location</code> 中语句；</li>
<li><code>redirect</code> 返回302临时重定向；</li>
<li><code>permanent</code> 返回301永久重定向；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name fe.lion.club; # 要在本地hosts文件进行配置</span><br><span class="line">  root html;</span><br><span class="line">  location &#x2F;search &#123;</span><br><span class="line">   rewrite ^&#x2F;(.*) https:&#x2F;&#x2F;www.baidu.com redirect;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;images &#123;</span><br><span class="line">   rewrite &#x2F;images&#x2F;(.*) &#x2F;pics&#x2F;$1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;pics &#123;</span><br><span class="line">   rewrite &#x2F;pics&#x2F;(.*) &#x2F;photos&#x2F;$1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;photos &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照这个配置我们来分析：</p>
<ul>
<li>当访问 <code>fe.lion.club/search</code> 时，会自动帮我们重定向到 <code>https://www.baidu.com</code>。</li>
<li>当访问 <code>fe.lion.club/images/1.jpg</code> 时，第一步重写 <code>URL</code> 为 <code>fe.lion.club/pics/1.jpg</code>，找到 <code>pics</code> 的 <code>location</code> ，继续重写 <code>URL</code> 为 <code>fe.lion.club/photos/1.jpg</code> ，找到<code>/photos</code> 的 <code>location</code> 后，去 <code>html/photos</code> 目录下寻找 <code>1.jpg</code> 静态资源。</li>
</ul>
<h2 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：if (condition) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">上下文：server、location</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">if($http_user_agent ~ Chrome)&#123;</span><br><span class="line">  rewrite &#x2F;(.*)&#x2F;browser&#x2F;$1 break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>condition</code> 判断条件：</p>
<ul>
<li><code>$variable</code> 仅为变量时，值为空或以0开头字符串都会被当做 <code>false</code> 处理；</li>
<li><code>=</code> 或 <code>!=</code> 相等或不等；</li>
<li><code>~</code> 正则匹配；</li>
<li><code>! ~</code> 非正则匹配；</li>
<li><code>~*</code> 正则匹配，不区分大小写；</li>
<li><code>-f</code> 或 <code>! -f</code> 检测文件存在或不存在；</li>
<li><code>-d</code> 或 <code>! -d</code> 检测目录存在或不存在；</li>
<li><code>-e</code> 或 <code>! -e</code> 检测文件、目录、符号链接等存在或不存在；</li>
<li><code>-x</code> 或 <code>! -x</code> 检测文件可以执行或不可执行；</li>
</ul>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 8080;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  root html;</span><br><span class="line">  </span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   if ( $uri &#x3D; &quot;&#x2F;images&#x2F;&quot; )&#123;</span><br><span class="line">     rewrite (.*) &#x2F;pics&#x2F; break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当访问 <code>localhost:8080/images/</code> 时，会进入 <code>if</code> 判断里面执行 <code>rewrite</code> 命令。</p>
<p><strong>autoindex</strong></p>
<p>用户请求以 <code>/</code> 结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。</p>
<p><code>autoindex.conf</code> 配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name fe.lion-test.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;download&#x2F; &#123;</span><br><span class="line">    root &#x2F;opt&#x2F;source;</span><br><span class="line">    </span><br><span class="line">    autoindex on; # 打开 autoindex，，可选参数有 on | off</span><br><span class="line">    autoindex_exact_size on; # 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩</span><br><span class="line">    autoindex_format html; # 以html的方式进行格式化，可选参数有 html | json | xml</span><br><span class="line">    autoindex_localtime off; # 显示的⽂件时间为⽂件的服务器时间。默认为off，显示的⽂件时间为GMT时间</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当访问 <code>fe.lion.com/download/</code> 时，会把服务器 <code>/opt/source/download/</code> 路径下的文件展示出来，如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZtGScQRCxyfmDPfskKicRMDGMibAnLj1WX8Vv0nS8hGaAZEfohJOIuzvTA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>变量</strong></p>
<p><code>Nginx</code> 提供给使用者的变量非常多，但是终究是一个完整的请求过程所产生数据， <code>Nginx</code> 将这些数据以变量的形式提供给使用者。</p>
<p>下面列举些项目中常用的变量：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tshHIlcFwiap9d3kaiaXLvLMAibOBfJXwBxia7msxn3zw1D7Obd4OO8HoOt23ibjMLhW2snkLDfj3YGGIkw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>实例演示 <code>var.conf</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"> listen 8081;</span><br><span class="line"> server_name var.lion-test.club;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  return 200 &quot;</span><br><span class="line">remote_addr: $remote_addr</span><br><span class="line">remote_port: $remote_port</span><br><span class="line">server_addr: $server_addr</span><br><span class="line">server_port: $server_port</span><br><span class="line">server_protocol: $server_protocol</span><br><span class="line">binary_remote_addr: $binary_remote_addr</span><br><span class="line">connection: $connection</span><br><span class="line">uri: $uri</span><br><span class="line">request_uri: $request_uri</span><br><span class="line">scheme: $scheme</span><br><span class="line">request_method: $request_method</span><br><span class="line">request_length: $request_length</span><br><span class="line">args: $args</span><br><span class="line">arg_pid: $arg_pid</span><br><span class="line">is_args: $is_args</span><br><span class="line">query_string: $query_string</span><br><span class="line">host: $host</span><br><span class="line">http_user_agent: $http_user_agent</span><br><span class="line">http_referer: $http_referer</span><br><span class="line">http_via: $http_via</span><br><span class="line">request_time: $request_time</span><br><span class="line">https: $https</span><br><span class="line">request_filename: $request_filename</span><br><span class="line">document_root: $document_root</span><br><span class="line">&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们访问 <code>http://var.lion-test.club:8081/test?pid=121414&amp;cid=sadasd</code> 时，由于<code>Nginx</code> 中写了 <code>return</code> 方法，因此 <code>chrome</code> 浏览器会默认为我们下载一个文件，下面展示的就是下载的文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">remote_addr: 27.16.220.84</span><br><span class="line">remote_port: 56838</span><br><span class="line">server_addr: 172.17.0.2</span><br><span class="line">server_port: 8081</span><br><span class="line">server_protocol: HTTP&#x2F;1.1</span><br><span class="line">binary_remote_addr: 茉</span><br><span class="line">connection: 126</span><br><span class="line">uri: &#x2F;test&#x2F;</span><br><span class="line">request_uri: &#x2F;test&#x2F;?pid&#x3D;121414&amp;cid&#x3D;sadasd</span><br><span class="line">scheme: http</span><br><span class="line">request_method: GET</span><br><span class="line">request_length: 518</span><br><span class="line">args: pid&#x3D;121414&amp;cid&#x3D;sadasd</span><br><span class="line">arg_pid: 121414</span><br><span class="line">is_args: ?</span><br><span class="line">query_string: pid&#x3D;121414&amp;cid&#x3D;sadasd</span><br><span class="line">host: var.lion-test.club</span><br><span class="line">http_user_agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;88.0.4324.182 Safari&#x2F;537.36</span><br><span class="line">http_referer: </span><br><span class="line">http_via: </span><br><span class="line">request_time: 0.000</span><br><span class="line">https: </span><br><span class="line">request_filename: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;test&#x2F;</span><br><span class="line">document_root: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br></pre></td></tr></table></figure>

<p><code>Nginx</code> 的配置还有非常多，以上只是罗列了一些常用的配置，在实际项目中还是要学会查阅文档。</p>
<p><strong>Nginx 应用核心概念</strong></p>
<p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p>
<p>不管是正向代理还是反向代理，实现的都是上面的功能。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZtguRkXWwLy0FsAVibBv3qiaJhmu1Dh28ibEZ1BxVXn4icUJJU7PvzibQx5Yg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>正向代理</strong></p>
<blockquote>
<p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
</blockquote>
<p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p>
<p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p>
<p><strong>反向代理</strong></p>
<blockquote>
<ul>
<li>反向代理*（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li>
</ul>
</blockquote>
<p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p>
<p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p>
<p>反向代理的优势：</p>
<ul>
<li>隐藏真实服务器；</li>
<li>负载均衡便于横向扩充后端动态服务；</li>
<li>动静分离，提升系统健壮性；</li>
</ul>
<p>那么“动静分离”是什么？负载均衡又是什么？</p>
<p><strong>动静分离</strong></p>
<p>动静分离是指在 <code>web</code> 服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提示整个服务的访问性和可维护性。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZtxdyM0vuy9aNSw1dp7ic3PxiajokELb0U4picENsJ0cQoUOwIXDMZibMoTg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>一般来说，都需要将动态资源和静态资源分开，由于 <code>Nginx</code> 的高并发和静态资源缓存等特性，经常将静态资源部署在 <code>Nginx</code> 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p>
<p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p>
<p><strong>负载均衡</strong></p>
<p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p>
<p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p>
<p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p>
<p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。<code>Nginx</code> 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p>
<p>举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 <code>B</code> 口，<code>B</code> 口人少车空….”，这个工作人员的作用就是负载均衡。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZt4hPMc4FRgLth4Yn0Q8F8tj0v2xaKCQrPfJVpWEn5W4Aq3JaT8M059A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><code>Nginx</code> 实现负载均衡的策略：</p>
<ul>
<li>轮询策略：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</li>
<li>最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</li>
<li>最快响应时间策略：优先分配给响应时间最短的服务器。</li>
<li>客户端 <code>ip</code> 绑定策略：来自同一个 <code>ip</code> 的请求永远只分配一台服务器，有效解决了动态网页存在的 <code>session</code> 共享问题。</li>
</ul>
<p><strong>Nginx 实战配置</strong></p>
<p>在配置反向代理和负载均衡等等功能之前，有两个核心模块是我们必须要掌握的，这两个模块应该说是 <code>Nginx</code> 应用配置中的核心，它们分别是：<code>upstream</code> 、<code>proxy_pass</code> 。</p>
<p><strong>upstream</strong></p>
<p>用于定义上游服务器（指的就是后台提供的应用服务器）的相关信息。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZtPq4RNcsFc6icp4alOBg28vOho4W8VCUUeJGrxuSktIYD7MeNbZTQ6eA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：upstream name &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">upstream back_end_server&#123;</span><br><span class="line">  server 192.168.100.33:8081</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>upstream</code> 内可使用的指令：</p>
<ul>
<li><code>server</code> 定义上游服务器地址；</li>
<li><code>zone</code> 定义共享内存，用于跨 <code>worker</code> 子进程；</li>
<li><code>keepalive</code> 对上游服务启用长连接；</li>
<li><code>keepalive_requests</code> 一个长连接最多请求 <code>HTTP</code> 的个数；</li>
<li><code>keepalive_timeout</code> 空闲情形下，一个长连接的超时时长；</li>
<li><code>hash</code> 哈希负载均衡算法；</li>
<li><code>ip_hash</code> 依据 <code>IP</code> 进行哈希计算的负载均衡算法；</li>
<li><code>least_conn</code> 最少连接数负载均衡算法；</li>
<li><code>least_time</code> 最短响应时间负载均衡算法；</li>
<li><code>random</code> 随机负载均衡算法；</li>
</ul>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>定义上游服务器地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：server address [parameters]</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>

<p><code>parameters</code> 可选值：</p>
<ul>
<li><code>weight=number</code> 权重值，默认为1；</li>
<li><code>max_conns=number</code> 上游服务器的最大并发连接数；</li>
<li><code>fail_timeout=time</code> 服务器不可用的判定时间；</li>
<li><code>max_fails=numer</code> 服务器不可用的检查次数；</li>
<li><code>backup</code> 备份服务器，仅当其他服务器都不可用时才会启用；</li>
<li><code>down</code> 标记服务器长期不可用，离线维护；</li>
</ul>
<h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p>限制每个 <code>worker</code> 子进程与上游服务器空闲长连接的最大数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keepalive connections;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br><span class="line"></span><br><span class="line">示例：keepalive 16;</span><br></pre></td></tr></table></figure>

<h3 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h3><p>单个长连接可以处理的最多 <code>HTTP</code> 请求个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：keepalive_requests number;</span><br><span class="line"></span><br><span class="line">默认值：keepalive_requests 100;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>



<p><strong>keepalive_timeout</strong></p>
<p>空闲长连接的最长保持时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：keepalive_timeout time;</span><br><span class="line"></span><br><span class="line">默认值：keepalive_timeout 60s;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>

<h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream back_end&#123;</span><br><span class="line"> server 127.0.0.1:8081 weight&#x3D;3 max_conns&#x3D;1000 fail_timeout&#x3D;10s max_fails&#x3D;2;</span><br><span class="line">  keepalive 32;</span><br><span class="line">  keepalive_requests 50;</span><br><span class="line">  keepalive_timeout 30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>用于配置代理服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_pass URL;</span><br><span class="line"></span><br><span class="line">上下文：location、if、limit_except</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1:8081</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1:8081&#x2F;proxy</span><br></pre></td></tr></table></figure>

<p><code>URL</code> 参数原则</p>
<p><code>1. URL</code> 必须以 <code>http</code> 或 <code>https</code> 开头；</p>
<p><code>2. URL</code> 中可以携带变量；</p>
<p><code>3. URL</code> 中是否带 <code>URI</code> ，会直接影响发往上游请求的 <code>URL</code> ；</p>
<p>接下来让我们来看看两种常见的 <code>URL</code> 用法：</p>
<ol>
<li><code>proxy_pass http://192.168.100.33:8081</code></li>
<li><code>proxy_pass http://192.168.100.33:8081/</code></li>
</ol>
<p>这两种用法的区别就是带 <code>/</code> 和不带 <code>/</code> ，在配置代理时它们的区别可大了：</p>
<ul>
<li>不带 <code>/</code> 意味着 <code>Nginx</code> 不会修改用户 <code>URL</code> ，而是直接透传给上游的应用服务器；</li>
<li>带 <code>/</code> 意味着 <code>Nginx</code> 会修改用户 <code>URL</code> ，修改方法是将 <code>location</code> 后的 <code>URL</code> 从用户 <code>URL</code> 中删除；</li>
</ul>
<p>不带 <code>/</code> 的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;bbs&#x2F;&#123;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>\1. 用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>\2. 请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>3 .请求到达上游应用服务器的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>带 <code>/</code> 的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;bbs&#x2F;&#123;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>\1. 用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>\2. 请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>\3. 请求到达上游应用服务器的 <code>URL</code> ：<code>/abc/test.html</code></p>
<p>并没有拼接上 <code>/bbs</code> ，这点和 <code>root</code> 与 <code>alias</code> 之间的区别是保持一致的。</p>
<p><strong>配置反向代理</strong></p>
<p>这里为了演示更加接近实际，作者准备了两台云服务器，它们的公网 <code>IP</code> 分别是：<code>121.42.11.34</code>与 <code>121.5.180.193</code> 。</p>
<p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy.conf</span><br><span class="line">server&#123;</span><br><span class="line">  listen 8080;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;proxy;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;proxy&#x2F;index.html</span><br><span class="line">&lt;h1&gt; 121.42.11.34 proxy html &lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>



<p>配置完成后重启 <code>Nginx</code> 服务器 <code>nginx \-s reload</code> 。</p>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy.conf</span><br><span class="line">upstream back_end &#123;</span><br><span class="line">  server 121.42.11.34:8080 weight&#x3D;2 max_conns&#x3D;1000 fail_timeout&#x3D;10s max_fails&#x3D;3;</span><br><span class="line">  keepalive 32;</span><br><span class="line">  keepalive_requests 80;</span><br><span class="line">  keepalive_timeout 20s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name proxy.lion.club;</span><br><span class="line">  location &#x2F;proxy &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;back_end&#x2F;proxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地机器要访问 <code>proxy.lion.club</code> 域名，因此需要配置本地 <code>hosts</code> ，通过命令：<code>vim /etc/hosts</code> 进入配置文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121.5.180.193 proxy.lion.club</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZt7ZagQyO1XZk6iclBoicY5v7OhGGrqfmCEswrNtAgyKpl6GhOefU6wo1w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>分析：</p>
<p>当访问 <code>proxy.lion.club/proxy</code> 时通过 <code>upstream</code> 的配置找到 <code>121.42.11.34:8080</code> ；</p>
<p>因此访问地址变为 <code>http://121.42.11.34:8080/proxy</code> ；</p>
<p>连接到 <code>121.42.11.34</code> 服务器，找到 <code>8080</code> 端口提供的 <code>server</code> ；</p>
<p>通过 <code>server</code> 找到 <code>/usr/share/nginx/html/proxy/index.html</code> 资源，最终展示出来。</p>
<h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p>配置负载均衡主要是要使用 <code>upstream</code> 指令。</p>
<p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（<code>/etc/nginx/conf.d/balance.conf</code> ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 8020;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   return 200 &#39;return 8020 \n&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">  listen 8030;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   return 200 &#39;return 8030 \n&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">  listen 8040;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   return 200 &#39;return 8040 \n&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后：</p>
<p><code>1. nginx -t</code> 检测配置是否正确；</p>
<p><code>2. nginx -s reload</code> 重启 <code>Nginx</code> 服务器；</p>
<p>\3. 执行 <code>ss -nlt</code> 命令查看端口是否被占用，从而判断 <code>Nginx</code> 服务是否正确启动。</p>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后重启 <code>Nginx</code> 服务器。并且在需要访问的客户端配置好 <code>ip</code> 和域名的映射关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;hosts</span><br><span class="line"></span><br><span class="line">121.5.180.193 balance.lion.club</span><br></pre></td></tr></table></figure>

<p>在客户端机器执行 <code>curl http://balance.lion.club/balance/</code> 命令：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZtJcN9Ghfnox2UsXQohHk2LOichwufTKWRBoU0F4ibAI5AKfXjeLXSLDXg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>不难看出，负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。就是通过简单的轮询策略进行上游服务器分发。</p>
<p>接下来，我们再来了解下 <code>Nginx</code> 的其它分发策略。</p>
<p><strong>hash 算法</strong></p>
<p>通过制定关键字作为 <code>hash key</code> ，基于 <code>hash</code> 算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  hash $request_uri;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hash $request_uri</code> 表示使用 <code>request_uri</code> 变量作为 <code>hash</code> 的 <code>key</code> 值，只要访问的 <code>URI</code> 保持不变，就会一直分发给同一台服务器。</p>
<p><strong>ip_hash</strong></p>
<p>根据客户端的请求 <code>ip</code> 进行判断，只要 <code>ip</code> 地址不变就永远分配到同一台主机。它可以有效解决后台服务器 <code>session</code> 保持的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h3><p>各个 <code>worker</code> 子进程通过读取共享内存的数据，来获取后端服务器的信息。来挑选一台当前已建立连接数最少的服务器进行分配请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：least_conn;</span><br><span class="line"></span><br><span class="line">上下文：upstream;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  zone test 10M; # zone可以设置共享内存空间的名字和大小</span><br><span class="line">  least_conn;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后你会发现，负载均衡的配置其实一点都不复杂。</p>
<p><strong>配置缓存</strong></p>
<p>缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（ <code>Nginx</code> ），乃至上游服务器都多少会涉及到缓存。可见缓存在每个环节都是非常重要的。下面让我们来学习<code>Nginx</code> 中如何设置缓存策略。</p>
<p><strong>proxy_cache</strong></p>
<p>存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整个访问速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache zone | off ; # zone 是共享内存的名称</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache off;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br></pre></td></tr></table></figure>

<p><strong>proxy_cache_path</strong></p>
<p>设置缓存文件的存放路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_path path [level&#x3D;levels] ...可选参数省略，下面会详细列举</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache_path off</span><br><span class="line"></span><br><span class="line">上下文：http</span><br></pre></td></tr></table></figure>

<p>参数含义：</p>
<ul>
<li><code>path</code> 缓存文件的存放路径；</li>
<li><code>level path</code> 的目录层级；</li>
<li><code>keys_zone</code> 设置共享内存；</li>
<li><code>inactive</code> 在指定时间内没有被访问，缓存会被清理，默认10分钟；</li>
</ul>
<h3 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h3><p>设置缓存文件的 <code>key</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_key</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache_key $scheme$proxy_host$request_uri;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br></pre></td></tr></table></figure>



<p><strong>proxy_cache_valid</strong></p>
<p>配置什么状态码可以被缓存，以及缓存时长。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_valid [code...] time;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">配置示例：proxy_cache_valid 200 304 2m;; # 说明对于状态为200和304的缓存文件的缓存时间是2分钟</span><br></pre></td></tr></table></figure>

<h3 id="proxy-no-cache"><a href="#proxy-no-cache" class="headerlink" title="proxy_no_cache"></a>proxy_no_cache</h3><p>定义相应保存到缓存的条件，如果字符串参数的至少一个值不为空且不等于“ 0”，则将不保存该响应到缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_no_cache string;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">示例：proxy_no_cache $http_pragma    $http_authorization;</span><br></pre></td></tr></table></figure>

<h3 id="proxy-cache-bypass"><a href="#proxy-cache-bypass" class="headerlink" title="proxy_cache_bypass"></a>proxy_cache_bypass</h3><p>定义条件，在该条件下将不会从缓存中获取响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_bypass string;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">示例：proxy_cache_bypass $http_pragma    $http_authorization;</span><br></pre></td></tr></table></figure>

<h3 id="upstream-cache-status-变量"><a href="#upstream-cache-status-变量" class="headerlink" title="upstream_cache_status 变量"></a>upstream_cache_status 变量</h3><p>它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MISS: 未命中缓存</span><br><span class="line">HIT：命中缓存</span><br><span class="line">EXPIRED: 缓存过期</span><br><span class="line">STALE: 命中了陈旧缓存</span><br><span class="line">REVALIDDATED: Nginx验证陈旧缓存依然有效</span><br><span class="line">UPDATING: 内容陈旧，但正在更新</span><br><span class="line">BYPASS: X响应从原始服务器获取</span><br></pre></td></tr></table></figure>

<h3 id="配置实例-1"><a href="#配置实例-1" class="headerlink" title="配置实例"></a>配置实例</h3><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 1010;</span><br><span class="line">  root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;1010;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 1020;</span><br><span class="line">  root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;1020;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path &#x2F;etc&#x2F;nginx&#x2F;cache_temp levels&#x3D;2:2 keys_zone&#x3D;cache_zone:30m max_size&#x3D;2g inactive&#x3D;60m use_temp_path&#x3D;off;</span><br><span class="line"></span><br><span class="line">upstream cache_server&#123;</span><br><span class="line">  server 121.42.11.34:1010;</span><br><span class="line">  server 121.42.11.34:1020;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name cache.lion.club;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_cache cache_zone; # 设置缓存内存，上面配置中已经定义好的</span><br><span class="line">    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟</span><br><span class="line">    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI</span><br><span class="line">    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;cache_server; # 代理转发</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存就是这样配置，我们可以在 <code>/etc/nginx/cache_temp</code> 路径下找到相应的缓存文件。</p>
<p><strong>对于一些实时性要求非常高的页面或数据来说，就不应该去设置缓存，下面来看看如何配置不缓存的内容。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name cache.lion.club;</span><br><span class="line">  # URI 中后缀为 .txt 或 .text 的设置变量值为 &quot;no cache&quot;</span><br><span class="line">  if ($request_uri ~ \.(txt|text)$) &#123;</span><br><span class="line">   set $cache_name &quot;no cache&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存</span><br><span class="line">    proxy_cache cache_zone; # 设置缓存内存</span><br><span class="line">    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟</span><br><span class="line">    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI</span><br><span class="line">    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;cache_server; # 代理转发</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HTTPS</strong>**<br>**</p>
<p>在学习如何配置 <code>HTTPS</code> 之前，我们先来简单回顾下 <code>HTTPS</code> 的工作流程是怎么样的？它是如何进行加密保证安全的？</p>
<p><strong>HTTPS 工作流程</strong></p>
<p>\1. 客户端（浏览器）访问 <code>https://www.baidu.com</code> 百度网站；</p>
<p>\2. 百度服务器返回 <code>HTTPS</code> 使用的 <code>CA</code> 证书；</p>
<p>\3. 浏览器验证 <code>CA</code> 证书是否为合法证书；</p>
<p>\4. 验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密；</p>
<p>\5. 发送公钥加密后的随机数给百度服务器；</p>
<p>\6. 百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）；</p>
<p>\7. 百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器；</p>
<p>\8. 此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容；</p>
<p>这就是 <code>HTTPS</code> 的基本运作原理，使用对称加密和非对称机密配合使用，保证传输内容的安全性。</p>
<p>关于HTTPS更多知识，可以查看作者的另外一篇文章《学习 HTTP 协议》。</p>
<h3 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h3><p>下载证书的压缩文件，里面有个 <code>Nginx</code> 文件夹，把 <code>xxx.crt</code> 和 <code>xxx.key</code> 文件拷贝到服务器目录，再进行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl http2 default_server; # SSL 访问端口号为 443</span><br><span class="line">  server_name lion.club; # 填写绑定证书的域名(我这里是随便写的)</span><br><span class="line">  ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;https&#x2F;lion.club_bundle.crt; # 证书地址</span><br><span class="line">  ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;https&#x2F;lion.club.key; # 私钥地址</span><br><span class="line">  ssl_session_timeout 10m;</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2]</span><br><span class="line"> </span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    index        index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此配置后就能正常访问 <code>HTTPS</code> 版的网站了。</p>
<p><strong>配置跨域 CORS</strong></p>
<p>先简单回顾下跨域究竟是怎么回事。</p>
<p><strong>跨域的定义</strong></p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。</p>
<p><strong>同源的定义</strong></p>
<p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p>下面给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;store.company.com&#x2F;dir2&#x2F;other.html 同源</span><br><span class="line">https:&#x2F;&#x2F;store.company.com&#x2F;secure.html 不同源，协议不同</span><br><span class="line">http:&#x2F;&#x2F;store.company.com:81&#x2F;dir&#x2F;etc.html 不同源，端口不同</span><br><span class="line">http:&#x2F;&#x2F;news.company.com&#x2F;dir&#x2F;other.html 不同源，主机不同</span><br></pre></td></tr></table></figure>

<p>不同源会有如下限制：</p>
<ul>
<li><code>Web</code> 数据层面，同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code> 、 <code>IndexDB</code> 、<code>LocalStorage</code> 等数据。</li>
<li><code>DOM</code> 层面，同源策略限制了来自不同源的 <code>JavaScript</code> 脚本对当前 <code>DOM</code> 对象读和写的操作。</li>
<li>网络层面，同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li>
</ul>
<h3 id="Nginx-解决跨域的原理"><a href="#Nginx-解决跨域的原理" class="headerlink" title="Nginx 解决跨域的原理"></a>Nginx 解决跨域的原理</h3><p>例如：</p>
<ul>
<li>前端 <code>server</code> 的域名为：<code>fe.server.com</code></li>
<li>后端服务的域名为：<code>dev.server.com</code></li>
</ul>
<p>现在我在 <code>fe.server.com</code> 对 <code>dev.server.com</code> 发起请求一定会出现跨域。</p>
<p>现在我们只需要启动一个 <code>Nginx</code> 服务器，将 <code>server_name</code> 设置为 <code>fe.server.com</code> 然后设置相应的 <code>location</code> 以拦截前端需要跨域的请求，最后将请求代理回 <code>dev.server.com</code> 。如下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen      80;</span><br><span class="line"> server_name  fe.server.com;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  proxy_pass dev.server.com;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以完美绕过浏览器的同源策略：<code>fe.server.com</code> 访问 <code>Nginx</code> 的 <code>fe.server.com</code> 属于同源访问，而 <code>Nginx</code> 对服务端转发的请求不会触发浏览器的同源策略。</p>
<p><strong>配置开启 gzip 压缩</strong></p>
<p><code>GZIP</code> 是规定的三种标准 <code>HTTP</code> 压缩格式之一。目前绝大多数的网站都在使用 <code>GZIP</code> 传输 <code>HTML</code>、<code>CSS</code> 、 <code>JavaScript</code> 等资源文件。</p>
<p>对于文本文件， <code>GZiP</code> 的效果非常明显，开启后传输所需流量大约会降至 <code>1/4~1/3</code> 。</p>
<p>并不是每个浏览器都支持 <code>gzip</code> 的，如何知道客户端是否支持 <code>gzip</code> 呢，请求头中的 <code>Accept-Encoding</code> 来标识对压缩的支持。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZtQ9PJYOamEYj5iaicj56RYTkgZIy3f99kB6wRibzA6jaqPGPbiceKG1QsCA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>启用 <code>gzip</code> 同时需要客户端和服务端的支持，如果客户端支持 <code>gzip</code> 的解析，那么只要服务端能够返回 <code>gzip</code> 的文件就可以启用 <code>gzip</code> 了,我们可以通过 <code>Nginx</code> 的配置来让服务端支持 <code>gzip</code> 。下面的 <code>respone</code> 中 <code>content-encoding:gzip</code> ，指服务端开启了 <code>gzip</code> 的压缩方式。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZtywHU7es5DM2kDNfU3jChbCnVr3RNYZlv5ekHgbGE5JvffWlPuMseibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在 <code>/etc/nginx/conf.d/</code> 文件夹中新建配置文件 <code>gzip.conf</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># # 默认off，是否开启gzip</span><br><span class="line">gzip on; </span><br><span class="line"># 要采用 gzip 压缩的 MIME 文件类型，其中 text&#x2F;html 被系统强制启用；</span><br><span class="line">gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;x-javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;</span><br><span class="line"></span><br><span class="line"># ---- 以上两个参数开启就可以支持Gzip压缩了 ---- #</span><br><span class="line"></span><br><span class="line"># 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</span><br><span class="line">gzip_static on;</span><br><span class="line"></span><br><span class="line"># 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；</span><br><span class="line">gzip_proxied any;</span><br><span class="line"></span><br><span class="line"># 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br><span class="line"># gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"></span><br><span class="line"># 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；</span><br><span class="line">gzip_buffers 16 8k;</span><br><span class="line"></span><br><span class="line"># 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</span><br><span class="line"># gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line"># 默认 1.1，启用 gzip 所需的 HTTP 最低版本；</span><br><span class="line">gzip_http_version 1.1;</span><br></pre></td></tr></table></figure>



<p>其实也可以通过前端构建工具例如 <code>webpack</code> 、<code>rollup</code> 等在打生产包时就做好 <code>Gzip</code> 压缩，然后放到 <code>Nginx</code> 服务器中，这样可以减少服务器的开销，加快访问速度。</p>
<p>关于 <code>Nginx</code> 的实际应用就学习到这里，相信通过掌握了 <code>Nginx</code> 核心配置以及实战配置，之后再遇到什么需求，我们也能轻松应对。接下来，让我们再深入一点学习下 <code>Nginx</code> 的架构。</p>
<p><strong>Nginx 架构</strong></p>
<p><strong>进程结构</strong></p>
<p>多进程结构 <code>Nginx</code> 的进程模型图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZtjISwuYtV601flgG5sgMTvqKOM6hf0jbzwvgrB7iafwlBkVSvmPp6lVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>多进程中的 <code>Nginx</code> 进程架构如下图所示，会有一个父进程（ <code>Master Process</code> ），它会有很多子进程（ <code>Child Processes</code> ）。</p>
<ul>
<li><p><code>Master Process</code> 用来管理子进程的，其本身并不真正处理用户请求。</p>
</li>
<li><ul>
<li>某个子进程 <code>down</code> 掉的话，它会向 <code>Master</code> 进程发送一条消息，表明自己不可用了，此时<code>Master</code> 进程会去新起一个子进程。</li>
<li>某个配置文件被修改了 <code>Master</code> 进程会去通知 <code>work</code> 进程获取新的配置信息，这也就是我们所说的热部署。</li>
</ul>
</li>
<li><p>子进程间是通过共享内存的方式进行通信的。</p>
</li>
</ul>
<h2 id="配置文件重载原理"><a href="#配置文件重载原理" class="headerlink" title="配置文件重载原理"></a>配置文件重载原理</h2><p><code>reload</code> 重载配置文件的流程：</p>
<p>\1. 向 <code>master</code> 进程发送 <code>HUP</code> 信号（ <code>reload</code> 命令）；</p>
<p><code>2. master</code> 进程检查配置语法是否正确；</p>
<p><code>3. master</code> 进程打开监听端口；</p>
<p><code>4. master</code> 进程使用新的配置文件启动新的 <code>worker</code> 子进程；</p>
<p><code>5. master</code> 进程向老的 <code>worker</code> 子进程发送 <code>QUIT</code> 信号；</p>
<p>\6. 老的 <code>worker</code> 进程关闭监听句柄，处理完当前连接后关闭进程；</p>
<p>\7. 整个过程 <code>Nginx</code> 始终处于平稳运行中，实现了平滑升级，用户无感知；</p>
<h2 id="Nginx-模块化管理机制"><a href="#Nginx-模块化管理机制" class="headerlink" title="Nginx 模块化管理机制"></a>Nginx 模块化管理机制</h2><p><code>Nginx</code> 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。<code>Nginx</code> 的模块是互相独立的,低耦合高内聚。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1CxxiaXXtjSM4U1Y0r7AeZtxkGzdXVSdAyy7KoYhFC2IoyfNaLNH87X6e5bEAXicC7xaqwfYbicsvVQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h1 id="nginx带参数转发链接"><a href="#nginx带参数转发链接" class="headerlink" title="nginx带参数转发链接"></a>nginx带参数转发链接</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ixr_wang/article/details/7359825">https://blog.csdn.net/ixr_wang/article/details/7359825</a></p>
<h1 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h1><p><img src="C:\Users\swx\AppData\Roaming\Typora\typora-user-images\image-20210330153357593.png" alt="image-20210330153357593"></p>
<p>修改root文件下的ngnix,新加一个server()</p>
<h2 id="default-conf"><a href="#default-conf" class="headerlink" title="/default.conf"></a>/default.conf</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;     <span class="comment">#ipv4的端口</span></span><br><span class="line">    <span class="attribute">listen</span>  [::]:<span class="number">80</span>;     <span class="comment">#ipv6的端口</span></span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;   在Unicode未流行之前，KOI8-R 是最为广泛使用的俄语编码，使用率甚至比ISO 8859-5还高</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png)$</span> &#123;  </span><br><span class="line">    <span class="attribute">expires</span> <span class="number">24h</span>;  </span><br><span class="line">      <span class="attribute">root</span> /yxtl/data/;<span class="comment">#鎸囧畾鍥剧墖瀛樻斁璺緞  </span></span><br><span class="line">      <span class="attribute">access_log</span> /usr/local/websrv/nginx-<span class="number">1</span>.<span class="number">9</span>.<span class="number">4</span>/logs/images.log;<span class="comment">#鏃ュ織瀛樻斁璺緞  </span></span><br><span class="line">      <span class="attribute">proxy_store</span> <span class="literal">on</span>;  </span><br><span class="line">      <span class="attribute">proxy_store_access</span> user:rw group:rw all:rw;  </span><br><span class="line">      <span class="attribute">proxy_temp_path</span>     /home/images/;<span class="comment">#鍥剧墖璁块棶璺緞  </span></span><br><span class="line">      <span class="attribute">proxy_redirect</span>     <span class="literal">off</span>;  </span><br><span class="line">      <span class="attribute">proxy_set_header</span>    Host <span class="number">127.0.0.1</span>;  </span><br><span class="line">      <span class="attribute">client_max_body_size</span>  <span class="number">10m</span>;  </span><br><span class="line">      <span class="attribute">client_body_buffer_size</span> <span class="number">1280k</span>;  </span><br><span class="line">      <span class="attribute">proxy_connect_timeout</span>  <span class="number">900</span>;  </span><br><span class="line">      <span class="attribute">proxy_send_timeout</span>   <span class="number">900</span>;  </span><br><span class="line">      <span class="attribute">proxy_read_timeout</span>   <span class="number">900</span>;  </span><br><span class="line">      <span class="attribute">proxy_buffer_size</span>    <span class="number">40k</span>;  </span><br><span class="line">      <span class="attribute">proxy_buffers</span>      <span class="number">40</span> <span class="number">320k</span>;  </span><br><span class="line">      <span class="attribute">proxy_busy_buffers_size</span> <span class="number">640k</span>;  </span><br><span class="line">      <span class="attribute">proxy_temp_file_write_size</span> <span class="number">640k</span>;  </span><br><span class="line">      <span class="attribute">if</span> ( !-e $request_filename)  </span><br><span class="line">      &#123;  </span><br><span class="line">         <span class="attribute">proxy_pass</span> http://elinktech.cn;<span class="comment">#榛樿80绔彛  </span></span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;   </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="attribute">location</span> /api &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://elinktech.cn:9005;</span><br><span class="line">	  <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">	  <span class="attribute">proxy_set_header</span> Upgrade $http_upgrade;</span><br><span class="line">	  <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;	</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="attribute">location</span> /daohang.html &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://elinktech.cn/#/;</span><br><span class="line">          <span class="attribute">proxy_redirect</span> default;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="attribute">location</span> /shop.html &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://elinktech.cn/#/shophome;</span><br><span class="line">          <span class="attribute">proxy_redirect</span> default;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nginx-default-conf"><a href="#nginx-default-conf" class="headerlink" title="/nginx/default/conf"></a>/nginx/default/conf</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>  [::]:<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> elinktech.cn  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#location ~ .*\.(gif|jpg|jpeg|png)$ &#123;  </span></span><br><span class="line">  <span class="comment">#  expires 24h;  </span></span><br><span class="line">  <span class="comment">#    root /yxtl/data/; </span></span><br><span class="line">  <span class="comment">#    access_log /usr/local/websrv/nginx-1.9.4/logs/images.log; </span></span><br><span class="line">  <span class="comment">#    proxy_store on;  </span></span><br><span class="line">  <span class="comment">#    proxy_store_access user:rw group:rw all:rw;  </span></span><br><span class="line">  <span class="comment">#    proxy_temp_path     /home/images/ </span></span><br><span class="line">  <span class="comment">#    proxy_redirect     off;  </span></span><br><span class="line">  <span class="comment">#    proxy_set_header    Host 127.0.0.1;  </span></span><br><span class="line">  <span class="comment">#    client_max_body_size  10m;  </span></span><br><span class="line">  <span class="comment">#    client_body_buffer_size 1280k;  </span></span><br><span class="line">  <span class="comment">#    proxy_connect_timeout  900;  </span></span><br><span class="line">  <span class="comment">#    proxy_send_timeout   900;  </span></span><br><span class="line">  <span class="comment">#    proxy_read_timeout   900;  </span></span><br><span class="line">  <span class="comment">#    proxy_buffer_size    40k;  </span></span><br><span class="line">  <span class="comment">#    proxy_buffers      40 320k;  </span></span><br><span class="line">  <span class="comment">#    proxy_busy_buffers_size 640k;  </span></span><br><span class="line">  <span class="comment">#    proxy_temp_file_write_size 640k;  </span></span><br><span class="line">  <span class="comment">#    if ( !-e $request_filename)  </span></span><br><span class="line">  <span class="comment">#    &#123;  </span></span><br><span class="line">  <span class="comment">#       proxy_pass http://elinktech.cn; </span></span><br><span class="line">  <span class="comment">#    &#125;  </span></span><br><span class="line">  <span class="comment">#&#125;   </span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /yxtl/data/shop;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /api/yxtl/data/ &#123;</span><br><span class="line">        <span class="attribute">alias</span>   /yxtl/data/;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="attribute">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://elinktech.cn:9005;</span><br><span class="line">    	  <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    	  <span class="attribute">proxy_set_header</span> Upgrade $http_upgrade;</span><br><span class="line">    	  <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;	</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /daohang.html &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://elinktech.cn/#/;</span><br><span class="line">          <span class="attribute">proxy_redirect</span> default;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="attribute">location</span> /shop.html &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://elinktech.cn/#/shophome;</span><br><span class="line">          <span class="attribute">proxy_redirect</span> default;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /about.html &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://elinktech.cn/#/auth/index;</span><br><span class="line">          <span class="attribute">proxy_redirect</span> default;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nginx-guanwang-conf"><a href="#nginx-guanwang-conf" class="headerlink" title="/nginx/guanwang.conf"></a>/nginx/guanwang.conf</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>  [::]:<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.elinktek.com.cn elinktek.com.cn;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /yxtl/data/myindex/index;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /mystatics/ &#123;</span><br><span class="line">   		<span class="attribute">alias</span>  /yxtl/data/myindex/mystatics/;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="root-nginx-conf-nginx-conf"><a href="#root-nginx-conf-nginx-conf" class="headerlink" title="/root/nginx/conf/nginx.conf"></a>/root/nginx/conf/nginx.conf</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="root-nginx-conf-default-conf"><a href="#root-nginx-conf-default-conf" class="headerlink" title="/root/nginx/conf/default.conf"></a>/root/nginx/conf/default.conf</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>  [::]:<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="attribute">location</span> /api &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://elinktech.cn:9005;</span><br><span class="line">          <span class="attribute">proxy_redirect</span> default;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="attribute">location</span> /daohang.html &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://39.101.193.57/#/;</span><br><span class="line">          <span class="attribute">proxy_redirect</span> default;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="attribute">location</span> /shop/index &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://39.101.193.57/#/shophome;</span><br><span class="line">          <span class="attribute">proxy_redirect</span> default;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="etc-nginx-nginx-conf"><a href="#etc-nginx-nginx-conf" class="headerlink" title="/etc/nginx/nginx.conf"></a>/etc/nginx/nginx.conf</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information on configuration, see:</span></span><br><span class="line"><span class="comment">#   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">user</span> root;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span></span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modules/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">   	<span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">sendfile</span>            <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>   <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">include</span>             /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>        application/octet-stream;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> tornado&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">upstream</span> admin&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="comment"># listen       [::]:80 default_server;</span></span><br><span class="line">        <span class="attribute">server_name</span>  www.elinktech.cn;</span><br><span class="line">        <span class="attribute">root</span>         /usr/share/nginx/html;</span><br><span class="line">    </span><br><span class="line">  <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">  <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="attribute">location</span> /admin &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  http://admin ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> /static/admin &#123;</span><br><span class="line">        <span class="attribute">alias</span> /root/project_helmet/tornado_admin/mystatics;</span><br><span class="line">                <span class="attribute">if</span> ($query_string) &#123;</span><br><span class="line">                    <span class="attribute">expires</span> max;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="attribute">location</span> /static &#123;</span><br><span class="line">        <span class="attribute">alias</span> /root/project_helmet/weixin_0.<span class="number">1</span>/mystatics;</span><br><span class="line">                <span class="attribute">if</span> ($query_string) &#123;</span><br><span class="line">                    <span class="attribute">expires</span> max;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  http://tornado ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">        <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings for a TLS enabled server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    server &#123;</span></span><br><span class="line"><span class="comment">#        listen       443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        listen       [::]:443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        server_name  _;</span></span><br><span class="line"><span class="comment">#        root         /usr/share/nginx/html;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;</span></span><br><span class="line"><span class="comment">#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;</span></span><br><span class="line"><span class="comment">#        ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="comment">#        ssl_session_timeout  10m;</span></span><br><span class="line"><span class="comment">#        ssl_ciphers HIGH:!aNULL:!MD5;</span></span><br><span class="line"><span class="comment">#        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        # Load configuration files for the default server block.</span></span><br><span class="line"><span class="comment">#        include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        location / &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 404 /404.html;</span></span><br><span class="line"><span class="comment">#        location = /404.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="comment">#        location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="etc-nginx-nginx-conf-default"><a href="#etc-nginx-nginx-conf-default" class="headerlink" title="/etc/nginx/nginx.conf.default"></a>/etc/nginx/nginx.conf.default</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">    </span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nginx部署静态网站"><a href="#nginx部署静态网站" class="headerlink" title="nginx部署静态网站"></a>nginx部署静态网站</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>  [::]:<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.elinktek.com.cn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/mystatics;</span><br><span class="line">        <span class="attribute">index</span>  index.html; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="nginx在一个服务器上部署多个网站"><a href="#nginx在一个服务器上部署多个网站" class="headerlink" title="nginx在一个服务器上部署多个网站"></a>nginx在一个服务器上部署多个网站</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span> default_server;<span class="comment">#只能配一个默认监听</span></span><br><span class="line"><span class="attribute">servername</span> aa.com;</span><br><span class="line"></span><br><span class="line"><span class="attribute">server_name_in_redirect</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host $host:$server_port;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> REMOTE-HOST $remote_addr;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line"><span class="attribute">access_log</span>  /home/wwwlogs/access_default.log;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;            </span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span> bb.com;</span><br><span class="line"></span><br><span class="line"><span class="attribute">server_name_in_redirect</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host $host:$server_port;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> REMOTE-HOST $remote_addr;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;            </span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8008;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>




<p>另：</p>
<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，特点是占用内存少，并发能力强，事实上 Nginx 的并发能力确实在同类型的网页服务器中表现较好。Nginx 专为性能优化而开发，性能是其最重要的要求，十分注重效率，有报告 Nginx 能支持高达 50000 个并发连接数。</p>
<p><strong>01</strong></p>
<p><strong>Nginx 知识网结构图</strong></p>
<p>Nginx 的知识网结构图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070f2NxYCRUkenCHGZCibFJicDiaCv9BcXgL4kRDibhCteU6zwOCEOvH5mO3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>02</strong></p>
<p><strong>反向代理</strong></p>
<p><strong>正向代理：</strong>局域网中的电脑用户想要直接访问网络是不可行的，只能通过代理服务器来访问，这种代理服务就被称为正向代理。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070PPlwbISQSBzhf1sAeeqNwUHQagLPtWwvHjA00mWluTYThibZnqnnia4g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>反向代理：</strong>客户端无法感知代理，因为客户端访问网络不需要配置，只要把请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据，然后再返回到客户端。</p>
<p>此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070CW3mYFhBcrgyGPrAXajVNPYB77RxkwVMjjY6HzEMIGCRaQXkWnbMxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>03</strong></p>
<p><strong>负载均衡</strong></p>
<p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕之后，再将结果返回给客户端。</p>
<p>普通请求和响应过程如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070ElynCNRq7Pwz1v2fjupnaIib9ury1RpHVfqicNeYsymMB1Lsh6yZLjHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>但是随着信息数量增长，访问量和数据量飞速增长，普通架构无法满足现在的需求。</p>
<p>我们首先想到的是升级服务器配置，可以由于摩尔定律的日益失效，单纯从硬件提升性能已经逐渐不可取了，怎么解决这种需求呢？</p>
<p>我们可以增加服务器的数量，构建集群，将请求分发到各个服务器上，将原来请求集中到单个服务器的情况改为请求分发到多个服务器，也就是我们说的负载均衡。</p>
<p>图解负载均衡：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070mYLYl3fEeXcNmh01c5Ue9cf72y8JVHPujiabqzn3PRG0icicrKg5jvibiag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>假设有 15 个请求发送到代理服务器，那么由代理服务器根据服务器数量，平均分配，每个服务器处理 5 个请求，这个过程就叫做负载均衡。</p>
<p>**04<br>**</p>
<p><strong>动静分离</strong></p>
<p>为了加快网站的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析的速度，降低由单个服务器的压力。</p>
<p>动静分离之前的状态：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070FwK0Z5yaibzTV33iccaV5HuMQaLr1oibDbXJyRnphUdrNePibbibNLLJORw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>动静分离之后：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u0701NlibJ7Qibnr5AoewJdI8nMEhLO3tqEUqQV9X60HvqXcQh5g7yib2kYlg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>**06<br>**</p>
<p><strong>Nginx安装</strong></p>
<p>Nginx 如何在 Linux 安装</p>
<p>参考链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;yujing1314&#x2F;article&#x2F;details&#x2F;97267369</span><br></pre></td></tr></table></figure>

<p>Nginx 常用命令</p>
<p>查看版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -v</span><br></pre></td></tr></table></figure>



<p>启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure>



<p>关闭（有两种方式，推荐使用 ./nginx -s quit）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s stop</span><br><span class="line">.&#x2F;nginx -s quit</span><br></pre></td></tr></table></figure>



<p>重新加载 Nginx 配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>



<p>Nginx 的配置文件</p>
<p>配置文件分三部分组成：</p>
<h5 id="①全局块"><a href="#①全局块" class="headerlink" title="①全局块"></a><strong>①全局块</strong></h5><p>从配置文件开始到 events 块之间，主要是设置一些影响 Nginx 服务器整体运行的配置指令。</p>
<p>并发处理服务的配置，值越大，可以支持的并发处理量越多，但是会受到硬件、软件等设备的制约。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070ceEurAwxEr7fReXN8soaFFM0UVYoEN5nxmSl1Nmh2F5Sx07lCuFxrA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h5 id="②events-块"><a href="#②events-块" class="headerlink" title="②events 块"></a><strong>②events 块</strong></h5><p>影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 workprocess 下的网络连接进行序列化，是否允许同时接收多个网络连接等等。</p>
<p>支持的最大连接数：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070ZSQBARRvI1m3ictwCkCIc7FT5lpxZXED9Oz7EpAUI3viaQEtuZuOercA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h5 id="③HTTP-块"><a href="#③HTTP-块" class="headerlink" title="③HTTP 块"></a><strong>③HTTP 块</strong></h5><p>诸如反向代理和负载均衡都在此配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location[ &#x3D; | ~ | ~* | ^~] url&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>location 指令说明，该语法用来匹配 url，语法如上：</p>
<ul>
<li><strong>=：</strong>用于不含正则表达式的 url 前，要求字符串与 url 严格匹配，匹配成功就停止向下搜索并处理请求。</li>
<li><strong>~：</strong>用于表示 url 包含正则表达式，并且区分大小写。</li>
<li><strong>~*：</strong>用于表示 url 包含正则表达式，并且不区分大小写。</li>
<li><strong>^~：</strong>用于不含正则表达式的 url 前，要求 Nginx 服务器找到表示 url 和字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再匹配。</li>
<li>如果有 url 包含正则表达式，不需要有 ~ 开头标识。</li>
</ul>
<p><strong>07</strong></p>
<p><strong>反向代理实战</strong></p>
<h3 id="①配置反向代理"><a href="#①配置反向代理" class="headerlink" title="①配置反向代理"></a><strong>①配置反向代理</strong></h3><p>目的：在浏览器地址栏输入地址 <a target="_blank" rel="noopener" href="http://www.123.com/">www.123.com</a> 跳转 Linux 系统 Tomcat 主页面。</p>
<p><strong>②具体实现</strong></p>
<p>先配置 Tomcat，因为比较简单，此处不再赘叙，并在 Windows 访问：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070H8YfyRgdjbvTxU07bdqckAczlpC9Edc71DDkuwd2TW1he4PD3qhiaNA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>具体流程如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070k1odBlOv9xC0smZE7f9KMaJ4askgGh8Sic5bPKNg0t7fIC89mcxFibfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>修改之前：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070PpzocXYnpJebzLmIDLKHmGOfr5AVCmquota4ylIuDEu6H19z37tCbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070yLGd7yicBY5tYMlAlgA6iag3rH7c7YR6ZXhQforXDAayQUvrr2amUV9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>再次访问：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070Y5UQ5Cf1JrrMy2t3wr4p8NQqHFLzeRpWqicsfpRk0frVnATteHNZTzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>③反向代理 2</strong></p>
<p>目标：</p>
<ul>
<li>访问 <a target="_blank" rel="noopener" href="http://192.168.25.132:9001/edu/">http://192.168.25.132:9001/edu/</a> 直接跳转到 192.168.25.132:8080</li>
<li>访问 <a target="_blank" rel="noopener" href="http://192.168.25.132:9001/vod/">http://192.168.25.132:9001/vod/</a> 直接跳转到 192.168.25.132:8081</li>
</ul>
<p><strong>准备：</strong>配置两个 Tomcat，端口分别为 8080 和 8081，都可以访问，端口修改配置文件即可。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u0706H62Sg72IoxrTBEuUu8aFsNiarB0LiaGIe6pzK1oOUfKbyunkHdcwwqg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070I2fsgic1O8TY0C0hJGxM7X0VnYxzXk14ehDrBuW1Xzib8kskB7jPzcVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>新建文件内容分别添加 8080！！！和 8081！！！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070g0gdPTzx0m4vS6WyBtKBicUDTQHG0j7qTEY424lmib7hX4EXPriaHZ8lg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070BMfElQMuXK2zRvPbYaTu5scZzQDcU3ibE1QIV3NzCecULNibefre4WiaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>响应如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070kBsRZwMwG8XwkplKFFtbqZxF08QXFHYSXwsIkl8gt4WYQmA1ib32WPg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070bGAacKJzwPq2Dtsb3ufOOXhuZbRu084EptVAJg5QJXUknTNZic00rTw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>具体配置如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070OHYLoHb3ewhcQZUE9VQklNYia7vKbgBYfpoMuvTHy8XJHic9MiaOqDyVA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>重新加载 Nginx：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>





<p>访问：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070kBdTVdKNOSdE3MTicS4cSulTIWSibueLrVFMOkEIEEgdSyaacRc5ibLLg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070kBdTVdKNOSdE3MTicS4cSulTIWSibueLrVFMOkEIEEgdSyaacRc5ibLLg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>实现了同一个端口代理，通过 edu 和 vod 路径的切换显示不同的页面。</p>
<p>**<br>**</p>
<p><strong>反向代理小结</strong></p>
<p><strong>第一个例子：</strong>浏览器访问 <a target="_blank" rel="noopener" href="http://www.123.com,由/">www.123.com，由</a> host 文件解析出服务器 ip 地址<br>192.168.25.132 <a target="_blank" rel="noopener" href="http://www.123.com./">www.123.com。</a></p>
<p>然后默认访问 80 端口，而通过 Nginx 监听 80 端口代理到本地的 8080 端口上，从而实现了访问 <a target="_blank" rel="noopener" href="http://www.123.com,最终转发到/">www.123.com，最终转发到</a> tomcat 8080 上去。</p>
<p>第二个例子：</p>
<ul>
<li>访问 <a target="_blank" rel="noopener" href="http://192.168.25.132:9001/edu/">http://192.168.25.132:9001/edu/</a> 直接跳转到 192.168.25.132:8080</li>
<li>访问 <a target="_blank" rel="noopener" href="http://192.168.25.132:9001/vod/">http://192.168.25.132:9001/vod/</a> 直接跳转到 192.168.25.132:8081</li>
</ul>
<p>实际上就是通过 Nginx 监听 9001 端口，然后通过正则表达式选择转发到 8080 还是 8081 的 Tomcat 上去。</p>
<p>**08<br>**</p>
<p><strong>负载均衡实战</strong></p>
<p>①修改 nginx.conf，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u0706HibdMeX4ZGoOloiaytW9cbmZUevic7zhCjhaCrIRuaIzVdricUZd5oLsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070tZR9ow4AbibMy4IS5ibBydBAwvhexiatORjMMoMfiac4F7k4Hyru0OeKHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>②重启 Nginx：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>



<p>③在 8081 的 Tomcat 的 webapps 文件夹下新建 edu 文件夹和 a.html 文件，填写内容为 8081！！！！</p>
<p>④在地址栏回车，就会分发到不同的 Tomcat 服务器上：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070AE4cFBZV8poPm4yMX6OLqODKktFOGPwrfNRPicqlMicEzUO6o8owE1JA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u0704MwPKwdyKKByy7QmFXjC2wjnHWDRBsaKv9tODDtCyFbWGnRIX7Zdww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>负载均衡方式如下：</p>
<ul>
<li>轮询（默认）。</li>
<li>weight，代表权，权越高优先级越高。</li>
<li>fair，按后端服务器的响应时间来分配请求，相应时间短的优先分配。</li>
<li>ip_hash，每个请求按照访问 ip 的 hash 结果分配，这样每一个访客固定的访问一个后端服务器，可以解决 Session 的问题。</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u0701YP460onMRSUz1EViaG60zFc3eibkJVibsOpD4sI4e2W4AOQ5qeTSW9eg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u0703OL89ibL8iag83gRicVLLicv4j7CVZE57FickVCHF6gdJvglic38fYP1G9AQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070tLvpqiaUJST9yzwS78snQnANPBwkcNfmAYTict12ry4ibfjnvE8k1AtTw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></h2><h2 id="09"><a href="#09" class="headerlink" title="09"></a><strong>09</strong></h2><h2 id="动静分离实战"><a href="#动静分离实战" class="headerlink" title="动静分离实战"></a><strong>动静分离实战</strong></h2><p>什么是动静分离？把动态请求和静态请求分开，不是讲动态页面和静态页面物理分离，可以理解为 Nginx 处理静态页面，Tomcat 处理动态页面。</p>
<p>动静分离大致分为两种：</p>
<ul>
<li>纯粹将静态文件独立成单独域名放在独立的服务器上，也是目前主流方案。</li>
<li>将动态跟静态文件混合在一起发布，通过 Nginx 分开。</li>
</ul>
<h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="动静分离图析："><a href="#动静分离图析：" class="headerlink" title="动静分离图析："></a>动静分离图析：</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070LdXqsEJibWwcVz4zFdQamlpIp5FZlxh4AU3lxibTqSFyo2vr9VfkUJYg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>实战准备，准备静态文件：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070bO5Fp4GaokbPWMUQVN5qVTEezeTnmy9t6qCibIOeOvfGQDj6HofJ2rA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070V5pH79DnRABQFtmCTaibBwoNcRd2iaMeNle8FqLNrn2xZ75I2uO5WEOg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>配置 Nginx，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070iaVlGlNUe0fjsAxYU2v21rhaZZ0JuPOXfsVMibC2AESt5blIPkoRL1gA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Nginx 高可用</p>
<p>如果 Nginx 出现问题：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070r6rib3ltNLZicw5iceYtRvz7sgY8yZQmMXldgpG3Q3ZOWZ5o0rbkibib9qA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>解决办法：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070AbQ0KH4Wu5y5pRwUnUbOXibR3UQoldXQ0lqMibXUhTvNGSQ6rTicIfxfA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>前期准备：</p>
<ul>
<li><strong>两台 Nginx 服务器</strong></li>
<li><strong>安装 Keepalived</strong></li>
<li><strong>虚拟 ip</strong></li>
</ul>
<h2 id="安装-Keepalived："><a href="#安装-Keepalived：" class="headerlink" title="安装 Keepalived："></a>安装 Keepalived：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@192 usr]# yum install keepalived -y</span><br><span class="line">[root@192 usr]# rpm -q -a keepalived</span><br><span class="line">keepalived-1.3.5-16.el7.x86_64</span><br></pre></td></tr></table></figure>



<p>修改配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@192 keepalived]# cd &#x2F;etc&#x2F;keepalived</span><br><span class="line">[root@192 keepalived]# vi keepalived.conf</span><br></pre></td></tr></table></figure>



<p>分别将如下配置文件复制粘贴，覆盖掉 keepalived.conf，虚拟 ip 为 192.168.25.50。</p>
<p>对应主机 ip 需要修改的是：</p>
<ul>
<li>smtp_server 192.168.25.147（主）smtp_server 192.168.25.147（备）</li>
<li>state MASTER（主） state BACKUP（备）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.25.147</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL # 访问的主机地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">  script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;  # 检测文件的地址</span><br><span class="line">  interval 2   # 检测脚本执行的间隔</span><br><span class="line">  weight 2   # 权重</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP    # 主机MASTER、备机BACKUP    </span><br><span class="line">    interface ens33   # 网卡</span><br><span class="line">    virtual_router_id 51 # 同一组需一致</span><br><span class="line">    priority 90  # 访问优先级，主机值较大，备机较小</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.25.50  # 虚拟ip</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@192 sbin]# systemctl start keepalived.service</span><br></pre></td></tr></table></figure>



<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070rxeYx90zzrcUfHmnJwRelYdnJr1sXrBScUPSD8yIib6D4nQkxKdqweQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>访问虚拟 ip 成功：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070JJMVSYVJnVhySneVp7C1Y7jMmcMoPwbVjZzGVe1iczcqJzpDrSRLVoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>关闭主机 147 的 Nginx 和 Keepalived，发现仍然可以访问。</p>
<p>原理解析</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u0706jB3SfG0RrqdmaU8HE6e5A4qTynwactlhBMmM0wqNicGGws98kCdiaqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如下图，就是启动了一个 master，一个 worker，master 是管理员，worker是具体工作的进程。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070muQU3rnx4KFwDOmx2ovwgFbmpu6o6ey0kZKWuWgjhSwDhohkpVNeCA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>worker 如何工作？如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070giaYRsmv7NU97QWqHra8HENYBGZib3DyEnVg0Qbky5Xzk1D9Tu87DFqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>worker 数应该和 CPU 数相等；一个 master 多个 worker 可以使用热部署，同时 worker 是独立的，一个挂了不会影响其他的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/30/6.1.nginx%E9%85%8D%E7%BD%AE/" data-id="ckw61se08007goswd4eh6f1wu" data-title="nginx配置" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.2.java基础概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/29/4.2.java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2021-03-29T06:56:50.000Z" itemprop="datePublished">2021-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/29/4.2.java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">java基础知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>java的一些基本概念</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>关键字：是被java语言赋予特定含义的单词</p>
<p>特点：组成关键字的字母全部小写</p>
<p>goto和const作为保留字存在，目前并不使用（jdk1.7中）</p>
<p>保留字：在jdk新版中可能提升为关键字</p>
<p>关键字</p>
<p>用于定义数据类型的关键字：class    interface[接口]    byte short  int  long  float  double  char  boolean  void</p>
<p>用于定义数据类型值的关键字：true  false  null</p>
<p>用于定义流程控制的关键字：if  else switch  case  default  while  do  for  break  continue  return</p>
<p>用于定义访问权限修饰符的关键字：public protected private</p>
<p>用于定义类，函数，变量修饰符的关键字：abstract  final  static synchronized[同步]</p>
<p>用于定义类与类之间关系的关键字：extends  implements</p>
<p>用于定义建立实例与引用实例，判断实例的关键字：new  this super instanceof [实例]</p>
<p>用于异常处理的关键字：try  catch  finally throw  throws </p>
<p>用于包的关键字：packge  import  </p>
<p>其他修饰符关键字：native[本地]  strictfp[精确浮点]  transient[短暂的,用于无需序列化]  volatile[易变的，保证单次读/写的原子性]  assert[宣称]</p>
<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>标识符就是给类，接口，方法，变量等起名字时使用的字符序列</p>
<p>组成规则：英文字母，数字字符，美元符$和下划线_（只有这几种，不能出现#￥之类的）</p>
<p>Tips：不能以数字开头，不能是java的关键字，严格区分大小写，不能出现空格。</p>
<p>常见命名规则：见名知意</p>
<p>包：其实就是文件夹，用于把相同的类名进行区分（全部小写）</p>
<p>单级：xxx</p>
<p>多级：cn.xxx</p>
<p>类或者接口：</p>
<p> 一个单词：单词的首字母必须大写</p>
<p> 多个单词：每个单词的首字母必须大写[驼峰原则]</p>
<p>方法或者变量：</p>
<p> 一个单词：单词的首字母必须小写</p>
<p> 多个单词：从第二个单词开始，每个单词的首字母大写[驼峰原则]</p>
<p>常量：</p>
<p> 一个单词：全部大写</p>
<p> 多个单词：每个字母都大写，用_隔开</p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>在程序执行的过程中其值不可以发生改变</p>
<p>分类：</p>
<p>1.字面值常量</p>
<p>字符串常量：用双引号括起来的内容</p>
<p>整数常量：所有整数</p>
<p>小数常量：所有小数</p>
<p>字符常量：用单引号括起来的单个字符</p>
<p>布尔常量：较为特有，只有false和true</p>
<p>空常量：null</p>
<p>2.自定义常量（final int x=10;）</p>
<p>整数常量提供了4种表现形式：</p>
<p>​    二进制（binary）：由0，1组成，以0b开头，或者结尾+B</p>
<p>​    八进制(octal)：由0，1，…7组成，以0开头，或者结尾+O</p>
<p>​    十进制(decimal)：由0，1，…9组成，默认是十进制,或者结尾+D</p>
<p>​    十六进制(hex)：由0，1，…，9，a，b，c，d，e，f（大小写均可），以0x开头,或者结尾+H</p>
<p>1byte=8bit     1个字节=8位</p>
<p>1k=1024byte   </p>
<p>1m=1024k</p>
<p>1g=1024m</p>
<p>1t=1024g</p>
<p>进制越大，表现形式越短。</p>
<p>二、八、十、十六进制间转换：</p>
<p>​    二进制转换为八进制：把二进制的数据，从右开始，每三位一组合，最左边不够的时候补0。然后分别计算出对应的十进制数值，最后把每个十进制的数据组合起来就是一个八进制数据。</p>
<p>​    二进制转换为十六进制：十六进制就是每4位组合。</p>
<p>​    二进制转换为十进制：8421码。8421码是中国大陆的叫法，8421码是BCD码中最常用的一种。在这种编码方式中每一位二值代码的1都是代表一个固定数值，把每一位的1代表的十进制数加起来，得到的结果就是它所代表的十进制数码。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>在程序执行的过程中，在一定范围内其值可以发生改变的量。本质上来说，变量其实是内存中的一小块区域，使用变量名来访问这块区域。因此，每个变量使用前必须要先申请（声明），然后必须进行赋值（填充内容）才能使用。</p>
<p>变量可以用来不断的存放<strong>同一类型</strong>的常量，并且可以重复使用。</p>
<p>定义格式(固定的)：</p>
<p>​    数据类型 变量名=初始化值；</p>
<p>Java是强类型语言，对于每一种数据类型都定义了明确的具体数据类型，由内存总分配了不同大小的内存空间。</p>
<p>作用域：变量定义在那一级大括号中，哪个大括号的范围就是这个变量的作用域。相同的作用域中不能定义两个同名变量。</p>
<p>没有初始化值不能直接使用，只要在使用前给值即可，不一定非要在定义的时候给值，推荐在定义的时候给值。</p>
<p>eg：  数据类型 变量名；</p>
<p>​          变量名=初始化值；</p>
<p>一行建议只定义一个变量，可以定义多个，但是不建议。</p>
<p>数据类型：</p>
<p>1.基本数据类型：4类8种</p>
<ul>
<li><p>数值型：</p>
<p>⑴整数型</p>
<p>byte  1字节      -2^7^<del>2^7^           -128</del>127</p>
<p>short  2字节   -2^15^<del>2^15^-1     -32768</del>32767</p>
<p>int  4字节        -2^31^<del>2^31^-1     -2,147,483,648</del>2,147,483,647     默认为int</p>
<p>long  8字节     -2^63^~2^63^-1    19位数      长的整数型变量后缀使用L或l，建议使用L。因为l会和1分不清</p>
<p>⑵浮点类型</p>
<p>float  4字节   -3.403 E^38^<del>3.403E^38^ （2^-127^</del>2^128^）   单精度浮点数用F或f，建议使用F</p>
<p>double  8字节   -1.798E^308^<del>1.798E^308^  （2^-1023^</del>2^1024^） 默认为 double</p>
</li>
<li><p>字符型：char  2字节  （可以存储中文汉字）</p>
</li>
<li><p>布尔型：boolean  1字节</p>
</li>
</ul>
<p>2.引用数据类型：</p>
<ul>
<li><p>类：class</p>
</li>
<li><p>接口：interface</p>
</li>
<li><p>数组：[]</p>
</li>
</ul>
<p>一般来说，我们在运算的时候，要求运算的数据类型必须一致。boolean类型不能转换为其他数据类型</p>
<p>默认转换，隐式转换（从小到大的转换）：</p>
<p>byte,short,char→int→long→float→double 出现后面的数据类型，结果必须为最后面的数据类型</p>
<p>byte,short,char相互之间不转换，他们一旦参与运算首先要转换成int数据类型</p>
<p>long是8字节，float是4字节，可以转换是因为它们的底层的存储结构不同；float表示的数据范围比long 的范围要大。</p>
<p>强制转换，显示转换（从大到小的转换）：</p>
<p>格式：目标数据类型 变量=（目标数据类型） （被转换的数据）；</p>
<p>不要随意使用强制转换，因为它隐含了精度损失的问题。其结果是数据的补码在计算机内被截断后的值。</p>
<p>byte的范围是-128~127，当（byte）128，其实输出的是-128。（byte）129输出的是-127</p>
<p>128：10000000</p>
<p>-128：10000000（这里的1既是符号位，也是数值位）</p>
<p>变量相加，会首先看类型问题，最终把结果赋值的时候也会考虑类型问题。</p>
<p>常量相加，首先做加法，然后看结果是否在赋值的数据类型范围内，如果不是，才会报错。</p>
<p>eg：</p>
<p>1.一个字符，结果就是一个字符。</p>
<p>2.一个字符+一个整数：参考ASCII表，结果为int整数型</p>
<p>   ‘0’ 48                                     ‘A’ 65                                 ‘a’ 97</p>
<p><img src="C:\Users\swx\AppData\Roaming\Typora\typora-user-images\image-20210323162019525.png" alt="image-20210323162019525"></p>
<p>3.字符串+一个字符+整数：第一个+是连接符。字符串+整数</p>
<p>4.一个字符+整数+字符串：第一个+是加号，ASCII表运算成整数类型。整数+字符串</p>
<p>规则：第一个东西和第二个东西先进行运算并输出，在计算第三个，第四个。</p>
<p>局部变量和成员变量的区别：</p>
<p>1.在类中的位置不同：</p>
<p>局部变量：在方法定义中或者方法声明上。</p>
<p>成员变量:在类中方法外。</p>
<p>2.在内存中的位置不同：</p>
<p>局部变量：在栈内存</p>
<p>成员变量：在堆内存</p>
<p>3.生命周期不同：</p>
<p>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失</p>
<p>4.初始化值不同：</p>
<p>局部变量：没有默认初始化值，必须定义，赋值然后才能使用</p>
<p>成员变量：有默认的初始化值</p>
<p>注意事项：局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算：对常量和变量进行操作的过程称为运算</p>
<p>运算符:对常量和变量进行操作的符号称为运算符</p>
<p>操作数：参与运算的数据称为操作数</p>
<p>表达式：用运算符把常量或变量连接起来符合java语法的句子可以称为表达式<br>1.算术运算符：   +，-，*，/，%，++，–</p>
<p>+的用法：a.加法    b.正号     c.字符串连接符</p>
<p>整数相除只能得到整数，若要得到小数，需要把操作的数据中的任意一个数据变为浮点数类型。</p>
<p>/获取的是除法操作的商，%获取的是除法操作的余数。</p>
<p>++自增1，–自减1。就是对<strong>变量</strong>进行自增或者自减。只能对变量</p>
<p>单独使用：放在操作数前或者操作数后效果一样（常用）</p>
<p>参与运算使用：放在操作数的前面++a，先自增或自减再参与运算（赋值）。放在操作数的后面a++，先参与运算（赋值）再自增或自减。</p>
<p>2.赋值运算符</p>
<p>基本的赋值运算符：=</p>
<p>把=右边的数据赋值给左边（左边必须是变量）</p>
<p>扩展的赋值运算符：+=，-=，*=，/=，%=</p>
<p>+=把左边和右边做加法，然后赋值给左边。（左边必须是变量）</p>
<p>s +=1;不是等价于s = s+1;而是等价于s = （s的数据类型）（s+1）；      扩展的赋值运算符其实隐含了一个强制类型转换。</p>
<p>3.比较运算符（关系运算符）</p>
<p>==，！=，&lt;,&gt;,&lt;=,&gt;=,instanceof(检查是否是类的对象)</p>
<p>无论操作是简单还是复杂，比较运算符的结果都是boolean型，要么是true，要么是false。</p>
<p>“==”不能写成”=”</p>
<p>4.逻辑运算符</p>
<p>&amp;与（AND）  ()&amp;()  有false则false</p>
<p>|或（OR）    ()|()  有true则true</p>
<p>^异或（XOR）  ()^()  相同为false，不同为true</p>
<p>！非（NOT）   !()  非false则true，非true则false，偶数个不改变本身。</p>
<p>&amp;&amp;短路与（AND） ()&amp;&amp;()</p>
<p>||短路或（OR）   ()||()</p>
<p>逻辑运算符用于连接布尔型表达式，不能写3&lt;x&lt;6,而应该是x&gt;3&amp;x&lt;6。</p>
<p>&amp;和&amp;&amp;的区别（|和||同理）：最终结果一样</p>
<p>单&amp;时，左边无论真假，右边都会进行运算。</p>
<p>双&amp;时，若左边为真，右边参与运算，若左边为假，右边不参与运算（不执行）。</p>
<p>开发中常用的逻辑运算符：&amp;&amp;，||，！</p>
<p>5.位运算符</p>
<p>&amp;位与运算   有0则0</p>
<p>|位或运算   有1则1 </p>
<p>^位异或运算  相同为0，不同为1</p>
<p>~按位取反运算符  0变1，1变0   （在计算机中，所有参与运算的都是补码）</p>
<p>&lt;&lt;左移  左边最高位丢弃，右边补齐0                把&lt;&lt;左边的数据乘以2的移动次幂</p>
<p>&gt;&gt;右移  最高位是0，左边补齐0；最高位是1，左边补齐1            把&gt;&gt;右边的数据除以2的移动次幂</p>
<p>&gt;&gt;&gt;无符号右移  无论最高位是0还是1，左边都补齐0</p>
<p>要做位运算，首先要把数据转换为二进制。</p>
<p>&amp;和|：两边是boolean型，代表逻辑与/或短路         两边是数据类型，代表的是位运算。</p>
<p>^的特点：一个数据对另一个数据位异或两次，该数本身不变。（应用：数据加密，异或后发给你，你在异或一下就得到原数据）</p>
<p>eg：实现两个整数变量的交换：a  b </p>
<ul>
<li><p>使用第三方变量（开发中用）</p>
<p>c=a  a=b  b=c</p>
</li>
<li><p>使用位异或实现(面试用)</p>
<p>左边aba，右边a^b：    a=a^b  b=a^b   a=a^b</p>
</li>
<li><p>用变量相加的做法</p>
<p>a=a+b  b=a-b  a=a-b</p>
</li>
<li><p>一句话搞定</p>
<p>b=(a+b)-(a=b)</p>
</li>
</ul>
<p>6.三目运算符</p>
<p>（关系表达式）？表达式1：表达式2</p>
<p>关系表达式结果为true，则结果为表达式1，为false，则结果为表达式2.</p>
<p>（单目运算符：~3            双目运算符：3+4  ）</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>存储同一数据类型的多个元素的容器。</p>
<p>定义格式：（2种）</p>
<ul>
<li><p>数据类型[]  数组名;  定义一个该数据类型的数组（数组名）变量</p>
</li>
<li><p>数据类型  数组名[];  定义一个该数据类型的（数组名）数组变量</p>
</li>
</ul>
<p>建议使用第一种，因为其他语言（如C#）正在淘汰第二种。</p>
<p>数组的初始化：java中的数组必须先初始化，然后才能使用。</p>
<p>初始化就是为数组中的每个元素分配内存空间，并为每个元素赋值。</p>
<p>初始化方式：（2种）</p>
<ul>
<li>动态初始化：初始化时只指定数组的长度，由系统为数组分配初始值。</li>
</ul>
<p>格式：  数据类型[]  数组名= new 数据类型[数组长度];</p>
<p>eg：      int[]  arr = new int [4];</p>
<p>​    int：说明数组中元素的数据类型是int类型</p>
<p>​    []：说明这是一个数组</p>
<p>​    arr：数组的名称</p>
<p>​    new：为数组分配内存空间</p>
<p>​    int：说明数组中元素的数据类型是int类型</p>
<p>​    [4]：说明这是一个长度为4的数组，数组中元素的个数为4</p>
<p>这时候直接打印输出arr的值 就是arr的内存地址值。</p>
<p>数组中的每个元素都是有编号的，并且是从0开始，最大编号是数组的长度-1。</p>
<p>用数组名和编号的组合就可以获取数组中的指定编号的元素，这个编号叫索引。</p>
<p>通过数组名访问数据的格式是：数组名  [索引]</p>
<p>arr[0]、arr[1]、arr[2]、arr[3]没有赋值时，均为默认值。</p>
<ul>
<li>静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。</li>
</ul>
<p>格式：   数据类型[]  数组名 = new  数据类型[]{元素1，元素2，…}；</p>
<p>eg:          int[] arr = new int[]{1,2,3};</p>
<p>简化写法int[] arr={1,2,3};</p>
<p>arr的输出值就是arr的地址值。</p>
<p>注意 不要同时动态和静态进行初始化。</p>
<p>数组操作的两个常见小问题：</p>
<p>1.数组索引越界异常（<code>ArrayIndexOutOfBoundsException</code>）：你访问了不存在的索引。</p>
<p>2.空指针异常(<code>NullPointerException</code>)：数组已经不再指向堆内存了，而你还用数组名去访问元素。引用类型的常量：空常量  null  </p>
<p>eg：arr=null；</p>
<h2 id="数组常见方法"><a href="#数组常见方法" class="headerlink" title="数组常见方法"></a>数组常见方法</h2><ul>
<li>数组遍历：依次输出数组中的每一个元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组获取最值：获取数组中的最大值、最小值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[x] &gt; max) &#123;</span><br><span class="line">            max = arr[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组元素逆序：元素对调。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length / <span class="number">2</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">       arr[x] = arr[arr.length - <span class="number">1</span> - x];</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数组查表法：根据键盘录入索引，查找对应元素。</p>
</li>
<li><p>数组元素查找：查找指定元素第一次在数组中出现的索引。如果找不到数据，我们一般返回一个负数即可，一般是-1。</p>
</li>
<li><p>数组排序和二分查找。</p>
</li>
</ul>
<p>二维数组：元素为一维数组的数组。</p>
<p>格式1：</p>
<p>列是一样的用:       数据类型[] []  数组名=new 数据类型[m] [n];</p>
<p>​    m表示这个二维数组有多少个一维数组。</p>
<p>​    n表示每一个一维数组的元素个数。</p>
<p>以下两个格式也可以但是不推荐：</p>
<p>数据类型  数组名[] []=new  数据类型[m] [n];</p>
<p>数据类型[]  数组名[]=new  数据类型[m] [n];</p>
<p>int x,y;  定义了一个x，一个y的int型数据。</p>
<p>int[] x,y[];  定义了一个x的一维数组和一个y的二维数组。</p>
<p>格式2：</p>
<p>列是变化的用:       数据类型[] []  数组名=new  数据类型[m] [];</p>
<p>m表示这个二维数组有m个一维数组</p>
<p>一维数组的元素个数可以动态给出。</p>
<p>格式3：</p>
<p>静态初始化：   <code>数据类型[][]  数组名=new  数据类型[][]&#123;&#123; 元素1，元素2，.... &#125;, &#123; 元素1，元素2，.... &#125;, &#123; 元素1，元素2，.... &#125;&#125;;</code></p>
<p>简化版：<code>数据类型[][]  数组名=&#123;&#123;元素1，元素2，....&#125;, &#123;元素1，元素2，....&#125;, &#123;元素1，元素2，....&#125;&#125;;</code></p>
<p>二维数组的遍历：</p>
<p>外循环控制的是二维数组的长度，也就是一维数组的个数。</p>
<p>内循环控制的是一维数组的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;arr.length;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; arr[x].length; y++) &#123;</span><br><span class="line">            System.out.println(arr[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法就是完成特定功能的代码块。（在很多语言里面都有函数的定义，函数在java中被称为方法）</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符  返回值类型  方法名（参数类型 参数名<span class="number">1</span>，参数类型 参数名<span class="number">2</span>，...）｛</span><br><span class="line">	函数体；</span><br><span class="line">	<span class="keyword">return</span> 返回值；</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>修饰符： public static</p>
<p>返回值类型：就是返回结果的数据类型。</p>
<p>方法名：符合命名规则即可，方便我们调用。</p>
<p>参数：</p>
<p>​    实际参数：就是实际参与运算时填入的参数。</p>
<p>​    形式参数:就是方法定义上的，用于接收实际参数。</p>
<p>​    形式参数的类型有2种：基本类型和引用类型。</p>
<p>​        基本类型（4类8种）中形式参数的改变不影响实际参数。</p>
<p>​        引用类型（类、接口、数组）中形式参数的改变直接影响实际参数。</p>
<p>如果一个方法的形式参数是一个类类型（引用类型），实际参数需要的是这个类的对象。</p>
<p>​    参数类型：参数的数据类型</p>
<p>​    参数名：变量名</p>
<p>​    方法体语句：完成功能的代码。</p>
<p>​    return：结束方法，用于返回结果。</p>
<p>​    返回值：就是功能的结果，由return带给调用者。</p>
<p>要写一个方法，必须明确两个东西：</p>
<p>A：返回值类型：结果的数据类型</p>
<p>B：参数列表：要传递的参数及参数类型。</p>
<p>方法的执行特点：不调用，不执行。</p>
<p>调用：</p>
<p>​    A：单独调用，一般来说没有意义，所以不推荐</p>
<p>​    B：输出调用，但是不够好，因为可能需要针对结果进行进一步的操作。</p>
<p>​    C：赋值调用，推荐方案。</p>
<p>方法的注意事项：</p>
<p>​    1.方法不调用，不执行。</p>
<p>​    2. 方法与方法之间是平级关系，不能嵌套定义。</p>
<p>​    3.方法定义的时候参数之间用逗号隔开。</p>
<p>​    4.方法调用的时候不用再传递数据类型。</p>
<p>​    5. 如果方法有明确的返回值，一定要有return带回一个值。</p>
<p>void类型返回值的方法调用：无返回结果，只有单独调用一种。</p>
<p>方法的<strong>重载</strong>：方法的功能相同，参数列表不同的情况，为了见名知意，java允许它们起一样的名字。jvm会根据不同的参数调用不同的功能。</p>
<p>方法重载的特点：与返回值类型无关，只看方法名和参数列表。在调用时，虚拟机通过参数列表的不同（参数个数、类型不同）来区分同名方法。</p>
<p>//一个方法不能访问另一个方法中的局部变量。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>单独开一个文章总结。</p>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>其实就是文件夹。</p>
<p>作用：把相同的类名放到不同的包中；对类进行分类管理。</p>
<p>1.可以按照功能分（增加、删除、修改、查找）</p>
<p>2.可以按照模块分（推荐）</p>
<p>包的定义：  package 包名；</p>
<p>多级包用.分开即可</p>
<p>注意事项：</p>
<p>package语句必须是程序的第一条可执行（可被虚拟机识别）的代码。package语句在一个java文件中只能有一个。如果没有package，默认表示无包名</p>
<p>带包的编译和运行：</p>
<ul>
<li><p>手动式：</p>
<p>a.编写一个java文件</p>
<p>b.通过javac命令编译该java文件</p>
<p>c.在文件夹中的当前目录下手动创建包名</p>
<p>d.把b步骤的class文件放到c步骤的最底层包</p>
<p>e.回到和包根目录在同一目录的地方，然后带包运行<code>java  cn.xxx.类名</code></p>
</li>
<li><p>自动式：</p>
<p>a. javac编译的时候带上-d即可（eg： <code>javac  -d  .  类名.java</code>）</p>
<p>b.通过java命令执行。和手动式一样</p>
</li>
</ul>
<p>不同包下类之间的访问，每次都需要加包的全路径，会很麻烦，所以java提供了导包功能。</p>
<p>导包格式：import 包名；</p>
<p>注意：</p>
<p>这种方式导入是到类的名称<code>import cn.xxx.类名</code>；虽然可以写<code>import cn.xxx.</code>代表导入这个cn.xxx包下的所有类，但是不建议。建议我们用谁导入谁。</p>
<p>package(只能有一个)-&gt;import(可以有多个)-&gt;class(可以有多个，以后建议是一个，使结构清晰)</p>
<p>权限修饰符：</p>
<p>​    public:同一个类中；同一个包下子类，无关类；不同包下该类是那个包的类的子类；不同包下无关类</p>
<p>​    protected:同一个类中；同一个包下子类，无关类；不同包下该类是那个包的类的子类</p>
<p>​    默认：同一个类中；同一个包下子类，无关类</p>
<p>​    private:同一个类中</p>
<p>总结：如果想都访问，用public；如果想访问不同包的子类，用protected（pretected是用来修饰子类的）；如果只想同一个包内访问用默认，不加；如果只想在本类中访问，用private。</p>
<p>修饰符：</p>
<p>​    权限修饰符：private，默认的，protected，public</p>
<p>​    状态修饰符：static，final</p>
<p>​    抽象修饰符：abstract</p>
<p>类及其组成可以用的修饰符：</p>
<p>​    类：默认，public；final，abstract   经常使用的是public</p>
<p>​    成员变量：四种权限修饰符均可；final,static   经常使用的是private</p>
<p>​    构造方法：四种权限修饰符均可；其他不可   经常使用的是public</p>
<p>​    成员方法：四种权限修饰符均可；final,static,abstract  经常使用的是public</p>
<p>注：自己写项目时的类名不要和常用的API的类名相同。</p>
<p>​    复制代码的时候，很容易把那个类所在的包也导入过来，容易出现不能理解的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/29/4.2.java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" data-id="ckw61sdw9004poswd0ix0cpg6" data-title="java基础知识" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>