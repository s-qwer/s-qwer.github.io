<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/page/10/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-20.测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/20.%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:42:18.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/20.%E6%B5%8B%E8%AF%95/">测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>测试</p>
<p>首先会根据需求文档编写测试用例，用于指导如何测试，以及那些输入条件预期得到什么结果（需求文档，测试用例文档）</p>
<p>\1. UI测试：这是最基础的测试步骤，主要是按照需求文档，点击页面，看各个页面是否正确打开，是否与需求一致</p>
<p>\2. 白盒测试：此项主要是开发人员的自测，因为此项需要知道代码内部的逻辑，对照需求文档测试各个条件分支是否如预期的执行</p>
<p>\3. 黑盒测试：主要是测试人员完成的，此项不需要知道程序代码的内部逻辑，只需要关注输入条件，得到的输出结果是否与需求文档和测试用例相符合</p>
<p>\4. 边界条件测试：主要是测试各种边界值的情况，比如，只能输入正数的场景，如果输入0、或者负数是否会有相关提示</p>
<p>\5. 兼容性测试：按照需求文档的要求，需要兼容的操作系统平台或者浏览器种类和版本，都需要测试</p>
<p>\6. 性能测试：此项主要是通过测试工具，编写测试脚本，录制测试步骤，让测试工具模拟大数据量，多用户并发的操作，看看系统是否能够应付得了</p>
<p>\7. 用户交付测试：这是最后一个测试步骤了，主要是用户按照业务场景来模拟测试了，测试通过之后，就可以交互试用了</p>
<p>灰度测试，就是在某项产品或应用正式发布前，选择特定人群试用，逐步扩大其试用者数量，以便及时发现和纠正其中的问题，由“灰”到“黑”</p>
<p>基本测试的时候注意：</p>
<p>\1. 正确数据</p>
<p>\2. 错误数据</p>
<p>\3. 边界数据</p>
<p>//写测试类的时候，注意测试类中只调用，不创建方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/20.%E6%B5%8B%E8%AF%95/" data-id="ckw61sduv000poswdfdel8qo3" data-title="测试" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-13.1.mybatis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/13.1.mybatis/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:42:08.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/13.1.mybatis/">mybatis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>框架一般都是有配置文件的，看官网文档最好。</p>
<p>Mybatis的学习：<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p>
<p>一、简介</p>
<ol>
<li><p>基础：JDBC/Mysql/java基础/Maven/Junit</p>
</li>
<li><p>本来是aoache的一个开源项目ibatis，现在存于github</p>
</li>
</ol>
<p>MyBatis 是一款优秀的<strong>持久层框架</strong></p>
<p>它支持自定义 SQL、存储过程以及高级映射</p>
<p>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作</p>
<p>MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<ol start="3">
<li><p>maven仓库下载/github下载</p>
</li>
<li><p>持久化</p>
</li>
</ol>
<p>数据持久化：持久化就是将程序的数据在持久状态和瞬时状态转化的过程</p>
<p>内存：断电即失、价格昂贵，因为有一些对象不能丢掉，所以需要持久化。</p>
<p>持久化：数据库（JDBC）、io文件持久化</p>
<ol start="5">
<li>持久层</li>
</ol>
<p>Dao层/Service层/Controller层</p>
<p>完成持久化工作的代码，层界限十分明显。</p>
<ol start="6">
<li>MyBatis的存在意义：</li>
</ol>
<p>方便，更容易上手，灵活</p>
<p>传统的JDBC代码太复杂，需要简化。Mybatis是一个框架，可以自动化生成</p>
<p>将数据存入到数据库中，sql和代码分离，提高了可维护性；提供映射标签，支持对象和数据库的orm字段关系对应；提供对象关系映射标签，支持对象关系组件维护；提供xml标签，支持编写sql。</p>
<p>二、写一个程序</p>
<p>思路：搭建环境–导入mybatis–编写代码–测试</p>
<p>1.mysql中创建数据库资源</p>
<p>2.idea中新建一个普通的maven项目</p>
<p>3.删除src目录（以后只需要在父工程下创建module就会继承父工程的所有maven依赖）</p>
<p>4.导入maven依赖：mysql/mybatis/junit</p>
<p>5.创建一个新的module。</p>
<p>（每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。有了 SqlSessionFactory，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。）</p>
<p>在新module下的resource下新建一个xml配置文件，在官网上找到相关的配置复制进去，environments中可以配置多个环境。配置的url可以连接到数据库中查找，？后可以添加相关的配置，&amp;需要用&amp;；转义。（中间不要加中文注释）    </p>
<p>例如：<code>jdbc:mysql://127.0.0.1:3306/jsh_erp?useUnicode=true&amp;characterEncoding=utf-8&amp;useCursorFetch=true&amp;defaultFetchSize=500&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true&amp;useSSL=false</code></p>
<p>也可以不使用 XML 构建 SqlSessionFactory</p>
<p>6.创建一个utils工具类（查看官方文档有具体方法）</p>
<p>静态初始化模块sqlSessionFactory，静态方法得到SqlSession</p>
<ol start="7">
<li>编写代码：</li>
</ol>
<p>以前：实体类pojo/Dao接口/接口实现类</p>
<p>现在：接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件</p>
<p>8.测试：</p>
<p>可能存在的错误：</p>
<p>在MapperRegistry中，类型接口是未知的（每一个Mapper.xml都需要在Mybatis核心配置文件中注册，这里的路径是/  不能是.）</p>
<p>在maven的pom.xml中Build中配置resources，防止我们的资源导出失败的问题</p>
<p>绑定的接口错误：namespace中的包名要和Dao/Mapper接口中的名字一致（必须要用.  不能用/）</p>
<p>方法名不对：id就是对应namespace中的方法名</p>
<p>返回类型不对：resultType是sql语句执行的返回值</p>
<p>参数类型：parameterType</p>
<p>标签不要匹配错误</p>
<p>NullPointerException空指针异常是因为sqlSessionFactory搞了两个</p>
<p>输出的xml文件中存在乱码问题：设置为UTF-8</p>
<p>最后用junit测试</p>
<p>三、CRUD</p>
<p>#{} 相当于是占位符   全限定名 别名</p>
<p>#{} 是 占位符 ：动态解析 -&gt; 预编译 -&gt; 执行    #{} 对应的变量会自动加上单引号  #{}  能防止sql 注入  #{} 默认值 arg0、arg1、arg2  或 0、 1</p>
<p>${} 是 拼接符 ：动态解析 -&gt; 编译 -&gt; 执行  ${} 对应的变量不会加上单引号  ${}  不能防止sql 注入  ${} 默认值param1、param2、param3</p>
<p>使用：</p>
<p>1.能用 #{} 的地方就用 #{}，尽量少用 ${}<br>2.表名作参数，或者order by 排序时用 ${}<br>3.传参时参数使用@Param(“”)注解，@Param注解的作用是给参数命名，参数命名后就能根据名字得到参数值（相当于又加了一层密），正确的将参数传入sql语句中（一般通过#{}的方式，${}会有sql注入的问题）。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Role selectById(@Param(&quot;id&quot;) String id);</span><br><span class="line">List&lt;Role&gt; selectByNameAndOrgId(@Param(&quot;name&quot;) String name, @Param(&quot;orgId&quot;) String orgId);</span><br></pre></td></tr></table></figure>



<p>增删改需要提交事务：sqlSession.commit(); </p>
<p>参数为int可以不用写</p>
<p>当报错的时候，读错要从后往前读</p>
<p>万能的Map：如果实体类中的属性有很多个，或者数据库的表/字段/参数过多时，可能直接传对象的属性不现实。所以可以使用map随意制造参数，通过键值对来传递（相当于是再new一个map，然后put参数，参数值，调用时候直接传map。会自动获取map参数对应的而参数值）。</p>
<p>Map传递参数，直接再sql中取出key即可。parameterType=“map”</p>
<p>对象传递参数，直接再sql中取对象的属性即可。parameterType=“object”</p>
<p>只有一个基本类型参数的情况下，可以直接再sql中取到。</p>
<p>多个参数可以用map，也可以用注解。</p>
<p>模糊查询：拼接参数的时候，防止sql注入的问题</p>
<p>1.java代码执行的时候，#{value} 参数中传递通配符 %*%</p>
<p>2.在sql拼接中使用通配符“%”+#{value}+“%”</p>
<p>四、配置解析</p>
<p>1.核心配置文件</p>
<p>Mybatis-config.xml（官方建议取这个名字）</p>
<p>configuration（配置）</p>
<p>properties（属性）</p>
<p>settings（设置）</p>
<p>typeAliases（类型别名）</p>
<p>typeHandlers（类型处理器）</p>
<p>objectFactory（对象工厂）</p>
<h3 id="plugins（插件）"><a href="#plugins（插件）" class="headerlink" title="plugins（插件）"></a>plugins（插件）</h3><p>介绍可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wuyuxing24/article/details/89343951">https://blog.csdn.net/wuyuxing24/article/details/89343951</a></p>
<p>MyBatis 允许你在映射语句执行过程中（这个过程就是sqlsession）的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
<p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可</p>
<p>利用插件可以完成 分页，动态填入update_by,update_time,create_by,create_time,del_flag字段，拦截sql语句使增删改功能不生效 等功能。</p>
<p>例子：拦截sql语句使增删改功能不生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>     <span class="comment">//将拦截器注册进spring</span></span><br><span class="line"><span class="meta">@Intercepts(@Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;))</span> <span class="comment">//method可以指定拦截器拦截的类型：update和quere</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionSql</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;  <span class="comment">//必须实现Interceptor接口才能完成拦截器的功能</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;<span class="comment">//拦截器的逻辑在这个方法里写</span></span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            Object arg = args[i];</span><br><span class="line">            String className = arg.getClass().getName();</span><br><span class="line">            System.out.println(i + <span class="string">&quot; 参数类型：&quot;</span> + className);</span><br><span class="line">            <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> MappedStatement) &#123;</span><br><span class="line">                MappedStatement ms = (MappedStatement) arg;</span><br><span class="line">                SqlCommandType sqlCommandType = ms.getSqlCommandType();</span><br><span class="line">                System.out.println(<span class="string">&quot;操作类型是：&quot;</span> + sqlCommandType.toString());</span><br><span class="line">                <span class="keyword">if</span> (Constant.VIRTUAL_OPENID.contains(UserUtil.getCurrentOpenid()) &amp;&amp; (sqlCommandType == SqlCommandType.INSERT || sqlCommandType == SqlCommandType.UPDATE || sqlCommandType == SqlCommandType.DELETE)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;不执行&quot;</span> + sqlCommandType.toString() + <span class="string">&quot;语句&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//拦截的返回值为Interger类型，所以直接返回设置为return 0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();<span class="comment">//不拦截返回invocation.proceed()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;<span class="comment">//这个方法里可以将拦截的sql语句设置自定义值</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给数据模型的一些通用操作属性（如：创建人、创建时间、修改人、修改时间等）自动赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器作用：给各实体对象在增加、修改时，自动添加操作属性信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class &#125;) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpeInfoInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------参数拦截---------------------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;02 当前线程ID:&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        <span class="comment">//遍历处理所有参数，update方法有两个参数，参见Executor类中的update()方法。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">            Object arg=args[i];</span><br><span class="line">            String className=arg.getClass().getName();</span><br><span class="line">            System.out.println(i + <span class="string">&quot; 参数类型：&quot;</span>+className);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第一个参数处理。根据它判断是否给“操作属性”赋值。</span></span><br><span class="line">            <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> MappedStatement)&#123;<span class="comment">//如果是第一个参数 MappedStatement</span></span><br><span class="line">                MappedStatement ms = (MappedStatement)arg;</span><br><span class="line">                SqlCommandType sqlCommandType = ms.getSqlCommandType();</span><br><span class="line">                System.out.println(<span class="string">&quot;操作类型：&quot;</span>+sqlCommandType);</span><br><span class="line">                <span class="keyword">if</span>(sqlCommandType == SqlCommandType.INSERT || sqlCommandType==SqlCommandType.UPDATE)&#123;</span><br><span class="line">                    <span class="comment">//如果是“增加”或“更新”操作，则继续进行默认操作信息赋值。否则，则退出</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第二个参数处理。（只有第二个程序才能跑到这）</span></span><br><span class="line">            <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Map)&#123;<span class="comment">//如果是map，有两种情况：（1）使用@Param多参数传入，由Mybatis包装成map。（2）原始传入Map</span></span><br><span class="line">                System.out.println(<span class="string">&quot;这是一个包装过的类型!&quot;</span>);</span><br><span class="line">                Map map=(Map)arg;</span><br><span class="line">                <span class="keyword">for</span> (Object obj : map.values())&#123;</span><br><span class="line">                    setProperty(obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;<span class="comment">//原始参数传入</span></span><br><span class="line">                setProperty(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为对象的操作属性赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 根据需要，将相关属性赋上默认值</span></span><br><span class="line">            BeanUtils.setProperty(obj, <span class="string">&quot;createrUsername&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            BeanUtils.setProperty(obj, <span class="string">&quot;createDT&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalAccessException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分页例子参考这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liang0000zai/article/details/102862284">https://blog.csdn.net/liang0000zai/article/details/102862284</a></p>
<p>environments（环境配置）</p>
<p>environment（环境变量）</p>
<p>T    ransactionManager（事务管理器）</p>
<p>dataSource（数据源）</p>
<p>databaseIdProvider（数据库厂商标识）</p>
<p>mappers（映射器）</p>
<h3 id="sqlsession"><a href="#sqlsession" class="headerlink" title="sqlsession"></a>sqlsession</h3><p>SqlSession是Mybatis最重要的构建之一，可以简单的认为Mybatis一系列的配置目的是生成类似 JDBC生成的Connection对象的SqlSession对象，这样才能与数据库开启“沟通”，通过SqlSession可以实现增删改查（当然现在更加推荐是使用Mapper接口形式）</p>
<p> SqlSessionInterceptor 是 SqlSessionTemplate 的内部类，目的只有一个，就是处理多个 session 的db操作！</p>
<p>所有请求都被 invoke() 拦截,从而做相应处理：</p>
<ol>
<li><p>进入请求，先生成一个新的sqlSession，为本次db操作做准备；</p>
</li>
<li><p>通过反射调用请求进来的方法，将 sqlSession 回调，进行复杂查询及结果映射；</p>
</li>
<li><p>如果需要立即提交事务，do it；</p>
</li>
<li><p>如果出现异常，包装异常信息，重新抛出；</p>
</li>
<li><p>操作完成后，关闭本次session；</p>
</li>
</ol>
<p> sqlSession 单例，并不会影响具体的db操作控制，所以不用担心session的线程安全问题</p>
<h3 id="sql语句的where问题"><a href="#sql语句的where问题" class="headerlink" title="sql语句的where问题"></a>sql语句的where问题</h3><p>where后面加&lt; if &gt;的标签：</p>
<p>​    如果if存在的话，会直接连and，导致出现 where and 的错误语句</p>
<p>​    如果if不存在的话，会直接多出来where，导致错误语句</p>
<p> 1.给where 后面加上1=1，以后的条件都可以正常and  </p>
<p> 2.mybatis 使用where 标签将所有的查询条件包括在内。<br>mybatis 就会将where标签后面第一个and 去掉（where只会去掉第一个多出来的and 或者  or）</p>
<p>where 1=0： where 后面跟一个永远不可能成立的条件1&lt;0 ， 1=0，1=2 这条sql语句结果不会返回任何数据，只有表结构，可用于快速建表</p>
<h3 id="sql语句的模糊查询字符串拼接"><a href="#sql语句的模糊查询字符串拼接" class="headerlink" title="sql语句的模糊查询字符串拼接"></a>sql语句的模糊查询字符串拼接</h3><p>1.利用concat进行拼接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT max(gateway_num) from gateway WHERE gateway_num LIKE  concat(&#x27;%&#x27;,#&#123;num&#125;,&#x27;%&#x27;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>这条语句的返回值是gateway_num这一列的最大值。如果需要返回这一行的值：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> gateway <span class="keyword">WHERE</span> gateway_num <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">max</span>(gateway_num) <span class="keyword">from</span> gateway <span class="keyword">WHERE</span> gateway_num <span class="keyword">LIKE</span>  concat(&quot;GFYD&quot;,<span class="string">&#x27;%&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>2.动态sql中的bind（未测试）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List<span class="tag">&lt;<span class="name">Hospital</span>&gt;</span> getHospitalLike(@Param(&quot;selectword&quot;) String selectword);</span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getHospitalLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hand.hand.domain.Hospital&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;bindselectword&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27;+selectword+&#x27;%&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bind</span>&gt;</span></span><br><span class="line">     SELECT *</span><br><span class="line">     FROM hospital</span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;selectword!=null&quot;</span>&gt;</span></span><br><span class="line">     where hid=cast(#&#123;selectword&#125; as signed INTEGER ) OR  hname like #&#123;bindselectword&#125;</span><br><span class="line">     OR  grade like #&#123;bindselectword&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/13.1.mybatis/" data-id="ckw61sdus000goswdbbg5aauh" data-title="mybatis" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-12.1.spring" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/12.1.spring/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:42:00.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/12.1.spring/">spring</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能。</p>
<p>Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题;</p>
<p>而Spring Boot 是基于Spring的一套快速开发整合包，Spring Boot遵循的也是约定优于配置原则,它的目的在于实现自动配置，降低项目搭建的复杂度;</p>
<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>
<p>Spring是一个轻量级的**控制反转(IoC)<strong>和</strong>面向切面(AOP)**的容器框架。</p>
<p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</p>
<h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>1、JAVA EE开发应该更加简单。</p>
<p>2、使用接口而不是使用类，是更好的编程习惯。Spring将使用接口的复杂度几乎降低到了零。</p>
<p>3、为JavaBean提供了一个更好的应用配置框架。</p>
<p>4、更多地强调面向对象的设计，而不是现行的技术如JAVA EE。</p>
<p>5、尽量减少不必要的异常捕捉。</p>
<p>6、使应用程序更加容易测试。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>1、可以令人方便愉快的使用Spring。</p>
<p>2、应用程序代码并不依赖于Spring APIs。</p>
<p>3、Spring不和现有的解决方案竞争，而是致力于将它们融合在一起。</p>
<h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>1、最完善的轻量级核心框架。</p>
<p>2、通用的事务管理抽象层。</p>
<p>3、JDBC抽象层。</p>
<p>4、集成了Toplink, Hibernate, JDO, and iBATIS SQL Maps。</p>
<p>5、AOP功能。</p>
<p>6、灵活的MVC Web应用框架。</p>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>Spring框架几乎涉及到了Java企业级服务开发的所有方面，也几乎针对所有开发常用的模式、中间件、数据库进行了整合适配。</p>
<p>当我们写一个业务把逻辑写死写出来是比较容易的，但是把这个逻辑提取成模式进而打包成一个框架来给大家使用，这是比较难的。因为我们只有经历过足够多的场景后才能提取出普适的功能框架，大部分人才能用上，而且我们需要针对核心功能开放出可配置的部分，满足小部分人进一步定制和扩展功能的需要。</p>
<p>Spring框架经历了几个阶段：</p>
<p>1.第一个阶段推出的Core、Security、Data是把单体应用开发服务好。不仅仅提供了便捷的数据库访问、Web MVC等必要功能，而且通过AOP、IOC两大利器让我们的程序内在能够做到低耦合可扩展。</p>
<p>2.第二个阶段推出的Boot的意义不仅仅是加速了开发效率而且能让我们的程序从可用变为好用，应用程序核心业务逻辑可能只有70%的工作量，要让程序在线上跑的愉快还有30%的监控日志打点等工作量需要去做。</p>
<p>3.第三个阶段推出的Cloud的意义在于推动了微服务架构的落地。让不具备开发微服务基础套件的小型互联网公司也能享受到免费的开箱即用的微服务解决方案。其实很多人不是看了微服务的架构思想去寻找解决方案，而是了解到了Spring Cloud才去了解微服务思想从而落地的。</p>
<p>4.目前属于第四个阶段，大力发展Cloud Dataflow（云数据流）+容器。Dataflow的思想是不管是做实时消息处理的服务还是临时运行的任务，都可以认为是服务的组件，如果可以有一套DSL来定义这些组件之间的交互方式，然后在容器中进行自由组合、部署、伸缩，那么架构会非常灵活。下图是Dataflow管理界面的一个示意图。</p>
<p>Spring的发展可以看到互联网架构的发展，Spring给我们带来相当多的技术启发，从软件设计模式的启发慢慢到了架构的启发，甚至我觉得Spring是为Java开发打造了架构风格的模板，接下去Spring继续发展2到3年有望成为架构标准</p>
<p><img src="/12.1.spring/image-20210922142605980.png" alt="image-20210922142605980"></p>
<p>在Spring4.x中增加了新的特性：如果类只提供了一个带参数的构造方法，则不需要对对其内部的属性写@Autowired注解，Spring会自动为你注入属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看spring的版本</span></span><br><span class="line">String springVersion = SpringVersion.getVersion();</span><br><span class="line">String springBootVersion = SpringBootVersion.getVersion();</span><br><span class="line">System.out.println(springVersion);</span><br><span class="line">System.out.println(springBootVersion);</span><br></pre></td></tr></table></figure>

<p>只要用了spring框架，肯定到处都是@Autowired。4.3之后的功能，如果只有一个构造方法，自动用这个构造方法注入配合lombok的@RequiredArgsConstructor使用体验很好：</p>
<p>我们平时开发中的bean大部分都不写构造函数，系统默认一个无参构造函数，这就符合这一条件。</p>
<p><img src="/12.1.spring/20191018160134977.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101816003785.png"></p>
<p>此时helloService已经注入了，但是有些人会说以前加个@Autowired就行了，现在还要加个构造方法，更麻烦了，这时可以使用lombok插件，类上加@AllArgsConstructor就行了。</p>
<p><img src="/12.1.spring/20191018160429867.png" alt="在这里插入图片描述"></p>
<p>在编写代码的时候，使用@Autowired注解是，发现IDE报的一个警告，如下：</p>
<p><img src="/12.1.spring/20190606170140759.jpg" alt="img"> </p>
<p>Spring Team recommends “Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies”.</p>
<p>翻译：</p>
<p>Spring建议”总是在您的bean中使用构造函数建立依赖注入。总是使用断言强制依赖”。</p>
<p>这段代码警告原来的写法是：</p>
<p>@Autowired<br>private EnterpriseDbService service;<br>建议后写成下面的样子：</p>
<p>private final EnterpriseDbService service;<br>@Autowired<br>public EnterpriseDbController(EnterpriseDbService service) {<br> this.service = service;<br>}<br>奇怪，为何会有这样的建议。</p>
<p>我们知道：@Autowired 可以对成员变量、方法以及构造函数进行注释。那么对成员变量和构造函数进行注释又有什么区别呢？</p>
<p>@Autowired注入bean，相当于在配置文件中配置bean，并且使用setter注入。而对构造函数进行注释，就相当于是使用构造函数进行依赖注入了吧。莫非是这两种注入方法的不同。</p>
<p>以下是：@Autowired和构造方法执行的顺序解析</p>
<p>先看一段代码，下面的代码能运行成功吗？</p>
<p>@Autowired<br>private User user;<br>private String school;<br>public UserAccountServiceImpl(){<br> this.school = user.getSchool();<br>}<br>答案是不能。</p>
<p>因为Java类会先执行构造方法，然后再给注解了@Autowired 的user注入值，所以在执行构造方法的时候，就会报错。</p>
<p>报错信息可能会像下面：</p>
<p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘…’ defined in file [….class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate […]: Constructor threw exception; nested exception is java.lang.NullPointerException<br>报错信息说：创建Bean时出错，出错原因是实例化bean失败，因为bean时构造方法出错，在构造方法里抛出了空指针异常。</p>
<p>解决办法是，使用构造器注入，如下：</p>
<p>private User user;<br>private String school;<br>@Autowired<br>public UserAccountServiceImpl(User user){<br> this.user = user;<br> this.school = user.getSchool();<br>}<br>可以看出，使用构造器注入的方法，可以明确成员变量的加载顺序。</p>
<p>PS：Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法–&gt;@Autowired</p>
<p>@Autowired和构造方法执行的顺序解析</p>
<p>先看一段代码，下面的代码能运行成功吗？</p>
<p> @Autowired<br>    private User user;<br>    private String school;</p>
<pre><code>public UserAccountServiceImpl()&#123;
    this.school = user.getSchool();
&#125;
</code></pre>
<p>答案是不能。因为Java类会先执行构造方法，然后再给注解了@Autowired 的user注入值，所以在执行构造方法的时候，就会报错。<br>报错信息可能会像下面：</p>
<p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘…’ defined in file [….class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate […]: Constructor threw exception; nested exception is java.lang.NullPointerException</p>
<p>报错信息说：创建Bean时出错，出错原因是实例化bean失败，因为bean时构造方法出错，在构造方法里抛出了空指针异常。</p>
<p>解决办法是，使用构造器注入，如下：</p>
<p> private User user;<br>    private String school;</p>
<pre><code>@Autowired
public UserAccountServiceImpl(User user)&#123;
    this.user = user;
    this.school = user.getSchool();
&#125;
</code></pre>
<p>那么最开始Spring建议，为何要将成员变量加上final类型呢？</p>
<p>网上有解释如下：spring配置默认的bean的scope是singleton，也就是启动后一直有。通过设置bean的scope属性为prototype来声明该对象为动态创建。但是，如果你的service本身是singleton，注入只执行一次。</p>
<p>@Autowired本身就是单例模式，只会在程序启动时执行一次，即使不定义final也不会初始化第二次，所以这个final是没有意义的吧。</p>
<p>可能是为了防止，在程序运行的时候，又执行了一遍构造函数；</p>
<p>或者是更容易让人理解的意思，加上final只会在程序启动的时候初始化一次，并且在程序运行的时候不会再改变。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired 注释可以在 setter 方法中被用于自动连接 bean，就像 @Autowired 注释，容器，一个属性或者任意命名的可能带有多个参数的方法。</p>
<p>可以在属性中使用 @Autowired 注释来除去 setter 方法。当时使用 为自动连接属性传递的时候，Spring 会将这些传递过来的值或者引用自动分配给那些属性</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>踩到一个坑，有一个接口，在这个接口的实现类里，需要用到@Autowired注解，一时大意，没有在实现类上加上@Component注解，导致了Spring报错，找不到这个类</p>
<p>一旦使用关于Spring的注解出现在类里，例如我在实现类中用到了@Autowired注解，被注解的这个类是从Spring容器中取出来的，那调用的实现类也需要被Spring容器管理，加上@Component</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;conversionImpl&quot;)</span></span><br><span class="line"><span class="comment">//其实默认的spring中的Bean id 为 conversionImpl(首字母小写)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConversionImpl</span> <span class="keyword">implements</span> <span class="title">Conversion</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient redisClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>介绍</p>
<p>开发中难免会遇到这个这个注解@Component</p>
<p>@Controller 控制器（注入服务）<br> 用于标注控制层，相当于struts中的action层</p>
<p>@Service 服务（注入dao）<br> 用于标注服务层，主要用来进行业务的逻辑处理</p>
<p>@Repository（实现dao访问）<br> 用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件</p>
<p>@Component （把普通pojo实例化到spring容器中，相当于配置文件中的 ）</p>
<p>泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</p>
<h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type1">异常处理方式一. @ExceptionHandler</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type2">异常处理方式二. 实现HandlerExceptionResolver接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type3">异常处理方式三. @ControllerAdvice+@ExceptionHandler</a></li>
</ol>
<p>spring的启动</p>
<p>Spring 是一个控制反转依赖管理的容器，作为 Java Web 的开发人员，基本没有不熟悉 Spring 技术栈的，尽管在依赖注入领域，Java Web 领域不乏其他优秀的框架，如 google 开源的依赖管理框架 guice，如 Jersey web 框架等。但 Spring 已经是 Java Web 领域使用最多，应用最广泛的 Java 框架。</p>
<p>此文将专注讲解如何在 Spring 容器启动时实现我们自己想要实现的逻辑。我们时常会遇到在 Spring 启动的时候必须完成一些初始化的操作，如创建定时任务，创建连接池等。</p>
<p>本文将介绍以下几种 Spring 启动监听方式：</p>
<ul>
<li>Bean 构造函数方式</li>
<li>使用 @PostConstruct 注解</li>
<li>实现 InitializingBean 接口</li>
<li>监听 ApplicationListener 事件</li>
<li>使用 Constructor 注入方式</li>
<li>实现 SpringBoot 的 CommandLineRunner 接口</li>
<li>SmartLifecycle 机制</li>
</ul>
<h2 id="spring装填bean"><a href="#spring装填bean" class="headerlink" title="spring装填bean"></a>spring装填bean</h2><p>我们知道如果我们要在一个类使用<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javaee">spring</a>提供的bean对象，我们需要把这个类注入到spring容器中，交给spring容器进行管理，但是在实际当中，我们往往会碰到在一个普通的<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javase">Java</a>类中，想直接使用spring提供的其他对象或者说有一些不需要交给spring管理，但是需要用到spring里的一些对象。如果这是spring框架的独立应用程序，我们通过</p>
<p>ApplicationContext ac = new FileSystemXmlApplicationContext(“applicationContext.xml”);<br>ac.getBean(“beanId”); </p>
<p>这样的方式就可以很轻易的获取我们所需要的对象。</p>
<p>但是往往我们所做的都是Web Application，这时我们启动spring容器是通过在web.xml文件中配置，这样就不适合使用上面的方式在普通类去获取对象了，因为这样做就相当于加载了两次spring容器，而我们想是否可以通过在启动web服务器的时候，就把Application放在某一个类中，我们通过这个类在获取，这样就可以在普通类获取spring bean对象了，让我们接着往下看</p>
<p><strong>普通类调用Spring bean对象:</strong></p>
<p>可以参考：<a target="_blank" rel="noopener" href="http://412887952-qq-com.iteye.com/blog/1479445">http://412887952-qq-com.iteye.com/blog/1479445</a></p>
<p>这里有更多这方面的介绍，比较详细</p>
<p>下面介绍在springboot中是如何使用的</p>
<p><strong>1.在Spring Boot可以扫描的包下</strong></p>
<p><strong>写的工具类为SpringUtil，实现ApplicationContextAware接口，并加入Component注解，让spring扫描到该bean</strong></p>
<p>springutil:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.util;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class SpringUtil implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        if(SpringUtil.applicationContext &#x3D;&#x3D; null) &#123;</span><br><span class="line">            SpringUtil.applicationContext &#x3D; applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------me.shijunjie.util.SpringUtil------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ApplicationContext配置成功,在普通类可以通过调用SpringUtils.getAppContext()获取applicationContext对象,applicationContext&#x3D;&quot;+SpringUtil.applicationContext+&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取applicationContext</span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name获取 Bean.</span><br><span class="line">    public static Object getBean(String name)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过class获取Bean.</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name,以及Clazz返回指定的Bean</span><br><span class="line">    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>为了测试，我们再启动的时候先通过代码方式给spring容器中注入一个bean，入下所示</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.entity.Demo2;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class BeanConfig &#123;</span><br><span class="line">    @Bean(name&#x3D;&quot;testDemo&quot;)</span><br><span class="line">    public Demo2 generateDemo() &#123;</span><br><span class="line">        Demo2 demo &#x3D; new Demo2();</span><br><span class="line">        demo.setId(12345);</span><br><span class="line">        demo.setName(&quot;test&quot;);</span><br><span class="line">        return demo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>然后我们编写测试controller，并从刚才写的springutil中获取这个bean</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.util.SpringUtil;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;application&quot;)</span><br><span class="line">public class TestApplicationController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;&#x2F;test1&quot;)</span><br><span class="line">    public Object testSpringUtil1() &#123;</span><br><span class="line">        return SpringUtil.getBean(&quot;testDemo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>测试</p>
<p>启动web应用，打开浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8080/application/test1%EF%BC%8C%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F">http://localhost:8080/application/test1，测试成功</a></p>
<p><img src="https://images2015.cnblogs.com/blog/1097735/201703/1097735-20170302105956954-82157382.png" alt="img"></p>
<p><strong>2 不在Spring Boot的扫描包下方式一</strong></p>
<p>这种情况处理起来也很简单，先编写SpringUtil类，同样需要实现接口：ApplicationContextAware，具体编码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.util;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line">public class SpringUtil2 implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        if(SpringUtil2.applicationContext &#x3D;&#x3D; null) &#123;</span><br><span class="line">            SpringUtil2.applicationContext &#x3D; applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------me.shijunjie.util.SpringUtil------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ApplicationContext配置成功,在普通类可以通过调用SpringUtils.getAppContext()获取applicationContext对象,applicationContext&#x3D;&quot;+SpringUtil2.applicationContext+&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取applicationContext</span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name获取 Bean.</span><br><span class="line">    public static Object getBean(String name)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过class获取Bean.</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name,以及Clazz返回指定的Bean</span><br><span class="line">    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Bean注解，在App.java类中将SpringUtil注解进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.context.web.SpringBootServletInitializer;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.util.SpringUtil2;</span><br><span class="line"></span><br><span class="line">@ComponentScan(basePackages&#x3D;&#123;&quot;me.shijunjie&quot;&#125;) &#x2F;&#x2F; 扫描该包路径下的所有spring组件</span><br><span class="line">&#x2F;*@EnableJpaRepositories(&quot;me.shijunjie.dao&quot;) &#x2F;&#x2F; JPA扫描该包路径下的Repositorie</span><br><span class="line">*&#x2F;&#x2F;*@EntityScan(&quot;me.shijunjie.entity&quot;) &#x2F;&#x2F; 扫描实体类</span><br><span class="line">*&#x2F;@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class App extends SpringBootServletInitializer&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public SpringUtil2 getSpringUtil2() &#123;</span><br><span class="line">        return new SpringUtil2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试（使用热部署的需要重启服务器）</p>
<p>启动web应用，打开浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8080/application/test2%EF%BC%8C%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F">http://localhost:8080/application/test2，测试成功</a></p>
<p><img src="https://images2015.cnblogs.com/blog/1097735/201703/1097735-20170302110921157-936863400.png" alt="img"></p>
<p>除此以外，也可以在<a href="mailto:主要是在App.java中使用@Import">App.java</a>中使用@Import进行导入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.context.web.SpringBootServletInitializer;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Import;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.util.SpringUtil2;</span><br><span class="line"></span><br><span class="line">@ComponentScan(basePackages&#x3D;&#123;&quot;me.shijunjie&quot;&#125;) &#x2F;&#x2F; 扫描该包路径下的所有spring组件</span><br><span class="line">&#x2F;*@EnableJpaRepositories(&quot;me.shijunjie.dao&quot;) &#x2F;&#x2F; JPA扫描该包路径下的Repositorie</span><br><span class="line">*&#x2F;&#x2F;*@EntityScan(&quot;me.shijunjie.entity&quot;) &#x2F;&#x2F; 扫描实体类</span><br><span class="line">*&#x2F;@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">@Import(SpringUtil2.class)</span><br><span class="line">public class App extends SpringBootServletInitializer&#123;</span><br><span class="line">    &#x2F;*@Bean</span><br><span class="line">    public SpringUtil2 getSpringUtil2() &#123;</span><br><span class="line">        return new SpringUtil2();</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跑出结果和上面相同</p>
<h2 id="原始构造函数"><a href="#原始构造函数" class="headerlink" title="原始构造函数"></a>原始构造函数</h2><p>如果没有 Spring 容器，不依赖于 Spring 的实现，回归 Java 类实现本身，我们可以在静态代码块，在类构造函数中实现相应的逻辑，Java 类的初始化顺序依次是<code>静态变量</code> &gt; <code>静态代码块</code> &gt; <code>全局变量</code> &gt; <code>初始化代码块</code> &gt; <code>构造器</code>。</p>
<p>比如，Log4j 的初始化，就是在 <code>LogManager</code> 的静态代码块中实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line"></span><br><span class="line">    Hierarchy h &#x3D; new Hierarchy(new RootLogger((Level) Level.DEBUG));</span><br><span class="line">    repositorySelector &#x3D; new DefaultRepositorySelector(h);</span><br><span class="line"></span><br><span class="line">    String override &#x3D;OptionConverter.getSystemProperty(DEFAULT_INIT_OVERRIDE_KEY,null);</span><br><span class="line"></span><br><span class="line">    if(override &#x3D;&#x3D; null || &quot;false&quot;.equalsIgnoreCase(override)) &#123;</span><br><span class="line">          String configurationOptionStr &#x3D; OptionConverter.getSystemProperty(DEFAULT_CONFIGURATION_KEY, null);</span><br><span class="line">          String configuratorClassName &#x3D; OptionConverter.getSystemProperty(CONFIGURATOR_CLASS_KEY, null);</span><br><span class="line"></span><br><span class="line">          URL url &#x3D; null;</span><br><span class="line"></span><br><span class="line">          if(configurationOptionStr &#x3D;&#x3D; null) &#123;</span><br><span class="line">            url &#x3D; Loader.getResource(DEFAULT_XML_CONFIGURATION_FILE);</span><br><span class="line">            if(url &#x3D;&#x3D; null) &#123;</span><br><span class="line">              url &#x3D; Loader.getResource(DEFAULT_CONFIGURATION_FILE);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              url &#x3D; new URL(configurationOptionStr);</span><br><span class="line">            &#125; catch (MalformedURLException ex) &#123;</span><br><span class="line">              url &#x3D; Loader.getResource(configurationOptionStr);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if(url !&#x3D; null) &#123;</span><br><span class="line">            LogLog.debug(&quot;Using URL [&quot;+url+&quot;] for automatic log4j configuration.&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                OptionConverter.selectAndConfigure(url, configuratorClassName,LogManager.getLoggerRepository());</span><br><span class="line">            &#125; catch (NoClassDefFoundError e) &#123;</span><br><span class="line">                LogLog.warn(&quot;Error during default initialization&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              LogLog.debug(&quot;Could not find resource: [&quot;+configurationOptionStr+&quot;].&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">            LogLog.debug(&quot;Default initialization of overridden by &quot; +  DEFAULT_INIT_OVERRIDE_KEY + &quot;property.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如在构造函数中实现相应的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment env;</span><br><span class="line"></span><br><span class="line">    public CustomBean() &#123;</span><br><span class="line">        env.getActiveProfiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里考验一下各位，上面的代码是否可以正常运行。—— 不行，构造函数中的<code>env</code>将会发生<code>NullPointException</code>异常。这是因为在 Spring 中将先初始化 Bean，也就是会先调用类的构造函数，然后才注入成员变量依赖的 Bean（<code>@Autowired</code>和<code>@Resource</code>注解修饰的成员变量），注意<code>@Value</code>等注解的配置的注入也是在构造函数之后。</p>
<h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>在 Spring 中，我们可以使用<code>@PostConstruct</code>在 Bean 初始化之后实现相应的初始化逻辑，<code>@PostConstruct</code>修饰的方法将在 Bean 初始化完成之后执行，此时 Bean 的依赖也已经注入完成，因此可以在方法中调用注入的依赖 Bean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment env;</span><br><span class="line"></span><br><span class="line">    @PostConstruce</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        env.getActiveProfiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>@PostConstruct</code>相对应的，如果想在 Bean 注销时完成一些清扫工作，如关闭线程池等，可以使用<code>@PreDestroy</code>注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ExecutorService executor &#x3D; Executors.newFixedThreadPool(1)</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        env.getActiveProfiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h2><p>实现 Spring 的<code>InitializingBean</code>接口同样可以实现以上在 Bean 初始化完成之后执行相应逻辑的功能，实现<code>InitializingBean</code>接口，在<code>afterPropertiesSet</code>方法中实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOG</span><br><span class="line">      &#x3D; Logger.getLogger(InitializingBeanExampleBean.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        LOG.info(environment.getDefaultProfiles());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h2><p>我们可以在 Spring 容器初始化的时候实现我们想要的初始化逻辑。这时我们就可以使用到 Spring 的初始化事件。Spring 有一套完整的事件机制，在 Spring 启动的时候，Spring 容器本身预设了很多事件，在 Spring 初始化的整个过程中在相应的节点触发相应的事件，我们可以通过监听这些事件来实现我们的初始化逻辑。Spring 的事件实现如下：</p>
<ul>
<li>ApplicationEvent，事件对象，由 ApplicationContext 发布，不同的实现类代表不同的事件类型。</li>
<li>ApplicationListener，监听对象，任何实现了此接口的 Bean 都会收到相应的事件通知。实现了 ApplicationListener 接口之后，需要实现方法 onApplicationEvent()，在容器将所有的 Bean 都初始化完成之后，就会执行该方法。</li>
</ul>
<p>与 Spring Context 生命周期相关的几个事件有以下几个：</p>
<ul>
<li>ApplicationStartingEvent: 这个事件在 Spring Boot 应用运行开始时，且进行任何处理之前发送（除了监听器和初始化器注册之外）。</li>
<li>ContextRefreshedEvent: ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。</li>
<li>ContextStartedEvent: 当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被触发。你可以查询你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</li>
<li>ApplicationReadyEvent: 这个事件在任何 application/ command-line runners 调用之后发送。</li>
<li>ContextClosedEvent: 当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被触发。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</li>
<li>ContextStoppedEvent: Spring 最后完成的事件。</li>
</ul>
<p>因此，如果我们想在 Spring 启动的时候实现一些相应的逻辑，可以找到 Spring 启动过程中符合我们需要的事件，通过监听相应的事件来完成我们的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class StartupApplicationListenerExample implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">        log.info(&quot;Subject ContextRefreshedEvent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了通过实现<code>ApplicationListener</code>接口来监听相应的事件，Spring 的事件机制也实现了通过<code>@EventListener</code>注解来监听相对应事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class StartupApplicationListenerExample &#123;</span><br><span class="line"></span><br><span class="line">    @EventListener</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">        log.info(&quot;Subject ContextRefreshedEvent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Event 是一套完善的进程内事件发布订阅机制，我们除了用来监听 Spring 内置的事件，也可以使用 Spring Event 实现自定义的事件发布订阅功能。</p>
<h2 id="Constructor-注入"><a href="#Constructor-注入" class="headerlink" title="Constructor 注入"></a>Constructor 注入</h2><p>在学习 Spring 的注入机制的时候，我们都知道 Spring 可以通过构造函数、Setter 和反射成员变量注入等方式。上面我们在成员变量上通过<code>@Autoware</code>注解注入依赖 Bean，但是在 Bean 的构造函数函数中却无法使用到注入的 Bean（因为 Bean 还未注入），其实我们也是使用 Spring 的构造函数注入方式， 这也是 Spring 推荐的注入机制（在我们使用 IDEA 的时候，如果没有关闭相应的代码 Warning 机制，会发现在成员变量上的<code>@Autoware</code>是黄色的，也就是 idea 不建议的代码）。Spring 更推荐构造函数注入的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class ConstructorBean &#123;</span><br><span class="line"></span><br><span class="line">    private final Environment environment;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public LogicInConstructorExampleBean(Environment environment) &#123;</span><br><span class="line">        this.environment &#x3D; environment;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><p>如果我们的项目使用的是 Spring Boot，那么可以使用 Spring Boot 提供的 <code>CommandLineRunner</code> 接口来实现初始化逻辑，Spring Boot 将在启动初始化完成之后调用实现了<code>CommandLineRunner</code>的接口的<code>run</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommandLineAppStartupRunner implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String...args) throws Exception &#123;</span><br><span class="line">        log.info(&quot;Increment counter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，多个<code>CommandLineRunner</code>实现，可以通过<code>@Order</code>来控制它们的执行顺序。</p>
<h2 id="SmartLifecycle"><a href="#SmartLifecycle" class="headerlink" title="SmartLifecycle"></a>SmartLifecycle</h2><p>还有一种更高级的方法来实现我们的逻辑。这可以 Spring 高级开发必备技能哦。SmartLifecycle 不仅仅能在初始化后执行一个逻辑，还能再关闭前执行一个逻辑，并且也可以控制多个 <code>SmartLifecycle</code> 的执行顺序，就像这个类名表示的一样，这是一个智能的生命周期管理接口。</p>
<ul>
<li>start()：bean 初始化完毕后，该方法会被执行。</li>
<li>stop()：容器关闭后，spring 容器发现当前对象实现了 SmartLifecycle，就调用 stop(Runnable)， 如果只是实现了 Lifecycle，就调用 stop()。</li>
<li>isRunning：当前状态，用来判你的断组件是否在运行。</li>
<li>getPhase：控制多个 SmartLifecycle 的回调顺序的，返回值越小越靠前执行 start() 方法，越靠后执行 stop() 方法。</li>
<li>isAutoStartup()：start 方法被执行前先看此方法返回值，返回 false 就不执行 start 方法了。</li>
<li>stop(Runnable)：容器关闭后，spring 容器发现当前对象实现了 SmartLifecycle，就调用 stop(Runnable)， 如果只是实现了 Lifecycle，就调用 stop()。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SmartLifecycleExample implements SmartLifecycle &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        isRunning &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getPhase() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认为 0</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAutoStartup() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认为 false</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isRunning() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认返回 false</span><br><span class="line">        return isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop(Runnable callback) &#123;</span><br><span class="line">        System.out.println(&quot;stop(Runnable)&quot;);</span><br><span class="line">        callback.run();</span><br><span class="line">        isRunning &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;stop&quot;);</span><br><span class="line"></span><br><span class="line">        isRunning &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Aspect、-Before、-After-注解实现-AOP-切面功能"><a href="#Spring-Aspect、-Before、-After-注解实现-AOP-切面功能" class="headerlink" title="Spring @Aspect、@Before、@After 注解实现 AOP 切面功能"></a>Spring @Aspect、@Before、@After 注解实现 AOP 切面功能</h2><p>Spring AOP 注解概述<br>1、Spring 的 AOP 功能除了在配置文件中配置一大堆的配置，比如切入点、表达式、通知等等以外，使用注解的方式更为方便快捷，特别是 Spring boot 出现以后，基本不再使用原先的 beans.xml 等配置文件了，而都推荐注解编程。</p>
<table>
<thead>
<tr>
<th>@Aspect</th>
<th>切面声明，标注在类、接口（包括注解类型）或枚举上。</th>
</tr>
</thead>
<tbody><tr>
<td>@Pointcut</td>
<td>切入点声明，即切入到哪些目标类的目标方法。<br />value 属性指定切入点表达式，默认为 “”，用于被通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式</td>
</tr>
<tr>
<td>@Before</td>
<td>前置通知, 在目标方法(切入点)执行之前执行。<br />value 属性绑定通知的切入点表达式，可以关联切入点声明，也可以直接设置切入点表达式<br />注意：如果在此回调方法中抛出异常，则目标方法不会再执行，会继续执行后置通知 -&gt; 异常通知。</td>
</tr>
<tr>
<td>@After</td>
<td>后置通知, 在目标方法(切入点)执行之后执行</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>返回通知, 在目标方法(切入点)返回结果之后执行，在 @After 的后面执行<br />pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 “”</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>异常通知, 在方法抛出异常之后执行, 意味着跳过返回通知<br />pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 “”<br />注意：如果目标方法自己 try-catch 了异常，而没有继续往外抛，则不会进入此回调函数</td>
</tr>
<tr>
<td>@Around</td>
<td>环绕通知：目标方法执行前后分别执行一些代码，类似拦截器，可以控制目标方法是否继续执行。<br />通常用于统计方法耗时，参数校验等等操作。<br />环绕通知早于前置通知，晚于返回通知</td>
</tr>
<tr>
<td>2、上面这些 AOP 注解都是位于如下所示的 aspectjweaver 依赖中：</td>
<td></td>
</tr>
</tbody></table>
<p><img src="/12.1.spring/20200822102819511.png" alt="img"></p>
<p>3、对于习惯了 Spring 全家桶编程的人来说，并不是需要直接引入 aspectjweaver 依赖，因为 spring-boot-starter-aop 组件默认已经引用了 aspectjweaver 来实现  AOP 功能。换句话说 Spring 的 AOP 功能就是依赖的 aspectjweaver ！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-aop --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;dependency&gt;    </span><br></pre></td></tr></table></figure>

<p>@Aspect 快速入门<br>1、@Aspect 常见用于记录日志、异常集中处理、权限验证、Web 参数校验、事务处理等等</p>
<p>2、要想把一个类变成切面类，只需3步：</p>
<p>1）在类上使用 @Aspect 注解使之成为切面类</p>
<p>2）切面类需要交由 Sprign 容器管理，所以类上还需要有 @Service、@Repository、@Controller、@Component  等注解<br>2）在切面类中自定义方法接收通知</p>
<p>3、AOP 的含义就不再累述了，下面直接上示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.lang3.time.StopWatch;</span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.Signature;</span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.aspectj.lang.reflect.SourceLocation;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line"> * 切面注解 Aspect 使用入门</span><br><span class="line"></span><br><span class="line"> * 1、@Aspect：声明本类为切面类</span><br><span class="line"></span><br><span class="line"> * 2、@Component：将本类交由 Spring 容器管理</span><br><span class="line"></span><br><span class="line"> * 3、@Order：指定切入执行顺序，数值越小，切面执行顺序越靠前，默认为 Integer.MAX_VALUE</span><br><span class="line">   *</span><br><span class="line"></span><br><span class="line"> * @author wangMaoXiong</span><br><span class="line"></span><br><span class="line"> * @version 1.0</span><br><span class="line"></span><br><span class="line"> * @date 2020&#x2F;8&#x2F;20 19:22</span><br><span class="line">   *&#x2F;</span><br><span class="line">   @Aspect</span><br><span class="line">   @Order(value &#x3D; 999)</span><br><span class="line">   @Component</span><br><span class="line">   public class AspectHelloWorld &#123;</span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(AspectHelloWorld.class);</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * @Pointcut ：切入点声明，即切入到哪些目标方法。value 属性指定切入点表达式，默认为 &quot;&quot;。</span><br><span class="line"></span><br><span class="line">    * 用于被下面的通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式</span><br><span class="line"></span><br><span class="line">    * &lt;p&gt;</span><br><span class="line"></span><br><span class="line">    * 切入点表达式常用格式举例如下：</span><br><span class="line"></span><br><span class="line">    * - * com.wmx.aspect.EmpService.*(..))：表示 com.wmx.aspect.EmpService 类中的任意方法</span><br><span class="line"></span><br><span class="line">    * - * com.wmx.aspect.*.*(..))：表示 com.wmx.aspect 包(不含子包)下任意类中的任意方法</span><br><span class="line"></span><br><span class="line">    * - * com.wmx.aspect..*.*(..))：表示 com.wmx.aspect 包及其子包下任意类中的任意方法</span><br><span class="line"></span><br><span class="line">    * &lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    * value 的 execution 可以有多个，使用 || 隔开.</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @Pointcut(value &#x3D;</span><br><span class="line">          &quot;execution(* com.wmx.hb.controller.DeptController.*(..)) &quot; +</span><br><span class="line">                  &quot;|| execution(* com.wmx.hb.controller.EmpController.*(..))&quot;)</span><br><span class="line">      private void aspectPointcut() &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 前置通知：目标方法执行之前执行以下方法体的内容。</span><br><span class="line"></span><br><span class="line">    * value：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line"></span><br><span class="line">    * &lt;br&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    * * @param joinPoint：提供对连接点处可用状态和有关它的静态信息的反射访问&lt;br&#x2F;&gt; &lt;p&gt;</span><br><span class="line"></span><br><span class="line">    * * * Object[] getArgs()：返回此连接点处（目标方法）的参数，目标方法无参数时，返回空数组</span><br><span class="line"></span><br><span class="line">    * * * Signature getSignature()：返回连接点处的签名。</span><br><span class="line"></span><br><span class="line">    * * * Object getTarget()：返回目标对象</span><br><span class="line"></span><br><span class="line">    * * * Object getThis()：返回当前正在执行的对象</span><br><span class="line"></span><br><span class="line">    * * * StaticPart getStaticPart()：返回一个封装此连接点的静态部分的对象。</span><br><span class="line"></span><br><span class="line">    * * * SourceLocation getSourceLocation()：返回与连接点对应的源位置</span><br><span class="line"></span><br><span class="line">    * * * String toLongString()：返回连接点的扩展字符串表示形式。</span><br><span class="line"></span><br><span class="line">    * * * String toShortString()：返回连接点的缩写字符串表示形式。</span><br><span class="line"></span><br><span class="line">    * * * String getKind()：返回表示连接点类型的字符串</span><br><span class="line"></span><br><span class="line">    * * * &lt;&#x2F;p&gt;</span><br><span class="line">          *&#x2F;</span><br><span class="line">          @Before(value &#x3D; &quot;aspectPointcut()&quot;)</span><br><span class="line">          public void aspectBefore(JoinPoint joinPoint) &#123;</span><br><span class="line">          Object[] args &#x3D; joinPoint.getArgs();</span><br><span class="line">          Signature signature &#x3D; joinPoint.getSignature();</span><br><span class="line">          Object target &#x3D; joinPoint.getTarget();</span><br><span class="line">          Object aThis &#x3D; joinPoint.getThis();</span><br><span class="line">          JoinPoint.StaticPart staticPart &#x3D; joinPoint.getStaticPart();</span><br><span class="line">          SourceLocation sourceLocation &#x3D; joinPoint.getSourceLocation();</span><br><span class="line">          String longString &#x3D; joinPoint.toLongString();</span><br><span class="line">          String shortString &#x3D; joinPoint.toShortString();</span><br><span class="line"></span><br><span class="line">        LOG.debug(&quot;【前置通知】&quot; +</span><br><span class="line">                        &quot;args&#x3D;&#123;&#125;,signature&#x3D;&#123;&#125;,target&#x3D;&#123;&#125;,aThis&#x3D;&#123;&#125;,staticPart&#x3D;&#123;&#125;,&quot; +</span><br><span class="line">                        &quot;sourceLocation&#x3D;&#123;&#125;,longString&#x3D;&#123;&#125;,shortString&#x3D;&#123;&#125;&quot;</span><br><span class="line">                , Arrays.asList(args), signature, target, aThis, staticPart, sourceLocation, longString, shortString);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 后置通知：目标方法执行之后执行以下方法体的内容，不管目标方法是否发生异常。</span><br><span class="line">    * value：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @After(value &#x3D; &quot;aspectPointcut()&quot;)</span><br><span class="line">      public void aspectAfter(JoinPoint joinPoint) &#123;</span><br><span class="line">      LOG.debug(&quot;【后置通知】kind&#x3D;&#123;&#125;&quot;, joinPoint.getKind());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 返回通知：目标方法返回后执行以下代码</span><br><span class="line">    * value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line">    * pointcut 属性：绑定通知的切入点表达式，优先级高于 value，默认为 &quot;&quot;</span><br><span class="line">    * returning 属性：通知签名中要将返回值绑定到的参数的名称，默认为 &quot;&quot;</span><br><span class="line">      *</span><br><span class="line">    * @param joinPoint ：提供对连接点处可用状态和有关它的静态信息的反射访问</span><br><span class="line">    * @param result    ：目标方法返回的值，参数名称与 returning 属性值一致。无返回值时，这里 result 会为 null.</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @AfterReturning(pointcut &#x3D; &quot;aspectPointcut()&quot;, returning &#x3D; &quot;result&quot;)</span><br><span class="line">      public void aspectAfterReturning(JoinPoint joinPoint, Object result) &#123;</span><br><span class="line">      LOG.debug(&quot;【返回通知】,shortString&#x3D;&#123;&#125;,result&#x3D;&quot;, joinPoint.toShortString(), result);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 异常通知：目标方法发生异常的时候执行以下代码，此时返回通知不会再触发</span><br><span class="line">    * value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line">    * pointcut 属性：绑定通知的切入点表达式，优先级高于 value，默认为 &quot;&quot;</span><br><span class="line">    * throwing 属性：与方法中的异常参数名称一致，</span><br><span class="line">      *</span><br><span class="line">    * @param ex：捕获的异常对象，名称与 throwing 属性值一致</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @AfterThrowing(pointcut &#x3D; &quot;aspectPointcut()&quot;, throwing &#x3D; &quot;ex&quot;)</span><br><span class="line">      public void aspectAfterThrowing(JoinPoint jp, Exception ex) &#123;</span><br><span class="line">      String methodName &#x3D; jp.getSignature().getName();</span><br><span class="line">      if (ex instanceof ArithmeticException) &#123;</span><br><span class="line">          LOG.error(&quot;【异常通知】&quot; + methodName + &quot;方法算术异常（ArithmeticException）：&quot; + ex.getMessage());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          LOG.error(&quot;【异常通知】&quot; + methodName + &quot;方法异常：&quot; + ex.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 环绕通知</span><br><span class="line"></span><br><span class="line">    * 1、@Around 的 value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line"></span><br><span class="line">    * 2、Object ProceedingJoinPoint.proceed(Object[] args) 方法：继续下一个通知或目标方法调用，返回处理结果，如果目标方法发生异常，则 proceed 会抛异常.</span><br><span class="line"></span><br><span class="line">    * 3、假如目标方法是控制层接口，则本方法的异常捕获与否都不会影响目标方法的事务回滚</span><br><span class="line"></span><br><span class="line">    * 4、假如目标方法是控制层接口，本方法 try-catch 了异常后没有继续往外抛，则全局异常处理 @RestControllerAdvice 中不会再触发</span><br><span class="line">      *</span><br><span class="line"></span><br><span class="line">    * @param joinPoint</span><br><span class="line"></span><br><span class="line">    * @return</span><br><span class="line"></span><br><span class="line">    * @throws Throwable</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @Around(value &#x3D; &quot;aspectPointcut()&quot;)</span><br><span class="line">      public Object handleControllerMethod(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">      this.checkRequestParam(joinPoint);</span><br><span class="line"></span><br><span class="line">      StopWatch stopWatch &#x3D; StopWatch.createStarted();</span><br><span class="line">      LOG.debug(&quot;【环绕通知】执行接口开始，方法&#x3D;&#123;&#125;，参数&#x3D;&#123;&#125; &quot;, joinPoint.getSignature(), Arrays.asList(joinPoint.getArgs()).toString());</span><br><span class="line">      &#x2F;&#x2F;继续下一个通知或目标方法调用，返回处理结果，如果目标方法发生异常，则 proceed 会抛异常.</span><br><span class="line">      &#x2F;&#x2F;如果在调用目标方法或者下一个切面通知前抛出异常，则不会再继续往后走.</span><br><span class="line">      Object proceed &#x3D; joinPoint.proceed(joinPoint.getArgs());</span><br><span class="line"></span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      long watchTime &#x3D; stopWatch.getTime();</span><br><span class="line">      LOG.debug(&quot;【环绕通知】执行接口结束，方法&#x3D;&#123;&#125;, 返回值&#x3D;&#123;&#125;,耗时&#x3D;&#123;&#125; (毫秒)&quot;, joinPoint.getSignature(), proceed, watchTime);</span><br><span class="line">      return proceed;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 参数校验，防止 SQL 注入</span><br><span class="line">      *</span><br><span class="line">    * @param joinPoint</span><br><span class="line">      *&#x2F;</span><br><span class="line">      private void checkRequestParam(ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line">      Object[] args &#x3D; joinPoint.getArgs();</span><br><span class="line">      if (args &#x3D;&#x3D; null || args.length &lt;&#x3D; 0) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      String params &#x3D; Arrays.toString(joinPoint.getArgs()).toUpperCase();</span><br><span class="line">      String[] keywords &#x3D; &#123;&quot;DELETE &quot;, &quot;UPDATE &quot;, &quot;SELECT &quot;, &quot;INSERT &quot;, &quot;SET &quot;, &quot;SUBSTR(&quot;, &quot;COUNT(&quot;, &quot;DROP &quot;,</span><br><span class="line">              &quot;TRUNCATE &quot;, &quot;INTO &quot;, &quot;DECLARE &quot;, &quot;EXEC &quot;, &quot;EXECUTE &quot;, &quot; AND &quot;, &quot; OR &quot;, &quot;--&quot;&#125;;</span><br><span class="line">      for (String keyword : keywords) &#123;</span><br><span class="line">          if (params.contains(keyword)) &#123;</span><br><span class="line">              LOG.warn(&quot;参数存在SQL注入风险，其中包含非法字符 &#123;&#125;.&quot;, keyword);</span><br><span class="line">              throw new RuntimeException(&quot;参数存在SQL注入风险：params&#x3D;&quot; + params);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/12.1.spring/20200822112024130.gif" alt="img"></p>
<p>如上所示在不修改原来业务层代码的基础上，就可以使用 AOP 功能，在目标方法执行前后或者异常时都能捕获然后执行。</p>
<p>execution 切点表达式<br>1、@Pointcut 切入点声明注解，以及所有的通知注解都可以通过 value 属性或者 pointcut 属性指定切入点表达式。</p>
<p>2、切入点表达式通过 execution 函数匹配连接点，语法：execution([方法修饰符]  返回类型  方法路径(参数类型) [异常类型])</p>
<p>3、切入点表达式的写法比较灵活，比如：* 号表示任意一个，.. 表示任意多个，还可以使用 &amp;&amp;、||、! 进行逻辑运算.实际开发中常用：</p>
<table>
<thead>
<tr>
<th>execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(Integer))</th>
<th>匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，且带有一个 Integer 类型参数。</th>
</tr>
</thead>
<tbody><tr>
<td>execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(*))</td>
<td>匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，且带有一个任意类型参数。</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(..))</td>
<td>匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，参数不限</td>
</tr>
<tr>
<td>execution(* grp.basic3.se.service.SEBasAgencyService3.editAgencyInfo(..)) || execution(* grp.basic3.se.service.SEBasAgencyService3.adjustAgencyInfo(..))</td>
<td>匹配 editAgencyInfo 方法或者 adjustAgencyInfo 方法</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect.EmpService.*(..))</td>
<td>匹配 com.wmx.aspect.EmpService 类中的任意方法</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect.<em>.</em>(..))</td>
<td>匹配 com.wmx.aspect 包(不含子包)下任意类中的任意方法</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect..<em>.</em>(..))</td>
<td>匹配 com.wmx.aspect 包及其子包下任意类中的任意方法</td>
</tr>
<tr>
<td>execution(* grp.pm..<em>Controller.</em>(..))</td>
<td>匹配 grp.pm 包下任意子孙包中以 “Controller” 结尾的类中的所有方法</td>
</tr>
</tbody></table>
<ul>
<li>execution：用于匹配方法执行的连接点；</li>
<li>within：用于匹配指定类型内的方法执行；</li>
<li>this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；    </li>
<li>target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；</li>
<li>args：用于匹配当前执行的方法传入的参数为指定类型的执行方法；</li>
<li>@within：用于匹配所以持有指定注解类型内的方法；</li>
<li>@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；</li>
<li>@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；</li>
<li>@annotation：用于匹配当前执行方法持有指定注解的方法；</li>
</ul>
<h2 id="SpEL表达式"><a href="#SpEL表达式" class="headerlink" title="SpEL表达式"></a><strong>SpEL表达式</strong></h2><p>SpEL（Spring Expression Language），即Spring表达式语言，是比JSP的EL更强大的一种表达式语言</p>
<p>它可以在运行时查询和操作数据，尤其是数组列表型数据，因此可以缩减代码量，优化代码结构</p>
<p>SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression</p>
<p>1.@Value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@Value能修饰成员变量和方法形参</span><br><span class="line">&#x2F;&#x2F;#&#123;&#125;内就是表达式的内容</span><br><span class="line">@Value(&quot;#&#123;表达式&#125;&quot;)</span><br><span class="line">public String arg;</span><br></pre></td></tr></table></figure>

<p>2.<bean>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;xxx&quot; class&#x3D;&quot;com.java.XXXXX.xx&quot;&gt;</span><br><span class="line">    &lt;!-- 同@Value,#&#123;&#125;内是表达式的值，可放在property或constructor-arg内 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;arg&quot; value&#x3D;&quot;#&#123;表达式&#125;&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>代码块中使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.expression.Expression;</span><br><span class="line">import org.springframework.expression.ExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"> </span><br><span class="line">public class SpELTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;创建ExpressionParser解析表达式</span><br><span class="line">        ExpressionParser parser &#x3D; new SpelExpressionParser();</span><br><span class="line">        &#x2F;&#x2F;表达式放置</span><br><span class="line">        Expression exp &#x3D; parser.parseExpression(&quot;表达式&quot;);</span><br><span class="line">        &#x2F;&#x2F;执行表达式，默认容器是spring本身的容器：ApplicationContext</span><br><span class="line">        Object value &#x3D; exp.getValue();</span><br><span class="line">        </span><br><span class="line">        &#x2F;**如果使用其他的容器，则用下面的方法*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;创建一个虚拟的容器EvaluationContext</span><br><span class="line">        StandardEvaluationContext ctx &#x3D; new StandardEvaluationContext();</span><br><span class="line">        &#x2F;&#x2F;向容器内添加bean</span><br><span class="line">        BeanA beanA &#x3D; new BeanA();</span><br><span class="line">        ctx.setVariable(&quot;bean_id&quot;, beanA);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;setRootObject并非必须；一个EvaluationContext只能有一个RootObject，引用它的属性时，可以不加前缀</span><br><span class="line">        ctx.setRootObject(XXX);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;getValue有参数ctx，从新的容器中根据SpEL表达式获取所需的值</span><br><span class="line">        Object value &#x3D; exp.getValue(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.#{…}和${…}</p>
<ul>
<li>#{…} 用于执行SpEl表达式，并将内容赋值给属性</li>
<li>${…} 主要用于加载外部属性文件中的值</li>
<li>#{…} 和${…} 可以混合使用，但是必须<code>#&#123;&#125;外面，$&#123;&#125;在里面</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果属性文件没有spelDefault.value，则会报错</span><br><span class="line">   &#x2F;&#x2F;  @Value(&quot;$&#123;spelDefault.value&#125;&quot;)</span><br><span class="line">   &#x2F;&#x2F;  private String spelDefault2;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 使用default.value设置值，如果不存在则使用默认值</span><br><span class="line">   @Value(&quot;$&#123;spelDefault.value:127.0.0.1&#125;&quot;)</span><br><span class="line">   private String spelDefault;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SpEL：调用字符串Hello World的concat方法</span><br><span class="line">@Value(&quot;#&#123;&#39;Hello World&#39;.concat(&#39;!&#39;)&#125;&quot;)</span><br><span class="line">private String helloWorld;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; SpEL: 调用字符串的getBytes方法，然后调用length属性</span><br><span class="line">@Value(&quot;#&#123;&#39;Hello World&#39;.bytes.length&#125;&quot;)</span><br><span class="line">private String helloWorldbytes;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&#123;...&#125;和#&#123;...&#125;可以混合使用，如下文代码执行顺序：通过$&#123;server.name&#125;从属性文件中获取值并进行替换，然后就变成了 执行SpEL表达式&#123;‘server1,server2,server3’.split(‘,’)&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; SpEL: 传入一个字符串，根据&quot;,&quot;切分后插入列表中， #&#123;&#125;和$&#123;&#125;配置使用(注意单引号，注意不能反过来$&#123;&#125;在外面，#&#123;&#125;在里面)</span><br><span class="line">    @Value(&quot;#&#123;&#39;$&#123;server.name&#125;&#39;.split(&#39;,&#39;)&#125;&quot;)</span><br><span class="line">    private List&lt;String&gt; servers;</span><br><span class="line">    </span><br><span class="line">	&#x2F;&#x2F; SpEL: 注意不能反过来$&#123;&#125;在外面，#&#123;&#125;在里面，这个会执行失败</span><br><span class="line">    @Value(&quot;$&#123;#&#123;&#39;HelloWorld&#39;.concat(&#39;_&#39;)&#125;&#125;&quot;)</span><br><span class="line">    private List&lt;String&gt; servers2;    </span><br><span class="line">因为spring执行$&#123;&#125;是时机要早于#&#123;&#125;。在本例中，Spring会尝试从属性中查找#&#123;‘HelloWorld’.concat(‘_’)&#125;，那么肯定找不到，由上文已知如果找不到，然后报错。所以$&#123;&#125;在外面，#&#123;&#125;在里面是非法操作    </span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/12.1.spring/" data-id="ckw61sdx4006roswd9x1lf6sf" data-title="spring" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-8.6.VUE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/8.6.VUE/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:41:51.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/8.6.VUE/">VUE</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="VUE简介"><a href="#VUE简介" class="headerlink" title="VUE简介"></a>VUE简介</h1><p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。</p>
<p>Vue 只关注视图层， 采用自底向上增量开发的设计。</p>
<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<h1 id="VUE安装"><a href="#VUE安装" class="headerlink" title="VUE安装"></a>VUE安装</h1><h2 id="1-独立版本"><a href="#1-独立版本" class="headerlink" title="1.独立版本"></a>1.独立版本</h2><p>我们可以在 Vue.js 的官网上直接下载最新版本, 并用 <code>&lt;script&gt;</code> 标签引入。</p>
<h2 id="2-使用-CDN-方法"><a href="#2-使用-CDN-方法" class="headerlink" title="2.使用 CDN 方法"></a>2.使用 CDN 方法</h2><p>以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p>
<ul>
<li><strong>Staticfile CDN（国内）</strong> : <a target="_blank" rel="noopener" href="https://cdn.staticfile.org/vue/3.0.5/vue.global.js">https://cdn.staticfile.org/vue/3.0.5/vue.global.js</a></li>
<li><strong>unpkg</strong>：<a target="_blank" rel="noopener" href="https://unpkg.com/vue@next">https://unpkg.com/vue@next</a>, 会保持和 npm 发布的最新的版本一致。</li>
<li><strong>cdnjs</strong> : <a target="_blank" rel="noopener" href="https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.5/vue.global.js">https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.5/vue.global.js</a></li>
</ul>
<h2 id="3-NPM-方法"><a href="#3-NPM-方法" class="headerlink" title="3.NPM 方法"></a>3.NPM 方法</h2><p>因为需要使用 npm 安装 Vue CLI，而 npm 是集成在 Node.js 中的，所以第一步我们需要安装 Node.js。在官网下载安装完node.js后，查看node版本。同时npm也安装好了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br><span class="line">2.3.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将 npm 更新至最新版本</span></span><br><span class="line">npm -g install npm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装cnpm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级或安装 cnpm</span></span><br><span class="line">npm install cnpm -g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">升级 npm</span></span><br><span class="line">cnpm install npm -g</span><br></pre></td></tr></table></figure>

<p>在用 Vue.js 构建大型应用时推荐使用 cnpm 安装，cnpm 能很好地和 Webpack 或 Browserify 模块打包器配合使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 最新稳定版</span><br><span class="line">$ cnpm install vue@next</span><br></pre></td></tr></table></figure>

<p>命令行工具</p>
<p>Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">$ cnpm install -g @vue&#x2F;cli</span><br><span class="line">npm install -g vue-cli</span><br><span class="line"></span><br><span class="line"># 安装完后查看版本</span><br><span class="line">$ vue --version</span><br><span class="line">@vue&#x2F;cli 4.5.11</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>vue-cli 3.x 和 vue-cli 2.x 使用了相同的 vue 命令，如果你之前已经安装了 vue-cli 2.x，它会被替换为 Vue-cli 3.x。</p>
<p>安装 @vue/cli-int：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm i -g @vue&#x2F;cli-init</span><br></pre></td></tr></table></figure>





<p>node版本</p>
<p>npm版本</p>
<p>vue版本</p>
<p>vue-cli版本</p>
<p>前端版本会有不兼容问题</p>
<p>注意：Vue.js 不支持 IE8 及其以下 IE 版本。</p>
<h2 id="4-安装yarn"><a href="#4-安装yarn" class="headerlink" title="4.安装yarn"></a>4.安装yarn</h2><p>1.使用msi安装：</p>
<p>首先进入yarn的官网 <a target="_blank" rel="noopener" href="https://yarn.bootcss.com/docs/install/#windows-stable%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%89%E6%8B%A9%E7%A8%B3%E5%AE%9A%E7%89%88%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E3%80%82%E7%84%B6%E5%90%8E%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85%E5%8D%B3%E5%8F%AF">https://yarn.bootcss.com/docs/install/#windows-stable，然后选择稳定版进行下载。然后双击安装即可</a></p>
<p>2.通过npm命令进行安装：</p>
<p>执行命令<code>npm install yarn -g</code> （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到C:\Users\用户名\AppData\Roaming\npm路径中。</p>
<p>yarn和npm都是包管理工具，但是yarn是崭新的，经过重新设计的npm客户端，于2016年10月发布，相比于npm，yarn在运行速度上有显著的提升，安装时间变少，功能上也有很多改进</p>
<h1 id="创建VUE项目"><a href="#创建VUE项目" class="headerlink" title="创建VUE项目"></a>创建VUE项目</h1><h3 id="直接使用命令行构建项目"><a href="#直接使用命令行构建项目" class="headerlink" title="直接使用命令行构建项目"></a>直接使用命令行构建项目</h3><p>1.新建一个文件夹，自行选择位置。</p>
<p>2.文件夹里打开cmd，输入 <code>vue init webpack 项目名字</code>  （这里 webpack 是以 webpack 为模板指生成项目，还可以替换为 pwa、simple 等参数）</p>
<p>接下来会让你确认项目名字，描述，作者，build，是否安装vue-router（选是Y），是否安装es-lint（代码质量）</p>
<p>3.可以看到文件夹里生成了VUE项目</p>
<p>4.在项目里打开命令行，执行命令 <code>npm run dev</code></p>
<h3 id="使用webstorm"><a href="#使用webstorm" class="headerlink" title="使用webstorm"></a>使用webstorm</h3><p>按步骤新建项目。可以在控制台上输入命令。也可以在package.json 文件上点击右键，选择 show npm scripts，双击命令运行。也可以在右上角选择npm命令运行。</p>
<h1 id="VUE的文件"><a href="#VUE的文件" class="headerlink" title="VUE的文件"></a>VUE的文件</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">vue-cource // 项目名称</span><br><span class="line">    |__ node_modules // 项目中的node依赖包</span><br><span class="line">    |__ public // public文件夹放公共文件</span><br><span class="line">    |    |__ favicon.ico // 标签栏的小图标</span><br><span class="line">    |    |__ index.html // 模板文件，最后打包后的index.html模板就是这个文件</span><br><span class="line">    |    </span><br><span class="line">    |__ src // 项目主文件</span><br><span class="line">    |    |__ api // api文件夹，项目的接口js文件都可以写在这里</span><br><span class="line">    |    |__ assets // 静态资源（图片、字体图标文件）</span><br><span class="line">    |    |    |__ img // 图片文件夹</span><br><span class="line">    |    |    |__ font // 字体图标文件夹</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ components // 组件</span><br><span class="line">    |    |__ config // 项目的配置（全局变量js文件）</span><br><span class="line">    |    |    |__ index.js     </span><br><span class="line">    |    |</span><br><span class="line">    |    |__ directive // vue的自定义指令文件夹</span><br><span class="line">    |    |    |__ index.js     </span><br><span class="line">    |    |</span><br><span class="line">    |    |__ lib // 全局方法放在这里</span><br><span class="line">    |    |    |__ util.js // 与业务结合的工具方法</span><br><span class="line">    |    |    |__ tools.js // 与业务无关的工具方法(例如日期转换时间戳方法)</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ mock // 模拟数据文件夹</span><br><span class="line">    |    |    |__ index.js</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ router // 路由文件夹</span><br><span class="line">    |    |    |__ index.js // 路由配置文件</span><br><span class="line">    |    |    |__ router.js // 拆分出来的routes数组</span><br><span class="line">    |    |__ store // Vuex配置文件夹</span><br><span class="line">    |    |    |__ module          // 模块文件夹</span><br><span class="line">    |    |    |__ plugin          // Vuex插件文件夹</span><br><span class="line">    |    |    |__ actions.js      // 异步调用接口方法都写在这里</span><br><span class="line">    |    |    |__ getters.js      // Vuex的计算属性都写在这里</span><br><span class="line">    |    |    |__ index.js        // Vuex主要配置管理文件</span><br><span class="line">    |    |    |__ mutations.js    // Vuex中的修改state的方法，都写在这里</span><br><span class="line">    |    |    |__ state.js        // Vuex的变量文件夹</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ views // 页面都写在这个文件夹中</span><br><span class="line">    |    |__ App.vue // 基础组件。项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。</span><br><span class="line">    |    |__ main.js // 项目入口文件（项目引入全局插件都在这里引入）项目的核心文件</span><br><span class="line">    |    </span><br><span class="line">    |__ .browserslistrc // 浏览器兼容</span><br><span class="line">    |__ .editorconfig // 编译器配置文件</span><br><span class="line">    |__ .eslintrc.js // 配置ESlint规则文件</span><br><span class="line">    |__ .gitignore // git提交的忽略文件</span><br><span class="line">    |__ babel.config.js // babel的配置文件，babel可以将es6、es7等等装换成es5兼容的代码</span><br><span class="line">    |__ package-lock.json // 锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致</span><br><span class="line">    |__ package.json // 项目名称、项目版本、项目描述、项目运行的一些脚本（依赖）</span><br><span class="line">    |__ postcss.config.js // css自动补充一些兼容性代码的配置（-webkit-、-moz-、-ms-之类的）</span><br><span class="line">    |__ README.en.md // 英文版项目说明</span><br><span class="line">    |__ README.md // 中文版项目说明</span><br><span class="line">    |__ vue.config.js // 配置文件</span><br></pre></td></tr></table></figure>

<h3 id="public-index-html"><a href="#public-index-html" class="headerlink" title="public/index.html"></a>public/index.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就是一个普普通通的 html 文件，让它不平凡的是 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> ，下面有一行注释，构建的文件将会被自动注入，也就是说我们编写的其它的内容都将在这个 div 中展示。</p>
<p>还有不普通的一点是，整个项目只有这一个 html 文件，所以这是一个 单页面应用，当我们打开这个应用，表面上可以有很多页面，实际上它们都只不过在一个 div 中。</p>
<h3 id="src-App-vue"><a href="#src-App-vue" class="headerlink" title="src/App.vue"></a>src/App.vue</h3><p>这个文件称为“根组件”，因为其它的组件又都包含在这个组件中</p>
<p>vue 文件是一种自定义文件类型，在结构上类似 html，一个 .vue 文件即是一个 vue 组件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-wechat-title</span>=<span class="string">&quot;$route.meta.title&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">		-webkit-<span class="attribute">font</span>-smoothing: antialiased;</span></span><br><span class="line"><span class="css">		<span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">font-family</span>: <span class="string">&#x27;PingFang SC&#x27;</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	#app &#123;</span><br><span class="line"><span class="css">		<span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>&lt;div id=&quot;app&quot;&gt;</code>,<code>id=app</code> 只是跟下面的 css 对应.</p>
<script>标签里的内容即该组件的脚本，也就是 js 代码，export default 是 ES6 的语法，意思是将这个组件整体导出，之后就可以使用 import 导入组件了。大括号里的内容是这个组件的相关属性

`<router-view/>`，是一个容器，名字叫“路由视图”，意思是当前路由（ URL）指向的内容将显示在这个容器中。也就是说，其它的组件即使拥有自己的路由（URL，需要在 router 文件夹的 index.js 文件里定义），也只不过表面上是一个单独的页面，实际上只是在根组件 App.vue 中。

### src/main.js

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置反向代理，前端请求默认发送到 http:&#x2F;&#x2F;localhost:8443&#x2F;api</span><br><span class="line">var axios &#x3D; require(&#39;axios&#39;)</span><br><span class="line">axios.defaults.baseURL &#x3D; &#39;http:&#x2F;&#x2F;localhost:8443&#x2F;api&#39;</span><br><span class="line">&#x2F;&#x2F; 全局注册，之后可在其他组件中通过 this.$axios 发送数据</span><br><span class="line">Vue.prototype.$axios &#x3D; axios</span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

没有分号（;），因为是 ES6 的语法，不这么写反而会提示错误，也可以把 es-lint 改了或者关了

最上面 import 了几个模块，其中 vue 模块在 node_modules 中，App 即 App.vue 里定义的组件，router 即 router 文件夹里定义的路由。

Vue.config.productionTip = false ,作用是阻止vue 在启动时生成生产提示。如果没有这行代码，或者设置为true，控制台就会多出这么一段代码：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You are running Vue in development mode.</span><br><span class="line">Make sure to turn on production mode when deploying for production.</span><br></pre></td></tr></table></figure>

在这个 js 文件中，我们创建了一个 Vue 对象（实例），el 属性提供一个在页面上已存在的 DOM 元素作为 Vue 对象的挂载目标，router 代表该对象包含 Vue Router，并使用项目中定义的路由。components 表示该对象包含的 Vue 组件，template 是用一个字符串模板作为 Vue 实例的标识使用，类似于定义一个 html 标签。



### **src/config/index.js**

**当前项目的配置**

**config/index.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面使用 **ES6** 的 **模块** 导出一个对象，如果有 **全局变量** 都可以写在这里，在需要用到的地方直接这么写：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  config  from  &#39;@&#x2F;config&#39;  &#x2F;&#x2F; nodejs就会自动找到他下面的index.js文件</span><br></pre></td></tr></table></figure>

或者这样也可以找到这个 **index** 文件，

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  config  from  &#39;@&#x2F;config&#x2F;index&#39; </span><br></pre></td></tr></table></figure>



### src/router

分为**正常路由结构** 和 **封装好的路由结构**

**正常路由**：创建项目初始化路由 会在 src文件夹 下生成一个 router.js 文件。

**router.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import  Home  from  &#39;.&#x2F;views&#x2F;Home&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;,</span><br><span class="line">    name: &#39;home&#39;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;about&#39;,</span><br><span class="line">    name: &#39;about&#39;,</span><br><span class="line">    &#x2F;&#x2F; route level code-splitting</span><br><span class="line">    &#x2F;&#x2F; this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    &#x2F;&#x2F; which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;.&#x2F;views&#x2F;About.vue&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

这种只是 **简单的路由（搭建项目初始化自动生成的路由文件）** ，如果以后 **复杂** 起来会**难以维护**。

**封装路由**

1. 在 **src目录** 下创建一个 **router文件夹** ，这里的思想是把 **routes数组** 拆分成一个 **单独的js文件**，这样看着简洁也**方便维护**。

![img](https://img.kancloud.cn/76/ee/76ee106ff5e570f4235eba358b6cbb6c_348x87.png)

1. **router文件夹**

**index.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import routes from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes &#x2F;&#x2F; 这里使用ES6的简写写法，正常应该是这样写&#39;routes : routes &#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**router.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import  Home  from  &#39;@&#x2F;views&#x2F;Home&#39;</span><br><span class="line"></span><br><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;,</span><br><span class="line">    name: &#39;home&#39;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;about&#39;,</span><br><span class="line">    name: &#39;about&#39;,</span><br><span class="line">    &#x2F;&#x2F; route level code-splitting</span><br><span class="line">    &#x2F;&#x2F; this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    &#x2F;&#x2F; which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;@&#x2F;views&#x2F;About.vue&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

### src/store

分为**正常vuex结构** 和 **封装好的vuex结构**

**正常vuex**

**创建项目** 初始化路由会在 **src文件夹** 下生成一个 **store.js** 文件。

**store.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

这种结构 **看似简单** ，后期项目 **维护麻烦** 。

**封装vuex**

**封装后** 的结构，在 **src目录** 下创建一个 **store文件夹**

![img](https://img.kancloud.cn/cd/c3/cdc31f614c6e19e0bbb0d9f705b05276_351x185.png)

module文件夹

首先讲一下为什么会有 **module文件夹** ，因为项目如果有 **好多vuex的状态** ，如果都写在 **sore.js** 中，看起来会 **杂乱无章** ，都不知道哪个 **vuex** 的 **状态** 是哪个 **模块** 中使用的，所以有了 **module文件夹** ，例如我有一个 **user模块** 我只需要在 **module文件夹** 中创建一个 **user.js**

**user.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">const mutations &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">const actions &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

使用时只需要在 **store文件夹** 下的 **index.js** 中这样 **引入** 即可：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import state from &#39;.&#x2F;state&#39; &#x2F;&#x2F; state.js文件可以不写.js结尾，这样写也会自动找到state.js文件</span><br><span class="line">import mutations from &#39;.&#x2F;mutations&#39;</span><br><span class="line">import actions from &#39;.&#x2F;actions&#39;</span><br><span class="line">import user from &#39;.&#x2F;module&#x2F;user&#39; &#x2F;&#x2F; 引入模块文件</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state,  &#x2F;&#x2F; ES6对象简写的形式，state: state 等同与 state</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  modules: &#123; &#x2F;&#x2F; 模块引用</span><br><span class="line">    user</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**plugin文件夹**

**plugin文件夹** 是存放 **Vuex插件** 的文件夹，假如我们这里有个持久化插件

**plugin/saveiInLocal.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 持久化储存插件：这个函数会在每次store实例初始化时调用。刷新浏览器后第一次要做的操作可以定义在这里</span><br><span class="line"> * @param store </span><br><span class="line"> *&#x2F;</span><br><span class="line">export default store &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果本地存储了state，就把这个stateJSON字符串转换成对象，替换到当前store实例的state</span><br><span class="line">    if(localStorage.state) store.replaceState(JSON.parse(localStorage.state))</span><br><span class="line">    store.subscribe((mutation, state) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 提交commit提交mutation之后执行这里，把state转换成JSON字符串储存到localStorage的state中</span><br><span class="line">        localStorage.state &#x3D; JSON.stringify(state)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**actions.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">export default actions</span><br></pre></td></tr></table></figure>

**index.js**

**index.js** 属于 **根级别的Vuex** 可以用来管理 **根级别** 的 **actions** 、 **state** 、 **mutations** 、 **getters** ，同样可以管理 **模块（module）** 中的 **actions** 、 **state** 、 **mutations**、 **getter**。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import state from &#39;.&#x2F;state&#39; &#x2F;&#x2F; state.js文件可以不写.js结尾，这样写也会自动找到state.js文件</span><br><span class="line">import getters from &#39;.&#x2F;getters&#39;</span><br><span class="line">import mutations from &#39;.&#x2F;mutations&#39;</span><br><span class="line">import actions from &#39;.&#x2F;actions&#39;</span><br><span class="line">import user from &#39;.&#x2F;module&#x2F;user&#39; &#x2F;&#x2F; 引入模块文件</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state,  &#x2F;&#x2F; ES6对象简写的形式，state: state 等同与 state</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  modules: &#123; &#x2F;&#x2F; 模块引用</span><br><span class="line">    user</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**mutations.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const mutations &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br><span class="line">export default mutations</span><br></pre></td></tr></table></figure>

**state.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 状态写这里</span><br><span class="line">&#125;</span><br><span class="line">export default state</span><br></pre></td></tr></table></figure>

**getters.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const getters &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default getters</span><br></pre></td></tr></table></figure>



### package.json

**package.json** 文件主要是 **项目名称** 、 **项目版本** 、 **项目描述** 、 **项目运行的一些脚本（依赖）**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;vue-cource&quot;, &#x2F;&#x2F; 项目名称</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;, &#x2F;&#x2F; 项目版本</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &#x2F;&#x2F; 运行指令 默认是development</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;, &#x2F;&#x2F; 打包指令 默认是production</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123; &#x2F;&#x2F; 项目打包后用到的依赖（运行依赖）</span><br><span class="line">    &quot;core-js&quot;: &quot;^2.6.5&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^2.6.10&quot;,</span><br><span class="line">    &quot;vue-router&quot;: &quot;^3.0.3&quot;,</span><br><span class="line">    &quot;vuex&quot;: &quot;^3.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123; &#x2F;&#x2F; 开发阶段用到的依赖（开发依赖）</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-babel&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-eslint&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-service&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;eslint-config-standard&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;babel-eslint&quot;: &quot;^10.0.1&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;^5.16.0&quot;,</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;node-sass&quot;: &quot;^4.9.0&quot;,</span><br><span class="line">    &quot;sass-loader&quot;: &quot;^7.1.0&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





### vue.config.js

**vue.config.js** 是 **vue** 的 **配置文件**

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 引入nodejs的path模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir) <span class="comment">// resolve方法用来加载路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_URL = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/iview-admin/&#x27;</span> : <span class="string">&#x27;/&#x27;</span> </span><br><span class="line"><span class="comment">// 判断当前为开发环境还是打包环境, &#x27;/&#x27;意思是代表指定在域名的根目录下，如果要指定到iview-admin下就这样写&#x27;/iview-admin/&#x27;, production为生产坏境，development为开发环境</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,                          <span class="comment">// 取消每次保存时都进行一次&#x27; ESLint &#x27;检测</span></span><br><span class="line">  publicPath: BASE_URL,                       <span class="comment">// 项目的基本路径,vuecli2.0时打包经常静态文件找不到，就是需要配置这个属性为&#x27;./&#x27;</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;                   <span class="comment">// 配置Webpack</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">    .set(<span class="string">&#x27;@&#x27;</span>, resolve(<span class="string">&#x27;src&#x27;</span>))                 <span class="comment">// 引入文件时候“ @ ”符号就代表src</span></span><br><span class="line">    .set(<span class="string">&#x27;_c&#x27;</span>, resolve(<span class="string">&#x27;src/components&#x27;</span>))     <span class="comment">// 引入组件文件夹中的文件就可以用“ _c ”代替src/components</span></span><br><span class="line">  &#125;,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,                 <span class="comment">// 打包时不生成.map文件，会减少打包体积，同时加快打包速度</span></span><br><span class="line">  devServer: &#123;                                <span class="comment">// 跨域有2种解决方案： 1. 在后端的header中配置， 2. 使用devServer来配置代理解决跨域</span></span><br><span class="line">    proxy: &#123;<span class="comment">// 这里写需要代理的URL,这里会告诉开发服务器，将任何未知请求匹配不到静态文件的请求，都代理到这个URL来满足跨域</span></span><br><span class="line">			<span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//api是为了把前端路由和后端路由区分开，没前缀的是前端路由，有前缀的是后端路由</span></span><br><span class="line">				target:process.env.VUE_APP_API_URL, <span class="comment">//这里后台的地址模拟的;应该填写你们真实的后台接口</span></span><br><span class="line">				changOrigin: <span class="literal">true</span>, <span class="comment">//允许跨域</span></span><br><span class="line">				pathRewrite: &#123;</span><br><span class="line">					<span class="comment">// &#x27;^/api&#x27;: &#x27;/api&#x27;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





# ESLint

ESLint是个管理代码风格的工具 统一代码风格 在多人协作的项目都会用到



# VUEX

当我们的应用遇到多个组件共享状态时，会需要多个组件依赖于同一状态抑或是来自不同视图的行为需要变更同一状态。以前的解决办法：

**a.将数据以及操作数据的行为都定义在父组件;**

**b.将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)**

传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。在搭建下面页面时，你可能会对 vue 组件之间的通信感到崩溃 ，特别是非父子组件之间通信。此时就应该使用vuex，轻松可以搞定组件间通信问题。

![组件间通信](https://user-gold-cdn.xitu.io/2018/5/23/1638b38a08088b12?w=1194&h=486&f=png&s=133255)

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。这里的关键在于集中式存储管理。**简单来说,对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)**。

原理

![img](8.6.VUE/1656f2b9277ece19)

Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。

#### 2.简要介绍各模块在流程中的主要功能：

- Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。
- dispatch：操作行为触发方法，是唯一能执行action的方法。
- actions：**操作行为处理模块,由组件中的`$store.dispatch('action 名称', data1)`来触发。然后由commit()来触发mutation的调用 , 间接更新 state**。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。
- commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。
- mutations：**状态改变操作方法，由actions中的`commit('mutation 名称')`来触发**。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。
- state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。
- getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。



如果您的应用够简单，您最好不要使用 Vuex,因为使用 Vuex 可能是繁琐冗余的。一个简单的 [global event bus](https://cn.vuejs.org/v2/guide/components.html#非父子组件通信) 就足够您所需了。但是，**如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。**






每一个 **Vuex** 应用的核心就是 **store（仓库）** 。**store** 基本上就是一个 **容器** ，它包含着你的 **应用中大部分的状态 (state)** 。**Vuex** 和 **单纯的全局对象** 有以下 **两点不同**：

1. **Vuex** 的 **状态** 存储是 **响应式** 的。当 **Vue 组件** 从 **store** 中 **读取状态** 的时候，若 **store** 中的**状态发生变化** ，那么 **相应的组件也会得到更新** 。
2. 你 **不能直接改变 store 中的状态**。改变 **store** 中的 **状态** 的 **唯一途径就是通过mutation** 。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

## Bus

**Vuex** 适合 **大型复杂项目** 中使用，进行 **状态管理**，我们的项目如果不是很复杂可以使用 **Bus** 来满足需求。

## state 与 getter

![img](https://img.kancloud.cn/b3/f9/b3f994c71d894b582bae15b4a1df8ebb_701x551.png)

上图就是 **Vuex** 状态管理的 **流程** ，在 **Vue Components（组件）** 里可以触发一个 **Actions（Actions里可以做异步接口请求）** ， **请求完成** 后触发一个 **Mutations** ，通过 **Mutations** 修改 **State** 的状态值，**State** 修改之后会触发 **vue组件视图的渲染** 。

**getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工**。getters就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。



## mutation 与 action / module

![img](https://img.kancloud.cn/b3/f9/b3f994c71d894b582bae15b4a1df8ebb_701x551.png)

上图是 **Vuex** 状态管理的 **流程**，描述了从 **Vue Components（组件）** 执行 **异步操作** 的一个 **环形流程** ，实际上如果 **没有异步操作的需求** 就不用走 **Actions** 的这个步骤， **2种操作（同步、异步操作）** 的流程如下：

1. **异步操作**： **Vue Components（组件）** > **Actions（请求接口操作写这里）** > **Mutations（接口成功返回值后在这里修改State的值）** > **State状态更新** > **Vue Components（组件）视图更新**
2. **同步操作** ： **Vue Components（组件）** > **Mutations（修改State的值）** > **State状态更新** > **Vue Components（组件）视图更新**



actions和上面的Mutations功能基本一样，不同点是，**actions是异步的改变state状态，而Mutations是同步改变状态**。

同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态----尤雨溪







# AJAX

**Ajax** 用来 **请求后端接口** 并且 **取得返回数据** ， 在 **Vue** 中 使用的是 **Vue** 官方推荐的 **axios** 库来作为 **异步接口请求** 的工具

**跨域** 是受到 **浏览器** 的 **同源策略** 的影响，在一些情况下是 **不允许通信的** 。

在下面表格中列出了 **跨域** 的案例：

| URL                                                         | 说明                           | 是否允许通信                            |
| :---------------------------------------------------------- | :----------------------------- | :-------------------------------------- |
| http://www.d.com/d.js <br />http://www.d.com/w.js           | 同一域名下                     | 允许                                    |
| http://www.d.com/lab/a.js <br />http://www.d.com/src/b.js   | 同一域名下不同文件夹           | 允许                                    |
| http://www.d.com:3333/a.js <br />http://www.d.com:4444/b.js | 同一域名不同端口               | 不允许                                  |
| http://www.d.com/a.js <br />http://46.33.22.44/b.js         | **域名和域名对应 IP**          | 不允许                                  |
| http://www.d.com/a.js <br />http://scipt.d.com/b.js         | 主域相同，子域不同             | 不允许                                  |
| http://www.d.com/a.js <br />http://d.com/b.js               | 同一域名，不同二级域名（同上） | 不允许（cookie 这种情况下也不允许访问） |
| http://www.d.com/a.js <br />http://www.v.com/b.js           | 不同域名                       | 不允许                                  |

### 前端解决跨域

**前端** 需要在 **vue.config.js** 文件中通过 **devServer** 中的 **proxy** 来 **配置代理** 。

**原理** ：我们在 **本地开发** 的时候，通过 **vueServe** 起一个 **本地的开发服务** ，这个 **服务的地址** 一般是 **localhost** ， **端口** 一般是 **8080** ，如果我们在 **本地起一个 node 服务** ，那么它的 **端口** 肯定是跟我们的 **前端服务的端口** 是不一样的，刚才在 上面表格中讲过 **同一域名不同端口** 也是 **存在跨域问题** ，是 **不在同一个域下** ，这个时候 **调用接口** 的话，受到 **同源策略** 影响，是 **无法调取成功** 的，我们可以用 **proxy** 来 **设置代理** ， **它会把我们所有的接口，代理到目标URL下** ，比如接口是 **/api/getUserInfo** ，我们 **设置代理** 是 **[http://localhost:4000](http://localhost:4000/)** ，这样的话请求的接口就会被代理到 **[http://localhost:4000](http://localhost:4000/)** 下，代理后请求接口时的**URL** ： **http://localhost:4000/#/api/getUserInfo** ， 例子如下：

**vue.config.js**

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 引入nodejs的path模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir) <span class="comment">// resolve方法用来加载路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_URL = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/iview-admin/&#x27;</span> : <span class="string">&#x27;/&#x27;</span> <span class="comment">// 判断当前为开发环境还是打包环境, &#x27;/&#x27;意思是代表指定在域名的根目录下，如果要指定到iview-admin下就这样写&#x27;/iview-admin/&#x27;, production为生产坏境，development为开发环境</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,                          <span class="comment">// 取消每次保存时都进行一次&#x27; ESLint &#x27;检测</span></span><br><span class="line">  publicPath: BASE_URL,                       <span class="comment">// 项目的基本路径,vuecli2.0时打包经常静态文件找不到，就是需要配置这个属性为&#x27;./&#x27;</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;                   <span class="comment">// 配置Webpack</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">    .set(<span class="string">&#x27;@&#x27;</span>, resolve(<span class="string">&#x27;src&#x27;</span>))                 <span class="comment">// 引入文件时候“ @ ”符号就代表src</span></span><br><span class="line">    .set(<span class="string">&#x27;_c&#x27;</span>, resolve(<span class="string">&#x27;src/components&#x27;</span>))     <span class="comment">// 引入组件文件夹中的文件就可以用“ _c ”代替src/components</span></span><br><span class="line">  &#125;,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,                 <span class="comment">// 打包时不生成.map文件，会减少打包体积，同时加快打包速度</span></span><br><span class="line">  devServer: &#123;                                <span class="comment">// 跨域有2种解决方案： 1. 在后端的header中配置， 2. 使用devServer来配置代理解决跨域</span></span><br><span class="line">    proxy: <span class="string">&#x27;http://localhost:4000&#x27;</span>            <span class="comment">// 这里写需要代理的URL,这里会告诉开发服务器，将任何未知请求匹配不到静态文件的请求，都代理到这个URL来满足跨域</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

这里的代理的 **URL地址** 以及 **端口号** 一定要与服务端 **一致** 。

### 注意

1. **前端配置代理** 只是在 **开发环境（develop）** 好用，便于开发，在 **生产环境（prod）** 还是 **需要由服务端解决跨域** 。

2. 这里需要注意，如果在 **前端配置代理** ，需要在 **src/config/index.js（接下来的axios封装中用到了这个文件）** 中添加一个 **逻辑判断** 如下：

   **src/config/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果当前是生产环境用生产环境地址，如果是开发环境并且在vue.config.js中配置了代理，就用空字符串【&#39;&#39;】，如果未配置代理就用开发环境地址</span><br><span class="line">export const baseURL&#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;http:&#x2F;&#x2F;production.com&#39; : &#39;http:&#x2F;&#x2F;develop.com&#39;</span><br></pre></td></tr></table></figure>

### 后端解决跨域

如果不在 **设置代理** ，可以在 **后端设置header** 来 **解决跨域问题** ，这里 **后端** 用的是 **nodejs** ，在**express（nodejs的框架）** 里使用 **app.all** 为 **所有请求** 都添加这 **3 个 header** 即可。

**app.js**

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createError = <span class="built_in">require</span>(<span class="string">&#x27;http-errors&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;colors&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;morgan&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indexRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> usersRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/users&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// view engine setup</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="string">&#x27;views&#x27;</span>))</span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;jade&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(logger(<span class="string">&#x27;dev&#x27;</span>))</span><br><span class="line">app.use(express.json())</span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.use(cookieParser())</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123; <span class="comment">// 设置header</span></span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;X-Requested-With,Content-Type&#x27;</span>)</span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="string">&#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;</span>)</span><br><span class="line">	next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, indexRouter)</span><br><span class="line">app.use(<span class="string">&#x27;/users&#x27;</span>, usersRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// catch 404 and forward to error handler</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">	next(createError(<span class="number">404</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error handler</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// set locals, only providing error in development</span></span><br><span class="line">	res.locals.message = err.message</span><br><span class="line">	res.locals.error = req.app.get(<span class="string">&#x27;env&#x27;</span>) === <span class="string">&#x27;development&#x27;</span> ? err : &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// render the error page</span></span><br><span class="line">	res.status(err.status || <span class="number">500</span>)</span><br><span class="line">	res.render(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br></pre></td></tr></table></figure>

## 封装axios

1. 首先在 **src文件夹** 下的 **lib文件夹** 中创建 **axios.js**

   **src/lib/axios.js**

   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; baseURL &#125; <span class="keyword">from</span> <span class="string">&#x27;@/config&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/lib/util&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">baseUrl = baseURL</span>)</span>&#123; <span class="comment">// baseUrl = baseURL 是ES6的默认值写法等同于 baseUrl = baseUrl || baseURL</span></span><br><span class="line">        <span class="built_in">this</span>.baseUrl = baseUrl <span class="comment">// this指向创建的实例，当你使用new HttpRequest创建实例时候，它会把this中定义的变量返回给你</span></span><br><span class="line">        <span class="built_in">this</span>.queue = &#123;&#125; <span class="comment">// 创建队列，每次请求都会向里面添加一个key:value，请求成功后就会去掉这个key:value，直到this.queue中没有属性值时，loading关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认options配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">getInsideConfig</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> config = &#123;</span><br><span class="line">            baseURL: <span class="built_in">this</span>.baseUrl,</span><br><span class="line">            headers: &#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;</span><br><span class="line">    distroy (url) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.queue[url]</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.queue).length) &#123;</span><br><span class="line">          <span class="comment">// Spin.hide()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">instance</span></span> - 通过axios创建的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">url</span></span> - 接口地址</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="function"><span class="title">interceptors</span>(<span class="params">instance, url</span>)</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求拦截器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">config</span></span> - 请求前的控制</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">error</span></span> - 出现错误的时候会提供一个错误信息</span></span><br><span class="line"><span class="comment">         */</span>    </span><br><span class="line">        instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 添加全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.queue).length)&#123;</span><br><span class="line">                <span class="comment">// Spin.show()</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">this</span>.queue[url] = <span class="literal">true</span></span><br><span class="line">            config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = getToken()</span><br><span class="line">            <span class="keyword">return</span> config</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 响应拦截器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">res</span></span> - 服务端返回的东西</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">error</span></span> - 出现错误的时候会提供一个错误信息</span></span><br><span class="line"><span class="comment">         */</span>            </span><br><span class="line">        instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.distroy(url) <span class="comment">// 关闭全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">const</span> &#123; data &#125; = res</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.distroy(url) <span class="comment">// 关闭全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error.response.data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">request</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create()</span><br><span class="line">        options = <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.getInsideConfig(), options) <span class="comment">//  Object.assign会将2个对象合并成1个对象，相同属性值会被后者覆盖</span></span><br><span class="line">        <span class="built_in">this</span>.interceptors(instance, options.url) <span class="comment">// 拦截器</span></span><br><span class="line">        <span class="keyword">return</span> instance(options)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HttpRequest</span><br></pre></td></tr></table></figure>

   **constructor方法** 是 **每一个类必须有的方法** ，如果我们不定义这个 **constructor方法** ， **class类** 会默认添加一个 **空的constructor方法（例如：constructor(){}）** ，在 **constructor方法** 中可以 **接收传入的参数** ， 在我们 **创建实例 new HttpRequest('参数')** 时候可以 **在括号内传入参数** ， 然后我们可以在 **constructor方法** 中 **对参数做一些操作** 。

2. 上面把 **baseUrl** 抽离到了 **config文件夹** 里的 **index.js 全局变量** 中

   **src/config/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果当前是生产环境用生产环境地址，如果是开发环境并且在vue.config.js中配置了代理，就用空字符串【&#39;&#39;】，如果未配置代理就用开发环境地址</span><br><span class="line">export const baseURL&#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;http:&#x2F;&#x2F;production.com&#39; : &#39;http:&#x2F;&#x2F;develop.com&#39;</span><br></pre></td></tr></table></figure>

### 使用方法

1. 在 **api文件夹** 中创建 **index.js**

   **src/api/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import HttpRequest from &#39;@&#x2F;lib&#x2F;axios&#39;</span><br><span class="line">const axios &#x3D; new HttpRequest()</span><br><span class="line">export default axios</span><br></pre></td></tr></table></figure>

   在使用时候：我们创建一个储存用户接口的 **uesr.js** 文件

   **src/api/user.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;.&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取用户信息接口</span><br><span class="line">export const getUserInfo &#x3D; (&#123; userId &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return axios.request(&#123;</span><br><span class="line">        url: &#39;&#x2F;getUserInfo&#39;,</span><br><span class="line">        method: &#39;post&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            userId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   然后在 **Home.vue** 页面组件中这样 **调用接口**

   **Home.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;getInfo&quot;&gt;请求数据&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; getUserInfo &#125; from &#39;@&#x2F;api&#x2F;user&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getInfo()&#123;</span><br><span class="line">      getUserInfo(&#123; userId: 21 &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">      &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



ajax.js`中配置了axios.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";`

在jquery的ajax中，如果没加contentType:"application/json"，那么data就应该对应的是json对象，反之，如果加了contentType:"application/json"，那么ajax发送的就必须是字符串

contentType参数指定的是浏览器将发送什么样类型的编码

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">text&#x2F;html ： HTML格式</span><br><span class="line"></span><br><span class="line">    text&#x2F;plain ：纯文本格式      </span><br><span class="line"></span><br><span class="line">    text&#x2F;xml ：  XML格式</span><br><span class="line"></span><br><span class="line">    mage&#x2F;gif ：gif图片</span><br><span class="line"></span><br><span class="line">    image&#x2F;jpeg ：jpg图片格式 </span><br><span class="line"></span><br><span class="line">    image&#x2F;png：png图片格式</span><br><span class="line"></span><br><span class="line">    application&#x2F;json  ：json数据格式</span><br><span class="line"></span><br><span class="line">    application&#x2F;pdf   ：pdf格式  </span><br><span class="line"></span><br><span class="line">    application&#x2F;octet-stream ： 二进制流数据</span><br></pre></td></tr></table></figure>

不指定contentType则代表为默认的application/x-www-form-urlencoded（表单）类型，这种类型有一个好处，它可以支持很多种情况，并能配合查询字符串（key1=value1&key2=vlaue2）的形式发送到服务器。而且这种默认类型可以很好地配合参数processData（默认为true，可以不用管他），该参数为true的时候，开启自动转化功能，**只要是一个合法对象**，都能将该对象**自动地转化成查询字符串**的形式

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data: &#123; &quot;username&quot; : &quot;ccc&quot; &#125; ,  &#x2F;&#x2F;查询字符串的映射形式（即对象），在默认模式下提交时会自动地转化成查询字符串</span><br><span class="line"> data: &quot;username&#x3D;ccc&quot;,   &#x2F;&#x2F;查询字符串形式</span><br></pre></td></tr></table></figure>

指定了contentType : "application/json"后，data就只能是字符串而且必须是json字符串了，首先你指定json格式，那提交格式肯定与json有关，再一个，因为你指定了"application/json"就意味着你放弃了"application/x-www-form-urlencoded"这种默认模式，默认模式虽可以自动地转化对象，不见得"application/json"这种格式就会自动帮你转，而事实证明，它确实不会帮你自动转

@RequestBody这个注解就是专门用来处理**非默认模式**下的请求的。该注解会提取你传过来的**json字符串**(注意是**json字符串**,不是查询字符串)，并将提取到的信息绑定到对象中

有些  关键的属性在Mvc层中反射失败，会导致其他所有属性都为null：比如joindate对应的pojo是Date，本来input框里的值是 Thu Dec 30 00:00:00 CST 1999 ，传到后台用Date接收，但是显然格式不对，于是Date合成出了错，然后坑爹的就来了，因为这个特殊的属性反射失败，Mvc层就将请求打回去然后导致浏览器报错400 bad request ，从而导致其他所有属性都为null。最后把joindate属性注释掉，后台什么属性的值都收到了

总结：在"application/json"的时候，ajax请求对跨域支持似乎不好，默认模式下的ajax成功跨域请求一旦改成了"application/json"就会报跨域请求的错，需要用@RequestBody在请求的参数中才能正常。

在非特殊情况下会有些更倾向application/x-www-form-urlencoded了，**跨域问题**既没有application/json那么多，安全问题也不像application/json那样会有一定概率被一些植入**恶意的回调代码**，而且能**很方便的传输和接受**复杂而又多重嵌套的对象

要调用别人的接口，那么就很可能要指定application/json格式，因为接口提供方就是这么规定的，json的数据格式**传输时带宽会更小**，尤其是在传输数组时，如果数组元素很多，那么application/json传输的数据量就会比application/x-www-form-urlencoded**要少很多**，同时，json的解析速度也会更快



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">在请求或响应被 then 或 <span class="keyword">catch</span> 处理前拦截它们。</span><br><span class="line"><span class="comment">// axios 配置</span></span><br><span class="line">axios.defaults.timeout = <span class="number">10000</span>; <span class="comment">// 设置请求超时为10秒</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;/api&#x27;</span>; <span class="comment">// 默认请求地址前都加/api</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;</span>; <span class="comment">// 请求头的设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置跨域携带用户凭证</span></span><br><span class="line"><span class="comment">//axios.defaults.withCredentials = true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    (config) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">        Toast.loading(&#123;</span><br><span class="line">            message: <span class="string">&quot;加载中...&quot;</span>,</span><br><span class="line">            loadingType: <span class="string">&quot;spinner&quot;</span>,</span><br><span class="line">            forbidClick: <span class="literal">true</span>,</span><br><span class="line">            duration: <span class="number">0</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> openid = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">        config.headers[<span class="string">&quot;openid&quot;</span>] = openid;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">        Toast.clear();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;请求出错&quot;</span> + error)</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;http://elinktech.cn/#/error&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">        Toast.clear(); <span class="comment">//在网络不好时清除加载中</span></span><br><span class="line">        <span class="keyword">const</span> responseCode = res.status;</span><br><span class="line">        <span class="comment">// 拦截器配置</span></span><br><span class="line">        <span class="keyword">if</span> (responseCode === <span class="number">200</span>) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (res.data.code === -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;返回出错了&quot;</span> + res)</span><br><span class="line">                <span class="built_in">window</span>.location.href = <span class="string">&#x27;http://elinktech.cn/#/error&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">                ok: <span class="literal">true</span>,</span><br><span class="line">                data: res.data,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.fail(&#123;</span><br><span class="line">                message: <span class="string">&quot;服务器开小差了，请稍后重试&quot;</span>,</span><br><span class="line">                duration: <span class="number">3000</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">        Toast.clear();</span><br><span class="line">        <span class="keyword">if</span> (error.response?.data?.code === <span class="number">401</span>) &#123;</span><br><span class="line">            <span class="comment">//  localStorage.removeItem(&quot;token&quot;);</span></span><br><span class="line">            <span class="comment">// localStorage.removeItem(&quot;userId&quot;);</span></span><br><span class="line">            <span class="comment">// window.location.reload();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求失败</span></span><br><span class="line">        Toast.fail(&#123;</span><br><span class="line">            message: <span class="string">&quot;请求超时！&quot;</span>,</span><br><span class="line">            duration: <span class="number">3000</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;返回出错&quot;</span> + error)</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;http://elinktech.cn/#/error&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



# 渲染函数（render函数）

在 **Vue** 中使用 **渲染函数** 来 **创建视图模板** ，并且会讲解 **JSX** 的 **语法** ，同时会补充2个内容，第一是 **函数式组件** ，第二是 **作用域插槽** 。

## render函数

**render函数** ：可以用 **函数的方式** 渲染 **dom元素** 到页面中。

下面会讲解2种使用场景：

1. 在 **main.js** 中如何使用
2. 在 **.vue** 文件中使用

### render函数在main.js中使用

**src/main.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39; &#x2F;&#x2F; app组件</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">import Bus from &#39;.&#x2F;lib&#x2F;bus&#39; &#x2F;&#x2F; 引入Bus</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line">Vue.prototype.$bus &#x3D; Bus &#x2F;&#x2F; 挂载Bus到Vue原型链（全局挂载Bus）</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(App) &#x2F;&#x2F; 渲染app组件</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

我们首先在 **main.js** 中学习 **render函数** ， **render** 的 **属性值** 是一个 **回调函数** ，它的参数可以用括号包裹起来，例如这样： **render: (h) => h(App)** ，如果 **只有一个参数就可以不用括号包裹** ， **h这个参数是一个方法** ，这个方法能 **创建一个虚拟节点** ，**这个函数 return 返回一个结果** 。

| 方法名                              | 参数                                                         | 是否必填 |
| :---------------------------------- | :----------------------------------------------------------- | :------- |
| **render函数：render: h => h(App)** | **h函数的第1个参数**：**要渲染的组件，或者一个标签字符串，或者也可以是一个函数** | **是**   |
|                                     | **h函数的第2个参数**： 该参数是一个 **配置对象**，可以 **通过该对象给元素设置属性** ，例如 **div** 标签的 **id、class 等等** | **否**   |
|                                     | **h函数的第3个参数**：该 **参数可以是字符串或者数组**，主要作用是 **给元素添加内容** | **否**   |

1. **h函数的参数1**

   **说明** ： **第1个参数** 是用来传入 **元素标签** 或者 **组件** 。

   1.1. **传入组件** ：**main.js** 中 **h函数** 默认传入的是 **app.vue页面组件**，所以就会 **渲染该组件** ，下面引入之前封装的 **CountTo 组件**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">import Bus from &#39;.&#x2F;lib&#x2F;bus&#39;</span><br><span class="line">import CountTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入CountTo 组件</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line">Vue.prototype.$bus &#x3D; Bus</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(CountTo, &#123;</span><br><span class="line">    &#x2F;&#x2F; &#39;class&#39;: &#39;count-to&#39;, &#x2F;&#x2F; 给组件最外层盒子添加class类名</span><br><span class="line">    &#x2F;&#x2F; 或者这样写</span><br><span class="line">    &#x2F;&#x2F; &#39;class&#39;: [&#39;count-to&#39;, true ? &#39;count-to2&#39; : &#39;&#39;], </span><br><span class="line">    &#x2F;&#x2F; 或者这样写</span><br><span class="line">    &#39;class&#39;: &#123;</span><br><span class="line">      &#39;count-to&#39;: true,</span><br><span class="line">      &#39;count-to2&#39;: 1 &#x3D;&#x3D;&#x3D; 1,</span><br><span class="line">    &#125;, </span><br><span class="line">    attrs: &#123;&#125;, &#x2F;&#x2F; 定义属性id等等</span><br><span class="line">    style: &#123;&#125;, &#x2F;&#x2F; 定义样式</span><br><span class="line">    props: &#123; &#x2F;&#x2F; 添加属性 这里可以理解为就是&lt;count-to :endValue&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">      endValue: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; domProps: &#123; &#x2F;&#x2F; dom的一些属性</span><br><span class="line">    &#x2F;&#x2F;   innerHTML: &#39;11&#39; &#x2F;&#x2F; 可以设置标签的一些内容</span><br><span class="line">    &#x2F;&#x2F; &#125;,</span><br><span class="line">    on: &#123; &#x2F;&#x2F; 添加事件</span><br><span class="line">      &#39;on-animation-end&#39;: (val) &#x3D;&gt; &#123; &#x2F;&#x2F; 事件名</span><br><span class="line">        console.log(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    nativeOn: &#123; &#x2F;&#x2F; 组件内没有定义click事件时，给组件最外层元素绑定一个click事件</span><br><span class="line">      &#39;click&#39;: () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;click&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    directives: [], &#x2F;&#x2F; 可以定义自定义指令</span><br><span class="line">    scopedSlots: &#123;&#125;,</span><br><span class="line">    slot: &#39;&#39;, &#x2F;&#x2F; 插槽</span><br><span class="line">    key: &#39;&#39;, &#x2F;&#x2F; 设置一个值让每个组件的key不相等</span><br><span class="line">    ref: &#39;&#39; &#x2F;&#x2F; ref</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   1.2. **传入字符串** ：也可以像下面写，这样页面中就 **渲染** 出一个 **div标签** 。

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   1.3. **传入函数** ：

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let func &#x3D; ()&#x3D;&gt; &#39;h3&#39;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(func())</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

2. **h函数的参数2**

   **说明** ： **h函数** 的 **第2个参数是个对象** ，用来 **定义元素的一些属性** 。

   2.1. **给元素设置属性** ：

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#123;</span><br><span class="line">    attrs: &#123; &#x2F;&#x2F; 添加属性</span><br><span class="line">      id: &#39;box&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    style: &#123; &#x2F;&#x2F; 添加样式</span><br><span class="line">      color: &#39;red&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

3. **h函数的参数3**

   **说明** ： **h函数的第3个参数可以是字符串或者数组** ，用来 **定义元素的内容** 。

   3.1. **传入字符串**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#123;</span><br><span class="line">    attrs: &#123; &#x2F;&#x2F; 添加属性</span><br><span class="line">      id: &#39;box&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    style: &#123; &#x2F;&#x2F; 添加样式</span><br><span class="line">      color: &#39;red&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#39;我是div的内容&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   **如果不设置样式可以直接忽略h函数的第2个参数** , 直接写内容

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#39;123&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   3.2. **传入数组**

   如果想让内容是 **多个标签** ，就需要 **传入数组**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, [</span><br><span class="line">    h(&#39;span&#39;, &#39;111&#39;),</span><br><span class="line">    h(&#39;span&#39;, &#39;222&#39;)</span><br><span class="line">  ])</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   3.3. **循环传入标签**

   如果想实现一个类似 **v-for** 的效果，首先先看 **正常循环列表写法**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul @click&#x3D;&quot;handleClick&quot;&gt;</span><br><span class="line">        &lt;li @click.stop&#x3D;&quot;handleClick&quot; v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;list_item_$&#123;index&#125;&#96;&quot;&gt;&#123;&#123; item.name &#125;&#125; &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default&#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                list: [</span><br><span class="line">                    &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                    &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleClick(event)&#123;</span><br><span class="line">                console.log(event)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   接下来使用 **render函数** 实现上面的 **循环列表跟点击事件**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 点击事件</span><br><span class="line">const handleClick &#x3D; event &#x3D;&gt; &#123;</span><br><span class="line">  console.log(event)</span><br><span class="line">  event.stopPropagation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">let list &#x3D; [</span><br><span class="line">  &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">  &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 循环生成li</span><br><span class="line">const getLiEleArr &#x3D; (h) &#x3D;&gt; &#123;</span><br><span class="line">  return list.map((item, index) &#x3D;&gt; h(&#39;li&#39;, &#123;</span><br><span class="line">    on: &#123;</span><br><span class="line">      &#39;click&#39;: handleClick</span><br><span class="line">    &#125;,</span><br><span class="line">    key: &#96;list_item_$&#123;index&#125;&#96;</span><br><span class="line">  &#125;, item.name))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最终渲染</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;,[</span><br><span class="line">    h(&#39;ul&#39;, &#123;</span><br><span class="line">      on: &#123;</span><br><span class="line">        &#39;click&#39;: handleClick</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, getLiEleArr(h))</span><br><span class="line">  ])</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

### render函数在.vue中使用

有时 **即使你封装好了组件，但是想根据自己的方式去定制组件内的元素以及内容**，这时候就需要 **给组件传入一个render函数**

1. **父组件**

   首先在 **路由列表** 的 **路由对象** 中添加新创建的 **render-page** 页面配置路由

   **src/router/router.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;render-page&#39;,</span><br><span class="line">    name: &#39;&#x2F;render_page&#39;,</span><br><span class="line">    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;render-page&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

   然后在 **src/views/render-page.vue** 页面 **引入list组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, name)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            return h(&#39;i&#39;, &#123;</span><br><span class="line">                style: &#123;</span><br><span class="line">                    color: &#39;pink&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

2. **子组件**

   **src/components/list/list.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">          &lt;!-- 如果未传入render函数就span标签内容 --&gt;</span><br><span class="line">          &lt;span v-if&#x3D;&quot;!render&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">          </span><br><span class="line">          &lt;!-- 如果传入了render函数，就使用render函数自定义dom的节点来渲染 --&gt;</span><br><span class="line">          &lt;render-dom v-else :render-func&#x3D;&quot;render&quot; :name&#x3D;&quot;item.name&quot;&gt;&lt;&#x2F;render-dom&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 引入函数式组件</span><br><span class="line">import RenderDom from &#39;_c&#x2F;render-dom&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        RenderDom &#x2F;&#x2F; 注册函数式组件</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;,</span><br><span class="line">        render: &#123; &#x2F;&#x2F; render 函数</span><br><span class="line">            type: Function,</span><br><span class="line">            default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   定义一个 **index.js 方便父组件引用**

   **src/components/list/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import List from &#39;.&#x2F;list.vue&#39;</span><br><span class="line">export default List</span><br></pre></td></tr></table></figure>

   在上面的组件中使用到了 **函数式组件** ，这里写的 **函数式组件** 就是使用 **reder函数 自定义一些想要的标签** 然后 **return** 返回一个 **虚拟节点** ， **最终渲染在使用函数式组件的地方** ，**函数式组件详解看下方的文档介绍**。

   **src/components/render-dom.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        name: String, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 函数式组件

**函数式组件** ： **只给它传入数据，它不做任何响应式的操作， 不监听传递给它的状态** ，这个组件 **没有生命周期和钩子函数**，它 **只是作为一个接收参数的函数** ， 当 **functional 设置为 true** 时候，证明 **它是一个没有状态的组件，也没有实例，就是一个对象** ， 当 **把这个对象引入到其他页面，当做一个组件去使用的时候，vue会把它做一个处理，会把 【render函数】里面逻辑返回的【虚拟节点】做一个渲染** 。

**src/components/render-dom.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        name: String, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## JSX

**JSX** ：**JSX** 最先是 **react** 提出的， **通过一种形式，在 js 里面写 html 标签，还有一些特定的语法** ，最后会把这个 **字符串** 转译成 **js** ，去用 **render函数** 来做渲染。

### JSX渲染标签字符串

1. **父组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, name)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * render函数方式</span><br><span class="line">             *&#x2F;</span><br><span class="line">            &#x2F;&#x2F; return h(&#39;i&#39;, &#123;</span><br><span class="line">            &#x2F;&#x2F;     style: &#123;</span><br><span class="line">            &#x2F;&#x2F;         color: &#39;pink&#39;</span><br><span class="line">            &#x2F;&#x2F;     &#125;</span><br><span class="line">            &#x2F;&#x2F; &#125;, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * JSX方式</span><br><span class="line">             * JSX与template模板对比</span><br><span class="line">             *   style:</span><br><span class="line">             *      template的标签中写法:style&#x3D;&quot;&#123; color: &#39;pink&#39; &#125;&quot;</span><br><span class="line">             *      JSX写法:style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;</span><br><span class="line">             *      JSX中style不需要添加双引号，属性都需要用&#123;&#125;包裹</span><br><span class="line">             * </span><br><span class="line">             *   事件:</span><br><span class="line">             *      template的标签中写法v-click&#x3D;&quot;handleClick&quot; 或者 @click&#x3D;&quot;handleClick&quot;</span><br><span class="line">             *      JSX写法on-click&#x3D;&#123; this.handleClick &#125;</span><br><span class="line">             *&#x2F;</span><br><span class="line">            return (</span><br><span class="line">                &lt;i on-click&#x3D;&#123; this.handleClick &#125; style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;&gt;&#123; name &#125;&lt;&#x2F;i&gt; </span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        handleClick(event)&#123;</span><br><span class="line">            console.log(event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   使用 **JSX** 时 **render函数** 的 **形参必须是 h** ，不可以改成其他的（例如 **createElement**）。以上代码中引入的 **List组件** 在上面的 **render函数** 文档中有写过，在此处就不再过多陈述。

### JSX渲染组件

1. **父组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line">import CountTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入组件</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123; number: 100 &#125;,</span><br><span class="line">                &#123; number: 45 &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, number)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            return (</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 这里可以引入组件进行渲染，而且不用在components对象中注册</span><br><span class="line">                 * 事件分为2种：原生事件、自定义事件</span><br><span class="line">                 *  html标签：支持原生事件</span><br><span class="line">                 *  组件：支持原生事件(给下面的CountTo组件绑定一个原生click事件,就相当于给组件内的最外层元素绑定了一个click事件，</span><br><span class="line">                 *  写法：nativeOn-事件名称&#x3D;&#123;方法&#125;)、</span><br><span class="line">                 *  自定义事件(写法：on-自定义事件名称&#x3D;&#123;方法&#125;)</span><br><span class="line">                 *  template模板中的事件修饰符在JSX跟render函数中用到需要看文档</span><br><span class="line">                 * *&#x2F; </span><br><span class="line">                &lt;CountTo nativeOn-click&#x3D;&#123;this.handleClick&#125; on-on-animation-end&#x3D;&#123;this.handleEnd&#125; endValue&#x3D;&#123;number&#125; style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;&gt;&lt;&#x2F;CountTo&gt; </span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        handleClick(event)&#123;</span><br><span class="line">            console.log(event)</span><br><span class="line">        &#125;,</span><br><span class="line">        handleEnd()&#123;</span><br><span class="line">            console.log(&#39;end!&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   父组件中引入的 **[CountTo组件](https://www.kancloud.cn/wangjiachong/vue_notes/1971966)**

2. **子组件**

   **src/components/list.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li @mousemove&#x3D;&quot;handleMove&quot; v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">          &lt;!-- 如果未传入render函数就span标签内容 --&gt;</span><br><span class="line">          &lt;span v-if&#x3D;&quot;!render&quot;&gt;&#123;&#123; item.number &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">          </span><br><span class="line">          &lt;!-- 如果传入了render函数，就使用render函数自定义dom的节点来渲染 --&gt;</span><br><span class="line">          &lt;render-dom v-else :render-func&#x3D;&quot;render&quot; :number&#x3D;&quot;item.number&quot;&gt;&lt;&#x2F;render-dom&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 引入函数式组件</span><br><span class="line">import RenderDom from &#39;_c&#x2F;render-dom&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        RenderDom &#x2F;&#x2F; 注册函数式组件</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;,</span><br><span class="line">        render: &#123; &#x2F;&#x2F; render 函数</span><br><span class="line">            type: Function,</span><br><span class="line">            default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleMove(event)&#123;</span><br><span class="line">            &#x2F;&#x2F; 阻止默认行为（文字不可以选中复制）</span><br><span class="line">            event.preventDefault()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   **list组件** 对应的 **index.js**，用于 **父组件方便引用**

   **src/components/list/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import List from &#39;.&#x2F;list.vue&#39;</span><br><span class="line">export default List</span><br></pre></td></tr></table></figure>

   **子组件** 中用到的 **函数式组件 render-dom.js**

   **src/components/render-dom.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        number: Number, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.number)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 作用域插槽

**定制组件内的元素以及内容** ，用 **render函数** 以及 **JSX** 都比较繁琐，接下来用 **作用域插槽** 来实现这个需求。

1. **父组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot;&gt;</span><br><span class="line">            &lt;h3 slot&#x3D;&quot;aa&quot;&gt;我是小明&lt;&#x2F;h3&gt;</span><br><span class="line">            &lt;coun-to slot-scope&#x3D;&quot;count&quot; :end-value&#x3D;&quot;count.number&quot;&gt;&lt;&#x2F;coun-to&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line">import CounTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入组件</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123; number: 100 &#125;,</span><br><span class="line">                &#123; number: 45 &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List,</span><br><span class="line">        CounTo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

2. **子组件**

   **src/components/list.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">            &lt;!-- 默认插槽 --&gt;</span><br><span class="line">            &lt;!-- &lt;slot&gt;&lt;&#x2F;slot&gt; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &lt;!-- 具名插槽 --&gt;</span><br><span class="line">            &lt;slot name&#x3D;&quot;aa&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        </span><br><span class="line">            &lt;!-- 作用域插槽 --&gt;</span><br><span class="line">            &lt;slot :number&#x3D;&quot;item.number&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

3. **插槽总结**

   3.1 **匿名插槽** 应用场景：**组件内** 只需要一个 **插槽** 的情况，可以使用 **匿名插槽** 。

   3.2 **具名插槽** 应用场景：**组件内** 需要多个 **插槽** 的情况，可以使用 **具名插槽** 。

   3.3 **作用域插槽**应用场景：**父组件插槽插入的内容中** 使用到了 **组件内的数据** 。



# render: h => h(App)

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//createElement就是h,一个形参，没有具体意义，可以随意改变书写</span></span><br><span class="line">render:(<span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(App);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

render是一个方法，自带一个形参createElement，这个参数也是一个方法，是用来创建vue 节点的，也就是html模板的，然后渲染(render)到指定的节点上



# VUE的配置



# VUE的路由：Vue Router

vue-router中经常会操作的两个对象route和router两个

## $route对象

表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等

**1.**  **$route.path**   字符串，对应当前路由的路径，总是解析为绝对路径，如"/foo/bar"。

  **2.**  **$route.params**   一个 key/value 对象，包含了 动态片段 和 全匹配片段，   如果没有路由参数，就是一个空对象。

  **3.**  **$route.query**   一个 key/value 对象，表示 URL 查询参数。   例如，对于路径 /foo?user=1，则有$route.query.user == 1，   如果没有查询参数，则是个空对象。

  **4.**  **$route.hash**   当前路由的hash值 (不带#) ，如果没有 hash 值，则为空字符串。锚点*

  **5.**  **$route.fullPath**   完成解析后的 URL，包含查询参数和hash的完整路径。

  **6.**  **$route.matched**   数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。

  **7.**  **$route.name**  当前路径名字

  **8.**  **$route.meta** 路由元信息

  导航钩子的参数：

  router.beforeEach((to,from, next)=>{//to 和from都是 路由信息对象,后面使用路由的钩子函数就容易理解了})

## **$router对象**

$router对象是全局路由的实例，是router构造方法的实例

**路由实例方法：**

#### **1、push**

  1.字符串this.$router.push('home')

2. 对象this.$router.push({path:'home'})

3. 命名的路由this.$router.push({name:'user',params:{userId:123}}) 

  4.带查询参数，变成 /register?plan=123this.$router.push({path:'register',query:{plan:'123'}})

  push方法其实和`<router-link :to="...">`是等同的。

  注意：push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。

使用name，必须使用params，刷新页面，参数会丢失。而使用path，必须使用query，刷新页面不会丢失参数。

#### **2、go**

   页面路由跳转 

   前进或者后退this.$router.go(-1) // 后退

#### 3、replace

  push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，

  不会向 history 栈添加一个新的记录

#### 4.一般使用replace来做404页面

  this.$router.replace('/')

  配置路由时path有时候会加 '/' 有时候不加,以'/'开头的会被当作根路径，就不会一直嵌套之前的路径。

$router对象是全局路由的实例，是router构造方法的实例。



**Vue Router** 是 **Vue** 官方提供的 **路由管理器** ，可以进行 **路由跳转**，以及 **页面之间跳转时传值**，以及 **路由拦截** 等等操作



这里的路由并不是指我们平时所说的硬件路由器，**这里的路由就是SPA（单页应用）的路径管理器**。再通俗的说，vue-router就是[WebApp](https://coding.imooc.com/?c=webapp)的链接路径管理系统。
vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。**路由模块的本质 就是建立起url和页面之间的映射关系**。

至于我们为啥不能用a标签，这是因为用Vue做的都是单页应用（**当你的项目准备打包时，运行`npm run build`时，就会生成dist文件夹，这里面只有静态资源和一个index.html页面**），所以你写的`<a></a>`标签是不起作用的，你必须使用vue-router来进行管理。


实现原理

SPA(single page application):单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。**单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面**;vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。

#### 1、Hash模式：

**vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。** hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说**Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据**

vue Router的跳转问题，就是如果引入了vue-router，例如给一个这样的链接https:www.app/index.html，但是真正在浏览器中输入后执行的时候就变成了 https:www.app/index.html#/

引入了vue-router，引入vue-router后，再点开链接的时候，会自动加上#/，因为vue-router是根据锚点来进行定位的,也就是根据hash值来跳转的（单页面应用）。只要程序中引入了vue-router，跳转的时候会自动加上#/的

#### 2、History模式：

由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入"mode: 'history'",这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main.js文件中</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

当你使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，比较好看！
不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。
所以呢，**你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const routes &#x3D; [ </span><br><span class="line"> &#123;path: &quot;&#x2F;&quot;, name: &quot;homeLink&quot;, component:Home&#125;</span><br><span class="line"> &#123;path: &quot;&#x2F;register&quot;, name: &quot;registerLink&quot;, component: Register&#125;,</span><br><span class="line"> &#123;path: &quot;&#x2F;login&quot;, name: &quot;loginLink&quot;, component: Login&#125;,</span><br><span class="line"> &#123;path: &quot;*&quot;, redirect: &quot;&#x2F;&quot;&#125;]</span><br></pre></td></tr></table></figure>

此处就设置如果URL输入错误或者是URL 匹配不到任何静态资源，就自动跳到到Home页面

#### 3、使用路由模块来实现页面跳转的方式

方式1：直接修改地址栏

方式2：this.$router.push(‘路由地址’)

方式3：`<router-link to="路由地址"></router-link>`










一、验证用户身份

大部分项目，除了登录页、重置密码页、用户协议页以外，页面都需要验证用户身份进行访问。使用 Vue Router 可以配合后端进行双重验证

给需要验证的路由对象添加 meta 字段，里面自定义一个代表验证的字段

（登录）验证身份方法：

1、给需要验证的路由对象添加 meta 字段，里面自定义一个代表验证的字段：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">	  name:&#39;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#39;bar&#39;,</span><br><span class="line">          component: Bar,</span><br><span class="line">          meta: &#123; </span><br><span class="line">              requiresAuth: true &#x2F;&#x2F; 添加该字段，表示进入这个路由是需要登录的</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

2、在全局导航钩子里验证 requiresAuth 字段：

注意事项：

- 使用 beforeEach 在路由变化前验证。验证原理是在跳转前，访问目标路由对象的 requiresAuth 字段判断是否需要验证用户身份，如为是，检测是否有保存用户信息（即用户登录成功后前端保存的信息，例如 token）
- 每个路由都有一个 $route.matched 数组，包含当前路由的父级路由对象和当前路由对象，在组件中可以通过 this.$route.matched 访问
- beforeEach 的 to 参数即目标路由对象 $route，to.matched 即是它的路由数组
- 因此，使用 some 方法，只要路由数组里的任意路由对象需要验证身份，即进行验证
- 验证成功跳转正确页面；失败则跳到登录页，将目标地址附在 url 的 query 里，登录成功就跳转到目标地址

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  if (to.matched.some(record &#x3D;&gt; record.meta.requiresAuth)) &#123;</span><br><span class="line">    if (!auth.loggedIn()) &#123;  &#x2F;&#x2F; 没登录</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: &#39;&#x2F;login&#39;,</span><br><span class="line">        query: &#123; redirect: to.fullPath &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()  &#x2F;&#x2F; 确保一定要调用 next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next() &#x2F;&#x2F; 确保一定要调用 next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

3、拦截 http 请求，验证用户身份

为了防止本地保存的 token 过期，需要拦截 http 请求，为每次请求头加上 token ，然后拦截 http 响应，根据响应内容判断是否需要跳回登录页面重新登录。使用 axios 的方法如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; http request 拦截器</span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    config &#x3D;&gt; &#123;</span><br><span class="line">        if (auth.loggedIn()) &#123; &#x2F;&#x2F; 判断是否存在token，如果存在的话，则每个http header都加上token</span><br><span class="line">            config.headers.Authorization &#x3D; &#96;token $&#123;auth.loggedIn()&#125;&#96;;</span><br><span class="line">        &#125;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;,</span><br><span class="line">    err &#x3D;&gt; &#123;</span><br><span class="line">        return Promise.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http response 拦截器</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    response &#x3D;&gt; &#123;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;,</span><br><span class="line">    error &#x3D;&gt; &#123;</span><br><span class="line">        if (error.response) &#123;</span><br><span class="line">            switch (error.response.status) &#123;</span><br><span class="line">                case 401:</span><br><span class="line">                    &#x2F;&#x2F; Unauthorized</span><br><span class="line">                    &#x2F;&#x2F; 返回 401 清除token信息并跳转到登录页面</span><br><span class="line">                    auth.clear();</span><br><span class="line">                    router.replace(&#123;</span><br><span class="line">                        path: &#39;login&#39;,</span><br><span class="line">                        query: &#123;</span><br><span class="line">                            redirect: router.currentRoute.fullPath</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error.response.data) &#x2F;&#x2F; 返回接口返回的错误信息</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

二、定义用户权限能访问的页面

前端查看权限，也是配合后端进行某些页面的隐藏显示功能。一般应用于综合的办公系统，由 IT 部分配账号，不同部门的人只能看到自己负责的内容，例如行政部不会看到财务数据页面。

实现方法：

1. 与后端商定每个用户角色对应的 level 级别，以数值表示
2. 前端路由每个页面的 meta 对象添加 level 字段，值为数组，里面是有权限访问页面的 level 数值
3. 登录成功，后台返回用户 token 的同时，返回其所属的 level 字段
4. 组件代码比较目标页面的 level 与用户 level，只显示包含在目标 level 数组里的页面
5. 全局导航钩子 beforeEach 里比较目标页面的 level 与用户 level，包含在目标 level 数组里则正确跳转，反之取消跳转并提示权限不足

> 上面第5步是为了防止用户直接在浏览器输入目标地址

三、其他内容控制

可以控制显示路由固定的搭配，例如某个路由地址的 title 是固定的字符串、固定的欢迎语、固定的 favicon 等。在组件里通过 this.$route.meta.xxx 访问。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#39;bar&#39;,</span><br><span class="line">          component: Bar,</span><br><span class="line">          meta: &#123; </span><br><span class="line">              title: &#39;标题&#39;,</span><br><span class="line">              message: &#39;欢迎您&#39;,</span><br><span class="line">              requiresAuth: true &#x2F;&#x2F; 添加该字段，表示进入这个路由是需要登录的</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



动态路由匹配是用于把某种模式匹配到的所有路由，全都映射到同个组件。通过给路由路径一个变量，即变成动态路由，把变化的内容赋值给变量即可。

例如文章详情页是一个组件，只有一个路由，从文章列表页点进来，变化的只是文章 id 而已。将其赋予给设定的变量，然后通过在组件里 watch $route 或者使用 beforeRouteUpdate 导航守卫监测路由变化，传递新的文章 id 获取文章详情即可。在组件里，可以通过`this.$route.params.xx`获取当前文章 id。

一个路由地址可以设置多个变量，适合有分叉情况的内容。例如 path: '/params/:foo/:bar'

> 从文章列表页点进来即传递路由变量，有三种方法：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）&lt;router-link to&#x3D;&quot;&#x2F;params&#x2F;list&#x2F;1&quot;&gt;跳转到 &#x2F;params&#x2F;list&#x2F;1&lt;&#x2F;router-link&gt;&#96;</span><br><span class="line">（2）this.$router.push(&#123; name: &#39;articles&#39;, params: &#123; foo: &#39;list&#39;, bar: 1 &#125; &#125;)&#96;</span><br><span class="line">（3）this.$router.push(&#123; path: &#39;&#x2F;params&#x2F;list&#x2F;1&#39; &#125;) &#x2F;&#x2F; path 不能与 params 同时使用</span><br></pre></td></tr></table></figure>



高级匹配模式

这里主要研究的是动态路由匹配的高级匹配模式，以达到合并差异不大的路由、减少路由数量的目的。

高级匹配即结合简单的正则匹配方法，给予路由更多的限制和操作空间。

1、可选路由参数

路由参数可选，添加与否都对应同一个组件。可以在组件里使用 v-if / v-show 结合 $route.params.xx 展现不同的内容

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a param can be made optional by adding &quot;?&quot;</span><br><span class="line">&#123; path: &#39;&#x2F;optional-params&#x2F;:foo?&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个链接都对应同个组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-params&quot;&gt;&#x2F;optional-params&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-params&#x2F;foo&quot;&gt;&#x2F;optional-params&#x2F;foo&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

2、精确匹配参数

只有参数通过正则匹配，完全符合格式，才能会跳转。例如只有参数是数字/手机号才允许跳转。适用于对第三方不规范格式的数据进行筛选。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a param can be followed by a regex pattern in parens</span><br><span class="line">&#x2F;&#x2F; this route will only be matched if :id is all numbers</span><br><span class="line">&#123; path: &#39;&#x2F;params-with-regex&#x2F;:id(\\d+)&#39; &#125;</span><br><span class="line">&#x2F;&#x2F; 只匹配数字</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;params-with-regex&#x2F;123&quot;&gt;&#x2F;params-with-regex&#x2F;123&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只匹配手机号</span><br><span class="line">&#123; path: &#39;&#x2F;params-with-regex&#x2F;:id(^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$)&#39; &#125;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;params-with-regex&#x2F;13800138000&quot;&gt;&#x2F;params-with-regex&#x2F;13800138000&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

3、匹配任意参数

不对参数格式、数量进行限制，任意参数都可。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; asterisk can match anything</span><br><span class="line">&#123; path: &#39;&#x2F;asterisk&#x2F;*&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个都是同一组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;asterisk&#x2F;foo&quot;&gt;&#x2F;asterisk&#x2F;foo&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;asterisk&#x2F;foo&#x2F;bar&quot;&gt;&#x2F;asterisk&#x2F;foo&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

4、部分可选参数

结合可选路由参数与多路由参数，其中一部分参数可选。适用于分叉情况下不确定参数数量的情况。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; make part of the path optional by wrapping with parens and add &quot;?&quot;</span><br><span class="line">&#123; path: &#39;&#x2F;optional-group&#x2F;(foo&#x2F;)?bar&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个都是同一组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-group&#x2F;bar&quot;&gt;&#x2F;optional-group&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-group&#x2F;foo&#x2F;bar&quot;&gt;&#x2F;optional-group&#x2F;foo&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>





### 路由的跳转

1、router-link （声明式路由）

 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 不带参数</span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;&#125;&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;</span>&gt;</span> //name,path都行, 建议用name  </span><br><span class="line">   // 注意：router-link中链接如果是&#x27;/&#x27;开始就是从根路由开始，如果开始不带&#x27;/&#x27;，则从当前路由开始。</span><br><span class="line"></span><br><span class="line">2.带参数</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;, params: &#123;id:1&#125;&#125;&quot;</span>&gt;</span>  </span><br><span class="line">// params传参数 (类似post)</span><br><span class="line">// 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot; </span><br><span class="line">// 不配置path ,第一次可请求,刷新页面id会消失</span><br><span class="line">// 配置path,刷新页面id会保留</span><br><span class="line"></span><br><span class="line">// html 取参  $route.params.id</span><br><span class="line">// script 取参  this.$route.params.id</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;, query: &#123;id:1&#125;&#125;&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>

  

   2、router.push(编程式路由)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">router.push(&#39;home&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象</span><br><span class="line">router.push(&#123; path: &#39;home&#39; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命名的路由</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 带查询参数，变成 &#x2F;register?plan&#x3D;private</span><br><span class="line">router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</span><br></pre></td></tr></table></figure>

注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userId &#x3D; &#39;123&#39;</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">router.push(&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user</span><br></pre></td></tr></table></figure>

3、this.$router.push() (函数里面调用)

 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.  不带参数</span><br><span class="line"></span><br><span class="line">this.$router.push(&#39;&#x2F;home&#39;)</span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;&#125;)</span><br><span class="line">this.$router.push(&#123;path:&#39;&#x2F;home&#39;&#125;)</span><br><span class="line"></span><br><span class="line">2. query传参 </span><br><span class="line"></span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;)</span><br><span class="line">this.$router.push(&#123;path:&#39;&#x2F;home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; html 取参  $route.query.id</span><br><span class="line">&#x2F;&#x2F; script 取参  this.$route.query.id</span><br><span class="line"></span><br><span class="line">3. params传参</span><br><span class="line"></span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;,params: &#123;id:&#39;1&#39;&#125;&#125;)  &#x2F;&#x2F; 只能用 name</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 路由配置 path: &quot;&#x2F;home&#x2F;:id&quot; 或者 path: &quot;&#x2F;home:id&quot; ,</span><br><span class="line">&#x2F;&#x2F; 不配置path ,第一次可请求,刷新页面id会消失</span><br><span class="line">&#x2F;&#x2F; 配置path,刷新页面id会保留</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; html 取参  $route.params.id</span><br><span class="line">&#x2F;&#x2F; script 取参  this.$route.params.id</span><br><span class="line"></span><br><span class="line">4. query和params区别</span><br><span class="line">   query类似 get, 跳转之后页面 url后面会拼接参数,类似?id&#x3D;1, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在</span><br><span class="line"></span><br><span class="line">params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失</span><br></pre></td></tr></table></figure>

   

4. this.$router.replace() (用法同上,push)

5. this.$router.go(n) ()


  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$router.go(n)</span><br><span class="line">   向前或者向后跳转n个页面，n可为正整数或负整数</span><br></pre></td></tr></table></figure>

  

  ps : 区别

  this.$router.push
  跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面
  this.$router.replace
  跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)

  this.$router.go(n)
  向前或者向后跳转n个页面，n可为正整数或负整数

  

注意：获取路由上面的参数，用的是$route，后面没有r
params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。
params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。
params、query不设置也可以传参，但是params不设置的时候，刷新页面或者返回参数会丢失，

两者都可以传递参数，区别是什么？
query 传参配置的是path，而params传参配置的是name，在params中配置path无效
query在路由配置不需要设置参数，而params必须设置
query传递的参数会显示在地址栏中
params传参刷新会无效，但是query会保存传递过来的值，刷新不变



**Vue router的query对象里的值的问题**

在使用 $router.push() 时，如果使用了query，则可以在跳转后从query中获取到对应的参数。如果传的是字符串自然没问题，但是如果传的其他类型的数据，在跳转之后是正常的，而跳转之后再刷新一遍页面的话，query里面的属性的值都会变成字符串。例如：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123; name:&#39;product&#39;, query: &#123;canSee: false&#125; &#125;);</span><br></pre></td></tr></table></figure>

　　最初跳转之后，this.$route.query.canSee打印的值是Boolean类型的。然后刷新一下，值就变成了String类型了。个人猜测是因为刷新后query的值是直接从页面URL中取的，而在页面URL上的参数的类型只能是字符串类型。

**解决方法**：

　　1. 在传值之前把要传的参数单独放到一个对象里，在放到query里面，然后进行JSON.stringify()处理，到了目标页面后再进行JSON.parse()处理，还原对象。这种方法的好处是可以一次性处理多个参数，而且适用度高，建议使用这种方法。

　　2. 传值前不做处理，到了目标页面后再单独对原本为非字符串的数据进行JSON.parse()处理。缺点是字符串类型的数据不能如此处理，要确保该数据不是字符串类型的。局限性大，不推荐适用。



### vue项目中跳转到外部链接方法

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;goPage(&#x27;http://www.chao99.top&#x27;)&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    goPage (url) &#123;</span><br><span class="line">            window.location.href = url</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

如果用.push的路由跳转，会在路径外面再加一个基本的url导致出错，例如本地项目：会在外部链接前面加上了http://localhost:8080/#/

一定要注意, 外部链接要加上 http:// , 不然跳转还是当前域名下



## VUE的图片路径

一般都是通过相对路径取到图片然后加载

官方文档没有存放静态的asset 文件了 ,静态现在存放在public 的里面. 但是在public里面去创建一个img 的文件,去放置图片,依然不可以. 

所以 三种办法里面 只有require 使用vuecli3 ,

1、在模板中直接引入图片资源（这种一般是@ 或者./ 去引入）

2、将图片资源放在static文件夹下

3、图片资源在assets文件夹下，data中必须用require加载，否则会当成字符串来处理
(我自己目前就是放在assets 里面. 因为是本地上传的 在做假数据的时候准备做一个预览,或者说以后的默认图片就是它了)
第二种，只要给图片放在static文件夹下即可：原因如下

这里在使用vuecli脚手脚构建工具，目录下会生成一个static目录，表示的是静态目录，推荐大家将img 存放在这个目录下，那么在webpack编译以后，依旧是可以获取到这个目录下的路径，这样就解决了路径不符而导致图片加载不出来的问题！当然项目中用的一般都是绝对路径，少数图片的话，这种方式挺好
但是 重点: vuecli3 没有static 啊!!!



# VUE的模板语法

Vue 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。

Vue 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。

结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上



### 插值

#### 文本

数据绑定最常见的形式就是使用 `{ {...} }`（双大括号）的文本插值：

##### 文本插值

`<div id="app">   <p></p> </div>`

`{ {...} }` 标签的内容将会被替代为对应组件实例中 **message** 属性的值，如果 **message** 属性的值发生了改变，`{ {...} }` 标签内容也会更新。

如果不想改变标签的内容，可以通过使用 **v-once** 指令执行一次性地插值，当数据改变时，插值处的内容不会更新。

`<span v-once>这个将不会改变: { { message } }</span>`

##### Html

使用 v-html 指令用于输出 html 代码：

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v-html 指令</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用双大括号的文本插值: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用 v-html 指令: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> RenderHtmlApp = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      rawHtml: &#x27;<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>这里会显示红色！<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(RenderHtmlApp).mount(<span class="string">&#x27;#example1&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

##### 属性

HTML 属性中的值应使用 v-bind 指令。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

对于布尔属性，常规值为 true 或 false，如果属性值为 null 或 undefined，则该属性不会显示出来。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-bind:disabled&#x3D;&quot;isButtonDisabled&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

以上代码中如果 isButtonDisabled 的值是 null 或 undefined，则 disabled 属性甚至不会被包含在渲染出来的 `<button> `元素中。

以下实例判断 use 的值，如果为 true 使用 class1 类的样式，否则不使用该类：

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v-bind 指令</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;r1&quot;</span>&gt;</span>修改颜色<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;use&quot;</span> <span class="attr">id</span>=<span class="string">&quot;r1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123;&#x27;class1&#x27;: use&#125;&quot;</span>&gt;</span></span><br><span class="line">    v-bind:class 指令</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      use: <span class="literal">false</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(app).mount(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

##### 表达式

Vue.js 都提供了完全的 JavaScript 表达式支持。

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 表达式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;5+5&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span>菜鸟教程<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> HelloVueApp = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      ok: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;RUNOOB!!&#x27;</span>,</span></span><br><span class="line">      id: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(HelloVueApp).mount(<span class="string">&#x27;#hello-vue&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  这是语句，不是表达式：--&gt;</span><br><span class="line">&#123;&#123; var a &#x3D; 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>

### 指令

指令是带有 v- 前缀的特殊属性。

指令用于在表达式的值改变时，将某些行为应用到 DOM 上。如下例子：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-if&#x3D;&quot;seen&quot;&gt;现在你看到我了&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      seen: true  &#x2F;* 改为false，信息就无法显示 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

这里， v-if 指令将根据表达式 seen 的值( true 或 false )来决定是否插入 p 元素。

另外还有其它很多指令，每个都有特殊的功能。例如，v-for 指令可以绑定数组的数据来渲染一个项目列表：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;ol&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;site in sites&quot;&gt;</span><br><span class="line">      &#123;&#123; site.text &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      sites: [</span><br><span class="line">        &#123; text: &#39;Google&#39; &#125;,</span><br><span class="line">        &#123; text: &#39;Runoob&#39; &#125;,</span><br><span class="line">        &#123; text: &#39;Taobao&#39; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

##### 参数

参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;菜鸟教程&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const HelloVueApp &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      url: &#39;https:&#x2F;&#x2F;www.runoob.com&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(HelloVueApp).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。

另一个例子是 v-on 指令，它用于监听 DOM 事件：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a @[event]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

在这里参数是监听的事件名。

##### 修饰符

修饰符是以半角句号 **.** 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，**.prevent** 修饰符告诉 **v-on** 指令对于触发的事件调用 **event.preventDefault()**：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

### 用户输入

在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">双向数据绑定</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Runoob!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

**v-model** 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。

按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。

以下实例在用户点击按钮后对字符串进行反转操作：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">字符串反转</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;&#x2F;title&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue@next&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;reverseMessage&quot;&gt;反转字符串&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Runoob!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage() &#123;</span><br><span class="line">      this.message &#x3D; this.message</span><br><span class="line">        .split(&#39;&#39;)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

### 缩写

#### v-bind 缩写

Vue.js 为两个最为常用的指令提供了特别的缩写：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

#### v-on 缩写

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

# VUE的条件语句



# VUE的循环语句



# VUE的组件



# VUE的计算属性



# VUE的监听属性



# VUE的样式绑定



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;vue根据绑定值判断应用具体的哪个css样式</span><br><span class="line">&lt;div :class&#x3D;&quot;from?&#39;loginShop&#39;:&#39;loginOperating&#39;&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



# VUE的事件处理

### VUE的方法

方法名: async function () {}

async 方法名() {}



# VUE中用到的一些关键字

### let、var和const

ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。

1. var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。可以修改，如果不初始化会输出undefined，不会报错
2. let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不可在声明之前调用，必须先定义再使用，否则会报错。不能定义同名变量。
3. const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。

**let和const属于局部变量，不会出现变量提升的情况，全局定义的let和const变量，不属于顶层变量，不属于window的属性**。let和const不允许重复声明，let和const不会绑定全局作用域

变量提升：可以在变量定义前使用定义过的变量。

暂时性死区（TDZ）：在运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。常见于：let、const、import、class、typeof等

**let和const定义的变量都会被提升，但是不会被初始化，不能被引用**



### fullPath和path

- $route.fullPath

  - type: `string`
    The full resolved URL including query and hash.

- $route.path

  - type: `string`
    A string that equals the path of the current route, always resolved as an absolute path. e.g. “/foo/bar”.

fullPath能缓存路由跳转后面携带的参数，刷新后依旧存在， 在PC端能起作用

而 path则不能缓存路由跳转后面携带的参数，所以path  能在`只有两层数据结构的`移动端起作用
   原因：

一般，移动端App 只能往里面走，表面和切换的页面是第一层， 点击功能按钮进去的是第二层。
这种层级的关系其实 是具有跳转作用，所以在第一层获取的数据，与第二层来回切换没问题。但是你第二层到第三层一来回切换，路由跳转携带的参数就丢失了。

fullPath匹配路由，path匹配路径。

例如：

路由是：`/path/one`
真正路径是：`/path/true`

那么此时path为`/path/true`，而fullPath为`/path/one`



### this和that

在Vue中this始终指向Vue，但axios中this为undefined

![这里写图片描述](https://img-blog.csdn.net/20171102210352732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzgyMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

若需要赋值给变量用以渲染数据，可以通过=>函数，这时this为Vue

![这里写图片描述](https://img-blog.csdn.net/20171102210527538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzgyMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

或者可以直接通过： 
let that = this 
将this保存在that中，再在函数中使用that均可 



个人理解：一般情况下，this就是此vue的页面，可以调用此页面的函数。但是涉及到异步axios时，this没有指向了。需要（）=>{}，在{}里this才会指代vue。

如果不使用（）=>{}方法，可以进行双向绑定：let that = this  ，将this保存在that中，再在函数中使用that均就可以了



async和await分别表示异步和等待，语义更加明确



解决异步调用：从最早的回调函数，到 Promise 对象，再到 Generator 函数，再到async





### return

return不论是什么，都是直接返回，即使是语句或者函数也不会执行的！是函数就返回该函数！

下面从一个例子来加深对return用法的理解：

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(‘xxxx’)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; <span class="keyword">return</span> res.data.result.info &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在axios和ajax中经常会用到return，从上面的代码可以看到有两个return，每个return的作用都需要理解：

第一个return后面跟的是axios配置，这个return就是将整个axios返回出来；

第二个return是在axios请求成功后将响应数据返回出来，即第二个return就是将axios异步请求的数据返回出来。



函数中有ajax和axios调用的有异步和同步，是异步的话里面如果有return，在函数外层（函数是指getTable()）调用的时候会取不到数据，除非换成同步。如果想异步取到数据，就需要在函数外层也加个return，相当于把ajax或者axios 整个配置返回出来，返回出来的数据格式是[object,promise]，所以函数执行获得的数据格式就是[object,promise]，然后使用.then()的形式将里面返回的数据拿出来!

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> getTable().then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="built_in">this</span>.tableData = res&#125;) <span class="comment">//此出先调用getTable()拿到axios的数据，然后在.then()出来结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

此段代码的目的是将axios异步请求的结果返回出来，因为是异步所以不能直接在axios里return数据，所以需要在axios外层也加个return，这样就可以拿到了。









### set：this.$set

由于JavaScript的限制，Vue不能检测以下变动的数组,页面不会刷新：

1.当你利用索引值直接设置一个项时。`vm.items[indexOfItem]=newValue`

2.当你修改数组的长度时。`vm.items.length=newLength`

使用Vue.set、vm.$set()或者数组的splice方法。使数值改变后，页面进行刷新后的效果展示

注：$set()方法调用时，页面会全部更新一遍



# VUE定义全局变量

在项目中，经常会复用一些变量和函数，比如用户的登录token，用户信息等。这时需要将它们设为全局，全局变量和全局函数之间有一些相通之处。

## 定义全局变量

原理：使用模块（.js或.vue文件）来管理全局变量，最后使用`export`暴露出去 （最好导出的格式为对象，方便在其他地方调用），当其它地方需要使用时，用`import`导入该模块

1、使用全局变量专用模块，挂载到main.js文件上面

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">全局变量模块Global.vue定义如下：</span><br><span class="line"><span class="keyword">const</span> token=<span class="string">&#x27;12345678&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> userStatus=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    token, <span class="comment">// 用户token身份</span></span><br><span class="line">    userStatus <span class="comment">// 用户登录状态</span></span><br><span class="line">&#125;</span><br><span class="line">模块里的变量用<span class="keyword">export</span>暴露出去，当其它地方需要使用时，引入模块便可。</span><br><span class="line"></span><br><span class="line">使用全局变量：</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">global</span> <span class="keyword">from</span> <span class="string">&#x27;../../components/Global&#x27;</span><span class="comment">//引用模块进来</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">         token:<span class="built_in">global</span>.token,<span class="comment">//将全局变量赋值到data里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2、全局变量模块挂载到Vue.prototype上

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Global.vue文件同上，在项目入口的main.js里配置：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">global</span> <span class="keyword">from</span> <span class="string">&#x27;../../components/Global&#x27;</span></span><br><span class="line">Vue.prototype.GLOBAL = <span class="built_in">global</span></span><br><span class="line">挂载之后，在需要引用全局变量的模块处，不需再导入全局变量模块，而是直接用<span class="built_in">this</span>就可以引用了，如下:</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">     token: <span class="built_in">this</span>.GLOBAL.token,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

方法一跟方法二的主要区别是，方法二全局只需要导入一次就可以，简单方便。

3、使用vuex定义全局变量

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态。因此可以存放着全局量。</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js文件里定义vuex</span></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// state.js里面存放全局变量，并且暴露出去</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  token：<span class="string">&#x27;12345678&#x27;</span>,</span><br><span class="line">  language: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> state</span><br><span class="line"></span><br><span class="line">使用的时候，在需要引用全局变量的模块处直接使用<span class="built_in">this</span>.$store调用</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">getInternation</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$store.state.language === <span class="string">&#x27;en&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.internation = <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.$store.state.language === <span class="string">&#x27;zh_CN&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.internation = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

因为Vuex有点繁琐，有点杀鸡用牛刀的感觉。因此认为并没有必要使用它。

## 定义全局函数

原理：在main.js里面通过Vue.prototype将函数挂载到Vue实例上面，通过this.函数名，来运行函数。

1、在main.js文件直接定义方法

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">简单的函数可以直接写在main.js文件里定义。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将方法挂载到vue原型上</span></span><br><span class="line">Vue.prototype.changeData = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;执行成功&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用的时候组件里直接调用。</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接通过this运行函数，这里this是vue实例对象</span></span><br><span class="line"><span class="built_in">this</span>.changeData();</span><br></pre></td></tr></table></figure>

2、使用全局函数专用模块，挂载到main.js上面

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">base.js文件，文件位置可以放在跟main.js同一级，方便引用（这点可以依据个人习惯决定）。</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">    Vue.prototype.changeData = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;执行成功&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main.js引入并使用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base <span class="keyword">from</span> <span class="string">&#x27;./base&#x27;</span></span><br><span class="line">Vue.use(base);</span><br><span class="line">所有的组件里就可以调用该函数。</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.changeData();</span><br></pre></td></tr></table></figure>



# VUE的生命周期

生命周期：

​    beforecreate : 一般使用场景是在加 loading事件 的时候
​    created ：处于loading结束后，还做一些初始化，实现函数自执行（data数据已经初始化，但是DOM结构渲染完成，组件没有加载）
​    beforemount：处于组件创建完成，但未开始执行操作
​    mounted (安装)：处于发起后端请求，获取数据，配合路由钩子执行操作（DOM渲染完成，组件挂载完成 ）
​    beforeupdate、updated：处于数据更新的前后
​    beforeDestroy：当前组件还在的时候，想删除组件
​    destroyed ：当前组件已被销毁，清空相关内容

![clipboard.png](8.6.VUE/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVjlSR1A_dz0xMjAwJmg9MzAzOQ)

created 与 mounted 的区别

created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

mounted 与 methods 的区别

mounted 是生命周期方法之一，会在对应生命周期时执行。

methods 是Vue实例对象上绑定的方法，供当前Vue组件作用域内使用，未调用不会执行，只执行逻辑，返回值可有可无。

computed 与 watched 的区别

computed 是计算属性，也可以理解为一个方法。其中计算的结果如果不发生改变就不会触发，且必须返回一个值并在DOM中绑定的才能取得值。他可以自动获取数据的改变。

watched 属性是手动定义的所需监听的值，不同的数据可以在其中多次定义监听值，这时会消耗一定性能，他并不能像computed那样自动改变。



activated 生命周期在keep-alive 组件激活时调用（在挂载后和更新前被调用的）。被`<keep-alive>`包裹的组件其会被缓存

服务器端渲染期间不调用该生命周期

通常和deactivated周期一起使用

`<keep-alive>`包裹动态组件的时候，会缓存不活动的组件实例，而不是摧毁他们。其是一个抽象的组件，自身不会渲染一个DOM元素，也不会出现在父组件链中。

activated()函数就是一个页面激活后的钩子函数，一进入页面就触发；

所以当我们运用了组件缓存时，如果想每次切换都发送一次请求的话，需要把请求函数写在activated中，而写在created或mounted中其只会在首次加载该组件的时候起作用

按自己的话说：actived相当于是一个缓存，当为false的时候，相当于没有actived，不会起任何作用。当为true时，第一次加载时会执行created，mounted，actived函数，当之后再执行的时候，不会执行created，mounted，只会执行actived

keep-alive组件除了actived，还有deactived函数钩子：

actived是keep-alive组件激活时使用

deactived是keep-alive组件停用时调用

使用：

1.在router中设置需要缓存的组件

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meta: &#123;</span><br><span class="line">        keepAlive : true </span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

2.`<keep-alive>`包裹需要缓存组件

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--app.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;!--需要缓存组件--&gt;</span><br><span class="line">        &lt;keep-alive&gt;</span><br><span class="line">            &lt;!--router-view组件是一个 functional 组件，渲染路径匹配到的视图组件--&gt;</span><br><span class="line">          &lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">        &lt;&#x2F;keep-alive&gt;</span><br><span class="line">        &lt;!--不需要缓存组件--&gt;</span><br><span class="line">        &lt;router-view v-if&#x3D;&quot;!$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">        &lt;moduleFooter&gt;&lt;&#x2F;moduleFooter&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

3.vue页面使用：第一次进入，钩子的触发顺序created-> mounted-> activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated
4.还可以动态控制是否缓存组件，代码如下：

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 设置下一个路由的 meta</span></span><br><span class="line">  to.meta.keepAlive = <span class="literal">false</span>; <span class="comment">// 不缓存，即刷新</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



# `==`和`===`的区别

1`==`'1';这个等式是成立的；
1`===`'1';这个等式是不成立的。
`==`只判断数值，`===`既判断数值，也判断类型。



# 对象的拷贝

Object.assign()对象的拷贝

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span><br><span class="line">Object.assign(target, ...sources)    【target：目标对象】，【souce：源对象（可多个）】</span><br><span class="line">举个栗子：</span><br><span class="line">const object1 &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 &#x3D; Object.assign(&#123;c: 4, d: 5&#125;, object1);</span><br><span class="line"></span><br><span class="line">console.log(object2.c, object2.d);</span><br><span class="line">console.log(object1)  &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(object2)  &#x2F;&#x2F; &#123; c: 3, d: 5, a: 1, b: 2 &#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性</span><br><span class="line">2.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标</span><br><span class="line">对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如</span><br><span class="line">果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到</span><br><span class="line">原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</span><br></pre></td></tr></table></figure>

Object.assign()对象的深拷贝

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。</span><br><span class="line">let obj1 &#x3D; &#123; a: 0 , b: &#123; c: 0&#125;&#125;; </span><br><span class="line">let obj2 &#x3D; Object.assign(&#123;&#125;, obj1); </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 0, b: &#123; c: 0&#125;&#125; </span><br><span class="line"></span><br><span class="line">obj1.a &#x3D; 1; </span><br><span class="line">console.log(JSON.stringify(obj1)); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 0&#125;&#125; </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 0, b: &#123; c: 0&#125;&#125; </span><br><span class="line"></span><br><span class="line">obj2.a &#x3D; 2; </span><br><span class="line">console.log(JSON.stringify(obj1)); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 0&#125;&#125; </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 2, b: &#123; c: 0&#125;&#125;</span><br><span class="line"> </span><br><span class="line">obj2.b.c &#x3D; 3; </span><br><span class="line">console.log(JSON.stringify(obj1)); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 3&#125;&#125; </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 2, b: &#123; c: 3&#125;&#125; </span><br><span class="line">最后一次赋值的时候，b是值是对象的引用，只要修改任意一个，其他的也会受影响</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deep Clone （深拷贝）</span><br><span class="line">obj1 &#x3D; &#123; a: 0 , b: &#123; c: 0&#125;&#125;; </span><br><span class="line">let obj3 &#x3D; JSON.parse(JSON.stringify(obj1)); </span><br><span class="line">obj1.a &#x3D; 4; </span><br><span class="line">obj1.b.c &#x3D; 4; </span><br><span class="line">console.log(JSON.stringify(obj3)); &#x2F;&#x2F; &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br></pre></td></tr></table></figure>

对象的合并

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const o1 &#x3D; &#123; a: 1 &#125;;</span><br><span class="line">const o2 &#x3D; &#123; b: 2 &#125;;</span><br><span class="line">const o3 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Object.assign(o1, o2, o3);</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(o1);  &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span><br><span class="line">其实就是对象的拷贝，o1就是目标对象，后面的是源对象，后面的属性等会拷贝到目标对象</span><br></pre></td></tr></table></figure>

合并具有相同属性的对象

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const o1 &#x3D; &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class="line">const o2 &#x3D; &#123; b: 2, c: 2 &#125;;</span><br><span class="line">const o3 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Object.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">1.属性被后续参数中具有相同属性的其他对象覆盖。</span><br><span class="line">2.目标对象的属性与源对象的属性相同，源的会覆盖目标的属性</span><br></pre></td></tr></table></figure>

继承属性和不可枚举属性是不能拷贝

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; Object.create(&#123;foo: 1&#125;, &#123; &#x2F;&#x2F; foo 是个继承属性。</span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: 2  &#x2F;&#x2F; bar 是个不可枚举属性。</span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        enumerable: true  &#x2F;&#x2F; baz 是个自身可枚举属性。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">创建对象时，如果没有设置enumerable的值，默认为false（不可枚举属性），设置为true，则为可枚举属性</span><br><span class="line">const copy &#x3D; Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); &#x2F;&#x2F; &#123; baz: 3 &#125;</span><br></pre></td></tr></table></figure>

原始类型会被包装为对象

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const v1 &#x3D; &quot;abc&quot;;</span><br><span class="line">const v2 &#x3D; true;</span><br><span class="line">const v3 &#x3D; 10;</span><br><span class="line">const v4 &#x3D; Symbol(&quot;foo&quot;)</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); </span><br><span class="line">&#x2F;&#x2F; 原始类型会被包装，null 和 undefined 会被忽略。</span><br><span class="line">&#x2F;&#x2F; 注意，只有字符串的包装对象才可能有自身可枚举属性。</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure>

异常会打断后续拷贝任务

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    writable: false</span><br><span class="line">&#125;); &#x2F;&#x2F; target 的 foo 属性是个只读属性。</span><br><span class="line"></span><br><span class="line">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class="line">&#x2F;&#x2F; TypeError: &quot;foo&quot; is read-only</span><br><span class="line">&#x2F;&#x2F; 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class="line"></span><br><span class="line">console.log(target.bar);  &#x2F;&#x2F; 2，说明第一个源对象拷贝成功了。</span><br><span class="line">console.log(target.foo2); &#x2F;&#x2F; 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class="line">console.log(target.foo);  &#x2F;&#x2F; 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class="line">console.log(target.foo3); &#x2F;&#x2F; undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class="line">console.log(target.baz);  &#x2F;&#x2F; undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure>



# rules方法

用于前端校验数据，校验表单，可以用rules模块





# 关于VUE的data里的数据问题

Vue 不允许在已经创建的实例上动态添加新的根级响应式属性。也就是说创建过后，data中不允许添加根数据

## 1. 对对象处理

- Vue可以检测到对象属性的修改，不能检测到对象属性的添加和删除，也就是说这种方式处理后，vue不能检察到数据变化，不能进行渲染更新，Vue可以使用Vue.set 和 Vue.delete实现

1. **Vue.set**
   Vue.set 方法用于设置对象的属性，它可以解决 Vue 无法检测添加属性的限制，语法格式如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set( target, key, value )</span><br></pre></td></tr></table></figure>

1. **Vue.delete**
   Vue.delete 用于删除动态添加的属性 语法格式：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.delete( target, key )</span><br></pre></td></tr></table></figure>

## 2. 对数组的处理

- vue中的被包装的观察数组能够触发视图更新
- 有push(),pop(),shift(),unshift(),splice(),sort(),reverse()
- 不能检测到下面数组变化：
  1）直接用索引设置属性，如 vm.item[0] = { }
  2）修改数组长度，如vm.items.length = 0
- 用$set
  Vue 包含一组观察数组的变异方法，它们将会触发视图更新，包含以下方法：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">push() 接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度</span><br><span class="line">pop() 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项</span><br><span class="line">shift() 移除数组中的第一个项并返回该项，同时数组的长度减1</span><br><span class="line">unshift() 在数组前端添加任意个项并返回新数组长度</span><br><span class="line">splice() 删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员</span><br><span class="line">sort() 调用每个数组项的toString()方法，然后比较得到的字符串排序，返回经过排序之后的数组</span><br><span class="line">reverse() 用于反转数组的顺序，返回经过排序之后的数组</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123;message: &#39;Foo&#39; &#125;,</span><br><span class="line">      &#123;message: &#39;Bar&#39; &#125;,</span><br><span class="line">      &#123;message: &#39;Baz&#39; &#125;</span><br><span class="line">    ],</span><br><span class="line">    addValue:&#123;message:&#39;zyb&#39;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    push()&#123;</span><br><span class="line">      this.items.push(this.addValue)</span><br><span class="line">    &#125;,</span><br><span class="line">    pop()&#123;</span><br><span class="line">      this.items.pop()</span><br><span class="line">    &#125;,</span><br><span class="line">    shift()&#123;</span><br><span class="line">      this.items.shift()</span><br><span class="line">    &#125;,</span><br><span class="line">    unshift()&#123;</span><br><span class="line">      this.items.unshift(this.addValue)</span><br><span class="line">    &#125;,</span><br><span class="line">    splice()&#123;</span><br><span class="line">      this.items.splice(0,1)</span><br><span class="line">    &#125;,</span><br><span class="line">    sort()&#123;</span><br><span class="line">     this.items.sort()</span><br><span class="line">    &#125;,</span><br><span class="line">    reverse()&#123;</span><br><span class="line">      this.items.reverse()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

### 变异方法与非变异方法

变异方法(mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异(non-mutating method)方法，例如：map(), filter(), concat(), slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组。同样页面会重新渲染
以下两种方式都可以实现和vm.items[indexOfItem]=newValue相同的效果， 同时也将触发状态更新

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">concat() 先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</span><br><span class="line">slice() 基于当前数组中一个或多个项创建一个新数组，接受一个或两个参数，即要返回项的起始和结束位置，最后返回新数组。</span><br><span class="line">map() 对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组、</span><br><span class="line">filter() 对数组中的每一项运行给定函数，该函数会返回true的项组成的数组</span><br></pre></td></tr></table></figure>

## 3.注意

$set()方法更新时，页面会全部更新一遍，包括其他数据
某个数据更新，会更新渲染所有数据



# 刷新页面

1、this.$router.go(0)

这种方法页面会一瞬间的白屏，体验不是很好，虽然只是一行代码的事

2、location.reload()

这种也是一样，画面一闪，效果总不是很好

3、跳转空白页再跳回原页面

在需要页面刷新的地方写上：this.$router.push('/emptyPage')，跳转到一个空白页。在emptyPage.vue里beforeRouteEnter 钩子里控制页面跳转，从而达到刷新的效果

beforeRouteEnter (to, from, next) {
   next(vm => {
    vm.$router.replace(from.path)
   })
}。

这种画面虽不会一闪，但是能看见路由快速变化。

4、控制`<router-view>`的显示隐藏

默认`<router-view v-if="isRouterAlive" />`isRouterAlive肯定是true，在需要刷新的时候把这个值设为false，接着再重新设为true：

this.isRouterAlive = false
this.$nextTick(function () {
 this.isRouterAlive = true
})
这种方法从画面上是看不出破绽的。也可以搭配provide、inject使用。例如：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;router-view v-if&#x3D;&quot;isRouterAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"> &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">  name: &#39;app&#39;,</span><br><span class="line">  provide()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      reload:this.reload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      isRouterAlive:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    reload()&#123;</span><br><span class="line">      this.isRouterAlive &#x3D;false;</span><br><span class="line">      this.$nextTick(function()&#123;</span><br><span class="line">        this.isRouterAlive&#x3D;true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>


然后在需要刷新的页面引入依赖：inject: ['reload'],

在需要执行的地方直接调用方法即可：this.reload()。

我的业务需求是在home里，页面右上角，在我的里面点击修改个人资料成功后，页面1就要刷新一下，如果是在app里面搭配provide、inject这样用的话，会出现一个问题，就是所有的弹窗以及menu部分就都不见了。还没有找到为什么，，

后来发现，我的需求不通过刷新页面也可以解决，就是利用VUE组件通信，监听事件发生，然后重新调一下获取数据的接口就行。

也就是说：

1、给Vue的原型上添加一个bus属性

main.js：Vue.prototype.$bus = new Vue()

2、home页面进行修改个人资料操作时触发事件，

home.vue： changeProfile （） {this.$bus.$emit('change')}

3、页面1里监听如果执行了操作，就调取页面1需要重新加载的数据接口。

mounted () {
 this.$bus.$on('change', ()=> {
  this.doSomething()
 })
},
对于我的需求来说，页面刷新的第四种方法和利用组件通信都能解决我的问题，前者更简单后者更专业，也更强大




# VUE项目的运行

1.先加载依赖包：控制台直接输入` npm install`

也可以webstorm软件进去右下角会出现一个` npm install`，直接点击

install的意思是安装前端用到的依赖包，运行之后，会生成一个node_modules文件。

2.本地运行项目可以控制台执行命令: `npm run serve`代表执行本地运行项目，此时运行的端口号默认为8080，后端的接口配置为.env.development（测试环境）文件下的端口号。

也可以使用webstorm自带的工具：右上角选“+”，找到npm，在npm的edit界面：Command设置为`run`，Scripts为 ` serve`，（记得选当前文件的package.json）默认端口号为8080，也可以在Environment里自己写，port=XXXX（端口号自己随便设置）

![image-20210412195648588](C:\Users\swx\AppData\Roaming\Typora\typora-user-images\image-20210412195648588.png)

运行后出现localhost：8080一般就成功了。

3.打包时控制台输入命令：`npm run build`，代表打包，完成后会生成一个dist文件夹，就是打包后的项目，部署到服务器即发布成功。build会执行.env.production（生产环境）下的配置

dist文件夹：

css文件夹下的.css文件是项目要用到的css文件,当你做webpack打包的时候，会把所有的css样式打包到这里
css文件夹下的.css.map文件是一个Source map文件，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。目的是帮助我们调试被压缩过的css代码，只是方便我们开发的时候做调试使用。
js文件夹下的.js.map依然是Source map文件，方便我们开发时调试js代码使用。
app.js文件里放的是项目中各个页面的逻辑代码
manifest.js文件可以理解为webpack打包生成的一个配置文件，我们一般不需要关心它
vendor.js放的是各个页面各个组件公用的一些代码
index.html使我们前端代码入口的一个html文件




      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/8.6.VUE/" data-id="ckw61se0i007moswd8pw112z0" data-title="VUE" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2.1.Typora使用快捷键" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/2.1.Typora%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:04:13.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/2.1.Typora%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/">Typora使用快捷键</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#+空格</td>
<td align="left">标题（几个#就是几级标题）</td>
</tr>
<tr>
<td align="left">ctrl+数字</td>
<td align="left">数字是几就是几级标题</td>
</tr>
<tr>
<td align="left">```+代码格式英文</td>
<td align="left">相应的代码块</td>
</tr>
<tr>
<td align="left">Ctrl+Shift+K</td>
<td align="left">插入代码块(```xxx)</td>
</tr>
<tr>
<td align="left">左下角启用源代码格式</td>
<td align="left">加```可以修改代码块的位置</td>
</tr>
<tr>
<td align="left">Ctrl + /</td>
<td align="left">源代码模式</td>
</tr>
<tr>
<td align="left">``中间放要引用的东西</td>
<td align="left">相应的代码片</td>
</tr>
<tr>
<td align="left">Ctrl+Shift+`</td>
<td align="left">插入代码片(<code>xxx</code>)</td>
</tr>
<tr>
<td align="left">—</td>
<td align="left">分隔符</td>
</tr>
<tr>
<td align="left">-+空格</td>
<td align="left">例举的圆点</td>
</tr>
<tr>
<td align="left">ctrl+b</td>
<td align="left">加粗</td>
</tr>
<tr>
<td align="left">Ctrl+U</td>
<td align="left">下划线</td>
</tr>
<tr>
<td align="left">Ctrl+I</td>
<td align="left">倾斜</td>
</tr>
<tr>
<td align="left">Ctrl+[</td>
<td align="left">减少缩进</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + V</td>
<td align="left">粘贴为纯文本</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ctrl+t</td>
<td align="left">插入一个表格</td>
</tr>
<tr>
<td align="left">表格里ctrl+回车</td>
<td align="left">下面新加一行</td>
</tr>
<tr>
<td align="left">Ctrl + Shift + Backspace</td>
<td align="left">删除行（在表中）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新</td>
<td align="left">Ctrl + N.</td>
<td align="left">Command + N.</td>
</tr>
<tr>
<td align="left">新窗户</td>
<td align="left">Ctrl + Shift + N.</td>
<td align="left">Command + Shift + N.</td>
</tr>
<tr>
<td align="left">打开</td>
<td align="left">Ctrl + O.</td>
<td align="left">Command + O.</td>
</tr>
<tr>
<td align="left">快速打开</td>
<td align="left">Ctrl + P.</td>
<td align="left">Command + Shift + O.</td>
</tr>
<tr>
<td align="left">重新打开已关闭的文件</td>
<td align="left">Ctrl + Shift + T.</td>
<td align="left">Command + Shift + T.</td>
</tr>
<tr>
<td align="left">另存为/重复</td>
<td align="left">Ctrl + Shift + S.</td>
<td align="left">Command + Shift + S.</td>
</tr>
<tr>
<td align="left">偏爱/偏好设置</td>
<td align="left">Ctrl +，</td>
<td align="left">Command +，</td>
</tr>
<tr>
<td align="left">关</td>
<td align="left">Ctrl + W</td>
<td align="left">Command + W</td>
</tr>
</tbody></table>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新段落</td>
<td align="left">输入</td>
<td align="left">输入</td>
</tr>
<tr>
<td align="left">新队</td>
<td align="left">Shift + Enter</td>
<td align="left">Shift + Enter</td>
</tr>
<tr>
<td align="left">复制为Markdown</td>
<td align="left">Ctrl + Shift + C.</td>
<td align="left">Command + Shift + C.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">Command + Shift + V.</td>
</tr>
<tr>
<td align="left">全选</td>
<td align="left">Ctrl + A.</td>
<td align="left">Command + A.</td>
</tr>
<tr>
<td align="left">选择行/句子 选择行（在表格中）</td>
<td align="left">Ctrl + L.</td>
<td align="left">Command + L.</td>
</tr>
<tr>
<td align="left">选择样式范围 选择单元格（在表格中）</td>
<td align="left">Ctrl + E.</td>
<td align="left">Command + E.</td>
</tr>
<tr>
<td align="left">选择Word</td>
<td align="left">Ctrl + D.</td>
<td align="left">Command + D.</td>
</tr>
<tr>
<td align="left">删除Word</td>
<td align="left">Ctrl + Shift + D.</td>
<td align="left">Command + Shift + D.</td>
</tr>
<tr>
<td align="left">跳到顶部</td>
<td align="left">Ctrl + Home</td>
<td align="left">Command +↑</td>
</tr>
<tr>
<td align="left">跳转到选择</td>
<td align="left">Ctrl + J</td>
<td align="left">Command + J</td>
</tr>
<tr>
<td align="left">跳到Buttom</td>
<td align="left">Ctrl + End</td>
<td align="left">Command +↓</td>
</tr>
<tr>
<td align="left">找</td>
<td align="left">Ctrl + F.</td>
<td align="left">Command + F.</td>
</tr>
<tr>
<td align="left">找下一个</td>
<td align="left">F3 /回车</td>
<td align="left">Command + G / Enter</td>
</tr>
<tr>
<td align="left">找到上一个</td>
<td align="left">Shift + F3 / Shift + Enter</td>
<td align="left">Command + Shift + G / Shift + Enter</td>
</tr>
<tr>
<td align="left">更换</td>
<td align="left">Ctrl + H.</td>
<td align="left">Command + H.</td>
</tr>
</tbody></table>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">段</td>
<td align="left">Ctrl + 0</td>
<td align="left">命令+ 0</td>
</tr>
<tr>
<td align="left">提高标题级别</td>
<td align="left">Ctrl + =</td>
<td align="left">命令+ =</td>
</tr>
<tr>
<td align="left">降低标题级别</td>
<td align="left">Ctrl + -</td>
<td align="left">命令+ -</td>
</tr>
<tr>
<td align="left">表</td>
<td align="left">Ctrl + T.</td>
<td align="left">Command + Option + T.</td>
</tr>
<tr>
<td align="left">代码围栏</td>
<td align="left">Ctrl + Shift + K.</td>
<td align="left">Command + Option + C.</td>
</tr>
<tr>
<td align="left">数学块</td>
<td align="left">Ctrl + Shift + M.</td>
<td align="left">Command + Option + B.</td>
</tr>
<tr>
<td align="left">引用</td>
<td align="left">Ctrl + Shift + Q.</td>
<td align="left">Command + Option + Q.</td>
</tr>
<tr>
<td align="left">订购清单</td>
<td align="left">Ctrl + Shift + [</td>
<td align="left">Command + Option + O.</td>
</tr>
<tr>
<td align="left">无序列表</td>
<td align="left">Ctrl + Shift +]</td>
<td align="left">Command + Option + U.</td>
</tr>
<tr>
<td align="left">减少缩进</td>
<td align="left">Ctrl +] / Shift + Tab</td>
<td align="left">Command +] / Shift + Tab</td>
</tr>
</tbody></table>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">罢工</td>
<td align="left">Alt + Shift + 5</td>
<td align="left">Control + Shift +`</td>
</tr>
<tr>
<td align="left">超链接</td>
<td align="left">Ctrl + K.</td>
<td align="left">Command + K.</td>
</tr>
<tr>
<td align="left">图片</td>
<td align="left">Ctrl + Shift + I</td>
<td align="left">Command + Control + I</td>
</tr>
<tr>
<td align="left">清除格式</td>
<td align="left">Ctrl + \</td>
<td align="left">命令+</td>
</tr>
</tbody></table>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">热键（Windows / Linux）</th>
<th align="left">热键（macOS）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">切换补充工具栏</td>
<td align="left">Ctrl + Shift + L.</td>
<td align="left">Command + Shift + L.</td>
</tr>
<tr>
<td align="left">大纲</td>
<td align="left">Ctrl + Shift + 1</td>
<td align="left">Command + Control + 1</td>
</tr>
<tr>
<td align="left">用品</td>
<td align="left">Ctrl + Shift + 2</td>
<td align="left">Command + Control + 2</td>
</tr>
<tr>
<td align="left">文件树</td>
<td align="left">Ctrl + Shift + 3</td>
<td align="left">Command + Control + 3</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Fouus模式</td>
<td align="left">F8</td>
<td align="left">F8</td>
</tr>
<tr>
<td align="left">打字机模式</td>
<td align="left">F9</td>
<td align="left">F9</td>
</tr>
<tr>
<td align="left">Toggler全屏</td>
<td align="left">F11</td>
<td align="left">Command + Option + F.</td>
</tr>
<tr>
<td align="left">真实大小</td>
<td align="left">Ctrl + Shift + 0</td>
<td align="left"><em>（不支持）</em></td>
</tr>
<tr>
<td align="left">放大</td>
<td align="left">Ctrl + Shift + =</td>
<td align="left"><em>（不支持）</em></td>
</tr>
<tr>
<td align="left">缩小</td>
<td align="left">Ctrl + Shift + -</td>
<td align="left"><em>（不支持）</em></td>
</tr>
<tr>
<td align="left">在打开的Documnets之间切换</td>
<td align="left">Ctrl + Tab</td>
<td align="left">命令+`</td>
</tr>
<tr>
<td align="left">切换DevTools</td>
<td align="left">Ctrl + Shift + I</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>基本功能快捷键</p>
<p>字体操作快捷键<br>功能    快捷键</p>
<p>删除线    Alt+Shift+5</p>
<p>插入功能快键键<br>功能    快键键<br>插入图片(本地图片可直接拖入)    Ctrl+Shift+I</p>
<p>插入有序列表    Ctrl+Shift+[<br>插入无序列表    Ctrl+Shift+]<br>插入超链接    Ctrl+K</p>
<p>插入公式块    Ctrl+Shift+M<br>插入引用块    Ctrl+Shift+Q</p>
<p>标题段落快捷键<br>MarkDown支持六级标题，可以使用Ctrl+数字 指定不同层次的标题和段落</p>
<p>功能    快捷键<br>段落（正文）    Ctrl+0</p>
<p>提升标题级别    Ctrl+‘+’<br>降低标题级别    Ctrl+‘-’</p>
<p>功能    快捷键</p>
<p>上移该行    Alt+↑<br>下移该行    Alt+↓<br>左移该列    Win键+←<br>右移该列    Win键+→<br>删除该行    Ctrl+退格键(BackSpace)<br>左右移动表格列的快捷键与WinDows系统自带的快捷键冲突，导致失效</p>
<p>删除行快捷键，不知道为什么没有生效</p>
<p>视图操作快捷键<br>侧边栏<br>功能    快捷键<br>大纲视图    Ctrl+Shift+1<br>文件列表视图    Ctrl+Shift+2<br>文件树视图<br>显示/隐藏侧边栏<br>放大视图    Ctrl+Shift+‘+’<br>缩小视图    Ctrl+Shift+‘-’<br>恢复原来大小视图    Ctrl+Shift+9</p>
<p>编辑模式<br>功能    快捷键<br>源代码模式    Ctrl+/<br>专注模式(当前编辑行为黑，其他行为灰色)    F8<br>打字机模式(光标始终在屏幕中央位置)    F9<br>其他<br>功能    快捷键<br>全屏    F11<br>应用内窗口切换    Ctrl+Tab<br>开发者工具    Shift+F12</p>
<p>搜索扩展快捷键<br>功能    快捷键</p>
<p>替换    Ctrl+H<br>查找下一个    F3<br>查找上一个    Shift+F3</p>
<p>基本操作快键键<br>选择操作<br>功能    快捷键<br>全选    Ctrl+A<br>选择当前行/句    Ctrl+L<br>选择当前格式文本    Ctrl+E<br>选择当前单词    Ctrl+D<br>删除当前单词    Ctrl+Shift+D</p>
<p>跳转操作<br>功能    快捷键<br>跳转到文首    Ctrl+Home<br>跳转到所选内容    Ctrl+J<br>跳转到文末    Ctrl+End</p>
<p>粘贴复制操作<br>功能    快捷键</p>
<p>复制为MarkDown标记语法    Ctrl+Shift+C<br>粘贴为纯文本    Ctrl+Shift+V</p>
<p>文件操作<br>功能    快捷键<br>新建    Ctrl+N<br>新建窗口(在Windows中，这两个作用一样)    Ctrl+Shift+N<br>打开文件    Ctrl+O<br>快速打开(在最近打开中打开)    Ctrl+P</p>
<p>偏好设置    Ctrl+，<br>关闭    Ctrl+W<br>重新打开关闭的文件    Ctrl+Shift+T</p>
<p>其他<br>功能    快捷键<br>清楚样式    Ctrl+<br>增加缩进    Ctrl+]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/2.1.Typora%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" data-id="ckw61sduu000noswdc2smd68c" data-title="Typora使用快捷键" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-10.3.项目编写文档" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/10.3.%E9%A1%B9%E7%9B%AE%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T08:57:29.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/10.3.%E9%A1%B9%E7%9B%AE%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3/">编写文档</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>项目开发过程中为了增加程序的可读性和程序的健壮性， 方便后期程序的调试和维护，所以需要在开发过程中统一技术规范，一般会在项目初期确定好相关文档作为这一统一的规范。不同公司会对文档做不同要求，划不同的分类，但一般来说大致可以分为需求文档、接口文档、流程图（可以单独作为一份文件可以作为附件附在文档中）、变更文件等。</p>
<h1 id="需求文档"><a href="#需求文档" class="headerlink" title="需求文档"></a>需求文档</h1><p>在项目启动之后，项目的目标已经明确了，那么就要开始着手干活了，但是在干活之前，需要对整个项目分析透彻。</p>
<p>首先，开发人员要有随意转换身份的意识和能力。</p>
<p>1.明确产品功能</p>
<p>在分析业务时，站在用户的角度上，思考要做的产品能实现什么功能。把所有的功能点列出来！</p>
<p>2.分析某一功能点的流程</p>
<p>在罗列了所有的功能之后，需要站在开发者的角度分析每一个功能点，考虑从客户端到后台操作数据库的整个流程，可以从是什么、为什么、在哪、怎么做、谁来做、做完如何反馈、反馈给谁、上传到哪、服务器用什么数据库、数据库需要什么表、表里有什么字段、每个字段的属性及意义等等。</p>
<p>比如，我要要做一个软件中个人头像上传的功能，首先明确我做的是上传功能；为什么要上传？因为个人资料需要头像；怎么做上传？通过网络I/O实现；这个功能在什么位置？软件有个个人中心模块，个人中心里有个个人信息子模块，在这个模块里可以上传头像；谁上传？已经登录的用户；上传完之后如何反馈？弹窗提示上传成功；反馈给谁？客户端已登录的用户；上传到哪？服务器上；用什么数据库？MySQL;需要什么表？（存到）用户表；表里有什么字段？用户信息的基本字段；每个字段的属性及意义？略。在思考完这些问题之后，可以把一个功能点串成一条完整的从前端到数据库的线。</p>
<p>3.整合各个功能点–明确分工</p>
<p>在串完所有的功能点之后，站在一个高一层次的角度，把每个功能点之间的联系理清楚，按照相互的联系分工合作，优化其中的细节问题。</p>
<p>4.撰写需求文档</p>
<p>分工完成之后，按照第二步分析的内容，每个人把自己负责的功能整理成文档，最后合并文档，作为统一的需求文档。</p>
<p>5.绘制业务流程图</p>
<p>需求文档确定之后，绘制整个项目的业务流程图，这时候的流程图只需要包含前端的业务流程，后台实现的流程图不需要在需求文档中体现，而是放在后面的接口文档中。</p>
<h1 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h1><p>不同公司对接口文档的要求也不尽相同，但包括的内容却是大同小异的。封面、标题、审批页、修订历史以及格式字体等等是次要内容，主要内容包括：</p>
<p>1.请求地址</p>
<p>需要哪个线上地址就写哪个。注意不要犯低级错误，比如写错某个字母或者大小写问题。</p>
<p>2.接口信息</p>
<p>说明请求方式，是POST还是GET。</p>
<p>3.功能描述</p>
<p>清晰地描述接口功能，要求言简意赅，不要写太多废话，也不要遗漏任何细节。</p>
<p>4.接口参数说明</p>
<p>声明参数的名称，严格要求与调用一致，包括大小写；</p>
<p>简单说明参数的含义；</p>
<p>参数的数据类型，是string 、int 还是long等（例如参数为@RequestParam(“appKey”)  String appKey,  @RequestParam(“randomId”)  Integer randomId）；</p>
<p>备注部分，说明参数值是需要哪个公司提供，并详细说明参数怎么生成的，例如时间戳，是哪个时间段的；参数是否必填，一些参数是必须要有的，有些是可选参数，一定要注意写清晰。</p>
<p>5.返回值说明</p>
<p>有一个模板返回值，并说明每个返回参数的意义。提供一个真实的调用接口，真实的返回值。</p>
<p>6.接口调用限制</p>
<p>为了安全，双方采用一个一致的加密算法，保证接口调用的安全。</p>
<p>7.文档维护</p>
<p>文档维护时，修改内容部分需要有修改人、修改日期、版本号的信息。</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>流程图可以单独作为一份文件，也可以作为附件附在对应的文档中，具体执行按要求来。</p>
<p>1.业务流程图</p>
<p>2.程序结构图</p>
<p>3.程序流程图</p>
<h1 id="变更文件"><a href="#变更文件" class="headerlink" title="变更文件"></a>变更文件</h1><p>在开发过程中如果出现与预期计划、文档不一致的地方，则视为发生变更，此时大致需要提供以下信息：</p>
<p>1.版本历史（版本号、基本信息）</p>
<p>2.变更前现状</p>
<p>3.变更内容</p>
<p>4.影响评估</p>
<p>5.审批</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/10.3.%E9%A1%B9%E7%9B%AE%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3/" data-id="ckw61sduo0007oswda7en0spw" data-title="编写文档" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-5.2.MySQL进阶" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/5.2.MySQL%E8%BF%9B%E9%98%B6/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:43:51.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/5.2.MySQL%E8%BF%9B%E9%98%B6/">MySQL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引，类似书籍的目录，可以根据目录的某个页码立即找到对应的内容。</p>
<p>索引的优点：1. 天生排序。2. 快速查找。<br>索引的缺点：1. 占用空间。2. 降低更新表的速度。</p>
<p>注意点：小表使用全表扫描更快，中大表才使用索引。超级大表索引基本无效。</p>
<p>索引从实现上说，分成 2 种：聚集索引和辅助索引（也叫二级索引或者非聚集索引）</p>
<p>从功能上说，分为 6 种：普通索引，唯一索引，主键索引，复合索引，外键索引，全文索引。</p>
<p>详细说说 6 种索引：</p>
<p>1、普通索引：最基本的索引，没有任何约束。<br>2、唯一索引：与普通索引类似，但具有唯一性约束。<br>3、主键索引：<strong>特殊的唯一索引，不允许有空值</strong>。<br>4、复合索引：将多个列组合在一起创建索引，可以覆盖多个列。<br>5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。<br>6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎（ES，Solr）。</p>
<ul>
<li><code>注意：主键就是唯一索引，但是唯一索引不一定是主键，唯一索引可以为空，但是空值只能有一个，主键不能为空。</code></li>
</ul>
<p>另外，InnoDB 通过主键聚簇数据，如果没有定义主键且没有定义聚集索引， MySql 会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个 6 字节的主键作为聚簇索引，用户不能查看或访问。</p>
<p>简单点说：</p>
<ol>
<li>设置主键时，会自动生成一个唯一索引，如果<strong>之前</strong>没有聚集索引，那么主键就是聚集索引。</li>
<li>没有设置主键时，会选择一个不为空的唯一索引作为聚集索引，如果还没有，那就生成一个隐式的 6 字节的索引。</li>
</ol>
<p>MySql 将数据按照页来存储，默认一页为 16kb，当你在查询时，不会只加载某一条数据，而是将这个数据所在的页都加载到 pageCache 中，这个其实和 OS 的就近访问原理类似。</p>
<p>MySql 的索引使用 B+ 树结构。在说 B+ 树之前，先说说 B 树，B 树是一个多路平衡查找树，相较于普通的二叉树，不会发生极度不平衡的状况，同时也是多路的。</p>
<p>B 树的特点是：他会将数据也保存在非页子节点。</p>
<p>看图可知：</p>
<p><img src="https://pic1.zhimg.com/80/v2-05f597852f53aef1e74cc2f5b5ba4d10_720w.png" alt="img"></p>
<p>而这个特点会导致非页子节点不能存储大量的索引。</p>
<p>而 B+ Tree 就是针对这个对 B tree 做了优化。如下图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-b5a1c7f34e65044a08cdb213f55295fd_720w.png" alt="img"></p>
<p>我们看到，B+ Tree 将所有的 data 数据都保存到了叶子节点中，非也子节点只保存索引和指针。</p>
<p>我们假设一个非页子节点是 16kb，每个索引，即主键是 bigint，即 8b，指针为 8b。那么每页能存储大约 1000 个索引（16kb/ 8b + 8b）.</p>
<p>而一颗 3 层的 B+树能够存储多少索引呢？如下图：</p>
<p><img src="https://pic3.zhimg.com/80/v2-38209d49a486354414b2358f2e88558a_720w.png" alt="img"></p>
<p>大约能够存储 10 亿个索引。通常 B+ 树的高度在 2-4 层，由于 MySql 在运行时，根节点是常驻内存的，因此每次查找只需要大约 2 -3 次 IO。可以说，B+ 树的设计，就是根据机械磁盘的特性来进行设计的。</p>
<p>知道了索引的设计，我们能够知道另外一些信息：</p>
<ol>
<li>MySql 的主键不能太大，如果使用 UUID 这种，将会浪费 B+ 树的非叶子节点。</li>
<li>MySql 的主键最好是自增的，如果使用 UUID 这种，每次插入都会调整 B+树，从而导致页分裂，严重影响性能。</li>
</ol>
<p>那么，如果项目中使用了分库分表，我们通常都会需要一个主键进行 sharding，那怎么办呢？在实现上，我们可以保留自增主键，而逻辑主键用来作为唯一索引即可。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h3 id="2-锁机制"><a href="#2-锁机制" class="headerlink" title="2. 锁机制"></a>2. 锁机制</h3><p>关于 Mysql 的锁，各种概念就会喷涌而出，事实上，锁有好几种维度，我们来解释一下。</p>
<h3 id="1-类型维度"><a href="#1-类型维度" class="headerlink" title="1. 类型维度"></a>1. 类型维度</h3><ul>
<li><p>共享锁（读锁 / S 锁）</p>
</li>
<li><p>排它锁（写锁 / X 锁）<br>类型细分：</p>
</li>
<li><ul>
<li>意向共享锁</li>
<li>意向排他（互斥）锁</li>
</ul>
</li>
</ul>
<ul>
<li>悲观锁（使用锁，即 for update）</li>
<li>乐观锁（使用版本号字段，类似 CAS 机制，即用户自己控制。缺点：并发很高的时候，多了很多无用的重试）</li>
</ul>
<h3 id="2-锁的粒度（粒度维度）"><a href="#2-锁的粒度（粒度维度）" class="headerlink" title="2. 锁的粒度（粒度维度）"></a>2. 锁的粒度（粒度维度）</h3><ul>
<li>表锁</li>
<li>页锁（Mysql BerkeleyDB 引擎）</li>
<li>行锁（InnoDB）</li>
</ul>
<h3 id="3-锁的算法（算法维度）"><a href="#3-锁的算法（算法维度）" class="headerlink" title="3. 锁的算法（算法维度）"></a>3. 锁的算法（算法维度）</h3><ul>
<li>Record Lock（单行记录）</li>
<li>Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）</li>
<li>Next-Key Lock（Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身， MySql 防止幻读，就是使用此锁实现）</li>
</ul>
<h3 id="4-默认的读操作，上锁吗？"><a href="#4-默认的读操作，上锁吗？" class="headerlink" title="4. 默认的读操作，上锁吗？"></a>4. 默认的读操作，上锁吗？</h3><ul>
<li>默认是 MVCC 机制（“一致性非锁定读”）保证 RR 级别的隔离正确性，是不上锁的。</li>
</ul>
<p>可以选择手动上锁：select xxxx for update (排他锁); select xxxx lock in share mode(共享锁)，称之为“一致性锁定读”。</p>
<p>使用锁之后，就能在 RR 级别下，避免幻读。当然，默认的 MVCC 读，也能避免幻读。</p>
<p>既然 RR 能够防止幻读，那么，SERIALIZABLE 有啥用呢？</p>
<p>防止丢失更新。例如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-1917d61efc5d3ab35029004d3eae7dc8_720w.png" alt="img"></p>
<p>这个时候，我们必须使用 SERIALIZABLE 级别进行串行读取。</p>
<p>最后，行锁的实现原理就是锁住聚集索引，如果你查询的时候，没有正确地击中索引，MySql 优化器将会抛弃行锁，使用表锁。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是数据库永恒不变的话题， ACID：原子性，一致性，隔离性，持久性。</p>
<p>四个特性，最重要的就是一致性。而<strong>一致性</strong>（（由DBMS的<strong>完整性子系统</strong>执行测试任务））由原子性，隔离性，持久性来保证。</p>
<ul>
<li>原子性由 Undo log 保证。Undo Log 会保存每次变更之前的记录，从而在发生错误时进行回滚。（由DBMS的<strong>事务管理子系统</strong>来实现）</li>
<li>隔离性由 MVCC 和 Lock 保证。这个后面说。（由DBMS的<strong>并发控制子系统</strong>来实现）</li>
<li>持久性由 Redo Log 保证。每次真正修改数据之前，都会将记录写到 Redo Log 中，只有 Redo Log 写入成功，才会真正的写入到 B+ 树中，如果提交之前断电，就可以通过 Redo Log 恢复记录。（由DBMS的<strong>恢复管理子系统</strong>来实现）</li>
</ul>
<p>然后再说隔离性。</p>
<p>隔离级别：</p>
<ol>
<li>未提交读（RU）</li>
<li>已提交读（RC）</li>
<li>可重复读（RR）</li>
<li>串行化（serializable）</li>
</ol>
<p>每个级别都会解决不同的问题，通常是3 个问题：脏读，不可重复读，幻读。一张经典的图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e4a89f7012dd6511edd7d970ffd0f659_720w.png" alt="img"></p>
<p>这里有个注意点，关于幻读，在数据库规范里，RR 级别会导致幻读，但是，由于 Mysql 的优化，MySql 的 RR 级别不会导致幻读：在使用默认的 select 时，MySql 使用 MVCC 机制保证不会幻读；你也可以使用锁，在使用锁时，例如 for update（X 锁），lock in share mode（S 锁），MySql 会使用 Next-Key Lock 来保证不会发生幻读。前者称为快照读，后者称为当前读。</p>
<p>原理剖析：</p>
<ul>
<li>RU 发生脏读的原因：RU 原理是对每个更新语句的行记录进行加锁，而不是对整个事务进行加锁，所以会发生脏读。而 RC 和 RR 会对整个事务加锁。</li>
<li>RC 不能重复读的原因：RC 每次执行 SQL 语句都会生成一个新的 Read View，每次读到的都是不同的。而 RR 的事务从始至终都是使用同一个 Read View。</li>
<li>RR 不会发生幻读的原因： 上面说过了。</li>
</ul>
<p>那 RR 和 Serializble 有什么区别呢？答：丢失更新。本文关于锁的部分已经提到。</p>
<p>MVCC 介绍：全称多版本并发控制。</p>
<p>innoDB 每个聚集索引都有 4 个隐藏字段，分别是主键（RowID），最近更改的事务 ID（MVCC 核心），Undo Log 的指针（隔离核心），索引删除标记（当删除时，不会立即删除，而是打标记，然后异步删除）；</p>
<p>本质上，MVCC 就是用 Undo Log 链表实现。</p>
<p>MVCC 的实现方式：事务以排它锁的方式修改原始数据，把修改前的数据存放于 Undo Log，通过回滚指针与数据关联，如果修改成功，什么都不做，如果修改失败，则恢复 Undo Log 中的数据。</p>
<p>多说一句，通常我们认为 MVCC 是类似乐观锁的方式，即使用版本号，而实际上，innoDB 不是这么实现的。当然，这不影响我们使用 MySql。</p>
<h1 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h1><p>事务：指的是逻辑上的一组操作，组成这组操作的各个逻辑单元，要么全都成功，要么全都失败。</p>
<p>开启事务：start transaction;</p>
<p>提交事务：commit;</p>
<p>回滚事务：rollback; //恢复到事务开启之前的状态（也相当于提交了事务）</p>
<p>事务的特性：</p>
<p>原子性：事务的不可分割，组成事务的各个逻辑单元不可分割。</p>
<p>一致性：事务执行的前后，数据完整性保持一致。（总和前后相等）</p>
<p>隔离性：事务执行不应该受到其他事务的干扰。</p>
<p>持久性：事务一旦结束，数据就持久化到数据库中。</p>
<p>如果不考虑隔离性（一个事务执行受到其他的事务的干扰），引发一些安全问题，主要体现在读取数据上：</p>
<p>l 脏读：一个事务读到了另一个事务未提交的数据，导致查询结果不一致</p>
<p>l 不可重复读：一个事务读到了另一个事务已经提交的update的数据，导致多次查询结果不一致。</p>
<p>l 虚读/幻读：一个事务读到了另一个事务已经提交的insert的数据，导致多次查询结果不一致。</p>
<p>设置事务的隔离级别：安全性越高的效率越低，一般使用中间两种</p>
<p>read uncommitted（未提交读）：脏读，不可重复读，虚读都有可能发生</p>
<p>read committed（已提交读）：避免脏读。但是不可重复读和虚读是有可能发生</p>
<p>repeatable read（重复读，默认）：避免脏读和不可重复读，但是虚读有可能发生。</p>
<p>serializable（串行化读（一个事务得接着另一个事务执行，禁止并发存在））：避免脏读，不可重复读，虚读。</p>
<p>设置事务的隔离级别： set session transaction isolation level 隔离级别</p>
<p>查看当前的隔离级别：  select @@tx_isolation;</p>
<p>演示脏读：</p>
<p>\1. 开启两个窗口A,B</p>
<p>\2. 设置A窗口的隔离级别为read uncommitted;</p>
<p>\3. 在A，B两个窗口中开启事务</p>
<p>\4. 在B窗口中完成转账的功能，但是不提交事务</p>
<p>\5. 在A窗口中进行查询：查询到已经转账成功了。（这就发生了脏读）</p>
<p>演示不可重复读：</p>
<p>\1. 开启两个窗口A,B</p>
<p>\2. 设置A窗口的隔离级别为read committed;</p>
<p>\3. 分别在两个窗口中开启事务</p>
<p>\4. 在B窗口中完成转账，不提交事务</p>
<p>\5. 在A窗口中进行查询：仍然是未到账（这就避免了脏读）</p>
<p><strong>6.</strong> <em><strong>*在B窗口中提交事务*</strong></em></p>
<p>\7. 在A窗口查询：发现到账了（两次A窗口的查询结果不同，这就是不可重复读）</p>
<p>避免不可重复读：将2中的隔离级别设置为repeatable read；（一个事务中的多次查询结果一致，跳出这个事务才能出现改变后的结果）</p>
<p>（虚读只是概率发生，无法演示）</p>
<p>演示串行化：</p>
<p>\1. 开启两个窗口A,B</p>
<p>\2. 设置A窗口的隔离级别：serializable</p>
<p>\3. 分别在两个窗口中开启事务</p>
<p>\4. 在B窗口中插入一条记录</p>
<p>\5. 在A窗口中进行查询：发现无反应，但是当B窗口提交事务的时候，A窗口会立马输出结果。（说明事务不允许吹袭案并发，A窗口需要等B窗口事务执行完成以后，才会执行A窗口的事务）</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h1 id="解释器explain"><a href="#解释器explain" class="headerlink" title="解释器explain"></a>解释器explain</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+-----+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>select 查询的序列号，包含一组可以重复的数字，表示查询中执行sql语句的顺序。一般有三种情况：  第一种：id全部相同，sql的执行顺序是由上至下；  第二种：id全部不同，sql的执行顺序是根据id大的优先执行；  第三种：id既存在相同，又存在不同的。先根据id大的优先执行，再根据相同id从上至下的执行。</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select 查询的类型，主要是用于区别普通查询，联合查询，嵌套的复杂查询  </p>
<p>simple：简单的select 查询，查询中不包含子查询或者union  </p>
<p>primary：查询中若包含任何复杂的子查询，最外层查询则被标记为primary  </p>
<p>subquery：在select或where 列表中包含了子查询  </p>
<p>derived：在from列表中包含的子查询被标记为derived（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。 </p>
<p>union：若第二个select出现在union之后，则被标记为union，若union包含在from子句的子查询中，外层select将被标记为：derived  union </p>
<p>result：从union表获取结果的select</p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>显示这一行的数据是关于哪张表的</p>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>表所使用的分区，如果要统计十年公司订单的金额，可以把数据分为十个区，每一年代表一个区。这样可以大大的提高查询效率。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>这是一个非常重要的参数，连接类型，常见的有：all , index , range , ref , eq_ref , const , system , null 八个级别。  </p>
<p>性能从最优到最差的排序：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all  </p>
<p>对java程序员来说，若保证查询至少达到range级别或者最好能达到ref则算是一个优秀而又负责的程序员。 </p>
<p>all：（full table scan）全表扫描无疑是最差，若是百万千万级数据量，全表扫描会非常慢。  </p>
<p>index：（full index scan）全索引文件扫描比all好很多，毕竟从索引树中找数据，比从全表中找数据要快。  </p>
<p>range：只检索给定范围的行，使用索引来匹配行。范围缩小了，当然比全表扫描和全索引文件扫描要快。sql语句中一般会有between，in，&gt;，&lt; 等查询。  </p>
<p>ref：非唯一性索引扫描，本质上也是一种索引访问，返回所有匹配某个单独值的行。比如查询公司所有属于研发团队的同事，匹配的结果是多个并非唯一值。  eq_ref：唯一性索引扫描，对于每个索引键，表中有一条记录与之匹配。比如查询公司的CEO，匹配的结果只可能是一条记录，  </p>
<p>const：表示通过索引一次就可以找到，const用于比较primary key 或者unique索引。因为只匹配一行数据，所以很快，若将主键至于where列表中，MySQL就能将该查询转换为一个常量。  </p>
<p>system：表只有一条记录（等于系统表），这是const类型的特列，平时不会出现，了解即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type中包含的值：</span><br><span class="line">system、const： 可以将查询的变量转为常量. 如id&#x3D;1; id为 主键或唯一键.</span><br><span class="line">eq_ref： 访问索引,返回某单一行的数据.(通常在联接时出现，查询使用的索引为主键或惟一键)</span><br><span class="line">ref： 访问索引,返回某个值的数据.(可以返回多行) 通常使用&#x3D;时发生 </span><br><span class="line">range： 这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西，并且该字段上建有索引时发生的情况(注:不一定好于index) </span><br><span class="line">index： 以索引的顺序进行全表扫描，优点是不用排序,缺点是还要全表扫描 </span><br><span class="line">ALL： 全表扫描，应该尽量避免</span><br></pre></td></tr></table></figure>

<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>显示查询语句可能用到的索引(一个或多个或为null)，不一定被查询实际使用。仅供参考使用。如果为空，表示没有可能应用的索引</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>显示查询语句实际使用的索引。若为null，则表示没有使用索引。</p>
<p>MySQL很少会选择优化不足的索引，此时可以在SELECT语句中使用FORCE INDEX（index_name）来强制使用一个索引或者用IGNORE INDEX（index_name）来强制忽略索引</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>显示索引中使用的字节数，可通过key_len计算查询中使用的索引长度。在不损失精确性的情况下索引长度越短越好。</p>
<p>key_len 显示的值为索引字段的最可能长度，并非实际使用长度，即key_len是根据表定义计算而得，并不是通过表内检索出的。</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>显示索引的哪一列或常量被用于查找索引列上的值。</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，值越大越不好。</p>
<h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>关于MySQL如何解析查询的额外信息</p>
<p>Using filesort： 说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序” 。出现这个就要立刻优化sql。  </p>
<p>Using temporary： 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序 order by 和 分组查询 group by。 出现这个更要立刻优化sql。  </p>
<p>Using index： 表示相应的select 操作中使用了覆盖索引（Covering index），避免访问了表的数据行，效果不错！如果同时出现Using where，表明索引被用来执行索引键值的查找。如果没有同时出现Using where，表示索引用来读取数据而非执行查找动作。  </p>
<p>覆盖索引（Covering Index） ：也叫索引覆盖，就是select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select 列表中的字段，而不必根据索引再次读取数据文件。  </p>
<p>Using index condition： 在5.6版本后加入的新特性，优化器会在索引存在的情况下，通过符合RANGE范围的条数 和 总数的比例来选择是使用索引还是进行全表遍历。  </p>
<p>Using where： 表明使用了where 过滤  </p>
<p>Using join buffer： 表明使用了连接缓存  </p>
<p>impossible where： where 语句的值总是false，不可用，不能用来获取任何元素  </p>
<p>distinct： 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Extra中包含的值：using index： 只用到索引,可以避免访问表，性能很高。 </span><br><span class="line">using where： 使用到where来过滤数据， 不是所有的where clause都要显示using where. 如以&#x3D;方式访问索引。</span><br><span class="line">using tmporary： 用到临时表去处理当前的查询。</span><br><span class="line">using filesort： 用到额外的排序，此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行。(当使用order by v1,而没用到索引时,就会使用额外的排序)。</span><br><span class="line">range checked for eache record(index map:N)： 没有好的索引可以使用。Using index for group-by：表明可以在索引中找到分组所需的所有数据，不需要查询实际的表。explain select user_id from t_order group by user_id;</span><br></pre></td></tr></table></figure>

<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>一个百分比的值，和rows 列的值一起使用，可以估计出查询执行计划(QEP)中的前一个表的结果集，从而确定join操作的循环次数。小表驱动大表，减轻连接的次数</p>
<p>见到Using temporary和Using filesort，就意味着MySQL根本不能使用索引，结果是检索会很慢，需要优化sql了。</p>
<p>MySQL本身的功能架构分为三个部分，分别是 应用层、逻辑层、物理层，不只是MySQL ，其他大多数数据库产品都是按这种架构来进行划分的。</p>
<ul>
<li>应用层，主要负责与客户端进行交互，建立链接，记住链接状态，返回数据，响应请求，这一层是和客户端打交道的。</li>
<li>逻辑层，主要负责查询处理、事务管理等其他数据库功能处理，以查询为例。</li>
</ul>
<p>​    </p>
<p>首先接收到查询SQL之后，数据库会立即分配一个线程对其进行处理，第一步查询处理器会对SQL查询进行优化，优化后会生成执行计划，然后交由计划执行器来执行。</p>
<p>​    </p>
<p>计划执行器需要访问更底层的事务管理器，存储管理器来操作数据，他们各自的分工各有不同，最终通过调用物理层的文件获取到查询结构信息，将最终结果响应给应用层。</p>
<ul>
<li>物理层，实际物理磁盘上存储的文件，主要有分文数据文件，日志文件。</li>
</ul>
<p>通过上面的描述，生成执行计划是执行一条SQL必不可少的步骤，一条SQL性能的好坏，可以通过查看执行计划很直观的看出来，执行计划提供了各种查询类型与级别，方便我们进行查看以及为作为性能分析的依据。</p>
<p>MySQL为我们提供了 explain 关键字来直观的查看一条SQL的执行计划。</p>
<p>explain显示了MySQL如何使用索引来处理select语句以及连接表，可以帮助选择更好的索引和写出更优化的查询语句。</p>
<p>下面我们使用 explain 做一个查询，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/DmibiaFiaAI4B2X3HLg3LCH4kOawemn0jK92f2UQNa6MzDzMSHF0kiaG8icDGUwjkyq4oZzflDzjhDqiaZXe9CXdhVfA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>查询结构中有12列，理解每一列的含义，对理解执行计划至关重要，下面进行说明。</p>
<p><strong>id</strong></p>
<p>SELECT识别符，这是SELECT的查询序列号。</p>
<p><strong>select_type</strong></p>
<p>SELECT类型,可以为以下任何一种:</p>
<ul>
<li>SIMPLE:简单SELECT(不使用UNION或子查询)</li>
<li>PRIMARY:最外面的SELECT</li>
<li>UNION:UNION中的第二个或后面的SELECT语句</li>
<li>DEPENDENT UNION:UNION中的第二个或后面的SELECT语句,取决于外面的查询</li>
<li>UNION RESULT:UNION 的结果</li>
<li>SUBQUERY:子查询中的第一个SELECT</li>
<li>DEPENDENT SUBQUERY:子查询中的第一个SELECT,取决于外面的查询</li>
<li>DERIVED:导出表的SELECT(FROM子句的子查询)</li>
</ul>
<p><strong>table</strong></p>
<p>输出的行所引用的表</p>
<p><strong>partitions</strong></p>
<p>如果查询是基于分区表的话，显示查询将访问的分区。</p>
<p><strong>type</strong></p>
<p>联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:</p>
<ul>
<li>system:表仅有一行(=系统表)。这是const联接类型的一个特例。</li>
<li>const:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!</li>
<li>eq_ref:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。</li>
<li>ref:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。</li>
<li>ref_or_:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。</li>
<li>index_merge:该联接类型表示使用了索引合并优化方法。</li>
<li>unique_subquery:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。</li>
<li>index_subquery:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)</li>
<li>range:只检索给定范围的行,使用一个索引来选择行。</li>
<li>index:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。</li>
<li>ALL:对于每个来自于先前的表的行组合,进行完整的表扫描，说明查询就需要优化了。</li>
</ul>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<p><strong>possible_keys</strong></p>
<p>指出MySQL能使用哪个索引在该表中找到行</p>
<p><strong>key</strong></p>
<p>显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。</p>
<p><strong>key_len</strong></p>
<p>显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。在不损失精确性的情况下，长度越短越好</p>
<p><strong>ref</strong></p>
<p>显示使用哪个列或常数与key一起从表中选择行。</p>
<p><strong>rows</strong></p>
<p>显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。</p>
<p><strong>filtered</strong></p>
<p>显示了通过条件过滤出的行数的百分比估计值。</p>
<p><strong>Extra</strong></p>
<p>该列包含MySQL解决查询的详细信息</p>
<ul>
<li>Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。</li>
<li>Select tables optimized away MySQL根本没有遍历表或索引就返回数据了，表示已经优化到不能再优化了</li>
<li>Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。</li>
<li>range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。</li>
<li>Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行，说明查询就需要优化了。</li>
<li>Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。</li>
<li>Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果，说明查询就需要优化了。</li>
<li>Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。</li>
<li>Using sort_union(…), Using union(…), Using intersect(…):这些函数说明如何为index_merge联接类型合并索引扫描。</li>
<li>Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。</li>
</ul>
<h1 id="mysql添加用户并设置权限"><a href="#mysql添加用户并设置权限" class="headerlink" title="mysql添加用户并设置权限"></a>mysql添加用户并设置权限</h1><p>1.登录本地用户</p>
<p>命令：[root@elk mysql]# mysql -uroot -p123456</p>
<p>登录外网用户（需要注意服务器可能只允许本地登录，需要修改响应的配置文件）</p>
<p>配置文件是/etc/mysql/my.cnf</p>
<p>命令：vim   /etc/mysql/my.cnf</p>
<p>修改bind-address  =127.0.0.1  将其注释掉；//作用是使得不再只允许本地访问</p>
<p>重启mysql：/etc/init.d/mysql restart  </p>
<p>然后登录</p>
<p>2.创建用户</p>
<p>命令：mysql&gt; CREATE USER ‘username’@’host’ IDENTIFIED BY ‘password’;</p>
<p>username:用户名；</p>
<p>host：指定在哪个主机上可以登录，本机可用localhost，%通配所有远程主机；</p>
<p>password：用户登录密码；</p>
<p>3.设置权限</p>
<p>命令：<strong>GRANT ALL PRIVILEGES ON  <em>.</em> TO ‘username’@‘%’ IDENTIFIED BY ‘password’；</strong></p>
<p>刷新权限：FLUSH PRIVILEGES;            #刷新之后才会生效，重启也可以</p>
<p>格式：grant 权限 on 库名.表名 to 用户@登录主机 identified by “用户密码”；*.*代表所有权；</p>
<p>@ 后面是访问的是客户端IP地址（或是 主机名） % 代表任意的客户端，如果填写 localhost 为本地访问（那此用户就不能远程访问该mysql数据库了）</p>
<p>一般情况下，修改MySQL密码，授权，是需要有mysql里的root权限的。 </p>
<p>注：本操作是在WIN命令提示符下，phpMyAdmin同样适用。     </p>
<p>用户：phplamp  用户数据库：phplampDB </p>
<p>1.新建用户。 </p>
<p>//登录MYSQL </p>
<p>@&gt;mysql -u root -p </p>
<p>@&gt;密码 </p>
<p>//创建用户 </p>
<p>mysql&gt; insert into mysql.user(Host,User,Password) values(“localhost”,”phplamp”,password(“1234”)); </p>
<p>//刷新系统权限表 </p>
<p>mysql&gt;flush privileges; </p>
<p>这样就创建了一个名为：phplamp  密码为：1234  的用户。 </p>
<p>然后登录一下。 </p>
<p>mysql&gt;exit; </p>
<p>@&gt;mysql -u phplamp -p </p>
<p>@&gt;输入密码 </p>
<p>mysql&gt;登录成功 </p>
<p>2.为用户授权。 </p>
<p>//登录MYSQL(有ROOT权限)。我以ROOT身份登录. </p>
<p>@&gt;mysql -u root -p </p>
<p>@&gt;密码 </p>
<p>//首先为用户创建一个数据库(phplampDB) </p>
<p>mysql&gt;create database phplampDB; </p>
<p>/授权phplamp用户拥有phplamp数据库的所有权限。 </p>
<p>mysql&gt;<em><em>grant all privileges on phplampDB.</em> to phplamp@localhost identified by ‘1234’;</em>* </p>
<p>//刷新系统权限表 </p>
<p>mysql&gt;flush privileges; </p>
<p>mysql&gt;其它操作 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 如果想指定部分权限给一用户，可以这样来写: </span><br><span class="line">mysql&gt;grant select,update on phplampDB.* to phplamp@localhost identified by &#39;1234&#39;; </span><br><span class="line">&#x2F;&#x2F;刷新系统权限表。 </span><br><span class="line">mysql&gt;flush privileges; *&#x2F; </span><br></pre></td></tr></table></figure>

<p>3.删除用户。 </p>
<p>@&gt;mysql -u root -p </p>
<p>@&gt;密码 </p>
<p>mysql&gt;DELETE FROM user WHERE User=”phplamp” and Host=”localhost”; </p>
<p>mysql&gt;flush privileges; </p>
<p>//删除用户的数据库 mysql&gt;drop database phplampDB; </p>
<p>4.修改指定用户密码。 </p>
<p>@&gt;mysql -u root -p </p>
<p>@&gt;密码 </p>
<p>mysql&gt;update mysql.user set password=password(‘新密码’) where User=”phplamp” and Host=”localhost”; </p>
<p>mysql&gt;flush privileges;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/06/5.2.MySQL%E8%BF%9B%E9%98%B6/" data-id="ckw61sdwa004uoswd4rzr61e2" data-title="MySQL" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-8.1.前端概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/05/8.1.%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2021-04-05T07:42:57.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/05/8.1.%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0/">前端概述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>网页主要是做前端样式，而现在的前端的框架越来越多：bootstrap，layui，基于Vue的elementui、iview。以前开发网页需要写html代码，css样式和js方法。现在用了框架之后，我们只需要将其中的示例改为自己的信息，将相应的css和js放在对应的路径下即可。</p>
<p>前端适配的问题：在css的样式下</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/05/8.1.%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0/" data-id="ckw61sdvh002foswd3xp4a389" data-title="前端概述" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-8.3.网页前端之CSS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/05/8.3.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/" class="article-date">
  <time class="dt-published" datetime="2021-04-05T05:37:52.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/05/8.3.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/">网页前端之CSS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTML是页面的结构，CSS是美化页面</p>
<p>CSS（Cascading Style Sheets）：层叠样式表  </p>
<p>样式表：存储样式的地方，多个样式</p>
<p>CSS通常称为CSS样式或层叠样式表，主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等），图片的外形（高宽、边框样式、边距等）以及版面的布局等外观显示样式。</p>
<p>作用：修饰HTML页面，更丰富多彩的展示超文本信息</p>
<p>因为HTML在单独使用设置属性会有一定的局限性，所以用CSS样式。</p>
<h1 id="样式类型"><a href="#样式类型" class="headerlink" title="样式类型"></a>样式类型</h1><p>1.行内样式表（内联样式）:<code>&lt;div style=&quot;width:400px;height:200px;background-color:#FFF&quot;&gt;&lt;/div&gt;</code></p>
<p>一般写在标签头部</p>
<p>放置规范：在<code>&lt;style&gt;</code>标签内容体中书写css样式代码<code>&lt;/style&gt;</code>      <code>&lt;style&gt;</code>标签放置在<code>&lt;head&gt;</code>标签之中</p>
<p>格式规范：选择器名称｛属性名1：属性值1； 属性名2：属性值2；……｝</p>
<p>代码规范：属性名和属性值之间是键值对关系    <code>：</code>连接   <code>；</code>结尾  </p>
<p>如果一个属性名有多个值，多个值之间用空格隔开：border:1px solid red;</p>
<p>CSS注释：<code>/*注释内容*/ </code> 等同于java的多行注释</p>
<p>缺点:样式只能操作某一个标签 优点:十分灵活，可以进行细节的调节,更加针对性修改某个标签的样式</p>
<p>2.嵌入式样式表（嵌入样式）:<code>&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;</code></p>
<p>一般写在<code>&lt;head&gt;&lt;/head&gt;</code>标签内。可以通过一条语句操作多个标签或类，但是仅限本页面内</p>
<p>3.引用式样式表（外联样式）:<code>&lt;link href=&quot;css文件路径&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code></p>
<p>​    rel=”stylesheet” 固定值，表示样式表</p>
<p>​    type=”text/css” 固定值，表示css类型</p>
<p>​    href表示css文件位置</p>
<p>(能用引用式样式表的地方就尽量用引用式)<br>一般写在<code>&lt;head&gt;&lt;/head&gt;</code>标签内。(多个HTML文件可以引用一个CSS样式表文件) </p>
<p>优点:占用空间资源少，修改方便，只要修改CSS文件就可以修改多个HTML页面的属性，适合不同页面进行样式复用</p>
<p>CSS注释写法:<code>/* */</code>   HTML注释写法:<code>&lt;!--  --&gt;</code></p>
<p>当三种样式表操作同一元素时，优先级依次为:行内样式表，嵌入式样式表，引用式样式表。 即后出现的先应用。引用式样式表一般放在嵌入式样式表的前面</p>
<h1 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h1><p>不要忘记每条属性的“;”结尾<br>如果缺少符号或者书写错误则样式表失效<br>需要单位的值要加上单位，例如:px(像素单位)</p>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>选择器：指定CSS样式作用在哪些HTML标签上</p>
<p>1.标签选择器：HTML标签又名html元素，就是以HTML标签名作为选择器名称。</p>
<p>作用：选择CSS样式代码，对应标签名的标签上。</p>
<p>格式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标签名｛</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CSS样式代码*/</span></span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>适用范围：适用于将相同样式，作用在多个同名标签上</p>
<p>2.类选择器：以HTML的类名（class属性值）作为选择器名称</p>
<p>每个HTML标签都有一个class属性，class属性即为类名。</p>
<p>作用：选择CSS样式代码作用于对应类名的HTML标签上。</p>
<p>格式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.类名｛</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CSS样式代码*/</span></span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>使用范围：适用于将样式一次作用在相同类名的标签上（即使标签名不同）。</p>
<p>3.id选择器：以HTML的id（id属性值）作为选择器名称</p>
<p>每个HTML标签都有一个id属性，这个id属性值必须在本页面是唯一的</p>
<p>作用：选择CSS样式代码作用于某个规定id值的html标签上</p>
<p>格式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>值｛</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CSS样式代码*/</span></span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>适用范围：适用于将样式作用某个标签上（更有针对性）</p>
<p>4.属性选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[href&#x3D;&quot;segmentfault.com&quot;]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.伪类选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:hover&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.伪元素选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::before&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.通配选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>所有 CSS 的选择符由上述 7 种基础的选择器或者组合而成，组合的方式有 3 种：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">后代选择符： </span><br><span class="line"><span class="selector-class">.father</span> <span class="selector-class">.child</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子选择符： </span><br><span class="line"><span class="selector-class">.father</span> &gt; <span class="selector-class">.child</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">相邻选择符: </span><br><span class="line">.bro1 + .bro2&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="CSS样式的优先级"><a href="#CSS样式的优先级" class="headerlink" title="CSS样式的优先级"></a>CSS样式的优先级</h1><h2 id="CSS-的继承性"><a href="#CSS-的继承性" class="headerlink" title="CSS 的继承性"></a>CSS 的继承性</h2><p>1.最近的祖先样式比其他祖先样式优先级高</p>
<p>2.”直接样式”比”祖先样式”优先级高</p>
<p>（总结就是看最近的元素的样式）</p>
<h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><p>3.优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML</span><br><span class="line">&lt;div class&#x3D;&quot;content-class&quot; id&#x3D;&quot;content-id&quot; style&#x3D;&quot;color: black&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; CSS</span><br><span class="line">#content-id &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">.content-class &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">    color: grey;</span><br><span class="line">&#125;</span><br><span class="line">最终的 color 为 black，因为内联样式比其他选择器的优先级高</span><br></pre></td></tr></table></figure>

<p>4.计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照”就近原则”来判断</p>
<p>如果外部样式表和内部样式表中的样式发生冲突会出现什么情况呢？这与样式表在 HTML 文件中所处的位置有关。样式被应用的位置越在下面则优先级越高，其实这仍然可以用规则 4 来解释</p>
<p>5.属性后插有 <strong>!important</strong> 的属性拥有最高优先级。若同时插有 <strong>!important</strong>，则再利用规则 3、4 判断优先级</p>
<h1 id="px、rpx、em、rem"><a href="#px、rpx、em、rem" class="headerlink" title="px、rpx、em、rem"></a>px、rpx、em、rem</h1><p>PX实际上就是像素，用PX设置字体大小时，比较稳定和精确。但是这种方法存在一个问题，当用户在浏览器中浏览我们制作的Web页面时，如果改变了浏览器的缩放，这时会使用我们的Web页面布局被打破。</p>
<p>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素</p>
<p>EM就是根据基准来缩放字体的大小。EM实质是一个相对值，而非具体的数值。这种技术需要一个参考点，em是相对于父元素的字体属性而计算的，一般都是以<code>&lt;body&gt;</code>的“font-size”为基准。em指字体高，任意浏览器的默认字体高都是16px。其他比如WordPress官方主题Twenntytwelve的基准就是14px=1em。</p>
<p>EM是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而Rem是相对于根元素<code>&lt;html&gt;</code>，这样就意味着，我们只需要在根元素确定一个参考值。</p>
<p>除了IE6-IE8r，其它的浏览器都支持em和rem属性，px是所有浏览器都支持。<br>因此为了浏览器的兼容性，可“px”和“rem”一起使用，用”px”来实现IE6-8下的效果，然后使用“Rem”来实现代浏览器的效果。</p>
<h1 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h1><h2 id="字体属性：-font"><a href="#字体属性：-font" class="headerlink" title="字体属性：(font)"></a>字体属性：(font)</h2><p>样式：</p>
<p>​    color : #999999;   文字颜色</p>
<p>​    font-family : sans-serif;   字体类型  “Courier New”, Courier, monospace, “Times New Roman”, Times, serif, Arial, Helvetica, sans-serif, Verdana</p>
<p>​    font-size:  字体大小 inherit| medium| large| larger| x-large| xx-large| small| smaller| x-small| xx-small |数值  单位：pt，px</p>
<p>​    font-weight:  字体粗细 bold,bolder; (文字粗体）   lighter;(细体) normal;(正常)  100-900</p>
<p>​    font-style:  字体风格  itelic; (文字斜体）  normal;(正常) oblique;(偏斜体)   inherit(继承)</p>
<p>​    letter-spacing :  字间距离  数值|inherit|normal</p>
<p>​    word-spacing: 单词间距  数值|inherit|normal</p>
<p>​    line-height :  设置行高   normal;(正常)   inherit(继承)  数值 单位：PX、PD、EM  </p>
<p>​    text-shadow: 阴影颜色 {16位色值}</p>
<p>​    font-variant: 字体变形  {inherit|normal|small-cps（小字体，小型大写字母） }</p>
<p>​    font-size-adjust:字体变形 {inherit|none}</p>
<p>​    font-stretch:字体 {condensed|expanded|extra-condensed|extra-expanded|inherit|narrower|normal| semi-condensed|semi-expanded|ultra-condensed|ultra-expanded|wider}</p>
<p>修饰：inherit|none|underline|overline|line-through|blink</p>
<p>​    text-decoration:line-through; 加删除线</p>
<p>​    text-decoration: overline; 加顶线（上划线）</p>
<p>​    text-decoration:underline; 加下划线</p>
<p>​    text-decoration:none; 删除链接下划线</p>
<p>​    text-decoration:blink; 闪烁</p>
<p>大小写：</p>
<p>text-transform:inherit|none|capitalize|uppercase|lowercase</p>
<p>​    text-transform : capitalize; 首字大写</p>
<p>​    text-transform : uppercase; 英文大写</p>
<p>​    text-transform : lowercase; 英文小写</p>
<h2 id="背景属性：-background"><a href="#背景属性：-background" class="headerlink" title="背景属性： (background)"></a>背景属性： (background)</h2><p>色彩：</p>
<p>​    background-color:#F5E2EC; 背景颜色  </p>
<p>两种方式：</p>
<p>​    ①英文单词</p>
<p>​    ②颜色代码  格式：#红绿蓝，每一个颜色用两个16进制位数表示  例如：#ff1100 红色ff 绿色11 蓝色00 红色颜色最重，绿色其次，没有蓝色  （数值代表每个颜色的色重）</p>
<p>​    background:transparent; 透视背景</p>
<p>图片：</p>
<p>​    background-image : url(/image/bg.gif); 背景图片  url(URL)|none</p>
<p>重复： inherit|no-repeat|repeat|repeat-x|repeat-y</p>
<p>​    background-repeat : repeat; 重复排列-网页默认</p>
<p>​    background-repeat : no-repeat; 不重复排列</p>
<p>​    background-repeat : repeat-x; 在x轴重复排列</p>
<p>​    background-repeat : repeat-y; 在y轴重复排列</p>
<p>滚动：</p>
<p>​    background-attachment : fixed; 浮水印固定背景   scroll;(滚动)</p>
<p>位置：</p>
<p>​    background-position : 90% 90%; 背景图片x与y轴的位置</p>
<p>​    background-position : top; 向上对齐</p>
<p>​    background-position : buttom; 向下对齐</p>
<p>​    background-position : left; 向左对齐</p>
<p>​    background-position : right; 向右对齐</p>
<p>​    background-position : center; 居中对齐</p>
<p>简写：  背影样式 {background:背景颜色|背景图象|背景重复|背景附件|背景位置}</p>
<p>例： {background:#000 url(..) repeat fixed left top;}</p>
<h2 id="区块属性：-Block"><a href="#区块属性：-Block" class="headerlink" title="区块属性： (Block)"></a>区块属性： (Block)</h2><p>排列方式：</p>
<p>​    text-align:right; 文字右对齐</p>
<p>​    text-align:left; 文字左对齐</p>
<p>​    text-align:center; 文字居中对齐</p>
<p>​    text-align:justify; 文字分散对齐（两端对齐）</p>
<p>​    vertical-align:baseline; 基线</p>
<p>​    vertical-align:top; 垂直向上对齐</p>
<p>​    vertical-align:bottom; 垂直向下对齐</p>
<p>​    vertical-align:middle; 垂直居中对齐</p>
<p>​    vertical-align:text-top; 文字垂直向上对齐</p>
<p>​    vertical-align:text-bottom; 文字垂直向下对齐</p>
<p>​    vertical-align:sub; 下标字</p>
<p>​    vertical-align:super; 上标字</p>
<h2 id="显示属性：（display）"><a href="#显示属性：（display）" class="headerlink" title="显示属性：（display）"></a>显示属性：（display）</h2><p>display属性可以使得元素在行内元素和块元素之间相互转换</p>
<p>格式：  选择器{display:属性值 }</p>
<p>属性值：block：此元素显示为块元素（块元素默认的display属性值）</p>
<p>​    inline：此元素显示为行内元素（行内元素默认的display属性值）</p>
<p>​    none：此元素将被隐藏，不显示，也不占用页面空间</p>
<p>display: 显示  {block;}(块) inline;(内嵌) list-item;(列表项) run-in;(追加部分) compact;(紧凑) marker;(标记) table; inline-table; table-raw-group; table-header-group; table-footer-group; table-raw; table-column-group; table-column; table-cell; table-caption;(表格标题)</p>
<p>​    text-indent: 缩进，段首空格 { 数值px; inherit}</p>
<p>​    white-space: 空格；控制空白  pre;(保留) nowrap;(不换行) normal</p>
<p>​    writing-mode: 书写方式 {lr-tb（从左到右，从上到下）|tb-rl（从上到下，从右到左）}</p>
<p>​    visibility: 是否可见 inherit; visible; hidden;collapse</p>
<p>即使不可见的元素也会占据页面上的空间。使用 “display” 属性来创建不占据页面空间的不可见元素</p>
<p>​    overflow:  当内容溢出元素框时发生的事情</p>
<p>​         visible:默认值。内容不会被修剪，会呈现在元素框之外。</p>
<p>​         hidden:内容会被修剪，并且其余内容是不可见的。</p>
<p>​         scroll:内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</p>
<p>​        auto:如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容</p>
<p>​    clip:  (裁切)剪裁绝对定位元素:这个属性用于定义一个剪裁矩形。对于一个绝对定义元素，在这个矩形内的内容才可见。出了这个剪裁区域的内容会根据 overflow 的值来处理。剪裁区域可能比元素的内容区大，也可能比内容区小</p>
<p>​        rect (<em>top</em>, <em>right</em>, <em>bottom</em>, <em>left</em>)</p>
<p>​        auto:默认值。不应用任何剪裁</p>
<h2 id="方框属性：-Box"><a href="#方框属性：-Box" class="headerlink" title="方框属性： (Box)"></a>方框属性： (Box)</h2><p>CSS盒子模型：所有的HTML元素，都可以看作一个四边形，即一个盒子。</p>
<p>用CSS来设置元素盒子的内边距（padding）、边框(border)和外边距(margin)的样式的方式相当于设置盒子的样式，我们称之为盒子模型。</p>
<p>边框：（HTML元素盒子的框体）简写：<code>border:1px solid red;</code></p>
<p>宽度：宽度值： thin|medium|thick|数值   100vh  100%  33rem  3em  window.screen.width </p>
<p>​    width:长度|百分比| auto</p>
<p>​    border-top-width </p>
<p>​    border-right-width </p>
<p>​    border-bottom-width </p>
<p>​    border-left-width</p>
<p>高度：</p>
<p>​    height:数值|auto</p>
<p>颜色：</p>
<p>​    border-color:数值 数值 数值 数值；　数值：分别代表top、right、bottom、left颜色值</p>
<p>风格： </p>
<p>​    border-style:none|hidden|inherit|dashed|solid|double|inset|outset|ridge|groove</p>
<p>漂浮：</p>
<p>​    float:left|right|none</p>
<p>​    通常默认的排版方式，将页面的元素从上到下一一罗列，而实际开发中，需要左右方式进行排版，所以需要使用到浮动属性：float</p>
<p>格式： 选择器{float：属性值；}</p>
<p>常用属性值：none：元素不浮动（默认值）</p>
<p>​    left：元素向左浮动</p>
<p>​    right：元素向右浮动</p>
<p>因为元素设置浮动属性后，会脱离原有文档流（会脱离原有的板式），从而会影响其他元素的样式，所以设置浮动以后，页面样式需要重新调整。</p>
<p>清除：规定元素的哪一侧不允许其他浮动元素</p>
<p>​    clear:none|left|right|both</p>
<p>注：这个规则只能影响使用清除的元素本身，不能影响其他元素。这个元素与float对应</p>
<p>外边距，边界留白：HTML元素边框到其他元素边框的距离</p>
<p>​    margin-top:10px; 上边界</p>
<p>​    margin-right:10px; 右边界值</p>
<p>​    margin-bottom:10px; 下边界值</p>
<p>​    margin-left:10px; 左边界值</p>
<p>通用性设置：margin: 10px;</p>
<p>内边距，补白：HTML元素里的内容体到HTML元素边框的距离</p>
<p>​    padding-top:10px; 上边框留空白</p>
<p>​    padding-right:10px; 右边框留空白</p>
<p>​    padding-bottom:10px; 下边框留空白</p>
<p>​    padding-left:10px; 左边框留空白</p>
<p>通用性设置：padding: 10px;</p>
<h2 id="边框属性：-Border"><a href="#边框属性：-Border" class="headerlink" title="边框属性： (Border)"></a>边框属性： (Border)</h2><p>所有的HTML标签都有边框，默认边框不可见</p>
<p>简写：    格式：宽度 样式 颜色</p>
<p>​    border：width style color; </p>
<p>​    border-top : 1px solid #6699cc; 上框线</p>
<p>​    border-bottom : 1px solid #6699cc; 下框线</p>
<p>​    border-left : 1px solid #6699cc; 左框线</p>
<p>​    border-right : 1px solid #6699cc; 右框线</p>
<p>也可以使用常规的方式 如下:</p>
<p>​    border-top-color : #369 设置上框线top颜色</p>
<p>​    border-top-width :1px设置上框线top宽度</p>
<p>​    border-top-style : solid设置上框线top样式</p>
<p>其他框线样式：</p>
<p>​    solid 实线框</p>
<p>​    dotted 虚线框（点线）</p>
<p>​    double 双线框</p>
<p>​    groove 立体内凸框 (槽线)</p>
<p>​    ridge 立体浮雕框 (脊状)</p>
<p>​    inset 凹框</p>
<p>​    outset 凸框</p>
<p>width：边框的宽度</p>
<p>height：边框的高度（只是边框，不是字体）</p>
<h2 id="列表属性：-List-style"><a href="#列表属性：-List-style" class="headerlink" title="列表属性： (List-style)"></a>列表属性： (List-style)</h2><p>符号列表： disc|circle|square|decimal|lower-roman|upper-roman|lower-alpha|upper-alpha|none</p>
<p>​    list-style-type:none; 不编号</p>
<p>​    list-style-type:decimal; 阿拉伯数字</p>
<p>​    list-style-type:lower-roman; 小写罗马数字</p>
<p>​    list-style-type:upper-roman; 大写罗马数字</p>
<p>​    list-style-type:lower-alpha; 小写英文字母</p>
<p>​    list-style-type:upper-alpha; 大写英文字母</p>
<p>​    list-style-type:disc; 实心圆形符号</p>
<p>​    list-style-type:circle; 空心圆形符号</p>
<p>​    list-style-type:square; 实心方形符</p>
<p>图像：</p>
<p>​    list-style-image:url(/dot.gif); 图片式符号</p>
<p>位置：</p>
<p>​    list-style-position: outside; 凸排</p>
<p>​    list-style-position:inside; 缩进</p>
<h2 id="定位属性：-Position"><a href="#定位属性：-Position" class="headerlink" title="定位属性： (Position)"></a>定位属性： (Position)</h2><p>这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。</p>
<p>​    position: absolute;   生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p>
<p>​    position: fixed;  生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定</p>
<p>​    position:relative; 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素</p>
<p>​    position:static; 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）</p>
<p>​    position:inherit;规定应该从父元素继承 position 属性的值</p>
<p>Z-index仅能在定位元素上奏效，可被用于将在一个元素放置于另一元素之后,拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。</p>
<h2 id="连接属性：（a）"><a href="#连接属性：（a）" class="headerlink" title="连接属性：（a）"></a>连接属性：（a）</h2><p>a /<em>所有超链接</em>/</p>
<p>​    a:link 超链接文字格式</p>
<p>​    a:visited 浏览过的链接文字格式</p>
<p>​    a:active 按下链接的格式</p>
<p>​    a:hover 鼠标转到链接</p>
<p>鼠标光标样式： hand|crosshair|text|wait|move|help|e-resize|nw-resize|w-resize|s-resize|se-resize|sw-resize</p>
<p>​    链接手指 cursor: hand</p>
<p>​    十字体 cursor:crosshair</p>
<p>​    箭头朝下 cursor:s-resize</p>
<p>​    十字箭头 cursor:move</p>
<p>​    箭头朝右 cursor:move</p>
<p>​    加一问号 cursor:help</p>
<p>​    箭头朝左 cursor:w-resize</p>
<p>​    箭头朝上 cursor:n-resize</p>
<p>​    箭头朝右上 cursor:ne-resize</p>
<p>​    箭头朝左上 cursor:nw-resize</p>
<p>​    文字I型 cursor:text</p>
<p>​    箭头斜右下 cursor:se-resize</p>
<p>​    箭头斜左下 cursor:sw-resize</p>
<p>​    漏斗 cursor:wait</p>
<p>​    光标图案(IE6) p {cursor:url(“光标文件名.cur”),text;}</p>
<h2 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h2><p>文字方块</p>
<p>按钮</p>
<p>复选框</p>
<p>选择钮</p>
<p>多行文字方块</p>
<p>下拉式菜单 选项1选项2</p>
<h2 id="伪元素-after和-before"><a href="#伪元素-after和-before" class="headerlink" title="伪元素::after和::before"></a>伪元素::after和::before</h2><p>::before和::after匹配一个虚拟元素，主要被用于为当前元素增加装饰性内容的。它显示的内容是其自身的“<code>content</code>”属性，默认是内联元素。</p>
<h2 id="兼容问题-important"><a href="#兼容问题-important" class="headerlink" title="兼容问题!important"></a>兼容问题!important</h2><p>​    CSS中的!important一般都是用于对低版本的除了iE 6 ，用来做hack的，后面缀上了!important的css语句，让浏览器首选执行这个语句，因为css有继承的样式，加上!importanrt可以覆盖父级的样式。 IE6不认识它的，IE7和别的浏览器中可以用，用来处理浏览器的兼容性。</p>
<h2 id="让两个组件变为一行"><a href="#让两个组件变为一行" class="headerlink" title="让两个组件变为一行"></a>让两个组件变为一行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;left&quot; style&#x3D;&quot;float:left&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;leftButton&quot; οnclick&#x3D;&quot;login()&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div align&#x3D;&quot;right&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;rightButton&quot; οnclick&#x3D;&quot;cancle()&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<h1 id="vue的样式"><a href="#vue的样式" class="headerlink" title="vue的样式"></a>vue的样式</h1><h3 id="lt-style-scoped-gt"><a href="#lt-style-scoped-gt" class="headerlink" title="&lt;style scoped&gt;"></a><code>&lt;style scoped&gt;</code></h3><p>在vue中，我们为了避免父组件的样式影响到子组件的样式，会在style中加<code>&lt;style scoped&gt;</code>，这样父组件中如果有跟子组件相同的class名称或者使用选择器的时候，就不会影响到子组件的样式。</p>
<h3 id="deep-gt-gt-gt"><a href="#deep-gt-gt-gt" class="headerlink" title="/deep/    &gt;&gt;&gt;"></a>/deep/    &gt;&gt;&gt;</h3><p>vue组件中，在style设置为scoped的时候，里面在写样式对子组件是不生效的，如果想让某些样式对所有子组件都生效，可以使用 /deep/ 深度选择器</p>
<p>把 /deep/ 换成 &gt;&gt;&gt;，也可以达到同样的效果</p>
<h3 id="lang-”scss”"><a href="#lang-”scss”" class="headerlink" title="lang=”scss”"></a>lang=”scss”</h3><p>SCSS是一种CSS预处理语言。定义了一种新的专门的编程语言，编译后形成正常的css文件，为css增加一些编程特性，无需考虑浏览器的兼容性（完全兼容css3），让css更加简洁、适应性更强，可读性更佳，更易于代码的维护等诸多好处。CSS预处理语言有SCSS (SASS) 和LESS、POSTCSS</p>
<p>SCSS和SASS有什么区别：</p>
<p>· 文件扩展名不同，文件后缀分别是“.scss”和“.sass”</p>
<p>· sass是以严格缩进语法规则来编写代码的，不包括大括号和分号，而scss的语法和css书写语法类似；</p>
<p>· scss是sass3.0引入的语法，可以理解scss是sass的一个升级版本，是一种SCSS-like语言，弥补了sass和css之间的鸿沟；</p>
<p>注释分为三种：/* */css中显示，//css中不显示，/<em>重要注释!</em>/压缩不会被删掉</p>
<p>@import 命令导入外部sass、scss、css文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt; style lang &#x3D; &quot;scss&quot; &gt;</span><br><span class="line">@import &#39;.&#x2F;test.scss&#39; ; &#x2F;&#x2F;导入外部scss文件</span><br><span class="line">.myText &#123;</span><br><span class="line">   border : 1px solid red ;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F; style &gt;</span><br></pre></td></tr></table></figure>

<p>声明变量：语法是：$+变量名+：+变量值；</p>
<p><code>$color : red ; //声明变量 $color</code></p>
<p>默认变量只需要在变量值后加上 !default , 用来设置默认值 ，对默认变量进行重新声明可以实现覆盖默认值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$color : red !default ; &#x2F;&#x2F;声明默认变量 $color</span><br><span class="line">$color : purple ; &#x2F;&#x2F;根据需求覆盖默认变量</span><br><span class="line">.father01 &#123;</span><br><span class="line">   color : $color ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区分全局变量和局部变量</p>
<p>全局变量是元素外声明的变量，局部变量是在元素里声明的变量，重复声明时局部变量会覆盖全局变量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$height : 200px ; &#x2F;&#x2F;全局变量声明不在大花括号内</span><br><span class="line">$bgcolor : blue ;</span><br><span class="line">body &#123;</span><br><span class="line">   .father01 &#123;  &#x2F;&#x2F;嵌套</span><br><span class="line">      width : $width ;</span><br><span class="line">      height : $height ;</span><br><span class="line">      $border : 1px solid red ; &#x2F;&#x2F;局部变量是声明在元素内的</span><br><span class="line">      border : $border ;</span><br><span class="line">      $bgcolor : purple ; &#x2F;&#x2F;全局变量和局部变量名一致时，调用局部变量进行覆盖</span><br><span class="line">      background-color : $bgcolor ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>局部变量值后加上 !global 关键词可以使得局部变量变成全局变量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">   .father01 &#123;</span><br><span class="line">      width : 200px ;</span><br><span class="line">      height : 200px ;</span><br><span class="line">      $border : 1px solid red !global; &#x2F;&#x2F;使用global关键词将$border变为了全局变量</span><br><span class="line">      border : $border ;</span><br><span class="line">   &#125;</span><br><span class="line">   .father02 &#123;</span><br><span class="line">      width : 300px ;</span><br><span class="line">      height : 300px ;</span><br><span class="line">      border : $border ; &#x2F;&#x2F;使用全局变量</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·变量嵌套引用：即字符串插值，需要使用 #{} 来进行包裹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$left : left ;</span><br><span class="line">.father02 &#123;</span><br><span class="line">   width : 300px ;</span><br><span class="line">   height : 300px ;</span><br><span class="line">   border : $border ; &#x2F;&#x2F;使用全局变量</span><br><span class="line">border- #&#123;$left&#125; : 2px solid purple ; &#x2F;&#x2F;使用字符串插值之前必须先声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·变量计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$left : left ;</span><br><span class="line">.father02 &#123;</span><br><span class="line">   width : 300px ;</span><br><span class="line">   height : 300px ;</span><br><span class="line">   border : $border ; &#x2F;&#x2F;使用全局变量</span><br><span class="line">border- #&#123;$left&#125; : 2px solid purple ; &#x2F;&#x2F;使用字符串插值之前必须先声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·嵌套</p>
<p>  选择器嵌套不多说了</p>
<p>属性嵌套（有相同属性前缀）如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">border:&#123;</span><br><span class="line">   color : red ;</span><br><span class="line">   width : 5px ;</span><br><span class="line">   style : solid ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在嵌套时候可以使用 &amp; 来引用父元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   &amp; &gt; p &#123;   &#x2F;&#x2F;可以编译成CSS的 .container&gt;p &#123;&#125; 效果</span><br><span class="line">      color : purple ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·继承</p>
<p> 继承 .class 使用 @extend</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   color : purple ;</span><br><span class="line">   border : 2px dashed purple ;</span><br><span class="line">&#125;</span><br><span class="line">.myText &#123;</span><br><span class="line">   @extend .container; &#x2F;&#x2F;这里将继承.container类的所有样式</span><br><span class="line">   font-size : 22px ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·SCSS占位符 %</p>
<p>使用% 声明的代码块，如果不被@extend调用的话就不会被编译。编译出来的代码会将相同的代码合并在一起，代码变得十分简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%m5 &#123; background-color : lightblue ;&#125;</span><br><span class="line">.P1 &#123; @extend %m5 ; &#125;</span><br></pre></td></tr></table></figure>

<p>·重复代码块，使用混合@mixin命令定义，以及使用@include调用该mixin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@mixin normalStyle &#123;</span><br><span class="line">   &#x2F;&#x2F;使用@mixin命令定义可重复使用的代码块</span><br><span class="line">   width : 300px ;</span><br><span class="line">   height : 100px ;</span><br><span class="line">   color : black ;</span><br><span class="line">   background-color : lightblue ;</span><br><span class="line">&#125;</span><br><span class="line">.container &#123;</span><br><span class="line">   @include normalStyle ;</span><br><span class="line">   &#x2F;&#x2F;使用@include 命令引用@mixin定义的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 在使用@mixin和@include时，传入参数和默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@mixin normalStyle ( $width , $height , $color , $defaultValue : orange ) &#123;</span><br><span class="line">   width : $width ;</span><br><span class="line">   height : $height ;</span><br><span class="line">   color : $color ;</span><br><span class="line">   background-color : $defaultValue ;</span><br><span class="line">&#125;</span><br><span class="line">.container &#123;</span><br><span class="line">   @include normalStyle ( 300px , 100px , green , lightgray );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>SCSS使用编程式方法 </p>
<p>·条件语句 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   p &#123;</span><br><span class="line">      @if 1 + 1 &lt; 3 &#123;</span><br><span class="line">         border : 1px solid blue ;</span><br><span class="line">      &#125; @else &#123;</span><br><span class="line">         border : 1 ps dashed palevioletred ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·SCSS中的三种循环</p>
<p>1.for循环</p>
<p>在sass中的@for循环有两种方式：</p>
<p>①@for $i from <start> through <end></p>
<p>②@for $i from <start> to <end></p>
<p>其中$i表示变量，start表示开始值，end表示结束值；</p>
<p>through表示包括end这个数值；to表示不包括end这个数值；</p>
<p>2.while循环</p>
<p>只要@while后面的条件为true就会执行，直到表达式值为false时停止循环；</p>
<p>3.each  in循环</p>
<p>就是去遍历一个列表，然后从列表中取出对用值；他的指令形式为：@each $var in <list>($var为变量值，list为sassscript表达式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;for 循环</span><br><span class="line">@for $i from 1 to 5 &#123;</span><br><span class="line">   .item- #&#123;$i&#125; &#123;</span><br><span class="line">      border : #&#123;$i&#125; px solid ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;while 循环</span><br><span class="line">$m : 8 ;</span><br><span class="line">@while $m &gt; 0 &#123;</span><br><span class="line">   .items- #&#123;$m&#125; &#123;</span><br><span class="line">      width : 2em * $m ;</span><br><span class="line">   &#125;</span><br><span class="line">   $m : $m - 2 ;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;这里可以对$m进行运算 让它每次都减去2</span><br><span class="line">&#x2F;&#x2F;each 语法</span><br><span class="line">@each $item in class01 , class02 &#123; &#x2F;&#x2F;$item就是遍历了in关键词后面的类名列</span><br><span class="line">   . #&#123;$item&#125; &#123;</span><br><span class="line">      background-color : purple ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;会编译成 .class01 , .class02 &#123;background-color:purple;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>·使用@function 自定义函数及使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@function double ( $sn )&#123; &#x2F;&#x2F;SCSS允许自定义函数</span><br><span class="line">   @return $sn * 2 ;</span><br><span class="line">&#125;</span><br><span class="line">.myText &#123;</span><br><span class="line">   border : 1px solid red ;</span><br><span class="line">   width : double ( 200px ); &#x2F;&#x2F;使用在SCSS中自定义的函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·可以直接使用SCSS内置的颜色函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.myText &#123;</span><br><span class="line">   color : black ;</span><br><span class="line">   &amp; :hover &#123;</span><br><span class="line">      &#x2F;&#x2F;以下的lighten()、darken()等是SCSS内置的颜色函数</span><br><span class="line">      color : lighten ( #cc3 , 10% ); &#x2F;&#x2F; #d6d65c颜色变浅</span><br><span class="line">      color : darken ( #cc3 , 10% ); &#x2F;&#x2F; #a3a329颜色加深</span><br><span class="line">      color : grayscale ( #cc3 ); &#x2F;&#x2F; #d6d65c</span><br><span class="line">      color : complement ( #cc3 ); &#x2F;&#x2F; #a3a329</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一、IE边框若显若无，须注意，定是高度设置已忘记；<br>二、浮动产生有缘故，若要父层包含住，紧跟浮动要清除，容器自然显其中；<br>三、三像素文本慢移不必慌，高度设置帮你忙；<br>四、兼容各个浏览须注意，默认设置行高可能是隐患；<br>五、独立清除浮动须铭记，行高设无，高设零，设计效果兼浏览；<br>六、学布局须思路，路随布局原理自然直，轻松驾驭html，流水布局少hack，代码清爽，兼容好，友好引擎喜欢迎。<br>七、所有标签皆有源，只是默认各不同，span是无极，无极生两仪—内联和块级，img较特殊，但也遵法理，其他只是改造各不同，一个*号全归原，层叠样式理须多练习，万物皆规律。<br>八、图片链接排版须小心，图片链接文字链接若对齐，padding和vertical-align:middle要设定，虽差微细倒无妨。<br>九、IE浮动双边距，请用display：inline拘。</p>
<p>css三大特性</p>
<p>层叠性：css样式冲突采取的原则(后者覆盖前者)</p>
<p>继承性：对于部分属性样式会有天生的继承</p>
<p>优先级：选择器优先级算法</p>
<p>选择器</p>
<p>在讲这三个特性之前我们需要来全面了解下选择器。</p>
<p>种类</p>
<p>下面我将选择进行划分为三大部分，对于基本选择器我就不说了，主要讲下伪类选择器，组合选择器及它们各自的使用场景。</p>
<p>基本选择器</p>
<p>类名：.box</p>
<p>标签: div</p>
<p>属性: input[type=“eamil”] | a[href*=“<a href="http://www.beige.world”]">http://www.beige.world”]</a></p>
<p>ID: #box</p>
<p>伪类选择器</p>
<p>结构伪类: :nth-child(n) | :nth-of-type(n) | :hover</p>
<p>伪元素: ::before | ::after</p>
<p>组合选择器</p>
<p>相邻兄弟 A + B</p>
<p>普通兄弟 A ~ B</p>
<p>子选择器 A &gt; B</p>
<p>后代选择器 A B</p>
<p>基本选择器</p>
<p>算了还是讲下属性选择器吧🤔，这个选择器我在项目开发中还是用到过的</p>
<p>直接看例子：</p>
<p>/* 匹配包含title属性的a标签 =&gt; */</p>
<p>a[title] {color: purple;}</p>
<p>/* 存在href属性并且属性值为”<a target="_blank" rel="noopener" href="http://beige.world&quot;的标签*/">http://beige.world&quot;的标签*/</a></p>
<p>/* */</p>
<p>a[href=“<a href="http://beige.world”]">http://beige.world”]</a> {color: green;}</p>
<p>/* 存在href属性并且属性值包含”baidu”的标签*/</p>
<p>/*</p>
<p>*/</p>
<p>a[href*=“baidu”] {font-size: 20px;}</p>
<p>/* 存在id属性并且属性值结尾是”-wrapper”的</p>
<p>标签 */</p>
<p>/*</p>
<p>*/</p>
<p>div[id$=”-wrapper”] {display: flex;}</p>
<p>/* 存在class属性并且属性值包含以空格分隔的”logo”的</p>
<p>元素 */</p>
<p>/*</p>
<p>*/</p>
<p>div[class~=“logo”] { padding: 2px; }</p>
<p>复制代码</p>
<p>伪类选择器</p>
<p>结构伪类</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>先讲这两比较作用类似的：nth-child(n) | nth-of-type(n)</p>
<p>结构</p>
<p>1</p>
<p>a1</p>
<p>b1</p>
<p>a2</p>
<p>b2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>复制代码</p>
<p>CSS</p>
<p>// 第一个li =&gt;</p>
<p>1</p>
<p>ul li:first-child { background-color: lightseagreen;}</p>
<p>// 最后一个li =&gt;</p>
<p>5</p>
<p>ul li:last-child { background-color: lightcoral;}</p>
<p>// 第三个li =&gt;</p>
<p>3</p>
<p>ul li:nth-child(3) { background-color: aqua; }</p>
<p>// 第二个li下的第一个div(不是div标签的都不算) =&gt;</p>
<p>b1</p>
<p>ul li:nth-child(2) &gt; div:nth-of-type(1) {background-color: red}</p>
<p>复制代码</p>
<p>它俩的区别</p>
<p>nth-child 选择父元素里面的第几个子元素，不管是第几个类型</p>
<p>nth-of-type 选择指定类型的元素</p>
<p>下面讲讲nth-child()括号中的公式，这个算是这个选择器的亮点了。</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>注意⚠：本质上就是选中第几个子元素</p>
<p>n 可以是数字、关键字、公式</p>
<p>n 如果是数字，就是选中第几个</p>
<p>常见的关键字有 even 偶数、odd 奇数</p>
<p>常见的公式如下(如果 n 是公式，则从 0 开始计算)</p>
<p>但是第 0 个元素或者超出了元素的个数会被忽略</p>
<p>对于这里面的公式平常也用不到太复杂的，我说下我的技巧：nth-child(3n + 3); 这里的n可以看做几个为一组，3可以看做选这组的第几个。</p>
<p>例： nth-child(5n + 3) ：5个为一组，选一组中的第三个。 对于”-“号就表示选择的是前面的。</p>
<p>组合选择器</p>
<p>组合选择器本质上就是通过连接符来对两个选择器进行组合</p>
<p>子选择器 A &gt; B</p>
<p>后代选择器 A B</p>
<p>上面这两我就不说了，相信大家都用烂了。主要说说下面这两个。</p>
<p>相邻兄弟 A + B</p>
<p>普通兄弟 A ~ B</p>
<p>结构</p>
<p>One</p>
<p>Two!</p>
<p>Three</p>
<p>pppp</p>
<p>One2</p>
<p>pppp1</p>
<p>Two2!</p>
<p>pppp2</p>
<p>复制代码</p>
<p>选择器解析</p>
<p>复制代码</p>
<p>好了，在讲完这些选择器之后我们来看看它们的使用场景。</p>
<p>组合选择器可以用于：hover伪类操纵自己包含的子元素及以外的元素。举个例子</p>
<p>元素1</p>
<p>元素2</p>
<p>元素3</p>
<p>元素2</p>
<p>同级元素1</p>
<p>同级元素2</p>
<p>同级元素3</p>
<p>复制代码</p>
<p>#a:hover &gt; #b{…}</p>
<p>#a:hover ~ div{…} // 鼠标停留在a元素的时候让所有同层级元素有某某样式</p>
<p>// 防止选择器层级替换了下面的样式</p>
<p>#a:hover + #c{…} // 鼠标停留在a元素的时候让同层级中的c元素有某某样式</p>
<p>#a:hover + #c &gt; #b{…} // 鼠标停留在a元素的时候让同层级中的c元素下的b元素有某某样式</p>
<p>复制代码</p>
<p>上面这两选择器在做一些特效页的时候应该是会用到的。</p>
<p>综合例子</p>
<p>效果</p>
<p>结构</p>
<p>标题名称</p>
<p>Bei Ge</p>
<p>这里放内容简介，内容简介,这里放内容简介，内容简介,这里放内容简介，内容简介</p>
<p>…</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>复制代码</p>
<p>样式</p>
<p>布局样式</p>
<p>复制代码</p>
<p>定义了一个animation动画</p>
<p>@keyframes textAnimation {<br>/* 0% {<br>transform: translateX(150%);</p>
<p>} */</p>
<p>100% {<br>transform: translateX(0);</p>
<p>}</p>
<p>}</p>
<p>复制代码</p>
<p>悬浮在盒子设置样式</p>
<p>.img-box:hover {<br>transform: scale(1.1);</p>
<p>box-shadow: 2px 2px 13px 3px #ccc;</p>
<p>}</p>
<p>.img-box:hover img {<br>opacity: .5;</p>
<p>}</p>
<p>.img-box:hover .cover h3 {<br>opacity: 1;</p>
<p>}</p>
<p>.img-box:hover p {<br>animation: textAnimation .6s ease-out forwards;</p>
<p>/* forwards让动画停留在最后一帧 */</p>
<p>}</p>
<p>.img-box:hover .cover .handle {<br>bottom: 5px;</p>
<p>}</p>
<p>.enter-box:hover ~ .img-box {<br>background-color: transparent;</p>
<p>color: wheat;</p>
<p>}</p>
<p>.enter-box:hover + .img-box {<br>color: red;</p>
<p>}</p>
<p>复制代码</p>
<p>上面这个例子有些还没有讲，但是相信大家之前也都学过，后文中也会说。主要会说些细节方面的东西。</p>
<p>flex(弹性布局)</p>
<p>transform: translate3D rodate3D</p>
<p>animation(设定动画)</p>
<p>3D or 透视(perspective)</p>
<p>这里需要注意在使用伪类Hover的注意点，在使用他影响子级元素的时候尽量将选择器写全。例：</p>
<p>先看下效果😗</p>
<p>上面的效果相信大家都能写出来，所以我要讲的肯定不是怎么去实现这个效果，我要说下使用Hover时的一些细节。</p>
<p>结构比较简单</p>
<p>flex类名用于布局实现重置和水平居中，box: 绿色盒子;center: 紫色盒子 inner: 橙黄色盒子</p>
<p>复制代码</p>
<p>我们用了一个:hover让鼠标虚浮的时候让盒子变红</p>
<p>.box:hover div {<br>background-color: red;</p>
<p>}</p>
<p>复制代码</p>
<p>这里有一个问题不知道大家想过没有，为什么我这段代码只让center盒子变红了，inner为什么没有变红呢???</p>
<p>展开查看</p>
<p>因为CSS选择器的优先级!复制代码</p>
<p>我们在实现的时候一般都会像下面这样写吧，这个时候使用伪类选择器改变元素样式的时候就要注意选择器优先级的问题了。</p>
<p>.box .center {<br>width: 150px;</p>
<p>height: 150px;</p>
<p>background-color: blueviolet;</p>
<p>}</p>
<p>.box .center .inner {<br>width: 100px;</p>
<p>height: 100px;</p>
<p>background-color: coral;</p>
<p>}</p>
<p>复制代码</p>
<p>这段代码的优先级比 .box .center高，所以他也就只能覆盖它了。</p>
<p>.box:hover div {<br>background-color: red;</p>
<p>}</p>
<p>复制代码</p>
<p>相信我们很多人如果在写鼠标悬浮大盒子让最里面的inner盒子变色的时候，都会这么写吧：</p>
<p>.box:hover .inner {<br>background-color: red;</p>
<p>}</p>
<p>复制代码</p>
<p>有用吗?没用!</p>
<p>注意⚠: 优先级还是没有.box .center .inner高。</p>
<p>层叠性</p>
<p>所谓层叠性是指多种CSS样式的叠加。是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</p>
<p>原则：</p>
<p>样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。</p>
<p>样式不冲突，不会层叠</p>
<p>CSS层叠性最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。</p>
<p>复制代码</p>
<p>继承性</p>
<p>：子标签会继承父标签的某些样式，如文本颜色和字号。 想要设置一个可继承的属性，只需将它应用于父元素即可。简单的理解就是： 子承父业</p>
<p>CSS继承性口诀： 龙生龙，凤生凤，老鼠生的孩子会打洞</p>
<p>复制代码</p>
<p>我们恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多后代元素都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。</p>
<p>注意点：在CSS的继承中不仅仅是儿子可以继承, 只要是后代都可以继承</p>
<p>可继承的属性</p>
<p>控制继承</p>
<p>注意点: 对于天生自带的继承属性我们可以控制它是否需要继承</p>
<p>四个属性</p>
<p>inherit: 被应用属性继承父级的该属性(默认就是该值)</p>
<p>initial初始化，把应用属性初始为它默认的样式，并且排除继承的干扰(默认会继承的属性也不在默认继承，而是表现出没有任何设置时候的默认样式)</p>
<p>unset：意思是恢复其原本的继承方式。对color属性而言，就相当于inherit;而对于诸如border这样默认不继承的属性，就相当于initial。</p>
<p>revert: 效果等同于unset且浏览器支持有限，这里不做演示</p>
<p>效果图</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>演示</p>
<p>Default link color</p>
<p>Inherit the link color</p>
<p>Reset the link color</p>
<p>Unset the link color</p>
<p>复制代码</p>
<p>default中的a标签没有写默认为inherit属性，但是使用了浏览器预设样式表：可以理解为浏览器帮我们为写了个style，其优先级自然就高于其父元素了。</p>
<p>inherit中的a标签在行内写了inherit，于是使用其父(或祖父，etc)元素的颜色值，在这里是绿色;</p>
<p>initial中的a标签使用color属性初始值(黑色), 注意不要混淆属性初始值和浏览器样式表指定值，样式预设表是浏览器事先写好的样式，但是我color默认值就是黑色啊。</p>
<p>unset，意思是恢复其原本的继承方式。对color属性而言，就相当于inherit;而对于诸如border这样默认不继承的属性，就相当于initial。</p>
<p>如果我们需要控制元素所有属性的继承使用all属性</p>
<p>.inherit a {<br>all: initial;</p>
<p>/* 将所有的属性都恢复成默认值(天生继承也不再继承) */</p>
<p>/* 行内设置过的除外：你的层级干不过人家 */</p>
<p>}</p>
<p>复制代码</p>
<p>继承的权重是0</p>
<p>这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。</p>
<p>(1) 如果选中了，那么以上面的公式来计权重。谁大听谁的。(2) 如果没有选中，那么权重是0，因为继承的权重为0.</p>
<p>控制继承在我们封装自己的组件的时候是会用到的，我们在封装组件需要沿用样式，有些默认情况下不可继承父元素的属性：box-sizing，这个其实用的就很多。</p>
<p>优先级</p>
<p>要想了解优先级，肯定得了解选择器;但是选择器非常多的，前面列举的是日常开发用的比较多，其他的你可能一辈子都用不到，这里贴出C1~C4的选择器，感兴趣的同学可以看看。</p>
<p>定义CSS样式时，经常出现两个或更多选择器应用在同一元素上，此时，</p>
<p>选择器相同，则执行层叠性(后者覆盖前者)</p>
<p>选择器不同，就会出现优先级的问题。</p>
<p>权重计算公式</p>
<p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity(特殊性)</p>
<p>标签选择器计算权重公式</p>
<p>继承或者 *0,0,0,0</p>
<p>每个元素(标签选择器)0,0,0,1</p>
<p>每个类，结构伪类(如:hover),属性选择器[type=“number”]0,0,1,0</p>
<p>每个ID0,1,0,0</p>
<p>每个行内样式 style=””1,0,0,0</p>
<p>h1 + p::first-line0,0,0,3</p>
<p>li &gt; a[href*=“beige.world”] &gt; .inline-warning0,0,2,2</p>
<p>每个!important 重要的∞ 无穷大</p>
<p>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</p>
<p>常用的选择器记法：</p>
<p>行内: 1,0,0,0</p>
<p>#id: 0,1,0,0</p>
<p>.class | :hover | :nth-child(): 0,0,1,0 (:hover这种一个冒号叫结构伪类)</p>
<p>::after | ::before | ::first-line: 0,0,0,1 (这种两冒号的叫伪元素，在书写的时候虽然你可以写一个冒号但是浏览器还是给你补上去了，本质上就是两冒号)</p>
<p>权重叠加</p>
<p>我们经常用组合选择器，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。</p>
<p>就是一个简单的加法计算</p>
<p>div ul li ——&gt; 0,0,0,3</p>
<p>.nav ul li ——&gt; 0,0,1,2</p>
<p>a:hover —–—&gt; 0,0,1,1</p>
<p>.nav a ——&gt; 0,0,1,1</p>
<p>注意⚠: 数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 = 0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</p>
<p>important适用优先级💡</p>
<p>#id .box div {<br>color: red !important;</p>
<p>}</p>
<p>#id div.box div {<br>color: green !important; // 使用这个选择器中的颜色</p>
<p>}</p>
<p>复制代码</p>
<p>通关答题</p>
<p>下面来几道题，全对才算通过了噢😗</p>
<p>文字</p>
<p>复制代码</p>
<p>什么颜色??</p>
<p>展开查看答案</p>
<p>yellow 上面两选择器的层级都是一样的, 后者覆盖前者 复制代码</p>
<p>试问这行字体是什么颜色的?</p>
<p>复制代码</p>
<p>展开查看答案</p>
<p>blue 复制代码</p>
<p>123</p>
<p>复制代码</p>
<p>展开查看答案</p>
<p>字体：80，有文字阴影，真实内容的宽：290px 高190px复制代码</p>
<p>讲下这最后一题</p>
<p>文字阴影有：因为从父元素中继承到了,字体: 80px;</p>
<p>真实内容宽290px, 高190px</p>
<p>常问的属性flex(弹性布局)</p>
<p>transform: translate3D rodate3D</p>
<p>animation(设定动画)</p>
<p>3D or 透视(perspective)</p>
<p>flex</p>
<p>flex布局相信大家也都用烂了，用来让盒子垂直和水平居中好用的一批</p>
<p>父项常用属性</p>
<p>flex-direction：设置主轴的方向</p>
<p>justify-content：设置主轴上的子元素排列方式</p>
<p>flex-wrap：设置子元素是否换行</p>
<p>align-content：设置侧轴上的子元素的排列方式(多行)</p>
<p>align-items：设置侧轴上的子元素排列方式(单行)</p>
<p>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</p>
<p>flex-direction</p>
<p>在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴</p>
<p>默认主轴方向就是 x 轴方向，水平向右</p>
<p>默认侧轴方向就是 y 轴方向，水平向下</p>
<p>&lt;img src=</p>
<p>“ width=“185” height=“30” align=””&gt;</p>
<p>： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</p>
<p>flex-wrap设置是否换行</p>
<p>默认情况下，项目都排在一条线(又称”轴线”)上。flex-wrap属性定义，flex布局中默认是不换行的。</p>
<p>nowrap 不换行</p>
<p>wrap 换行</p>
<p>justify-content 设置主轴上的子元素排列方式</p>
<p>&lt;img src=</p>
<p>“ width=“185” height=“30” align=””&gt;</p>
<p>效果图</p>
<p>： 这里讲下space-around和space-evenly</p>
<p>space-around：项目之间的间距为左右两侧项目到容器间距的2倍。</p>
<p>space-evenly：项目两侧之间的间距与项目与容器两侧的间距相等，相当于除去项目宽度和容器和项目的两侧间距，剩下的平均分配了剩余宽度作为项目左右margin。</p>
<p>**设置侧轴上的子元素排列方式：align-items(单行)/align-content(多行) **</p>
<p>上图写能设置多行只能用于子项出现 换行 的情况(多行)，在单行下是没有效果的。</p>
<p>效果跟上面是一样的只不过是方向换了，上面是元素在主轴上排列，这个是在侧抽上，至于侧轴是不是Y轴就看你的flex-direciton怎么设置的了</p>
<p>子项常见属性</p>
<p>flex(复合属性): 默认: flex: 0 1 auto;</p>
<p>flex-grow</p>
<p>flex-shrink</p>
<p>flex-basis</p>
<p>align-self：控制子项自己在侧轴的排列方式</p>
<p>order：定义子项的排列顺序(前后顺序), 0是第一个</p>
<p>flex-grow</p>
<p>默认0，用于决定项目在有剩余空间的情况下是否放大，默认不放大;注意，即便设置了固定宽度，也会放大。</p>
<p>假设第一个项目默认为0，第二个项目为flex-grow:2，最后一个项目为1，则第二个项目在放大时所占空间是最后项目的两倍。</p>
<p>可以这么理解:</p>
<p>flex: 1 =&gt; 在剩余的空间里我就占一份</p>
<p>flex: 2 =&gt; 在剩余的空间里我就占两份</p>
<p>flex: 3 =&gt; 在剩余的空间里我就占三份</p>
<p>假设三个盒子分别都设置了上面的属性: 那就将剩余空间分成6份, 各占自己的份数</p>
<p>假设前两个没有设置, 就最后一个设置了flex: 3 === flex: 1, 那就将剩余空间都给它</p>
<p>复制代码</p>
<p>flex-shrink</p>
<p>默认1，用于决定项目在空间不足时是否缩小，默认项目都是1，即空间不足时大家一起等比缩小;注意，即便设置了固定宽度，也会缩小。但如果某个项目flex-shrink设置为0，则即便空间不够，自身也不缩小。</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>上图中第二个项目flex-shrink为0，所以自身不会缩小。</p>
<p>flex-basis</p>
<p>默认auto，用于设置项目宽度，默认auto时，项目会保持默认宽度，或者以width为自身的宽度，但如果设置了flex-basis，权重会width属性高，因此会覆盖widtn属性。</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>上图中先设置了flex-basis属性，后设置了width属性，但宽度依旧以flex-basis属性为准。</p>
<p>注意⚠: 如果当容器中有多个盒子并且还宽度100%, flex-basis会被影响, 如下图</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>解决办法就是在我们设置flex-basis宽度时, 最好给他设置flex-shrink为0不缩放</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>transform</p>
<p>2D的属性相信大家都会用了, 本文主要深究transform的3D属性</p>
<p>透视：perspctive</p>
<p>3D呈现：transfrom-style</p>
<p>3D 位移：translate3d(x, y, z)</p>
<p>3D旋转：rotate3d(x, y, z)</p>
<p>透视(perspective)</p>
<p>在讲3D之间先来了解一下透视(视距)，只有了解了透视我们才能理解3D的物体投影在2D平面上</p>
<p>透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离</p>
<p>实际上模仿人类的视觉位置，可视为安排一直眼睛去看</p>
<p>距离透视点越近的在电脑平面成像越大，越远成像越小</p>
<p>透视的单位是像素</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>注意: 透视需要写在被视察元素的父盒子上面</p>
<p>拿图说话👇</p>
<p>d：就是视距，视距就是指人的眼睛到屏幕的距离</p>
<p>z：就是 z 轴，z 轴越大(正值)，我们看到的物体就越大</p>
<p>来个栗子🌰</p>
<p>给实例的父元素设置: perspective: 200px;</p>
<p>复制代码</p>
<p>上面我们在div的父盒子上设置了perspective，也就是说从3D成像的角度来讲我们人眼距离屏幕div是200的视距，translate3D设置Z轴让div往前挪了100，视距变小距离我们人眼距离也就越小，所以看到的div也就变大了。 (可以想像成在500米远看见的人， 和5米看见的人。)</p>
<p>translate3d(x, y, z)</p>
<p>3D的特点</p>
<p>近大远小</p>
<p>物体和面遮挡不可见</p>
<p>三维坐标系</p>
<p>x 轴：水平向右 – 注意：x 轴右边是正值，左边是负值</p>
<p>y 轴：垂直向下 – 注意：y 轴下面是正值，上面是负值</p>
<p>z 轴：垂直屏幕 – 注意：往外边的是正值，往里面的是负值</p>
<p>“ alt=” “ width=“35” height=“30” align=””&gt;</p>
<p>3D 呈现 transform-style</p>
<p>transform-style：控制子元素是否开启三维立体环境，代码写给父级，但是影响的是子盒子</p>
<p>transform-style: flat 代表子元素不开启 3D 立体空间，默认的</p>
<p>transform-style: preserve-3d 子元素开启立体空间</p>
<p>效果图</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>body {<br>perspective: 500px;</p>
<p>}</p>
<p>.box {<br>position: relative;</p>
<p>width: 200px;</p>
<p>height: 200px;</p>
<p>margin: 100px auto;</p>
<p>transition: all 2s;</p>
<p>/* 让子元素保持3d立体空间环境 */</p>
<p>transform-style: preserve-3d;</p>
<p>}</p>
<p>.box:hover {<br>transform: rotateY(60deg);</p>
<p>}</p>
<p>.box div {<br>position: absolute;</p>
<p>top: 0;</p>
<p>left: 0;</p>
<p>width: 100%;</p>
<p>height: 100%;</p>
<p>background-color: pink;</p>
<p>}</p>
<p>.box div:last-child {<br>background-color: purple;</p>
<p>transform: rotateX(60deg);</p>
<p>}</p>
<p>复制代码</p>
<p>rotate3d(x, y, z)</p>
<p>3D 旋转指可以让元素在三维平面内沿着 x 轴、y 轴、z 轴 或者自定义轴进行旋转</p>
<p>transform: rotate3d(x, y, z, 45deg)` – 沿着自定义轴旋转 45 deg 为角度</p>
<p>例子：</p>
<p>公众号:</p>
<p>前端自学驿站</p>
<p>复制代码</p>
<p>ul li {<br>float: left;</p>
<p>margin: 0 5px;</p>
<p>width: 120px;</p>
<p>height: 35px;</p>
<p>list-style: none;</p>
<p>/* 一会我们需要给box 旋转 也需要透视 干脆给li加 里面的子盒子都有透视效果 */</p>
<p>perspective: 500px;</p>
<p>}</p>
<p>.box {<br>position: relative;</p>
<p>width: 100%;</p>
<p>height: 100%;</p>
<p>transform-style: preserve-3d;</p>
<p>transition: all .4s;</p>
<p>}</p>
<p>.box:hover {<br>transform: rotateX(90deg);</p>
<p>}</p>
<p>.front,</p>
<p>.bottom {<br>position: absolute;</p>
<p>left: 0;</p>
<p>top: 0;</p>
<p>width: 100%;</p>
<p>height: 100%;</p>
<p>}</p>
<p>.front {<br>background-color: pink;</p>
<p>z-index: 1;</p>
<p>transform: translateZ(17.5px);</p>
<p>}</p>
<p>.bottom {<br>background-color: purple;</p>
<p>/* 这个x轴一定是负值 */</p>
<p>/* 我们如果有移动 或者其他样式，必须先写我们的移动 */</p>
<p>transform: translateY(17.5px) rotateX(-90deg);</p>
<p>}</p>
<p>复制代码</p>
<p>animation</p>
<p>动画(animation)是 CSS3 中最具颠覆性的特征之一，可通过设置多个节点来精确的控制一个或者一组动画，从而实现复杂的动画效果, 先定义动画在调用定义好的动画</p>
<p>动画序列</p>
<p>0% 是动画的开始，100 % 是动画的完成，这样的规则就是动画序列</p>
<p>在 @keyframs 中规定某项 CSS 样式，就由创建当前样式逐渐改为新样式的动画效果</p>
<p>动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数</p>
<p>用百分比来规定变化发生的时间，或用 from 和 to，等同于 0% 和 100%</p>
<p>@keyframes move{<br>0% {<br>transform: translate(0px)</p>
<p>}</p>
<p>form {<br>transform: translate(0px)</p>
<p>}</p>
<p>100% {<br>transform: translate(500px, 0)</p>
<p>}</p>
<p>to {<br>transform: translate(500px, 0)</p>
<p>}</p>
<p>}</p>
<p>复制代码</p>
<p>动画常见属性</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>动画简写方式</p>
<p>/* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */</p>
<p>animation: name duration timing-function delay iteration-count direction fill-mode</p>
<p>复制代码</p>
<p>除了名字，持续时间，何时开始有严格顺序要求其它随意</p>
<p>CSS实现扫描二维码</p>
<p>效果</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>代码篇幅过长我放到gitHub仓库了，大家可以pull下来自行研究。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/it-beige/blog">https://github.com/it-beige/blog</a></p>
<p>面试常问题BFC相关</p>
<p>BFC(Block formatting context)直译为”块级格式化上下文”。</p>
<p>在讲BFC之前得先说下display的属性值，只有它符合成为条件才资格触发BFC机制</p>
<p>“ alt=“display属性值” width=“113” height=“30” align=””&gt;</p>
<p>那些属性值会具有BFC的条件</p>
<p>不是所有的元素模式都能产生BFC，w3c 规范： display 属性为 block, list-item, table 的元素，会产生BFC.</p>
<p>大家有没有发现这个三个都是用来布局最为合理的元素，因为他们就是用来可视化布局。注意其他的，display属性，比如 line 等等，他们创建的是 IFC ，我们下面研究。</p>
<p>这个BFC 有着具体的布局特性：</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>有宽度和高度，有 外边距margin 有内边距padding 有边框 border。就好比，你有了练习武术的体格了。 有潜力，有资质。</p>
<p>什么情况下可以让元素产生BFC</p>
<p>以上盒子具有BFC条件了，就是说有资质了，但是怎样触发才会产生BFC，从而创造这个封闭的环境呢?</p>
<p>就好比，你光有资质还不行，你需要一定额外效果才能出发的武学潜力，要么你掉到悬崖下面，捡到了一本九阴真经，要么你学习葵花宝典，欲练此功必先…</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>同样，要给这些元素添加如下属性就可以触发BFC。</p>
<p>float属性不为none</p>
<p>position为absolute或fixed</p>
<p>display为inline-block, table-cell, table-caption, flex, inline-flex</p>
<p>overflow不为visible。</p>
<p>BFC元素所具有的特性</p>
<p>BFC布局规则特性：</p>
<p>在BFC中，盒子从顶端开始垂直地一个接一个地排列</p>
<p>盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</p>
<p>在BFC中，每一个盒子的左外边缘(margin-left)会触碰到容器的左边缘(border-left)(对于从右到左的格式来说，则触碰到右边缘)。</p>
<p>BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</p>
<p>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度</p>
<p>它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<p>白话文： 孩子在家里愿意怎么折腾都行，但是出了家门口，你就的乖乖的，不能影响外面的任何人。</p>
<p>复制代码</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>BFC的主要用途</p>
<p>(1) 清除元素内部浮动</p>
<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式</p>
<p>主要用到</p>
<p>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</p>
<p>复制代码</p>
<p>(2) 解决外边距合并(塌陷)问题</p>
<p>主要用到</p>
<p>盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</p>
<p>复制代码</p>
<p>属于同一个sBFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>(3) 制作右侧自适应的盒子问题</p>
<p>主要用到</p>
<p>普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文</p>
<p>复制代码</p>
<p>“ alt=”” width=“28” height=“30” align=””&gt;</p>
<p>BFC 总结</p>
<p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等，因此，有了这个特性，我们布局的时候就不会出现意外情况了。</p>
<p>IFC相关</p>
<p>IFC(inline Formatting Context)叫做“行级格式化上下”相对BFC比较简单且问的也不是很多，这里大该做个了解</p>
<p>布局规则如下：</p>
<p>内部的盒子会在水平方向，一个个地放置(默认就是IFC);</p>
<p>IFC的高度，由里面最高盒子的高度决定(里面的内容会撑开父盒子);</p>
<p>当一行不够放置的时候会自动切换到下一行;</p>
<p>哪些属性开启了性能加速</p>
<p>何为硬件加速：就是将浏览器的渲染过程交给GPU(Graphics Processing Unit)处理，而不是使用自带的比较慢的渲染器。这样就可以使得animation与transition更加顺畅</p>
<p>我们可以在浏览器中用CSS开启硬件加速，使GPU发挥功能，从而提升性能</p>
<p>所谓GPU，就是图形处理器的缩写，相当于PC中的显卡。手机中的GPU也是为了对图形、图像处理而存在的，所谓强制渲染，就是hwa(hardware acceleration硬件加载)的一种，其存在的意义就是为了分担cpu的负担，其原理是通过GPU对软件图形的处理来减轻CPU的负担。从而使应用软件能够以更快的速度被处理，以达到提速的目的。</p>
<p>硬件加速的原理</p>
<p>浏览器接收到页面文档后，会将文档中的标记语言解析为DOM树。DOM树和CSS结合后形成浏览器构建页面的渲染树。渲染树中包含大量的渲染元素，每个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理，而图层在GPU中transform是不会触发repaint的，最终这些使用transform的图层都会由独立的合成器进程进行处理, CSS transform会创建了一个新的复合图层，可以被GPU直接用来执行transform操作。</p>
<p>浏览器什么时候会创建一个独立的复合图层呢?事实上一般是在以下几种情况下：</p>
<p>3D或者CSS transform</p>
<p>和标签</p>
<p>css filters(滤镜效果)</p>
<p>元素覆盖时，比如使用了z-index属性</p>
<p>为什么硬件加速会使页面流畅</p>
<p>因为transform属性不会触发浏览器的repaint(重绘)，而绝对定位absolute中的left和top则会一直触发repaint(重绘)。</p>
<p>为什么transform没有触发repaint呢?</p>
<p>简而言之，transform动画由GPU控制，支持硬件加载，并不需要软件方面的渲染。并不是所有的CSS属性都能触发GPU的硬件加载，事实上只有少数的属性可以，比如transform、opacity、filter</p>
<p>如何用CSS开启硬件加速</p>
<p>CSS animation、transform以及transition不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行，那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。</p>
<p>当浏览器检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素是3D变化。</p>
<p>.cube{<br>translate3d(250px,250px,250px);</p>
<p>rotate3d(250px,250px,250px,-120deg)</p>
<p>scale3d(0.5,0.5,0.5);</p>
<p>}</p>
<p>复制代码</p>
<p>可能在一些情况下，我们并不需要对元素应用3D变幻的效果，那怎么办呢?这时候我们可以使用“欺骗”浏览器来开启硬件加速。虽然我们可能不想对元素应用3D变幻，可我们一样可以开启3D引擎。例如我们可以用transform:translateZ(0);来开启硬件加速</p>
<p>.cube{<br>transform: translateZ(0);</p>
<p>}</p>
<p>复制代码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/05/8.3.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/" data-id="ckw61sdx8006yoswdcrkye0qw" data-title="网页前端之CSS" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-8.2.网页前端之HTML" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/03/8.2.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BHTML/" class="article-date">
  <time class="dt-published" datetime="2021-04-03T01:43:19.000Z" itemprop="datePublished">2021-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/03/8.2.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BHTML/">网页前端之HTML</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lt-HTML-gt"><a href="#lt-HTML-gt" class="headerlink" title="&lt;HTML&gt;"></a><code>&lt;HTML&gt;</code></h1><p><code>&lt;html&gt;</code>标签相当于java类的大括号</p>
<p>HTML：(Hyper Text Markup Language)超文本标记语言,是用来写网页的，是设计页面的基础。</p>
<p>HTML是由标签所组成的语言，能展示超文本效果,由头和体组成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>需要展示给用户看的信息内容<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTML文件的扩展名为html或者htm:htm是老的命名规范，html是新的</p>
<p>HTML文件由浏览器直接解析运行，无需编译，直接由上到下依次解析执行</p>
<p>HTML标签通常由开始标签和结束标签组成，开始标签和结束标签之间的内容叫做内容体。</p>
<p>没有内容体的标签叫做空标签。仅由一个标签组成，例如：<code>&lt;br/&gt;</code> 自关闭</p>
<p>HTML标签不区分大小写，为了方便阅读，建议小写</p>
<p>HTML标签是有属性的，格式为属性名=“属性值”，属性值用引号引起来(单引号双引号都可以，建议双引号)</p>
<p>HTML标签建议包裹嵌套，不建议交叉嵌套</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p><code>&lt;!--HTML注释内容--&gt;</code>用于注释HTML源码，不在HTML效果中展示</p>
<h1 id="lt-head-gt"><a href="#lt-head-gt" class="headerlink" title="&lt;head&gt;"></a><code>&lt;head&gt;</code></h1><p><code>&lt;head&gt;</code>中存放的是网页的说明性内容</p>
<h2 id="lt-meta-gt"><a href="#lt-meta-gt" class="headerlink" title="&lt;meta&gt;"></a><code>&lt;meta&gt;</code></h2><p>是 HTML 语言头部的一个辅助性标签，我们可以定义页面编码语言、搜索引擎优化、自动刷新并指向新的页面、控制页面缓冲、响应式视窗等。·</p>
<p><code>&lt;meta&gt;</code> 元素可提供有关页面的元信息（meta-information,元数据总是以名称/值的形式被成对传递的），比如针对搜索引擎和更新频度的描述和关键词。</p>
<p><code>&lt;meta&gt;</code> 标签位于文档的头部，不包含任何内容。</p>
<p><code>&lt;meta&gt;</code> 标签的属性定义了与文档相关联的名称/值对。</p>
<p>整体来看，HTML5之前，meta标签只有两个主要属性，分别是 name 属性和 http-equiv 属性。 HTML5新添加”charset”</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;参数&quot;</span> <span class="attr">content</span>=<span class="string">&quot;参数值&quot;</span> /&gt;</span>  </span><br><span class="line">//name属性主要用于描述网页，对应属性是 content ，以便于搜索引擎机器人查找、分类（目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类）</span><br><span class="line">这里的name参数可以是多种值，对应不同效果：</span><br><span class="line">Keywords（关键字）</span><br><span class="line">Description（简介）</span><br><span class="line">robots（机器人向导）   用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引</span><br><span class="line">参数为 all ：默认值，文件将被检索，且页面上的链接可以被查询； 参数为 none ：文件将不被检索，且页面上的链接不可以被查询； 参数为 index ：文件将被检索； 参数为 follow ：页面上的链接可以被查询； 参数为 noindex ：文件将不被检索，但页面上的链接可以被查询； 参数为 nofollow ：文件将被检索，但页面上的链接不可以被查询；</span><br><span class="line">author（作者）</span><br><span class="line">copyright（版权）</span><br><span class="line">generator（编辑器）</span><br><span class="line">revisit-after（网站重访）</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;参数&quot;</span>  <span class="attr">content</span>=<span class="string">&quot;参数值&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;参数&quot;</span>  <span class="attr">content</span>=<span class="string">&quot;参数值&quot;</span>/&gt;</span></span><br><span class="line">//http-equiv类似于HTTP的头部协议，它回应给浏览器一些有用的信息，以帮助正确和精确地显示网页内容。与之对应的属性值为content，content中的内容其实就是各个参数的变量值</span><br><span class="line">Expires（期限）  指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新传输  必须使用GMT的时间格式，或者直接设为0（数字表示多久后过期）</span><br><span class="line">Pragma（cache模式） 禁止浏览器从本地计算机的缓存中访问页面内容   网页不保存在缓存中，每次访问都刷新页面。这样设定，访问者将无法脱机浏览</span><br><span class="line">Refresh（刷新）自动刷新并指向新页面 `<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span><span class="attr">content</span>=<span class="string">&quot;5; url=http://www.baidu.com/&quot;</span>/&gt;</span>`</span><br><span class="line">Set-Cookie（cookie设定）</span><br><span class="line">Window-target（显示窗口的设定） 强制页面在当前窗口以独立页面显示,可以用来防止别人在框架里调用你的页面</span><br><span class="line">content-Type（显示字符集的设定）设定页面使用的字符集，一般不用</span><br><span class="line">content-Language（显示语言的设定）</span><br><span class="line">http-equiv=&quot;imagetoolbar&quot; 指定是否显示图片工具栏，当为false代表不显示，当为true代表显示</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="&lt;link&gt;"></a><code>&lt;link&gt;</code></h2><p><code>&lt;link&gt;</code> 标签定义该文档与外部资源的关系。最常见的用途是链接样式表，也可以被用来创建站点图标(比如PC端的“favicon”图标和移动设备上用以显示在主屏幕的图标)</p>
<p>网站站点的小图标：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;images/logo.png&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/png&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;1651*1024&quot;</span>/&gt;</span>  指定格式为icon，然后类型指定图片，href放资源位置，可以设置大小</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span> /&gt;</span>  指定格式为icon，类型指定为ico，href放资源位置</span><br></pre></td></tr></table></figure>

<h2 id="lt-script-gt"><a href="#lt-script-gt" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h2><p>1、async  表示立即下载该脚本，但不妨碍页面中的其他操作(比如：下载其他资源或等待加载其他脚本)，只对外部文件有效。<br>2、charset 属性与 src 属性一起使用，告诉浏览器用来编码这个 javascript 程序的字符集。它的值是任何一个 ISO 标准字符集编码的名称。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。</p>
<p>3、defer 表示脚本可以延迟到文档完全被解析和显示后再执行。只对外部文件有效。<br>4、language 已废弃。 原来用于表示编写代码用的脚本语言，因大多数浏览器都会忽略这个属性，因此也没必要再用了。<br>5、src 表示包含要执行代码的外部文件。</p>
<p>6、type 可以看成language的替代属性；表示编写代码使用的脚本语言的内容类型。默认值为text/javascript</p>
<p>注意：<br>1、传统做法是将所有的<code>&lt;script&gt;</code>元素都放在页面的<code>&lt;head&gt;</code>元素中，但是这样页面响应就会比较慢（必须等到全部的Javascript代码都被下载、解析和执行完后，才能呈现页面内容）。现在的做法一般都是将Javascript引用放在<code>&lt;body&gt;</code>元素中页面内容的后面。</p>
<p>2、defer和asyncd的作用基本相似。定义defer=“defer”的脚本将延迟到浏览器遇到<code>&lt;/html&gt;</code>标签后再执行，原则上是延迟脚本还是按照原来的顺序执行，但是实际上执行的顺序不一定按照指定顺序执行。但是HTML5（以后称为H5）中已经明确规定,defer属性只使用于外部脚本文件，因此支持H5的实现会忽略给嵌入脚本设置的defer属性。async也只适用于外部脚本文件，并告诉浏览器立即下载脚本文件。但与defer不同的是，它并不保证按照指定顺序执行，又称为异步脚本标签（各脚本文件相互独立，互不依赖）</p>
<h1 id="lt-body-gt"><a href="#lt-body-gt" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h1><p>分类：</p>
<p>1.单标签：在⾃身标签标识结束，主要应⽤场景为<strong>功能性</strong>标签</p>
<p>双标签：有成对的结束标识，主要应⽤场景为<strong>内容性</strong>标签</p>
<p>2.行标签：⼜名<strong>内联标签</strong>，内联标签⾃身不具备宽⾼，可以和其他元素保持在同一行。根据内容多少来占用行内空间，不会自动换行。例：<code>&lt;br&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;，&lt;span&gt;</code>strong，u（下划线），em(强调)，i(斜体)，sub(下标),sup(上标)</p>
<p>块标签：又名<strong>块级标签</strong>，块标签可以设置宽⾼，不可以和其他元素保持在同一行，通常独⾃占据⼀⾏。以区域块方式出现，每个块标签独自占据一整行或多整行，块结束会自动换行。例：<code>&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;，&lt;div&gt;</code>li，dl，dt，dd,form,hr,pre</p>
<p>行内块级标签：可以和其他元素保持在在一行，还能能设置宽高。例：textarea，input，img，button</p>
<p>所谓的行级标签，块级标签，其实可以根据需要，在开发中通过css样式互相转换。即通过设置display属性，它的属性值中，inline（元素以行内标签进行展示），block（元素以块级标签进行展示），inline-block（元素以行内块级标签进行展示）</p>
<p>3.单一标签：单独出现，表示具体的功能或展示具体的内容</p>
<p>组合标签：配合使⽤，才能产⽣相应的内容与效果</p>
<h2 id="lt-h-gt-标题"><a href="#lt-h-gt-标题" class="headerlink" title="&lt;h&gt;标题"></a><code>&lt;h&gt;</code>标题</h2><p>标题（Heading）是通过 <code>&lt;h1&gt; - &lt;h6&gt;</code> 等标签进行定义的。</p>
<p><code>&lt;h1&gt;</code> 定义最大的标题    <code>&lt;h6&gt;</code> 定义最小的标题</p>
<p>注意：</p>
<ol>
<li>浏览器会自动地在标题的前后添加空行。</li>
<li>默认情况下，HTML 会自动地在块级元素前后添加一个额外的空行，比如段落、标题元素前后</li>
</ol>
<h2 id="lt-p-gt-段落"><a href="#lt-p-gt-段落" class="headerlink" title="&lt;p&gt;段落"></a><code>&lt;p&gt;</code>段落</h2><p>用于展示效果中划分段落，并且自动在段前和段后自动加空行</p>
<p>align：段落内容的对齐方式，默认是left，内容居左；right，右；center，居中。</p>
<p>（这个将要分段的内容放在<code>&lt;p&gt;&lt;/p&gt;</code>中即可）</p>
<p>注意：</p>
<ol>
<li><p>浏览器会自动地在段落的前后添加空行。（<code>&lt;p&gt;</code> 是块级元素）</p>
</li>
<li><p>使用空的段落标记 <code>&lt;p&gt;&lt;/p&gt; </code>去插入一个空行是个坏习惯。用 <code>&lt;br /&gt;</code> 标签代替它！（但是不要用 <code>&lt;br /&gt;</code> 标签去创建列表。）</p>
</li>
</ol>
<h2 id="lt-br-gt-换行"><a href="#lt-br-gt-换行" class="headerlink" title="&lt;br /&gt;换行"></a><code>&lt;br /&gt;</code>换行</h2><p>用于展示效果中换行 </p>
<p>HTML源码中换行，浏览器解析时会自动忽略</p>
<p>（这个放在要换行的地方就行）</p>
<h2 id="lt-font-gt-字体"><a href="#lt-font-gt-字体" class="headerlink" title="&lt;font&gt;字体"></a><code>&lt;font&gt;</code>字体</h2><p>用于展示效果中修饰文字样式</p>
<p><code>&lt;font 属性名=”属性值”&gt; 文字&lt;/font&gt;</code></p>
<p>size:控制字体大小。最小1~最大7</p>
<p>color:控制字体颜色.使用英文设置</p>
<p>face:控制字体类型。只能设置系统字库中存在的字体类型<br>这个font可以加载在文字中间，不一定非要在开始，从哪开始的字就是从哪变化）</p>
<h2 id="lt-hr-gt-分割线"><a href="#lt-hr-gt-分割线" class="headerlink" title="&lt;hr /&gt;分割线"></a><code>&lt;hr /&gt;</code>分割线</h2><p>水平线，多用于段落之间的分割</p>
<h2 id="lt-pre-gt-原样标签"><a href="#lt-pre-gt-原样标签" class="headerlink" title="&lt;pre&gt;原样标签"></a><code>&lt;pre&gt;</code>原样标签</h2><p>原样标签会保留空格和换行符，显示原文本文字。格式化文本。预定义格式文本。</p>
<p>在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。(紧跟在 <code>&lt;pre&gt; </code>开始标签后的换行符也会被省略)</p>
<h2 id="lt-section-gt-段落标签"><a href="#lt-section-gt-段落标签" class="headerlink" title="&lt;section&gt;段落标签"></a><code>&lt;section&gt;</code>段落标签</h2><p>和p同为块标签，自动换行显示每一段，但是section不存在行距，p自带行距</p>
<p>注：section和P放在一起，p优先，使用行距</p>
<h2 id="lt-div-gt-块级的块标签"><a href="#lt-div-gt-块级的块标签" class="headerlink" title="&lt;div&gt;块级的块标签"></a><code>&lt;div&gt;</code>块级的块标签</h2><p>用于在效果中 定义一块，默认占满一行，进行内容的显示  （会自动换行，默认占满一行 适用于大量信息展示）</p>
<p>是块级元素，内容会独立占一行。它是可用于组合其他 HTML 元素的容器。<code>&lt;div&gt;</code> 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。</p>
<p>如果与 CSS 一同使用，<code>&lt;div&gt; </code>元素可用于对大的内容块设置样式属性。</p>
<p><code>&lt;div&gt; </code>元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 <code>&lt;table&gt;</code> 元素进行文档布局不是表格的正确用法。<code>&lt;table&gt;</code> 元素的作用是显示表格化的数据</p>
<h2 id="lt-span-gt-行级的块标签"><a href="#lt-span-gt-行级的块标签" class="headerlink" title="&lt;span&gt;行级的块标签"></a><code>&lt;span&gt;</code>行级的块标签</h2><p>用于在效果中 一行上定义一个块，进行内容显示  （有多少内容就会占用多大空间 span不会自动换行 适用于少量信息展示，比如提示密码错误）</p>
<p>HTML <code>&lt;span&gt; </code>元素是内联元素，行内标签，可用作文本的容器。</p>
<p><code>&lt;span&gt; </code>元素也没有特定的含义。</p>
<p>当与 CSS 一同使用时，<code>&lt;span&gt; </code>元素可用于为部分文本设置样式属性</p>
<h2 id="lt-ol-gt-lt-li-gt-有序的列表标签"><a href="#lt-ol-gt-lt-li-gt-有序的列表标签" class="headerlink" title="&lt;ol&gt; &lt;li&gt; 有序的列表标签"></a><code>&lt;ol&gt; &lt;li&gt;</code> 有序的列表标签</h2><p><code>&lt;ol&gt;&lt;/ol&gt;</code> 用于在效果中定义一个有序列表  （会表明每个条目的顺序）</p>
<p>列表条项目标签：<code>&lt;li&gt;&lt;/li&gt; </code>用于在效果中定义一个列表的项目</p>
<h2 id="lt-ul-gt-lt-li-gt-无序的列表标签"><a href="#lt-ul-gt-lt-li-gt-无序的列表标签" class="headerlink" title="&lt;ul&gt; &lt;li&gt; 无序的列表标签"></a><code>&lt;ul&gt; &lt;li&gt; </code>无序的列表标签</h2><p><code>&lt;ul&gt;&lt;/ul&gt; </code>用于在效果中定义一个无序列表  （使用最多）</p>
<h2 id="lt-dl-gt-lt-dt-gt-lt-dd-gt-项目列表标签"><a href="#lt-dl-gt-lt-dt-gt-lt-dd-gt-项目列表标签" class="headerlink" title="&lt;dl&gt;&lt;dt&gt;&lt;dd&gt;项目列表标签"></a><code>&lt;dl&gt;&lt;dt&gt;&lt;dd&gt;</code>项目列表标签</h2><p>dl（定义列表，跟ul…li类似），dt（定义了定义列表中的项目），dd（定义描述项目的内容，跟dt一起搭配）</p>
<h2 id="lt-sub-gt-下标"><a href="#lt-sub-gt-下标" class="headerlink" title="&lt;sub&gt; 下标"></a><code>&lt;sub&gt; </code>下标</h2><h2 id="lt-sup-gt-上标"><a href="#lt-sup-gt-上标" class="headerlink" title="&lt;sup&gt; 上标"></a><code>&lt;sup&gt;</code> 上标</h2><h2 id="实体标签-转义字符"><a href="#实体标签-转义字符" class="headerlink" title="实体标签(转义字符)"></a>实体标签(转义字符)</h2><p>空格 <code>&amp;nbsp;</code>   HTML源码中的多个空格，效果中最终会合并成一个</p>
<p>小于号 <code>&amp;lt;</code></p>
<p>大于号 <code>&amp;gt;</code></p>
<p>人民币<code> &amp;yen;</code>&yen;</p>
<p>版权 <code>&amp;copy;</code>&copy;</p>
<p>商标<code> &amp;reg;</code>&reg;</p>
<h2 id="lt-embed-gt-lt-embed-gt-媒体标签"><a href="#lt-embed-gt-lt-embed-gt-媒体标签" class="headerlink" title="&lt;embed&gt;&lt;/embed&gt;媒体标签"></a><code>&lt;embed&gt;&lt;/embed&gt;</code>媒体标签</h2><p>hidden ： 设置隐藏插件是否隐藏</p>
<p>src ：用于指定音乐的路径    例：<code>&lt;embed src=&quot;1.mp3&quot; &gt;&lt;/embed&gt;</code></p>
<h2 id="lt-marquee-gt-滚动标签-（已废弃）"><a href="#lt-marquee-gt-滚动标签-（已废弃）" class="headerlink" title="&lt;marquee&gt; 滚动标签  （已废弃）"></a><code>&lt;marquee&gt;</code> 滚动标签  （已废弃）</h2><p>用来插入一段滚动的文字。可以使用它的属性控制当文本到达容器边缘发生的事情</p>
<p>direction : 指定滚动的方向</p>
<p>scrollamount : 指定滚动的速度。</p>
<p>loop :指定滚动的次数</p>
<h2 id="lt-a-gt-超链接标签"><a href="#lt-a-gt-超链接标签" class="headerlink" title="&lt;a&gt; 超链接标签"></a><code>&lt;a&gt;</code> 超链接标签</h2><p><code>&lt;a&gt;&lt;/a&gt;</code>用于在效果中定义一个可以点击跳转的链接<br>href：超链接跳转的路径</p>
<p>​    内网本机路径：相对路径和绝对路径</p>
<p>​    互联网路径：http://地址</p>
<p>​    本页：默认跳转到本页</p>
<p>href : 用于指定链接的资源</p>
<p>target: 设置打开新资源的目标</p>
<p>_Blank 在独立的窗口上打开新资源</p>
<p>_self 在当前窗口打开新资源</p>
<p>file: file协议（文件协议）这种协议主要是用于搜索本地机器的资源文件的。      格式：file:///f:/图片/1.jpg</p>
<p>邮件 的协议： mailTo</p>
<p>迅雷的协议： thunder</p>
<p>超链接标签的作用：</p>
<ol>
<li><p>可以用于链接资源。</p>
</li>
<li><p>锚点点位:首先编写一个锚点 ,锚点的格式：<code> &lt;a name=&quot;锚点名字&quot;&gt; 数据&lt;/a&gt;</code> ,再使用a标签 的herf属性连接到锚点出。 href=”#锚点的名字“</p>
</li>
</ol>
<p>超链接正常工作：1. a标签中必须有内容     2.a标签必须有href属性</p>
<p>注意：a标签内容体，不仅仅是文字，也可以是其他内容，例如图片</p>
<p>a标签的href属性，不仅仅可以链接到html上，也可以链接到其他文件上。例如图片</p>
<h2 id="lt-img-gt-图片标签"><a href="#lt-img-gt-图片标签" class="headerlink" title="&lt;img&gt; 图片标签"></a><code>&lt;img&gt;</code> 图片标签</h2><p><code>&lt;img /&gt; </code>用于在页面效果中展示一张图片<br>    src：图片的路径。（必有属性）</p>
<p>路径的写法：内网路径：绝对路径：C:\javaweb001_html\img\c_1.jpg文件在硬盘上的具体位置  （不建议使用）</p>
<p>相对路径：../img/c_1.jpg  从引入者所在目录出发 ../表示上一层目录 ./表示当前目录  （建议使用）</p>
<p>互联网路径：<code>http://www.baidu.com/xxx.jpg </code>必须在前面加上http://</p>
<p>​    width： 设置图片宽度</p>
<p>​    height： 设置图片高度</p>
<p>​    宽度和高度的设置：</p>
<p>​        默认单位是px，像素  “400” 固定的</p>
<p>​        百分比设置：是父标签的百分比  “50%” 动态改变的</p>
<p>​    alt: 如果图片资源无法找到，那么就显示对应的文字对图片进行说明。</p>
<p>​        （这些属性放在img和/之间）</p>
<h2 id="lt-table-gt-表格标签"><a href="#lt-table-gt-表格标签" class="headerlink" title="&lt;table&gt;表格标签"></a><code>&lt;table&gt;</code>表格标签</h2><p>表格使用到的标签：</p>
<p><code>&lt;table&gt;</code> 表格</p>
<p><code>&lt;tr&gt;</code> 定义表格中的一行</p>
<p><code>&lt;td&gt; </code>在表格一行中定义单元格</p>
<p><code>&lt;th&gt;</code> 表头 。默认的样式是居中，加粗。区别于普通单元格标签，里面的内容居中加粗了</p>
<p><code>&lt;caption&gt; </code>表格的标题</p>
<p>表格常用的属性：</p>
<p>​    border ：设置表格的边框</p>
<p>​    width : 设置表格的宽度</p>
<p>​    height: 设置表格的高度</p>
<p>单元格合并：<code>&lt;td&gt;</code> <code>&lt;th&gt;</code>都有这个合并属性<br>colspan：    设置单元格占据指定的列数;跨列合并单元格  colspan=”n”</p>
<p>rowspan： 设置单元格占据指定的行数; 跨行合并单元格  rowspan=”n”</p>
<p>合并步骤：A：确定合并哪几个单元格，确定是跨行合并还是跨列合并</p>
<p>B：在第一个出现的单元格上书写合并单元格属性</p>
<p>C：合并几个单元格，属性值就写几</p>
<p>D：被合并的单元格必须删掉</p>
<p><code>&lt;thead&gt; </code>标签用于组合 HTML 表格的表头内容。</p>
<p><code>&lt;thead&gt;</code> 元素应该与<code>&lt;tbody&gt;</code>和<code>&lt;tfoot&gt;</code>元素结合起来使用，用来规定表格的各个部分（表头、主体、页脚）。</p>
<p>通过使用这些元素，使浏览器有能力支持独立于表格表头和表格页脚的表格主体滚动。当包含多个页面的长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。</p>
<p><code>&lt;thead&gt; </code>标签必须被用在以下情境中：作为 <code>&lt;table&gt; </code>元素的子元素，出现在 <code>&lt;caption&gt;、&lt;colgroup&gt; </code>元素之后，<code>&lt;tbody&gt;、 &lt;tfoot&gt; 和 &lt;tr&gt; </code>元素之前。</p>
<h2 id="lt-form-gt-表单标签"><a href="#lt-form-gt-表单标签" class="headerlink" title="&lt;form&gt;表单标签"></a><code>&lt;form&gt;</code>表单标签</h2><p>表单标签的根标签是<code>&lt;form&gt;</code>标签</p>
<p>用来将用户输入的数据提交给服务器的程序  相当于一个WEB程序的入口</p>
<p>1.定义一个表单 <code>&lt;form&gt;</code>表单内容<code>&lt;/form&gt;</code></p>
<p>2.在表单中定义对应的表单输入项<br>    <code>&lt;input /&gt; </code>是一种自关闭的标签，用户可以在该标签上通过填写和选择进行数据的输入</p>
<p>​    type：设置该标签的种类</p>
<p>​    text：文本框  默认  不一定需要指定value值</p>
<p>​    password：密码框  内容为非明文</p>
<p>​    radio：单选框  在同一组内才具有单选效果（分组需要用到name属性，将name设置成相同的就变为一组）（单选框只能选择，不能输入 需要指定value属性，否则提交的都是on）（可以checked设置默认选中）</p>
<p>​    checkbox：复选框  在同一组内才具有复选效果</p>
<p>​    submit：提交按钮  用于控制表单提交数据（当表单提交后，会出现  ？参数列表  参数列表格式：参数1=参数值1&amp;参数2=参数值2&amp;参数3=参数值3 这些参数都是之前设置的name，参数值是value）</p>
<p>​    rest：重置按钮  用于将表单输入项恢复到默认状态</p>
<p>​    file：附件框  用于文件上传</p>
<p>​    hidden：隐藏域 一般用于提交时，服务器需要拿到，但是用户不需要看到的数据</p>
<p>​    button：普通按钮  需要和js的事件一起使用</p>
<p>​    name：单选框、复选框进行数据的分组；设置该标签对应的参数名</p>
<p>​    value：设置该标签对应的参数值；作为按钮的名字</p>
<p>​    checked：设置单选框/复选框的默认选中状态  值就是”cheked”</p>
<p>​    readonly：设置该标签的参数值只读，用户无法手动更改，但是数据可以正常提交 readonly=“readonly”</p>
<p>​    disabled：设置该标签不可用，参数值无法更改且参数值也无法提交</p>
<p>​    <code>&lt;select&gt;&lt;/select&gt;</code>选择框标签  定义一个选择框</p>
<p>​    name：设置该标签对应的参数名</p>
<p>​    multiple：设置该标签选项全部显示，并且可以进行多选提交，默认为单选</p>
<p>​    <code>&lt;option&gt;&lt;/option&gt;</code>选项标签  用于为一个选择添加一个选项</p>
<p>​    value：设置需要提交的参数值（一般选择的东西都需要指定的返回值value）</p>
<p>​    selected：设置选项的默认选中状态</p>
<p>注意事项：option的内容体一般是用来展示的  参数值应该是option的value属性值</p>
<p>​    <code>&lt;textarea&gt;&lt;/textarea&gt;</code>文本域标签</p>
<p>表单输入项标签之一，用户可以在该标签上通过输入进行数据的输入</p>
<p>name：设置该标签对应的参数名</p>
<p>文本域和文本框的区别：文本框不能换行，文本域可以</p>
<p>文本框参数值是value属性，文本域参数值是标签的内容体</p>
<p>提交表单</p>
<p>action：指定提交数据的地址.将数据提交到何处（提交的地方其实是？前面的地址）  默认提交到本页</p>
<p>​    本机内网路径：相对路径:      绝对路径：</p>
<p>​    互联网路径：http：//</p>
<p>method：指定表单的提交方式.将数据以何种方式提交  默认为get  提交方式可定义为get或者post</p>
<p>get提交方式的特点：把数据拼接到地址栏上</p>
<p>post提交方式的特点：没有把数据拼接到地址栏上。请求体</p>
<p>get和post的区别：</p>
<p>​    get会把提交的参数列表拼接到了地址栏后面，post不会</p>
<p>​    get方式提交的数据敏感信息不安全，post提交的数据相对安全</p>
<p>​    get方式提交的数据量是有限的，post方式从理论上提交的数据量是无限大的。所以尽量使用post方式提交表单</p>
<p>提交表单的注意事项：</p>
<p>提交中文问题：为什么要用URL编码：（因为你可能提交的数据中包含&amp;符号，后台无法正确切割）</p>
<p>URL编码解决方式：对特殊符号，中文进行编码，为了保证表单数据传递时能更好区分出name和value，保证数据传递的完整性</p>
<p>例子：中文的你好进行URL编码：</p>
<p>（1）你好，进行普通的编码，编码成字节数组（使用的是页面规定的字符集，例如utf-8）</p>
<p>（2）字节数组中的每一个元素都会从10进制转为16进制</p>
<p>（3）把已经转为16进制的字节数组，以%进行拼接，拼接出的字符串，就是URL编码后的结果</p>
<p>注意： 表单项的数据如果需要提交到服务器上面，那么表单项必须要有name的属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; method&#x3D;&quot;post&quot;&gt; &lt;!-- 文本输入框 单 行- -&gt; 用户名：&lt;input name&#x3D;&quot;userName&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;!-- 密码框 --&gt;</span><br><span class="line">密码：&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;!-- 单选框 --&gt;</span><br><span class="line">性别： 男&lt;input checked&#x3D;&quot;true&quot; value&#x3D;&quot;man&quot; name&#x3D;&quot;sex&quot; type&#x3D;&quot;radio&quot;&#x2F;&gt;</span><br><span class="line">女&lt;input name&#x3D;&quot;sex&quot; value&#x3D;&quot;woman&quot; type&#x3D;&quot;radio&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt; !-- 下拉框 --&gt;</span><br><span class="line">来自的城市：&lt;select name&#x3D;&quot;city&quot;&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;BJ&quot;&gt;北京&lt;&#x2F;option&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;SH&quot;&gt;上海&lt;&#x2F;option&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;GZ&quot;&gt;广州&lt;&#x2F;option&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;SZ&quot;&gt;深圳&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;!-- 复选框 同一组的复选框name的属性值要一致 --&gt;</span><br><span class="line">兴趣爱好：java &lt;input value&#x3D;&quot;java&quot; name&#x3D;&quot;hobit&quot; checked&#x3D;&quot;checked&quot; type &#x3D;&quot;checkbox&quot; &#x2F;&gt;</span><br><span class="line">javascript &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;javascript&quot; name&#x3D;&quot;hobit&quot; &#x2F;&gt;</span><br><span class="line">android &lt;input value&#x3D;&quot;android&quot; name&#x3D;&quot;hobit&quot; type&#x3D;&quot;checkbox&quot; &#x2F;&gt;&lt;br&#x2F;&gt; &lt;!-- 文件上传框--&gt;</span><br><span class="line">大头照：&lt;input name&#x3D;&quot;image&quot; type&#x3D;&quot;file&quot; &#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">个人简介:</span><br><span class="line">&lt;!-- 文本域 --&gt;</span><br><span class="line">&lt;textarea name&#x3D;&quot;intro&quot; rows&#x3D;&quot;10&quot; cols&#x3D;&quot;30&quot;&gt;&lt;&#x2F;textarea&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;!-- 提交按钮 --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&#x2F;&gt;</span><br><span class="line">&lt;!-- 重置按钮 --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;reset&quot; value&#x3D;&quot;重置&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="lt-figure-gt-标签"><a href="#lt-figure-gt-标签" class="headerlink" title="&lt;figure&gt; 标签"></a><code>&lt;figure&gt; </code>标签</h2><p>代表一段独立的内容, 经常与说明（caption）<code> &lt;figcaption&gt;</code> 配合使用, 并且作为一个独立的引用单元。当它属于主内容流（main flow）时，它的位置独立于主体。这个标签经常是在主文中引用的图片，插图，表格，代码段等等，当这部分转移到附录中或者其他页面时不会影响到主体</p>
<h2 id="lt-template-gt-标签"><a href="#lt-template-gt-标签" class="headerlink" title="&lt;template&gt;标签"></a><code>&lt;template&gt;</code>标签</h2><p>模板元素</p>
<p>1.标签内容隐藏性:   自带display:none</p>
<p>2.标签位置任意性：类似<code>&lt;script&gt;</code>或者<code>&lt;style&gt;</code>标签，可以在<code>&lt;head&gt;</code>中，也可以在<code>&lt;body&gt;</code>或者<code>&lt;frameset&gt;</code>中</p>
<p>3.childNodes无效性:肉眼看上去是<code>&lt;template&gt;</code>标签里面还有很多子标签,但是template.childNodes无效，可以使用template.innerHTML获取完整的HTML片段。template.content会返回一个文档片段，可以理解为另外一个document，然后，使用document下的一些查询API就可以获得<code>&lt;template&gt;</code>标签里面的“伪子元素”了</p>
<h2 id="lt-iframe-gt-标签"><a href="#lt-iframe-gt-标签" class="headerlink" title="&lt;iframe&gt;标签"></a><code>&lt;iframe&gt;</code>标签</h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。可以用来在一个网页内引用另一个网页，网页的内容资源用src。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#fh5co-menu &#123;</span><br><span class="line">  background: ;</span><br><span class="line">  position: absolute;   绝对的</span><br><span class="line">  top: 0;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  width: 100%;</span><br><span class="line">  padding-bottom: 20px;</span><br><span class="line">  -webkit-transition: 0.5s;</span><br><span class="line">  -o-transition: 0.5s;</span><br><span class="line">  transition: 0.5s;</span><br><span class="line">  -webkit-border-radius: 0px;</span><br><span class="line">  -moz-border-radius: 0px;</span><br><span class="line">  -ms-border-radius: 0px;</span><br><span class="line">  border-radius: 0px;</span><br><span class="line">  margin-top: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//控制背景随动</span><br><span class="line">#fh5co-clients &#123;</span><br><span class="line">  padding: 2em 0;</span><br><span class="line">  background: #4fd2c2;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#fh5co-clients1 &#123;</span><br><span class="line">  padding: 2em 0;</span><br><span class="line">  background: #4fd2c2;</span><br><span class="line">  position: relative;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 992px) &#123;</span><br><span class="line">  #fh5co-clients1 .fh5co-client &#123;</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 768px) &#123;</span><br><span class="line">  #fh5co-clients1 .fh5co-client &#123;</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 480px) &#123;</span><br><span class="line">  #fh5co-clients1 .fh5co-client img &#123;</span><br><span class="line">    max-width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>长度单位</p>
<p>px 像素（Pixel），相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br>em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</p>
<p>ex 相对长度单位。相对于字符“x”的高度。此高度通常为字体尺寸的一半。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>% 相对长度单位。相对于浏览器窗口的大小</p>
<p>CSS绝对长度单位 说明<br>in 英寸Inches (1 英寸 = 2.54 厘米)<br>cm 厘米Centimeters<br>mm 毫米Millimeters<br>pt 点Points (1点 = 1/72英寸)<br>pc 皮卡Picas (1 皮卡 = 12 点)</p>
<p><strong>PX和PT转换的公式： pt=px乘以3/4。</strong>比如12px×3/4=9pt大小。<br><strong>PX和em转换的公式： em=16乘以px</strong>，也就是说1.5em=1.5×16=24px</p>
<p>用px来定义字体，就无法用浏览器字体放大的功能。</p>
<p>任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合:1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为16px*62.5%=10px,这样12px=1.2em,10px=1em,也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。<br>◆CSS中em属性有如下特点</p>
<p>1.em的值并不是固定的；</p>
<p>2.em会继承父级元素的字体大小。</p>
<p>◆所以我们在写CSS的时候，需要注意</p>
<p>1.body选择器中声明Font-size=62.5%；</p>
<p>2.将你的原来的px数值除以10，然后换上em作为单位；</p>
<p>3.重新计算那些被放大的字体的em数值。避免字体大小的重复声明。</p>
<p>也就是避免1.2*1.2=1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em,因为此em非彼em，它因继承#content的字体高而变为了1em=12px。</p>
<p>但是12px汉字例外，就是由以上方法得到的12px(1.2em)大小的汉字在IE中并不等于直接用12px定义的字体大小，而是稍大一点。这个问题Jorux已经解决，只需在body选择器中把62.5%换成63%就能正常显示了。原因可能是IE处理汉字时，对于浮点的取值精确度有限。不知道有没有其他的解释</p>
<p><strong>position</strong>: absolute;的元素会相对于第一个设置了position: relative;的祖先元素进行定位，将assistor设置为position: reletive;，滚动条是在parent中的，position: fixed;和parent内的内容滚动就都实现了。</p>
<p><strong>z-index</strong> 属性来控制这些框的堆放次序</p>
<h1 id="响应式布局（PC端适配手机端）"><a href="#响应式布局（PC端适配手机端）" class="headerlink" title="响应式布局（PC端适配手机端）"></a>响应式布局（PC端适配手机端）</h1><p>只开发一个网页，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。可以适配任何设备，兼容多个终端。</p>
<p>响应式开发的原理是使用CSS3中的Media Query（媒体查询）针对不同宽度的设备设置不同的布局和样式，从而适配不同的设备</p>
<p>使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面</p>
<p>设备的划分情况为：</p>
<ul>
<li>小于768的为超小屏幕（手机）</li>
<li>768~992之间的为小屏设备（平板）</li>
<li>992~1200的中等屏幕（桌面显示器）</li>
<li>大于1200的宽屏设备（大桌面显示器）</li>
</ul>
<p>屏幕宽度低于480像素的设备（如iPhone等）</p>
<p>1.在网站HTML文件的开头，增加viewport meta标签告诉浏览器视口宽度等于设备屏幕宽度，且不进行初始缩放：</p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; </code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。 </span><br><span class="line">height：和 width 相对应，指定高度。也可以指定为 window.screen.height</span><br><span class="line">initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</span><br><span class="line">maximum-scale：允许用户缩放到的最大比例。 </span><br><span class="line">minimum-scale：允许用户缩放到的最小比例。</span><br><span class="line">user-scalable：用户是否可以手动缩放。</span><br></pre></td></tr></table></figure>

<p>2.在CSS文件尾部增加针对不同屏幕分辨率的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-device-width: 720px) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">media&#x3D;”screenand(max-device-width:400px)” href&#x3D;”tinyScreen.css”&#x2F;&gt;</span><br><span class="line">如果屏幕宽度小于400像素(max-device-width:400px)，就加载tinyScreen.css文件　</span><br><span class="line">media&#x3D;”screenand(min-width:400px)and(max-device-width:600px)” href&#x3D;”smallScreen.css”&#x2F;&gt;</span><br><span class="line">如果屏幕宽度在400像素到600像素之间，则加载smallScreen.css文件　　</span><br></pre></td></tr></table></figure>

<p>3.<strong>布局宽度使用相对宽度。</strong>网页总体框架可以使用绝对宽度，但往下的内容框架、侧栏等最好使用相对宽度，这样针对不同分辨率进行修改就方便。当然也可以不用相对宽度，那就需要在 @media screen and (max-device-width: 480px) 里面增加各个div的针对小屏幕的宽度，实际上更麻烦</p>
<p>4.在HTML页面上不要使用绝对字体（px），而要使用相对字体（em），对于大多数浏览器来说，通常用 em = px/16 换算，例如16px就等于1em</p>
<p>PC站和手机站匹配最常用的几种方法是移动适配、<a target="_blank" rel="noopener" href="http://www.w3cschool.cn/lwp2e2/hqky12kg.html">JS跳转</a>、<a target="_blank" rel="noopener" href="http://www.w3cschool.cn/htmltags/tag-meta.html">Meta声明</a>、302规则等等</p>
<p><strong>1、移动适配</strong></p>
<p>现在很多搜索引擎都提供移动适配的功能，例如百度的开放适配和360的移动适配，利用<a target="_blank" rel="noopener" href="http://www.w3cschool.cn/ycx23r">百度站长工具</a>提交PC页-手机页对应关系Sitemap，或者利用<a target="_blank" rel="noopener" href="http://www.w3cschool.cn/seoyh/gwyrpf.html">360站长工具</a>提交PC页-手机页对应关系txt就能实现PC站内容和手机站一一适配。 这样做的优点是只需要在搜索引擎工具提交资料，无需对站点本事做改动，而且网站内容一一对应，并不只局限于网站首页。 缺点就是只能在百度或者360移动搜索中生效，其他没用提交适配文件的搜索中就无效了。</p>
<p><strong>2、JS跳转</strong></p>
<p><a target="_blank" rel="noopener" href="http://www.w3cschool.cn/lwp2e2/hqky12kg.html">JS跳转</a>对于某些行业来说有着重要的作用，尤其是对于用户转换率网站首页较高的网站，只需要在网站的头部加一段JS代码判定是否是移动端访问，然后所有的流量就会全部流向手机站的主页。 JS跳转的优点是适用于所以的移动搜索，并不局限于百度和360，可以提高用户的转换率。 缺点是难以实现每个页面的一一对应，而且容易被某些搜索引擎判定作弊，从而受到惩罚。</p>
<p><strong>3、Meta声明</strong></p>
<p><a target="_blank" rel="noopener" href="http://www.w3cschool.cn/htmltags/tag-meta.html">Meta声明</a>的格式一般为，站长可以将这段代码加在PC站的头部，由Meta信息来指明该PC页对应的手机页的<a target="_blank" rel="noopener" href="http://www.w3cschool.cn/html/html-url.html">URL</a>，以及该URL对应页面的格式。 Meta声明的优点是代码简单易懂，操作方便。 缺点是只能在百度移动搜索中生效，对于其他搜索引擎无效。</p>
<p><strong>4、302规则</strong></p>
<p>302规则指的是，当判定移动端访问网站时，302临时跳转到一个网址(手机站)，例如可以在htaccess文件里加上一段判定手机的代码，做个302重定向。 这样做的好处是，不需要再额外在网站的前端代码中加任何东西，也不需要向搜索引擎提交规则，可是据测试，有可能会导致PC站被降权。 虽然302是暂时性的重定向，但过于频繁的302是很有可能给网站带来不利的影响的，具体的尺度需要站长自己去把握。</p>
<p>以上4种适配方法是最为常见的操作方法，通常PC站做了以上处理后，一段时间以后移动端搜索出来的结果，下面匹配的网址就变成了移动站网址，不过标题还是PC站标题。 至于到底哪种方法更好，更倾向于第一种，毕竟百度移动搜索占据着网站的大部分流量，而且用户体验度也最好。</p>
<h1 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h1><p>轮播图的样式有很多,可以选择一个框架，然后将代码复制下来，将用到的样式放到自己的文件夹里，这样就可以做成一个轮播图。</p>
<p>在layui中，如果想让轮播图完成在放大缩小的过程中保证图片随动，目前解除了两种方法：</p>
<p>1.写一个响应式布局的css样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#fh5co-clients &#123;</span><br><span class="line">  padding: 2em 0;</span><br><span class="line">  background: #4fd2c2;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">#fh5co-clients &#123;</span><br><span class="line">  margin-bottom: 0px;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 992px) &#123;</span><br><span class="line">  #fh5co-clients &#123;</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 768px) &#123;</span><br><span class="line">  #fh5co-clients&#123;</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 480px) &#123;</span><br><span class="line">  #fh5co-clients img &#123;</span><br><span class="line">    max-width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.写一个js方法，会不断刷新，影响体验</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> b = <span class="number">1768</span>/<span class="number">881</span>;<span class="comment">//这里的图片数值是根据自己的图片指定</span></span><br><span class="line">    <span class="comment">//获取浏览器宽度</span></span><br><span class="line">    <span class="keyword">var</span> W = $(<span class="built_in">window</span>).width();</span><br><span class="line">    <span class="keyword">var</span> H = $(<span class="built_in">window</span>).height();</span><br><span class="line">    layui.use(<span class="string">&#x27;carousel&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> carousel = layui.carousel;</span><br><span class="line">        <span class="comment">//建造实例</span></span><br><span class="line">        carousel.render(&#123;</span><br><span class="line">            elem: <span class="string">&#x27;#test1&#x27;</span></span><br><span class="line">            ,<span class="attr">width</span>: <span class="string">&#x27;100%&#x27;</span> <span class="comment">//设置容器宽度</span></span><br><span class="line">            ,<span class="attr">height</span>: (W/b).toString()+<span class="string">&quot;px&quot;</span>  <span class="comment">//按比例和浏览器可视页面宽度来获取高度</span></span><br><span class="line">            <span class="comment">// ,arrow: &#x27;always&#x27; //始终显示箭头</span></span><br><span class="line">            <span class="comment">//,anim: &#x27;updown&#x27; //切换动画方式</span></span><br><span class="line">            ,<span class="attr">indicator</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// setBanner();</span></span><br><span class="line">        <span class="built_in">window</span>.location.reload()  <span class="comment">//每当设置后，进行刷新</span></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="网页调试技巧"><a href="#网页调试技巧" class="headerlink" title="网页调试技巧"></a>网页调试技巧</h1><p>1.F12开发模式，左上角图标有两个：箭头图标可以选择元素，就会指示当前指向的元素，可以注意数值多大，方便知道这个标签管辖的范围。手机图标，点击之后可以模拟手机端查看网页，也可以通过拖动浏览器大小模拟查看。</p>
<p>2.开发者模式下，elements中选择了某一行后，可以在style中查看生效的样式，不生效的样式被划掉了，没有写过的样式不会显示。可以在样式中手动编辑数值模拟调试（比改一处看一处方便一点）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/03/8.2.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BHTML/" data-id="ckw61sdws006doswd1zx096xy" data-title="网页前端之HTML" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/17/SpringBootSecurity/">SpringBootSecurity</a>
          </li>
        
          <li>
            <a href="/2021/12/16/SpringBootActuator/">SpringBootActuator</a>
          </li>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>