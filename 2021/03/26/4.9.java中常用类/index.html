<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>java中常用类 | swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="API（Application Programming Interface）概述：就是java提供给我们使用的类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用，我们可以通过查找帮助文档来了解java提供的API如何使用。 Object类JDK1.0 类层次结构的根类，每个类都直接或者间接继承自Object类。 所有对象（包括数组）都实现了这个类的方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="java中常用类">
<meta property="og:url" content="https://s-qwer.github.io/2021/03/26/4.9.java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="API（Application Programming Interface）概述：就是java提供给我们使用的类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用，我们可以通过查找帮助文档来了解java提供的API如何使用。 Object类JDK1.0 类层次结构的根类，每个类都直接或者间接继承自Object类。 所有对象（包括数组）都实现了这个类的方法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s-qwer.github.io/4.9.java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/image-20210809165151605.png">
<meta property="article:published_time" content="2021-03-26T11:03:45.000Z">
<meta property="article:modified_time" content="2021-10-25T03:43:58.581Z">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s-qwer.github.io/4.9.java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/image-20210809165151605.png">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-4.9.java中常用类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/4.9.java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T11:03:45.000Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      java中常用类
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>API（Application Programming Interface）概述：就是java提供给我们使用的类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用，我们可以通过查找帮助文档来了解java提供的API如何使用。</p>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>JDK1.0</p>
<p>类层次结构的根类，每个类都直接或者间接继承自Object类。 所有对象（包括数组）都实现了这个类的方法。</p>
<p>构造方法： public Object()  </p>
<p>成员方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>



<p>public int hashCode()  返回该对象的哈希码值</p>
<p>哈希值是根据哈希算法计算出来的一个值，这个值和地址值有关，但不是实际地址值，可以理解为地址值。</p>
<p>public final Class getClass()  返回此Object的运行时类。</p>
<p>//Class也是一个类，是Class对象建模的类的类型。它其中有个方法：</p>
<p>//public String getName()  以String的形式返回此Class对象所表示的全类名称</p>
<p>public String toString()  返回该对象的字符串表示</p>
<p>toString()方法的值等价于：<a href="mailto:getClass().getName()+’@’+Integer.toHexString(hashCode())">getClass().getName()+’@’+Integer.toHexString(hashCode())</a></p>
<p>这个信息是没有任何意义的，所以建议所有子类都重写此方法。</p>
<p>重写：建议重写成把该类的所有成员变量值组成返回。（右键–resources–toString 自动生成，重写的最终版方案就是自动生成）</p>
<p>注意：直接输出一个对象的名称，其实就是调用该对象的toString()方法。</p>
<p>public boolean equals(Object obj)  指示其他某个对象是否与此对象“相等”</p>
<p>这个方法默认情况下比较的是地址值。</p>
<p>比较地址值一般意义不大，所以我们要重写该方法。重写完的方法一般是用来比较对象的成员变量值是否相同。</p>
<p>String的equals()方法是重写自Object类的，比较的是字符串的内容是否相同</p>
<p>重写的代码优化：提高效率，提高代码的健壮性。</p>
<p>最终版其实是自动生成。</p>
<p>==：基本类型：比较的就是值是否相同</p>
<p>引用类型：比较的就是地址值是否相同</p>
<p>equals：</p>
<p>只能比较引用类型：默认情况比较的是地址值，不过我们可以根据自己的情况重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同。</p>
<p>protected void finalize()  当垃圾回收器不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。永远垃圾回收，但是什么时候回收不确定。</p>
<p>protected Object clone()  创建并返回此对象的一个副本。</p>
<p>因为是prtected，所以需要重写该方法。</p>
<p>Cloneable：此类实现了Cloneable接口，以指示Object.clone()方法可以合法的对该类实力进行按字段复制。这个接口是****标记****接口，告诉我们实现该接口的类就可以实现对象的复制了。（就只是起个标记的作用，只有实现该接口的类才能被clone）</p>
<p>意义：clone之后改动对以前的数据无影响。而直接赋值引用改动会对以前的数据产生影响。（这只是浅克隆）</p>
<h1 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h1><p>需要导包：import java.util.Scanner</p>
<p>JDK5以后用于获取用户的键盘输入</p>
<p>构造方法：public Scanner(InputStreamsource)</p>
<p>System类下有一个静态的字段： public static final InputStream in; 标准的输入流，对应着键盘录入。</p>
<p>成员方法：</p>
<p>hasNextXxx() ****判断****是否还有下一个输入项，其中Xxx可以是Int，Double等。如果需要判断的是否包含下一个字符串，可以省略Xxx</p>
<p>nextXxx() 获取下一个输入项。</p>
<p>默认情况下，Scanner使用空格，回车等作为分隔符。</p>
<p>常用的方法：</p>
<p>public int nextInt()</p>
<p>public String nextLine()</p>
<p>先获取一个数值，在获取一个字符串，就会出现问题（因为换行符号被当成是字符串输入）</p>
<p>解决：A.先获取一个数值后，再创建一个新的键盘录入对象获取字符串。</p>
<p>B.把所有的数据都先按照字符串获取，然后要什么在对应转换成什么。</p>
<p>键盘录入数据</p>
<p>1.导包：import java.util.Scanner  （import必须出现在所有的class前面）</p>
<p>2.创建对象：Scanner sc=new Scanner(System.in)</p>
<p>3.接收数据：int x=sc.nextInt();</p>
<p>String s=sc.nextLine();</p>
<h1 id="String类-StringBuffer类-StringBuilder类"><a href="#String类-StringBuffer类-StringBuilder类" class="headerlink" title="String类/StringBuffer类/StringBuilder类"></a>String类/StringBuffer类/StringBuilder类</h1><p>字符串是由多个字符组成的一串数据（字符序列）</p>
<p>字符串可以看成是字符数组。</p>
<p>字符串字面值”abc”也可以看成是一个字符串对象。</p>
<p>字符串是常量，一旦被赋值，就不能被改变。字符串直接赋值的方式是先到方法区中的字符串常量池里面去找，如果有就直接返回，没有就创建返回。（赋的值不能变，引用可以变）</p>
<ol>
<li>String s=”hello”;  s+=”world”; 则s的输出结果是：helloworld</li>
</ol>
<p>因为s的赋值hello不能改变，但是+world后在方法区的常量池中会重新生成一个地址值指向栈的s。</p>
<ol start="2">
<li>String s=new String(“hello”);和String s=”hello”; 的区别？</li>
</ol>
<p>区别就是前者会生成2个或1个（可能常量池中已经存在hello常量）对象，而后者只会生成1个或0个对象。（因为前者会在堆内存中生成一个地址值，而后者是方法区中的常量池直接指向栈内存）</p>
<p>字符串如果是变量相加，先开空间，在拼接。</p>
<p>字符串如果是常量相加，直接加，然后在常量池中找，如果有就直接返回，否则就创建。</p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span>   <span class="comment">//空构造</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span>  <span class="comment">//把字节数组转成字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes,<span class="keyword">int</span> index,<span class="keyword">int</span> length)</span><span class="comment">//把字节数组的一部分转成字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value)</span>  <span class="comment">//把字符数组转成字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value,<span class="keyword">int</span> index,<span class="keyword">int</span> count)</span><span class="comment">//把字符数组的一部分转成字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span>  <span class="comment">//把字符串常量值转成字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String s</span>=”hello”; <span class="comment">//这个虽然不是构造方法，但结果也是一个字符串对象</span></span><br></pre></td></tr></table></figure>

<p>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>  ：返回此字符串的长度。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String类的判断功能：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>   比较字符串的内容是否相同，区分大小写</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span>比较字符串的内容是否相同，忽略大小写</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span>  判断大串中是否包含小串<span class="params">(连续的)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span> 判断字符串是否以某个指定的字符串开头</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span> 判断字符串是否以某个指定的字符串结尾</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> 判断字符串是否为空</span></span><br></pre></td></tr></table></figure>

<p>字符串内容为空（“”）和字符串对象为空（null）是两个概念。</p>
<p>空指针不能调用方法。</p>
<p>String类的获取功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>   获取字符串的长度</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>  获取指定索引位置的字符</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span>  返回指定字符在此字符串中第一次出现的索引</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">为什么是<span class="keyword">int</span>类型不是字符类型：因为’a’和97都可以代表’a’，但是如果写字符类型的话就不能写数字了，因为<span class="keyword">int</span>类型的范围比字符<span class="keyword">char</span>的类型范围大，要强转，可能会出错。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>  返回指定字符串在此字符串中第一次出现的索引</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch,<span class="keyword">int</span> fromIndex)</span>  返回指定字符在此字符串中从指定位置后第一次出现的索引</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str,<span class="keyword">int</span> fromIndex)</span>  返回指定字符串在此字符串中从指定位置后第一次出现的索引</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span>  从指定位置开始截取字符串，默认到末尾（包括start索引）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>  从指定位置开始到指定位置结束截取字符串（包括start索引但是不包括end索引）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">遍历数组：<span class="title">length</span><span class="params">()</span>和<span class="title">charAt</span><span class="params">()</span>即可</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">统计一个字符串中大、小写字母、数字出现的次数：定义统计变量，遍历数组，每个字符判断。（判断就直接判断，因为字符判断时候都会转化成<span class="keyword">int</span>型在判断）</span></span><br></pre></td></tr></table></figure>

<p>String类的转换功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getBytes()   把字符串转换成字节数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] toCharArray() 把字符串转换成字符数组</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span>[] chs)</span> 把字符数组转换成字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> 把<span class="keyword">int</span>类型转换成字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String类的valueOf方法可以把任意类型的数据转成字符串（方法的重载）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span> 把字符串转成小写（原字符串不变）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span> 把字符串转成大写</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span> 把字符串拼接</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">String format（）</span></span><br></pre></td></tr></table></figure>

<p>String类的其他功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">替换功能：</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> old,<span class="keyword">char</span> new)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String old,String new)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">去除字符串的两端空格（不去除中间的）：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">按字典顺序比较两个字符串 ： （依次比较字符串的<span class="keyword">int</span>值，再做减法，返回值。如果两个字符串的长度不同，返回长度差。（都是看源码得知））</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>

<p>字符串反转：定义一个新的字符串，将给定的字符串倒着遍历，拼接到新的字符串。</p>
<p>统计大串中小串出现的次数：定义一个统计变量，获取小串在大串中第一次出现的索引（用indexOf()方法，不存在的话会返回-1），将索引+小串的长度作为起始位置截取原始大串并赋值给原始大串（用int indexOf(String str,int fromIndex)方法），继续获取小串在大串中第一次出现的索引（用indexOf()方法，不存在的话会返回-1）。</p>
<p>匹配功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">public int indexOf( String  str )</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">public boolean contains( CharSequence  s )</span><br><span class="line"></span><br><span class="line">3.通过正则表达式 + matches方法</span><br><span class="line">publicboolean matches( String  regex )</span><br><span class="line"></span><br><span class="line">4.字符串精确匹配，不考虑大小写</span><br><span class="line">public boolean equalsIgnoreCase( String  anotherString )</span><br></pre></td></tr></table></figure>



<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p>如果对字符串进行拼接操作，每次拼接都会构建一个新的String对象，既耗时又耗空间，所以产生了StringBuffer类。</p>
<p>线程安全的可变字符序列。</p>
<p>安全–同步–数据是安全的</p>
<p>不安全–不同步–效率高一些</p>
<p>StringBuffer和String的区别：前者长度和内容可变，后者不可变。</p>
<p>当字符串拼接时，前者不会浪费太多的资源。</p>
<p>StringBuffer的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span>  无参构造方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> 指定容量的字符串缓冲区对象 默认为16</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> 指定字符串内容的字符串缓冲区对象</span></span><br></pre></td></tr></table></figure>

<p>StringBuffer的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span>:返回当前容量。  理论值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>:返回长度（字符数）。实际值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">StringBuffer添加功能</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> 可以把任意类型的数据添加到字符串缓冲区里面，并返回字符串缓冲区本身。（所以可以使用链式编程）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset,String str)</span> 在指定位置把任意类型的数据插入到字符串缓冲区里面，并返回字符串缓冲区本身</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">StringBuffer删除功能</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span> 删除指定位置的字符，并返回本身</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> 删除从指定位置开始指定位置结束的内容，并返回本身 [) 包左不包右</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="number">0</span>,x.length()</span>)用于初始化清空容器。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">StringBuffer替换功能</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,String str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">StringBuffer反转功能	</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> StringBuffer <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">StringBuffer截取功能</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span>这个索引后的所有字符串输出并返回到String</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>  把这段截取出来输出String</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">截取功能的返回值类型是String类型，本身String Buffer没有发生改变（前面的都是容器内容发生了变化，所以值都改变了，但是容器本身没有变化）</span></span><br></pre></td></tr></table></figure>

<p>类之间的转换：</p>
<p>A–B的转换：把A转换成B是为了使用B的功能</p>
<p>B–A的转换：要的结果是A类型，所以需要再转回来。</p>
<p>String和StringBuffer的相互转换：</p>
<p>String转成StringBuffer：</p>
<p>不能把字符串的值直接赋值给StringBuffer</p>
<p>方法1：通过构造方法：StringBuffer sb=new StringBuffer(s);</p>
<p>方法2：通过append方法：StringBuffer sb2=new StringBuffer();    sb2.append(s);</p>
<p>StringBuffer转成String：</p>
<p>方法1：通过构造方法：String s=new String(buffer);</p>
<p>方法2：通过toString方法：String str2 = buffer.toString();    </p>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>一个可变的字符序列，此类提供一个与StringBuffer兼容的API（在单线程中完全可以替代StringBuffer），但不保证同步。在单个线程使用时很普遍，因为不保证安全，但是比StringBuffer类快。</p>
<p>1.String，StringBuffer，String Builder的区别：</p>
<p>String内容是不可变的，而StringBuffer、StringBuilder都是内容可变的。</p>
<p>StringBuffer是同步的，数据安全，效率低；StringBuilder是不同步的，数据不安全，效率高。</p>
<p>2.StringBuffer和数组的区别：</p>
<p>二者都可以看成是容器装其他数据，但是StringBuffer的数据最终是一个字符串数据，而数组可以放置多种数据，但必须是同一种数据类型。</p>
<p>\3. 形式参数问题：</p>
<p>基本类型：形式参数的改变不影响实际参数</p>
<p>引用类型：形式参数的改变直接影响实际参数</p>
<p>String作为参数传递：效果和基本类型作为参数传递是一样的。（因为String是一种特殊的基本类型，常量池）</p>
<p>StringBuffer作为参数传递：只有调用方法时才改变了值，一般的赋值=不改变原来值。</p>
<h1 id="Arrays类和数组高级"><a href="#Arrays类和数组高级" class="headerlink" title="Arrays类和数组高级"></a>Arrays类和数组高级</h1><p>Arrays类：需要导包import java.util.Arrays</p>
<p>是针对数组进行操作的工具类，提供了排序，查找等功能。</p>
<p>无构造方法。成员方法全是静态方法。</p>
<p>成员方法：不懂就去看源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span> 把数组转成字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span>  对数组进行排序（底层是快速排序）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> key)</span> 二分查找（必须是有序的）</span></span><br></pre></td></tr></table></figure>



<p>数组高级：排序和查找</p>
<p>排序：</p>
<p>\1. 插入排序类：</p>
<p>（1）直接插入排序：（在小规模数据集或是基本有序时，该算法效率较高）每一步将一个待排序的元素，按其排序码的大小，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止</p>
<p>（2）希尔排序：先对数据进行预处理，使其基本有序，然后再用直接插入排序算法排序。</p>
<p>\2. 选择排序类：</p>
<p>（1）简单选择排序：（每次选择一个最大(小)的，直到所有元素都被输出）从0索引开始，依次和后面元素比较，小的回到0索引；第一次完毕后，最小值出现在了最小索引处；第二次比较，有1个元素不比；比较的次数是array.length-1。</p>
<p>（2）堆排序：根节点是整个堆的最大值，将它移走；将剩余n-1个节点重新构造成一个堆，再将根节点移走；重复执行1,2。直到没有节点可移动，就生成了有序序列。</p>
<p>\3. 交换排序类：</p>
<p>（1）冒泡排序：（该算法比较简单，几乎所有语言涉及到算法时，都会涉及到冒泡算法）相邻元素两两比较，大的往后放；第一次完毕，最大值出现在最大索引处；第二次比较，有1个元素不比；比较的次数是array.length-1。</p>
<p>（2）快速排序：（利用“分而治之”的思想对集合进行排序）</p>
<p>4.归并排序类：</p>
<p>归并排序：归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<p>5.计数排序：计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
<p>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。</p>
<p>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。</p>
<p>计数排序不是比较排序，排序的速度快于任何比较排序算法。</p>
<p>6.桶排序：将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</p>
<p>7.基数排序：取得数组中的最大数，并取得位数；arr为原始数组，从最低位开始取每个位组成radix数组；对radix进行计数排序（利用计数排序适用于小范围数的特点）</p>
<table>
<thead>
<tr>
<th><em><strong>*排序算法*</strong></em></th>
<th><em><strong>*平均时间复杂度*</strong></em></th>
<th><em><strong>*最差时间复杂度*</strong></em></th>
<th><em><strong>*空间复杂度*</strong></em></th>
<th><em><strong>*数据对象稳定性*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>数组不稳定、链表稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n*log2n)</td>
<td>O(n2)</td>
<td>O(log2n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n*log2n)</td>
<td>O(n*log2n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n*log2n)</td>
<td>O(n*log2n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n*log2n)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(m)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(k*n)</td>
<td>O(n2)</td>
<td></td>
<td>稳定</td>
</tr>
</tbody></table>
<p>查找：</p>
<p>\1. 基本查找：查找的数组无序（从头找到尾）</p>
<p>\2. 二分（折半）查找：查找的数组有序</p>
<p>只要是无序的就不能使用二分查找，因为二分查找一旦排序就改变了元素在数组中的位置，其索引也就不对了。</p>
<table>
<thead>
<tr>
<th><em><strong>*查找算法*</strong></em></th>
<th><em><strong>*平均时间复杂度*</strong></em></th>
<th><em><strong>*空间复杂度*</strong></em></th>
<th><em><strong>*查找条件*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>顺序查找</td>
<td>O(n)</td>
<td>O(1)</td>
<td>无序或有序</td>
</tr>
<tr>
<td>二分查找（折半查找）</td>
<td>O(log2n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td>插值查找</td>
<td>O(log2(log2n))</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td>斐波那契查找</td>
<td>O(log2n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td>哈希查找</td>
<td>O(1)</td>
<td>O(n)</td>
<td>无序或有序</td>
</tr>
<tr>
<td>二叉查找树（二叉搜索树查找）</td>
<td>O(log2n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>红黑树</td>
<td>O(log2n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2-3树</td>
<td>O(log2n - log3n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B树/B+树</td>
<td>O(log2n)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="基本类型包装类（Interger，Character）"><a href="#基本类型包装类（Interger，Character）" class="headerlink" title="基本类型包装类（Interger，Character）"></a>基本类型包装类（Interger，Character）</h1><p>为了对基本数据类型进行更多的操作，更方便的操作，java就对每一种基本类型提供了对应的类类型，包装类类型。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>常用于基本数据类型与字符串之间的转换。</p>
<p>Integer类：</p>
<p>Integer 类在对象中包装了一个基本类型 int 的值</p>
<p>该类提供了多个方法，能在 int 类型和 String 类型之间互相转换，还提供了处理 int 类型时非常有用的其他一些常量和方法</p>
<p>构造方法：</p>
<p>public Integer(int value)</p>
<p>public Integer(String s) 这个字符串s必须是由数字字符组成，不然就会报错。</p>
<p>int类型和String类型的相互转换</p>
<p>int – String：</p>
<p>\1. 字符串拼接：String s=””+number</p>
<p>\2. 调用String的方法：String  s= String.valueOf(number);</p>
<p>\3. int–Integer–String:： Integer i=new Integer(number);    String  s= i.toString();</p>
<p>\4. 调用Integer的方法：String  s= Integer.toString(number);</p>
<p>String – int:</p>
<p>\1. String–Integer–int: Integer  ii= new Integer(s);    int x = ii.intValue();</p>
<p>\2. 调用Integer的方法**:int x=Integer.parseInt(s); （这个方法很重要，是将字符串类型转换为基本数据类型，调用的是该基本数据类型的包装类的parseXxx方法）</p>
<p>成员方法：</p>
<p>常用的基本进制转换：</p>
<p>public static String toBinaryString(int i)   十进制到二进制</p>
<p>public static String toOctalString(int i)   十进制到八进制</p>
<p>public static String toHexString(int i)   十进制到十六进制</p>
<p>十进制到其他进制：</p>
<p>public static String toString(int i,int radix) radix代表int型数字（2-36），表示二到三十六进制（0-9，a-z）</p>
<p>其他进制到十进制</p>
<p>public static int parseInt(String s,int radix) 给出的s必须是radix可以转换的，不然会报错。</p>
<p>JDK5新特性：（通过反编译就可以发现）</p>
<p>自动装箱：把基本类型转换为包装类类型。</p>
<p>Integer x = new Integer(4);可以直接写成Integer x = 4;//自动装箱。</p>
<p>自动拆箱：把包装类类型转换为基本类型。</p>
<p>x  = x + 5;//自动拆箱。通过intValue方法。</p>
<p>在使用时，Integer  x = null;上面的代码就会出现NullPointerException。（所以要先判断对象是否为null）</p>
<p>1.5之后，加了个byte常量池：Integer的数据直接赋值，如果在-128到127之间，会直接从缓冲池里获取数据，而不会new一个新对象。</p>
<p>Character类：</p>
<p>Character 类在对象中包装一个基本类型 char 的值</p>
<p>此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，小写转成大写</p>
<p>构造方法</p>
<p>public Character(char value)</p>
<p>成员方法：</p>
<p>public static boolean isUpperCase(char ch)  判断给定的字符是否是大写字符</p>
<p>public static boolean isLowerCase(char ch)  判断给定的字符是否是小写字符</p>
<p>public static boolean isDigit(char ch)  判断给定的字符是否是数字字符</p>
<p>public static char toUpperCase(char ch)  把给定的字符转换成大写字符</p>
<p>public static char toLowerCase(char ch)  把给定的字符转换成小写字符</p>
<h1 id="正则表达式regex（Pattern，Matcher）"><a href="#正则表达式regex（Pattern，Matcher）" class="headerlink" title="正则表达式regex（Pattern，Matcher）"></a>正则表达式regex（Pattern，Matcher）</h1><p>是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。</p>
<p>组成规则：</p>
<p>规则字符在java.util.regex  Pattern类中</p>
<p>常见组成规则：</p>
<ol>
<li>字符：</li>
</ol>
<p>x  字符x。举例：’a’ 表示字符a</p>
<p>\  反斜线字符。因为一个\代表了转义。</p>
<p>\n  新行（换行）符  （‘\uoooA’）</p>
<p>\r   回车符  (‘\uoooD’)</p>
<ol start="2">
<li>字符类</li>
</ol>
<p>[abc]  a、b或c(简单类)  abc中的任意一个，但只能是一个</p>
<p>[^abc]  任何字符，除了a、b或c（否定）</p>
<p>[a-zA-Z]  a到z或A到Z，两头的字母包括在内（范围）</p>
<p>[0-9]  0到9的字符都包括</p>
<p>[]里不用转义字符，是什么就是什么</p>
<ol start="3">
<li>预定义字符类</li>
</ol>
<p>.  任何字符。如果就是.本身，应该写为 <code>\.</code> </p>
<p>\d  数字：[0-9]  在写的时候都是\d表示 因为要先转义。</p>
<p>\D  非数字:<code>[^ 0-9]</code></p>
<p>\w  单词字符(小w)：[a-zA-Z_0-9]  在正则表达式里面组成单词的东西必须由这些东西组成（可以是A-Z，a-z，0-9，下划线都行）</p>
<p><code>\W</code>  即(大W)表示除\w单词字符之外的其他所有字符</p>
<p>\S  匹配任何非Unicode空白的字符 <code>[^\s]</code></p>
<p>\s  空格字符:[\ t\n\x0B\f\r\n]</p>
<ol start="4">
<li>边界匹配器</li>
</ol>
<p>^  行的开头</p>
<p>$  行的结尾</p>
<p>\b  单词边界  就是不是单词字符的地方。（单词间隔就用这个字符占）</p>
<ol start="5">
<li>数量词</li>
</ol>
<p>X？  X，一次或一次也没有</p>
<p>X*  X,零次或多次</p>
<p>X+  X，一次或多次</p>
<p>X{n}  X，恰好n次</p>
<p>X{n,}  X，至少n次</p>
<p>X{n,m}  X，至少n次，但不超过m次</p>
<p>6.POSIX字符类</p>
<p>\p{Punct}  匹配任何标点字符 <code>“＃$％＆&#39;（）* +， - 。/:; &lt;=&gt;？@ [\ _] ^ _&gt; &#123;|&#125;</code></p>
<p>\p{Lower}  小写字母字符:[az]</p>
<p>\p{Upper}  大写字母字符:[AZ]</p>
<p>\p{ASCII}  所有ASCII:[\ x00-\x7F]</p>
<p>\p{Alpha}  字母字符:[\ p {Lower}\p {Upper}]</p>
<p>\p{Digit}  十进制数字:[0-9]</p>
<p>\p{Alnum}  字母数字字符:[\ p {Alpha}\p {Digit}]</p>
<p>\p{Graph}  一个可见的角色:[\ p {Alnum}\p {Punct}]</p>
<p>\p{Print}  可打印字符:[\ p {Graph}\x20]</p>
<p>\p{Blank}  空格或制表符:[\ t]</p>
<p>\p{XDigit}  十六进制数字:[0-9a-fA-F]</p>
<p>\p{Space}  一个空白字符:[\ t\n\x0B\f\r]</p>
<p>(?:pattern)<br>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。<br>(?=pattern)<br>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<br>(?!pattern)<br>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。<br>(?&lt;=pattern)<br>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。<br>(?&lt;!pattern)<br>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题 </p>
<p>应用：</p>
<p>判断功能</p>
<p>String类的public boolean matches(String regex)方法</p>
<p>分割功能</p>
<p>String类的public String[] split(String regex)方法  根据给定正则表达式的匹配拆分此字符串成字符串数组（相当于是把regex这个字符删除了，剩下的分成小片段）</p>
<p>（硬盘上的路径，我们应该用<code>\\</code>替代\，把它分割是<code>\\\\</code> 第一个\代表格式，第二个\代表转义，<code>\\</code>代表字符串）</p>
<p>替换功能</p>
<p>String类的public String replaceAll(String regex,String replacement)方法： 使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串  （应用：可以屏蔽一些子，密码的*等等）</p>
<p>获取功能</p>
<p>Pattern和Matcher类的使用</p>
<p>模式和匹配器的典型调用顺序：</p>
<p>\1. 把正则表达式编译成模式对象:Pattern p= Pattern.compile(“a*b”);</p>
<p>\2. 通过模式对象得到匹配器对象，这个时候需要的是被匹配的字符串:Matcher m=p.matcher(“aaaaab”);</p>
<p>\3. 调用匹配器对象的功能:</p>
<p>(1) boolean b=m.matches();  调用的matches方法尝试将整个输入序列与该模式匹配</p>
<p>(2) lookingAt  尝试将输入序列从头开始与该模式匹配</p>
<p>(3) find方法扫描输入序列以查找玉该模式匹配的下一个子序列</p>
<p>以上三种方法都是返回boolean类型。find方法后还有一个group方法用来获取匹配的子字符串。</p>
<p>JAVA时间字符串去空格、冒号和横杠</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String date &#x3D; &quot;2017-09-19 14:40:01&quot;;</span><br><span class="line">String response &#x3D; date.replaceAll(&quot;[[\\s-:punct:]]&quot;,&quot;&quot;);</span><br><span class="line">匹配所有空白字符，-，：，标点符号</span><br></pre></td></tr></table></figure>

<p>[[:punct:]]是指所有的符号<code>！#$%&amp;&#39;（）*+，-./：；&lt;=&gt;？@[]^ </code>{}~`</p>
<p>\s匹配任何空白字符[\t\n\x0B\f\r]，第一个\是转义</p>
<h1 id="Math类-Random类-System类"><a href="#Math类-Random类-System类" class="headerlink" title="Math类/Random类/System类"></a>Math类/Random类/System类</h1><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p>
<p>成员变量：</p>
<p>publi static final double PI</p>
<p>publi static final double E</p>
<p>成员方法（都是静态，不用创建对象）</p>
<p>public static int abs(int a)  绝对值</p>
<p>public static double ceil(double a)  向上取整</p>
<p>public static double floor(double a)  向下取整</p>
<p>public static int max(int a,int b)  最大值</p>
<p>public static double pow(double a,double b)  a的b次幂</p>
<p>public static double random()  随机数[0.0,1.0)</p>
<p>public static int round(float a)  四舍五入（+0.5后向下取整）</p>
<p>public static double sqrt(double a)  正平方根</p>
<p>如果想得到任意范围的随机数：</p>
<p>int number=(int) (Math.random()*(end-start+1))+start;</p>
<p>Random类：util包中，此类的实例用于生成伪随机数流。</p>
<p>如果用<em>相同的种子</em>创建两个 Random 实例，则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列。</p>
<p>构造方法</p>
<p>public Random() 没有给种子，用的是默认种子，是当前时间的毫秒值</p>
<p>public Random(long seed) 给出指定的种子。  给定种子后，每次得到的随机数是相同的。</p>
<p>Random类成员方法</p>
<p>public int nextInt() 返回的是int范围内的随机数</p>
<p>public int nextInt(int n) 返回的是[0,n)范围内的随机数</p>
<p>System类：lang包</p>
<p>System 类包含一些有用的类字段和方法。它不能被实例化，全是静态。</p>
<p>成员方法</p>
<p>public static void gc() 运行垃圾回收器 不要一直调用们因为每一次执行垃圾回收，jvm都会强制启动垃圾回收器运行，这回耗费更多的系统资源，会与正常的java程序争夺资源，只有执行大量的对象的释放时，才会调用垃圾回收。</p>
<p>public static void exit(int status) 终止当前正在运行的java虚拟机，参数用作状态码，根据惯例，非0的状态码表示异常终止。（所以一般用System.exit（0）；相当于按了x退出，后面的都不运行）</p>
<p>public static long currentTimeMillis() 返回以毫秒为单位的当前时间（可以用来计时）</p>
<p>为什么是1970年1月1日0点：一种说法是java起源于UNIX系统，而UNIX系统认为1970.1.1是时间纪元。因为当时的操作系统是32位，换算下来相当于68.1年就会达到最大值，从而回到起始值，所以将1970.1.1当作起点，让这个时间推迟到2038年，而现在已经出现了64位操作系统，所以时间无线大，解决了这个问题。</p>
<p>public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length) 从指定原数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。arraycopy中c小写，因为刚开始命名不规范改不回去了。src代表原数组，srcPos代表原数组中的起始位置。dest目标数组，destPos代表目标数组中的起始位置。length代表要复制的数组元素的数量。相当于原数组不变，新数组的长度也不变，只是把原数组中的length长度元素替换到了新数组中。</p>
<h1 id="BigInterger类-BigDecimal类"><a href="#BigInterger类-BigDecimal类" class="headerlink" title="BigInterger类/BigDecimal类"></a>BigInterger类/BigDecimal类</h1><p>BigInteger类：</p>
<p>可以让超过Integer范围内的数据进行运算</p>
<p>构造方法</p>
<p>public BigInteger(String val)</p>
<p>BigInteger类的成员方法</p>
<p>public BigInteger add(BigInteger val)  +</p>
<p>public BigInteger subtract(BigInteger val)  -</p>
<p>public BigInteger multiply(BigInteger val)  * </p>
<p>public BigInteger divide(BigInteger val)  /</p>
<p>public BigInteger[] divideAndRemainder(BigInteger val)  返回的是商和余数的数组</p>
<p>BigDecimal类：</p>
<p>由于在运算的时候，float类型和double很容易丢失精度，演示案例。所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal（金融方面就要用）</p>
<p>是不可变的、任意精度的有符号十进制数。</p>
<p>构造方法</p>
<p>public BigDecimal(String val)</p>
<p>BigDecimal类的成员方法</p>
<p>public BigDecimal add(BigDecimal augend)</p>
<p>public BigDecimal subtract(BigDecimal subtrahend)</p>
<p>public BigDecimal multiply(BigDecimal multiplicand)</p>
<p>public BigDecimal divide(BigDecimal divisor)</p>
<p>public BigDecimal divide(BigDecimal divisor,int scale, int roundingMode) 商，几位小数，如何取舍</p>
<p>判断 BigDecimal 是否为0：</p>
<p>new BigDecimal(“0.00”).compareTo(你的数据)  == 0</p>
<h1 id="Date类-DateFormat类-Calendar类"><a href="#Date类-DateFormat类-Calendar类" class="headerlink" title="Date类/DateFormat类/Calendar类"></a>Date类/DateFormat类/Calendar类</h1><p>Date类：</p>
<p>类 Date 表示特定的瞬间，精确到毫秒。  大部分方法已经过时。</p>
<p>构造方法</p>
<p>public Date()</p>
<p>public Date(long date)</p>
<p>成员方法</p>
<p>public long getTime()  获取时间，以毫秒为单位</p>
<p>public void setTime(long time)  设置时间</p>
<p>Syste.ou.println(new Date(0));  为什么打印的是8.而不是0.呢：因为存在系统时间和本地时间的间隔，系统时间依然是0点，而电脑的时区设置在东8区，所以打印的结果是8点。</p>
<p>DateFormat类：txt包</p>
<p>Date–String  格式化  public final String format(Date  date)</p>
<p>String–Date  解析   public Date parse(String source)</p>
<p>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。</p>
<p>DateFormat可以进行日期和字符串的格式化和解析，但由于是抽象类，所以使用其子类SimpleDateFormat</p>
<p>SimpleDateFormat类的构造方法：</p>
<p>public SimpleDateFormat() 默认模式</p>
<p>public SimpleDateFormat(String pattern) 给定的模式</p>
<p>API中有对应的模式举例：</p>
<p>年  y</p>
<p>月  M</p>
<p>日  d</p>
<p>时  H</p>
<p>分  m</p>
<p>秒  s</p>
<p>2020年11月14日 17：58：20</p>
<p>yyyy年MM月dd日 HH:mm：ss</p>
<p>在把一个字符串解析为日期的时候，请注意格式必须和给定的字符串格式匹配。</p>
<p>成员方法</p>
<p>public final String format(Date date)</p>
<p>public Date parse(String source)</p>
<p>Calendar类</p>
<p>Date类的很多都被Calendar类替代了。</p>
<p>Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p>
<p>成员方法</p>
<p>public static Calendar getInstance() 其实相当于多态，表面上返回的是Calendar，其实返回的是Calendar的一个实现子类。</p>
<p>public int get(int field) 返回给定日历字段的值。日历类中的每个日历字段都是静态的成员变量，并且是int类型。</p>
<p>public void add(int field,int amount) 根据给定的日历字段和对应的时间，来对当前的日历进行操作。  amount可以是 -3  3</p>
<p>public final void set(int year,int month,int date) 设置当前日历的年月日。</p>
<p>month都是0-11  所以适当+1</p>
<h1 id="RunTime类"><a href="#RunTime类" class="headerlink" title="RunTime类"></a>RunTime类</h1><p>该类主要代表了应用程序的运行环境。一个RunTime就代表一个运行环境</p>
<p>方法</p>
<p>(1) getRuntime()：该方法用于返回当前应用程序的运行环境对象。</p>
<p>(2) exec(String command)：该方法用于根据指定的路径执行对应的可执行文件。</p>
<p>(3) freeMemory()：该方法用于返回Java虚拟机中的空闲内存量，以字节为单位。<br>(4) maxMemory()：该方法用于返回Java虚拟机试图使用的最大内存量。</p>
<p>(5) totalMemory()：该方法用于返回Java虚拟机中的内存总量。</p>
<p>例子：</p>
<p><img src="/4.9.java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/image-20210809165151605.png" alt="image-20210809165151605"></p>
<h3 id="getRuntime-exec"><a href="#getRuntime-exec" class="headerlink" title="getRuntime().exec()"></a>getRuntime().exec()</h3><p>在java中，RunTime.getRuntime().exec()实现了调用服务器命令脚本来执行功能需要</p>
<p>用法：     </p>
<p>public Process exec(String command)—–在单独的进程中执行指定的字符串命令。</p>
<p>public Process exec(String [] cmdArray)—在单独的进程中执行指定命令和变量</p>
<p>public Process exec(String command, String [] envp)—-在指定环境的独立进程中执行指定命令和变量</p>
<p>public Process exec(String [] cmdArray, String [] envp)—-在指定环境的独立进程中执行指定的命令和变量</p>
<p>public Process exec(String command,String[] envp,File dir)—-在有指定环境和工作目录的独立进程中执行指定的字符串命令</p>
<p>public Process exec(String[] cmdarray,String[] envp,File dir)—-在指定环境和工作目录的独立进程中执行指定的命令和变量</p>
<p>举例：</p>
<ol>
<li><p>RunTime.getRuntime().exec（String  command）;</p>
<pre><code>     在windows下相当于直接调用   /开始/搜索程序和文件  的指令，比如
 
     Process process = Runtime.getRuntime().exec(&quot;notepad.exe&quot;);  -------打开windows下记事本。
</code></pre>
</li>
<li><p>public Process exec(String [] cmdArray)；</p>
<pre><code>      Linux下：
 
      Process process = Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/sh&quot;,&quot;-c&quot;, &quot;;
 
      Windows下：
 
      Process process = Runtime.getRuntime().exec(new String[]&#123; &quot;cmd&quot;, &quot;/c&quot;, cmds&#125;);
</code></pre>
</li>
</ol>
<p><strong>补充</strong>：#!/bin/bash和#!/bin/sh的区别</p>
<p>#! 是个指示路径的表示符，/bin/bash和/bin/sh指定了脚本解析器的程序路径</p>
<p>bash是sh的完整版，bash完全兼容sh命令，反之不行</p>
<p>OPTIONS:</p>
<p>　    -c string　　　   该选项表明string中包含了一条命令.如 bash -c ls ~</p>
<p>　　-i　　　　　　　使Bash以交互式方式运行</p>
<p>　　-r　　　　　　　使Bash以受限方式运行</p>
<p>　　–login　　　　   使Bash以登录Shell方式运行</p>
<p>　　–posix　　　　  使Bash遵循POSIX标准</p>
<p>　　–verbose　　　 使Bash显示所有其读入的输入行</p>
<p>　　–help　　　　　打印Bash的使用信息</p>
<p>　　–version　　　  打印版本信息</p>
<p><strong>Process</strong>的几种方法：<br>1.destroy()：杀掉子进程</p>
<p>2.exitValue()：返回子进程的出口值，值 0 表示正常终止</p>
<p>3.getErrorStream()：获取子进程的错误流</p>
<p>4.getInputStream()：获取子进程的输入流</p>
<p>5.getOutputStream()：获取子进程的输出流</p>
<p>6.waitFor()：导致当前线程等待，如有必要，一直要等到由该 Process 对象表示的进程已经终止。如果已终止该子进程，此方法立即返回。如果没有终止该子进程，调用的线程将被阻塞，直到退出子进程，根据惯例，0 表示正常终止</p>
<p>注意：在java中，调用runtime线程执行脚本是非常消耗资源的，所以切忌不要频繁使用！</p>
<p>在调用runtime去执行脚本的时候，其实就是JVM开了一个子线程去调用JVM所在系统的命令，其中开了三个通道： 输入流、输出流、错误流，其中输出流就是子线程走调用的通道。</p>
<p>waitFor是等待子线程执行命令结束后才执行， 但是在runtime中，打开程序的命令如果不关闭，就不算子线程结束。比如以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static Process p &#x3D; null;</span><br><span class="line"></span><br><span class="line">p &#x3D; Runtime.getRuntime().exec(&quot;notepad.exe&quot;);</span><br><span class="line"></span><br><span class="line">p.waitFor();     </span><br><span class="line"></span><br><span class="line">System.out.println(&quot;--------------------------------------------我被执行了&quot;);</span><br></pre></td></tr></table></figure>

<p>以上代码中，打开windows中记事本。如果我们不手动关闭记事本，那么输出语句就不会被执行，这点是需要理解的。  </p>
<p> process的阻塞：</p>
<p>在runtime执行大点的命令中，输入流和错误流会不断有流进入存储在JVM的缓冲区中，如果缓冲区的流不被读取被填满时，就会造成runtime的阻塞。所以在进行比如：大文件复制等的操作时，我们还需要不断的去读取JVM中的缓冲区的流，来防止Runtime的死锁阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">在linux 上封装的方法：</span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> daemon true,后台执行，false,直接执行</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args 指令行</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">sendCommand</span><span class="params">(<span class="keyword">boolean</span> daemon,String args)</span> </span>&#123;</span><br><span class="line">		logger.info(<span class="string">&quot;args=&#123;&#125;&quot;</span>, args);</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="comment">//	InputStreamReader ir = null;</span></span><br><span class="line">	<span class="comment">//	LineNumberReader input = null;</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String[] envp = &#123; <span class="string">&quot;LANG=UTF-8&quot;</span> &#125;;</span><br><span class="line">			Process process=<span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span>(daemon) &#123;</span><br><span class="line">				String[] comands = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, args&#125;;</span><br><span class="line">				process = Runtime.getRuntime().exec(comands, envp);</span><br><span class="line">				process.waitFor();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				process = Runtime.getRuntime().exec(args, envp);</span><br><span class="line">				process.waitFor(<span class="number">60</span>,TimeUnit.SECONDS);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> (InputStreamReader ir =  <span class="keyword">new</span> InputStreamReader(process.getInputStream(), Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));LineNumberReader input = <span class="keyword">new</span> LineNumberReader(ir)) &#123;</span><br><span class="line">				String tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				<span class="keyword">while</span> ((tmp = input.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">					builder.append(tmp).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				logger.error(e.getMessage(), e);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Result(ErrorCode.EC_FAILED, e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> (InputStreamReader ir =  <span class="keyword">new</span> InputStreamReader(process.getErrorStream(), Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));LineNumberReader input = <span class="keyword">new</span> LineNumberReader(ir)) &#123;</span><br><span class="line">				String tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				<span class="keyword">while</span> ((tmp = input.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">					builder.append(tmp).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				logger.error(e.getMessage(), e);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Result(ErrorCode.EC_FAILED, e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			logger.error(e.getMessage(), e);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(ErrorCode.EC_FAILED, e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		String result = builder.toString();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isNotEmpty(result)&amp;&amp;StringUtils.containsIgnoreCase(result, <span class="string">&quot;ERROR&quot;</span>)) &#123;</span><br><span class="line">			logger.info(<span class="string">&quot;result=&#123;&#125;&quot;</span>, result);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(ErrorCode.EC_FAILED, result);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Result(ErrorCode.EC_OK);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/03/26/4.9.java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B1%BB/" data-id="cku567uke006gu8wd2e24e44m" data-title="java中常用类" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/29/4.2.java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          java基础知识
        
      </div>
    </a>
  
  
    <a href="/2021/03/26/10.4.%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">项目踩坑</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>