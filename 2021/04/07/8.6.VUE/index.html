<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>VUE | swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="VUE简介Vue.js（读音 &#x2F;vjuː&#x2F;, 类似于 view） 是一套构建用户界面的渐进式框架。 Vue 只关注视图层， 采用自底向上增量开发的设计。 Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 VUE安装1.独立版本我们可以在 Vue.js 的官网上直接下载最新版本, 并用 &lt;script&gt; 标签引入。 2.使用 CDN 方法以下推荐国外比较稳定">
<meta property="og:type" content="article">
<meta property="og:title" content="VUE">
<meta property="og:url" content="https://s-qwer.github.io/2021/04/07/8.6.VUE/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="VUE简介Vue.js（读音 &#x2F;vjuː&#x2F;, 类似于 view） 是一套构建用户界面的渐进式框架。 Vue 只关注视图层， 采用自底向上增量开发的设计。 Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 VUE安装1.独立版本我们可以在 Vue.js 的官网上直接下载最新版本, 并用 &lt;script&gt; 标签引入。 2.使用 CDN 方法以下推荐国外比较稳定">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-07T11:41:51.000Z">
<meta property="article:modified_time" content="2021-11-24T07:03:36.406Z">
<meta property="article:author" content="swx">
<meta property="article:tag" content="node.js">
<meta property="article:tag" content="npm">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-8.6.VUE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/8.6.VUE/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:41:51.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      VUE
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="VUE简介"><a href="#VUE简介" class="headerlink" title="VUE简介"></a>VUE简介</h1><p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。</p>
<p>Vue 只关注视图层， 采用自底向上增量开发的设计。</p>
<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<h1 id="VUE安装"><a href="#VUE安装" class="headerlink" title="VUE安装"></a>VUE安装</h1><h2 id="1-独立版本"><a href="#1-独立版本" class="headerlink" title="1.独立版本"></a>1.独立版本</h2><p>我们可以在 Vue.js 的官网上直接下载最新版本, 并用 <code>&lt;script&gt;</code> 标签引入。</p>
<h2 id="2-使用-CDN-方法"><a href="#2-使用-CDN-方法" class="headerlink" title="2.使用 CDN 方法"></a>2.使用 CDN 方法</h2><p>以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p>
<ul>
<li><strong>Staticfile CDN（国内）</strong> : <a target="_blank" rel="noopener" href="https://cdn.staticfile.org/vue/3.0.5/vue.global.js">https://cdn.staticfile.org/vue/3.0.5/vue.global.js</a></li>
<li><strong>unpkg</strong>：<a target="_blank" rel="noopener" href="https://unpkg.com/vue@next">https://unpkg.com/vue@next</a>, 会保持和 npm 发布的最新的版本一致。</li>
<li><strong>cdnjs</strong> : <a target="_blank" rel="noopener" href="https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.5/vue.global.js">https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.5/vue.global.js</a></li>
</ul>
<h2 id="3-NPM-方法"><a href="#3-NPM-方法" class="headerlink" title="3.NPM 方法"></a>3.NPM 方法</h2><p>因为需要使用 npm 安装 Vue CLI，而 npm 是集成在 Node.js 中的，所以第一步我们需要安装 Node.js。在官网下载安装完node.js后，查看node版本。同时npm也安装好了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br><span class="line">2.3.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将 npm 更新至最新版本</span></span><br><span class="line">npm -g install npm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装cnpm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级或安装 cnpm</span></span><br><span class="line">npm install cnpm -g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">升级 npm</span></span><br><span class="line">cnpm install npm -g</span><br></pre></td></tr></table></figure>

<p>在用 Vue.js 构建大型应用时推荐使用 cnpm 安装，cnpm 能很好地和 Webpack 或 Browserify 模块打包器配合使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 最新稳定版</span><br><span class="line">$ cnpm install vue@next</span><br></pre></td></tr></table></figure>

<p>命令行工具</p>
<p>Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">$ cnpm install -g @vue&#x2F;cli</span><br><span class="line">npm install -g vue-cli</span><br><span class="line"></span><br><span class="line"># 安装完后查看版本</span><br><span class="line">$ vue --version</span><br><span class="line">@vue&#x2F;cli 4.5.11</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>vue-cli 3.x 和 vue-cli 2.x 使用了相同的 vue 命令，如果你之前已经安装了 vue-cli 2.x，它会被替换为 Vue-cli 3.x。</p>
<p>安装 @vue/cli-int：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm i -g @vue&#x2F;cli-init</span><br></pre></td></tr></table></figure>





<p>node版本</p>
<p>npm版本</p>
<p>vue版本</p>
<p>vue-cli版本</p>
<p>前端版本会有不兼容问题</p>
<p>注意：Vue.js 不支持 IE8 及其以下 IE 版本。</p>
<h2 id="4-安装yarn"><a href="#4-安装yarn" class="headerlink" title="4.安装yarn"></a>4.安装yarn</h2><p>1.使用msi安装：</p>
<p>首先进入yarn的官网 <a target="_blank" rel="noopener" href="https://yarn.bootcss.com/docs/install/#windows-stable%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%89%E6%8B%A9%E7%A8%B3%E5%AE%9A%E7%89%88%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E3%80%82%E7%84%B6%E5%90%8E%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85%E5%8D%B3%E5%8F%AF">https://yarn.bootcss.com/docs/install/#windows-stable，然后选择稳定版进行下载。然后双击安装即可</a></p>
<p>2.通过npm命令进行安装：</p>
<p>执行命令<code>npm install yarn -g</code> （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到C:\Users\用户名\AppData\Roaming\npm路径中。</p>
<p>yarn和npm都是包管理工具，但是yarn是崭新的，经过重新设计的npm客户端，于2016年10月发布，相比于npm，yarn在运行速度上有显著的提升，安装时间变少，功能上也有很多改进</p>
<h1 id="创建VUE项目"><a href="#创建VUE项目" class="headerlink" title="创建VUE项目"></a>创建VUE项目</h1><h3 id="直接使用命令行构建项目"><a href="#直接使用命令行构建项目" class="headerlink" title="直接使用命令行构建项目"></a>直接使用命令行构建项目</h3><p>1.新建一个文件夹，自行选择位置。</p>
<p>2.文件夹里打开cmd，输入 <code>vue init webpack 项目名字</code>  （这里 webpack 是以 webpack 为模板指生成项目，还可以替换为 pwa、simple 等参数）</p>
<p>接下来会让你确认项目名字，描述，作者，build，是否安装vue-router（选是Y），是否安装es-lint（代码质量）</p>
<p>3.可以看到文件夹里生成了VUE项目</p>
<p>4.在项目里打开命令行，执行命令 <code>npm run dev</code></p>
<h3 id="使用webstorm"><a href="#使用webstorm" class="headerlink" title="使用webstorm"></a>使用webstorm</h3><p>按步骤新建项目。可以在控制台上输入命令。也可以在package.json 文件上点击右键，选择 show npm scripts，双击命令运行。也可以在右上角选择npm命令运行。</p>
<h1 id="VUE的文件"><a href="#VUE的文件" class="headerlink" title="VUE的文件"></a>VUE的文件</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">vue-cource // 项目名称</span><br><span class="line">    |__ node_modules // 项目中的node依赖包</span><br><span class="line">    |__ public // public文件夹放公共文件</span><br><span class="line">    |    |__ favicon.ico // 标签栏的小图标</span><br><span class="line">    |    |__ index.html // 模板文件，最后打包后的index.html模板就是这个文件</span><br><span class="line">    |    </span><br><span class="line">    |__ src // 项目主文件</span><br><span class="line">    |    |__ api // api文件夹，项目的接口js文件都可以写在这里</span><br><span class="line">    |    |__ assets // 静态资源（图片、字体图标文件）</span><br><span class="line">    |    |    |__ img // 图片文件夹</span><br><span class="line">    |    |    |__ font // 字体图标文件夹</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ components // 组件</span><br><span class="line">    |    |__ config // 项目的配置（全局变量js文件）</span><br><span class="line">    |    |    |__ index.js     </span><br><span class="line">    |    |</span><br><span class="line">    |    |__ directive // vue的自定义指令文件夹</span><br><span class="line">    |    |    |__ index.js     </span><br><span class="line">    |    |</span><br><span class="line">    |    |__ lib // 全局方法放在这里</span><br><span class="line">    |    |    |__ util.js // 与业务结合的工具方法</span><br><span class="line">    |    |    |__ tools.js // 与业务无关的工具方法(例如日期转换时间戳方法)</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ mock // 模拟数据文件夹</span><br><span class="line">    |    |    |__ index.js</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ router // 路由文件夹</span><br><span class="line">    |    |    |__ index.js // 路由配置文件</span><br><span class="line">    |    |    |__ router.js // 拆分出来的routes数组</span><br><span class="line">    |    |__ store // Vuex配置文件夹</span><br><span class="line">    |    |    |__ module          // 模块文件夹</span><br><span class="line">    |    |    |__ plugin          // Vuex插件文件夹</span><br><span class="line">    |    |    |__ actions.js      // 异步调用接口方法都写在这里</span><br><span class="line">    |    |    |__ getters.js      // Vuex的计算属性都写在这里</span><br><span class="line">    |    |    |__ index.js        // Vuex主要配置管理文件</span><br><span class="line">    |    |    |__ mutations.js    // Vuex中的修改state的方法，都写在这里</span><br><span class="line">    |    |    |__ state.js        // Vuex的变量文件夹</span><br><span class="line">    |    |</span><br><span class="line">    |    |__ views // 页面都写在这个文件夹中</span><br><span class="line">    |    |__ App.vue // 基础组件。项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。</span><br><span class="line">    |    |__ main.js // 项目入口文件（项目引入全局插件都在这里引入）项目的核心文件</span><br><span class="line">    |    </span><br><span class="line">    |__ .browserslistrc // 浏览器兼容</span><br><span class="line">    |__ .editorconfig // 编译器配置文件</span><br><span class="line">    |__ .eslintrc.js // 配置ESlint规则文件</span><br><span class="line">    |__ .gitignore // git提交的忽略文件</span><br><span class="line">    |__ babel.config.js // babel的配置文件，babel可以将es6、es7等等装换成es5兼容的代码</span><br><span class="line">    |__ package-lock.json // 锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致</span><br><span class="line">    |__ package.json // 项目名称、项目版本、项目描述、项目运行的一些脚本（依赖）</span><br><span class="line">    |__ postcss.config.js // css自动补充一些兼容性代码的配置（-webkit-、-moz-、-ms-之类的）</span><br><span class="line">    |__ README.en.md // 英文版项目说明</span><br><span class="line">    |__ README.md // 中文版项目说明</span><br><span class="line">    |__ vue.config.js // 配置文件</span><br></pre></td></tr></table></figure>

<h3 id="public-index-html"><a href="#public-index-html" class="headerlink" title="public/index.html"></a>public/index.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就是一个普普通通的 html 文件，让它不平凡的是 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> ，下面有一行注释，构建的文件将会被自动注入，也就是说我们编写的其它的内容都将在这个 div 中展示。</p>
<p>还有不普通的一点是，整个项目只有这一个 html 文件，所以这是一个 单页面应用，当我们打开这个应用，表面上可以有很多页面，实际上它们都只不过在一个 div 中。</p>
<h3 id="src-App-vue"><a href="#src-App-vue" class="headerlink" title="src/App.vue"></a>src/App.vue</h3><p>这个文件称为“根组件”，因为其它的组件又都包含在这个组件中</p>
<p>vue 文件是一种自定义文件类型，在结构上类似 html，一个 .vue 文件即是一个 vue 组件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-wechat-title</span>=<span class="string">&quot;$route.meta.title&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">	<span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">		-webkit-<span class="attribute">font</span>-smoothing: antialiased;</span></span><br><span class="line"><span class="css">		<span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">font-family</span>: <span class="string">&#x27;PingFang SC&#x27;</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	#app &#123;</span><br><span class="line"><span class="css">		<span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>&lt;div id=&quot;app&quot;&gt;</code>,<code>id=app</code> 只是跟下面的 css 对应.</p>
<script>标签里的内容即该组件的脚本，也就是 js 代码，export default 是 ES6 的语法，意思是将这个组件整体导出，之后就可以使用 import 导入组件了。大括号里的内容是这个组件的相关属性

`<router-view/>`，是一个容器，名字叫“路由视图”，意思是当前路由（ URL）指向的内容将显示在这个容器中。也就是说，其它的组件即使拥有自己的路由（URL，需要在 router 文件夹的 index.js 文件里定义），也只不过表面上是一个单独的页面，实际上只是在根组件 App.vue 中。

### src/main.js

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置反向代理，前端请求默认发送到 http:&#x2F;&#x2F;localhost:8443&#x2F;api</span><br><span class="line">var axios &#x3D; require(&#39;axios&#39;)</span><br><span class="line">axios.defaults.baseURL &#x3D; &#39;http:&#x2F;&#x2F;localhost:8443&#x2F;api&#39;</span><br><span class="line">&#x2F;&#x2F; 全局注册，之后可在其他组件中通过 this.$axios 发送数据</span><br><span class="line">Vue.prototype.$axios &#x3D; axios</span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

没有分号（;），因为是 ES6 的语法，不这么写反而会提示错误，也可以把 es-lint 改了或者关了

最上面 import 了几个模块，其中 vue 模块在 node_modules 中，App 即 App.vue 里定义的组件，router 即 router 文件夹里定义的路由。

Vue.config.productionTip = false ,作用是阻止vue 在启动时生成生产提示。如果没有这行代码，或者设置为true，控制台就会多出这么一段代码：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You are running Vue in development mode.</span><br><span class="line">Make sure to turn on production mode when deploying for production.</span><br></pre></td></tr></table></figure>

在这个 js 文件中，我们创建了一个 Vue 对象（实例），el 属性提供一个在页面上已存在的 DOM 元素作为 Vue 对象的挂载目标，router 代表该对象包含 Vue Router，并使用项目中定义的路由。components 表示该对象包含的 Vue 组件，template 是用一个字符串模板作为 Vue 实例的标识使用，类似于定义一个 html 标签。



### **src/config/index.js**

**当前项目的配置**

**config/index.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面使用 **ES6** 的 **模块** 导出一个对象，如果有 **全局变量** 都可以写在这里，在需要用到的地方直接这么写：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  config  from  &#39;@&#x2F;config&#39;  &#x2F;&#x2F; nodejs就会自动找到他下面的index.js文件</span><br></pre></td></tr></table></figure>

或者这样也可以找到这个 **index** 文件，

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import  config  from  &#39;@&#x2F;config&#x2F;index&#39; </span><br></pre></td></tr></table></figure>



### src/router

分为**正常路由结构** 和 **封装好的路由结构**

**正常路由**：创建项目初始化路由 会在 src文件夹 下生成一个 router.js 文件。

**router.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import  Home  from  &#39;.&#x2F;views&#x2F;Home&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;,</span><br><span class="line">    name: &#39;home&#39;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;about&#39;,</span><br><span class="line">    name: &#39;about&#39;,</span><br><span class="line">    &#x2F;&#x2F; route level code-splitting</span><br><span class="line">    &#x2F;&#x2F; this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    &#x2F;&#x2F; which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;.&#x2F;views&#x2F;About.vue&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

这种只是 **简单的路由（搭建项目初始化自动生成的路由文件）** ，如果以后 **复杂** 起来会**难以维护**。

**封装路由**

1. 在 **src目录** 下创建一个 **router文件夹** ，这里的思想是把 **routes数组** 拆分成一个 **单独的js文件**，这样看着简洁也**方便维护**。

![img](https://img.kancloud.cn/76/ee/76ee106ff5e570f4235eba358b6cbb6c_348x87.png)

1. **router文件夹**

**index.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import routes from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes &#x2F;&#x2F; 这里使用ES6的简写写法，正常应该是这样写&#39;routes : routes &#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**router.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import  Home  from  &#39;@&#x2F;views&#x2F;Home&#39;</span><br><span class="line"></span><br><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;,</span><br><span class="line">    name: &#39;home&#39;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;about&#39;,</span><br><span class="line">    name: &#39;about&#39;,</span><br><span class="line">    &#x2F;&#x2F; route level code-splitting</span><br><span class="line">    &#x2F;&#x2F; this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    &#x2F;&#x2F; which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#39;@&#x2F;views&#x2F;About.vue&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

### src/store

分为**正常vuex结构** 和 **封装好的vuex结构**

**正常vuex**

**创建项目** 初始化路由会在 **src文件夹** 下生成一个 **store.js** 文件。

**store.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

这种结构 **看似简单** ，后期项目 **维护麻烦** 。

**封装vuex**

**封装后** 的结构，在 **src目录** 下创建一个 **store文件夹**

![img](https://img.kancloud.cn/cd/c3/cdc31f614c6e19e0bbb0d9f705b05276_351x185.png)

module文件夹

首先讲一下为什么会有 **module文件夹** ，因为项目如果有 **好多vuex的状态** ，如果都写在 **sore.js** 中，看起来会 **杂乱无章** ，都不知道哪个 **vuex** 的 **状态** 是哪个 **模块** 中使用的，所以有了 **module文件夹** ，例如我有一个 **user模块** 我只需要在 **module文件夹** 中创建一个 **user.js**

**user.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">const mutations &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">const actions &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

使用时只需要在 **store文件夹** 下的 **index.js** 中这样 **引入** 即可：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import state from &#39;.&#x2F;state&#39; &#x2F;&#x2F; state.js文件可以不写.js结尾，这样写也会自动找到state.js文件</span><br><span class="line">import mutations from &#39;.&#x2F;mutations&#39;</span><br><span class="line">import actions from &#39;.&#x2F;actions&#39;</span><br><span class="line">import user from &#39;.&#x2F;module&#x2F;user&#39; &#x2F;&#x2F; 引入模块文件</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state,  &#x2F;&#x2F; ES6对象简写的形式，state: state 等同与 state</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  modules: &#123; &#x2F;&#x2F; 模块引用</span><br><span class="line">    user</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**plugin文件夹**

**plugin文件夹** 是存放 **Vuex插件** 的文件夹，假如我们这里有个持久化插件

**plugin/saveiInLocal.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 持久化储存插件：这个函数会在每次store实例初始化时调用。刷新浏览器后第一次要做的操作可以定义在这里</span><br><span class="line"> * @param store </span><br><span class="line"> *&#x2F;</span><br><span class="line">export default store &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果本地存储了state，就把这个stateJSON字符串转换成对象，替换到当前store实例的state</span><br><span class="line">    if(localStorage.state) store.replaceState(JSON.parse(localStorage.state))</span><br><span class="line">    store.subscribe((mutation, state) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 提交commit提交mutation之后执行这里，把state转换成JSON字符串储存到localStorage的state中</span><br><span class="line">        localStorage.state &#x3D; JSON.stringify(state)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**actions.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const actions &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">export default actions</span><br></pre></td></tr></table></figure>

**index.js**

**index.js** 属于 **根级别的Vuex** 可以用来管理 **根级别** 的 **actions** 、 **state** 、 **mutations** 、 **getters** ，同样可以管理 **模块（module）** 中的 **actions** 、 **state** 、 **mutations**、 **getter**。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import state from &#39;.&#x2F;state&#39; &#x2F;&#x2F; state.js文件可以不写.js结尾，这样写也会自动找到state.js文件</span><br><span class="line">import getters from &#39;.&#x2F;getters&#39;</span><br><span class="line">import mutations from &#39;.&#x2F;mutations&#39;</span><br><span class="line">import actions from &#39;.&#x2F;actions&#39;</span><br><span class="line">import user from &#39;.&#x2F;module&#x2F;user&#39; &#x2F;&#x2F; 引入模块文件</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state,  &#x2F;&#x2F; ES6对象简写的形式，state: state 等同与 state</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  modules: &#123; &#x2F;&#x2F; 模块引用</span><br><span class="line">    user</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**mutations.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const mutations &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br><span class="line">export default mutations</span><br></pre></td></tr></table></figure>

**state.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 状态写这里</span><br><span class="line">&#125;</span><br><span class="line">export default state</span><br></pre></td></tr></table></figure>

**getters.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const getters &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default getters</span><br></pre></td></tr></table></figure>



### package.json

**package.json** 文件主要是 **项目名称** 、 **项目版本** 、 **项目描述** 、 **项目运行的一些脚本（依赖）**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;vue-cource&quot;, &#x2F;&#x2F; 项目名称</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;, &#x2F;&#x2F; 项目版本</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &#x2F;&#x2F; 运行指令</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;, &#x2F;&#x2F; 打包指令</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123; &#x2F;&#x2F; 项目打包后用到的依赖（运行依赖）</span><br><span class="line">    &quot;core-js&quot;: &quot;^2.6.5&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^2.6.10&quot;,</span><br><span class="line">    &quot;vue-router&quot;: &quot;^3.0.3&quot;,</span><br><span class="line">    &quot;vuex&quot;: &quot;^3.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123; &#x2F;&#x2F; 开发阶段用到的依赖（开发依赖）</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-babel&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-eslint&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-service&quot;: &quot;^3.10.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;eslint-config-standard&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;babel-eslint&quot;: &quot;^10.0.1&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;^5.16.0&quot;,</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;node-sass&quot;: &quot;^4.9.0&quot;,</span><br><span class="line">    &quot;sass-loader&quot;: &quot;^7.1.0&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





### vue.config.js

**vue.config.js** 是 **vue** 的 **配置文件**

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 引入nodejs的path模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir) <span class="comment">// resolve方法用来加载路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_URL = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/iview-admin/&#x27;</span> : <span class="string">&#x27;/&#x27;</span> </span><br><span class="line"><span class="comment">// 判断当前为开发环境还是打包环境, &#x27;/&#x27;意思是代表指定在域名的根目录下，如果要指定到iview-admin下就这样写&#x27;/iview-admin/&#x27;, production为生产坏境，development为开发环境</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,                          <span class="comment">// 取消每次保存时都进行一次&#x27; ESLint &#x27;检测</span></span><br><span class="line">  publicPath: BASE_URL,                       <span class="comment">// 项目的基本路径,vuecli2.0时打包经常静态文件找不到，就是需要配置这个属性为&#x27;./&#x27;</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;                   <span class="comment">// 配置Webpack</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">    .set(<span class="string">&#x27;@&#x27;</span>, resolve(<span class="string">&#x27;src&#x27;</span>))                 <span class="comment">// 引入文件时候“ @ ”符号就代表src</span></span><br><span class="line">    .set(<span class="string">&#x27;_c&#x27;</span>, resolve(<span class="string">&#x27;src/components&#x27;</span>))     <span class="comment">// 引入组件文件夹中的文件就可以用“ _c ”代替src/components</span></span><br><span class="line">  &#125;,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,                 <span class="comment">// 打包时不生成.map文件，会减少打包体积，同时加快打包速度</span></span><br><span class="line">  devServer: &#123;                                <span class="comment">// 跨域有2种解决方案： 1. 在后端的header中配置， 2. 使用devServer来配置代理解决跨域</span></span><br><span class="line">    proxy: &#123;<span class="comment">// 这里写需要代理的URL,这里会告诉开发服务器，将任何未知请求匹配不到静态文件的请求，都代理到这个URL来满足跨域</span></span><br><span class="line">			<span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//api是为了把前端路由和后端路由区分开，没前缀的是前端路由，有前缀的是后端路由</span></span><br><span class="line">				target:process.env.VUE_APP_API_URL, <span class="comment">//这里后台的地址模拟的;应该填写你们真实的后台接口</span></span><br><span class="line">				changOrigin: <span class="literal">true</span>, <span class="comment">//允许跨域</span></span><br><span class="line">				pathRewrite: &#123;</span><br><span class="line">					<span class="comment">// &#x27;^/api&#x27;: &#x27;/api&#x27;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





# ESLint

ESLint是个管理代码风格的工具 统一代码风格 在多人协作的项目都会用到



# VUEX

当我们的应用遇到多个组件共享状态时，会需要多个组件依赖于同一状态抑或是来自不同视图的行为需要变更同一状态。以前的解决办法：

**a.将数据以及操作数据的行为都定义在父组件;**

**b.将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)**

传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。在搭建下面页面时，你可能会对 vue 组件之间的通信感到崩溃 ，特别是非父子组件之间通信。此时就应该使用vuex，轻松可以搞定组件间通信问题。

![组件间通信](https://user-gold-cdn.xitu.io/2018/5/23/1638b38a08088b12?w=1194&h=486&f=png&s=133255)

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。这里的关键在于集中式存储管理。**简单来说,对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)**。

原理

![img](8.6.VUE/1656f2b9277ece19)

Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。

#### 2.简要介绍各模块在流程中的主要功能：

- Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。
- dispatch：操作行为触发方法，是唯一能执行action的方法。
- actions：**操作行为处理模块,由组件中的`$store.dispatch('action 名称', data1)`来触发。然后由commit()来触发mutation的调用 , 间接更新 state**。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。
- commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。
- mutations：**状态改变操作方法，由actions中的`commit('mutation 名称')`来触发**。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。
- state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。
- getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。



如果您的应用够简单，您最好不要使用 Vuex,因为使用 Vuex 可能是繁琐冗余的。一个简单的 [global event bus](https://cn.vuejs.org/v2/guide/components.html#非父子组件通信) 就足够您所需了。但是，**如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。**






每一个 **Vuex** 应用的核心就是 **store（仓库）** 。**store** 基本上就是一个 **容器** ，它包含着你的 **应用中大部分的状态 (state)** 。**Vuex** 和 **单纯的全局对象** 有以下 **两点不同**：

1. **Vuex** 的 **状态** 存储是 **响应式** 的。当 **Vue 组件** 从 **store** 中 **读取状态** 的时候，若 **store** 中的**状态发生变化** ，那么 **相应的组件也会得到更新** 。
2. 你 **不能直接改变 store 中的状态**。改变 **store** 中的 **状态** 的 **唯一途径就是通过mutation** 。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

## Bus

**Vuex** 适合 **大型复杂项目** 中使用，进行 **状态管理**，我们的项目如果不是很复杂可以使用 **Bus** 来满足需求。

## state 与 getter

![img](https://img.kancloud.cn/b3/f9/b3f994c71d894b582bae15b4a1df8ebb_701x551.png)

上图就是 **Vuex** 状态管理的 **流程** ，在 **Vue Components（组件）** 里可以触发一个 **Actions（Actions里可以做异步接口请求）** ， **请求完成** 后触发一个 **Mutations** ，通过 **Mutations** 修改 **State** 的状态值，**State** 修改之后会触发 **vue组件视图的渲染** 。

**getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工**。getters就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。



## mutation 与 action / module

![img](https://img.kancloud.cn/b3/f9/b3f994c71d894b582bae15b4a1df8ebb_701x551.png)

上图是 **Vuex** 状态管理的 **流程**，描述了从 **Vue Components（组件）** 执行 **异步操作** 的一个 **环形流程** ，实际上如果 **没有异步操作的需求** 就不用走 **Actions** 的这个步骤， **2种操作（同步、异步操作）** 的流程如下：

1. **异步操作**： **Vue Components（组件）** > **Actions（请求接口操作写这里）** > **Mutations（接口成功返回值后在这里修改State的值）** > **State状态更新** > **Vue Components（组件）视图更新**
2. **同步操作** ： **Vue Components（组件）** > **Mutations（修改State的值）** > **State状态更新** > **Vue Components（组件）视图更新**



actions和上面的Mutations功能基本一样，不同点是，**actions是异步的改变state状态，而Mutations是同步改变状态**。

同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态----尤雨溪







# AJAX

**Ajax** 用来 **请求后端接口** 并且 **取得返回数据** ， 在 **Vue** 中 使用的是 **Vue** 官方推荐的 **axios** 库来作为 **异步接口请求** 的工具

**跨域** 是受到 **浏览器** 的 **同源策略** 的影响，在一些情况下是 **不允许通信的** 。

在下面表格中列出了 **跨域** 的案例：

| URL                                                         | 说明                           | 是否允许通信                            |
| :---------------------------------------------------------- | :----------------------------- | :-------------------------------------- |
| http://www.d.com/d.js <br />http://www.d.com/w.js           | 同一域名下                     | 允许                                    |
| http://www.d.com/lab/a.js <br />http://www.d.com/src/b.js   | 同一域名下不同文件夹           | 允许                                    |
| http://www.d.com:3333/a.js <br />http://www.d.com:4444/b.js | 同一域名不同端口               | 不允许                                  |
| http://www.d.com/a.js <br />http://46.33.22.44/b.js         | **域名和域名对应 IP**          | 不允许                                  |
| http://www.d.com/a.js <br />http://scipt.d.com/b.js         | 主域相同，子域不同             | 不允许                                  |
| http://www.d.com/a.js <br />http://d.com/b.js               | 同一域名，不同二级域名（同上） | 不允许（cookie 这种情况下也不允许访问） |
| http://www.d.com/a.js <br />http://www.v.com/b.js           | 不同域名                       | 不允许                                  |

### 前端解决跨域

**前端** 需要在 **vue.config.js** 文件中通过 **devServer** 中的 **proxy** 来 **配置代理** 。

**原理** ：我们在 **本地开发** 的时候，通过 **vueServe** 起一个 **本地的开发服务** ，这个 **服务的地址** 一般是 **localhost** ， **端口** 一般是 **8080** ，如果我们在 **本地起一个 node 服务** ，那么它的 **端口** 肯定是跟我们的 **前端服务的端口** 是不一样的，刚才在 上面表格中讲过 **同一域名不同端口** 也是 **存在跨域问题** ，是 **不在同一个域下** ，这个时候 **调用接口** 的话，受到 **同源策略** 影响，是 **无法调取成功** 的，我们可以用 **proxy** 来 **设置代理** ， **它会把我们所有的接口，代理到目标URL下** ，比如接口是 **/api/getUserInfo** ，我们 **设置代理** 是 **[http://localhost:4000](http://localhost:4000/)** ，这样的话请求的接口就会被代理到 **[http://localhost:4000](http://localhost:4000/)** 下，代理后请求接口时的**URL** ： **http://localhost:4000/#/api/getUserInfo** ， 例子如下：

**vue.config.js**

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 引入nodejs的path模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">dir</span> =&gt;</span> path.join(__dirname, dir) <span class="comment">// resolve方法用来加载路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BASE_URL = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/iview-admin/&#x27;</span> : <span class="string">&#x27;/&#x27;</span> <span class="comment">// 判断当前为开发环境还是打包环境, &#x27;/&#x27;意思是代表指定在域名的根目录下，如果要指定到iview-admin下就这样写&#x27;/iview-admin/&#x27;, production为生产坏境，development为开发环境</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: <span class="literal">false</span>,                          <span class="comment">// 取消每次保存时都进行一次&#x27; ESLint &#x27;检测</span></span><br><span class="line">  publicPath: BASE_URL,                       <span class="comment">// 项目的基本路径,vuecli2.0时打包经常静态文件找不到，就是需要配置这个属性为&#x27;./&#x27;</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;                   <span class="comment">// 配置Webpack</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">    .set(<span class="string">&#x27;@&#x27;</span>, resolve(<span class="string">&#x27;src&#x27;</span>))                 <span class="comment">// 引入文件时候“ @ ”符号就代表src</span></span><br><span class="line">    .set(<span class="string">&#x27;_c&#x27;</span>, resolve(<span class="string">&#x27;src/components&#x27;</span>))     <span class="comment">// 引入组件文件夹中的文件就可以用“ _c ”代替src/components</span></span><br><span class="line">  &#125;,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,                 <span class="comment">// 打包时不生成.map文件，会减少打包体积，同时加快打包速度</span></span><br><span class="line">  devServer: &#123;                                <span class="comment">// 跨域有2种解决方案： 1. 在后端的header中配置， 2. 使用devServer来配置代理解决跨域</span></span><br><span class="line">    proxy: <span class="string">&#x27;http://localhost:4000&#x27;</span>            <span class="comment">// 这里写需要代理的URL,这里会告诉开发服务器，将任何未知请求匹配不到静态文件的请求，都代理到这个URL来满足跨域</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

这里的代理的 **URL地址** 以及 **端口号** 一定要与服务端 **一致** 。

### 注意

1. **前端配置代理** 只是在 **开发环境（develop）** 好用，便于开发，在 **生产环境（prod）** 还是 **需要由服务端解决跨域** 。

2. 这里需要注意，如果在 **前端配置代理** ，需要在 **src/config/index.js（接下来的axios封装中用到了这个文件）** 中添加一个 **逻辑判断** 如下：

   **src/config/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果当前是生产环境用生产环境地址，如果是开发环境并且在vue.config.js中配置了代理，就用空字符串【&#39;&#39;】，如果未配置代理就用开发环境地址</span><br><span class="line">export const baseURL&#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;http:&#x2F;&#x2F;production.com&#39; : &#39;http:&#x2F;&#x2F;develop.com&#39;</span><br></pre></td></tr></table></figure>

### 后端解决跨域

如果不在 **设置代理** ，可以在 **后端设置header** 来 **解决跨域问题** ，这里 **后端** 用的是 **nodejs** ，在**express（nodejs的框架）** 里使用 **app.all** 为 **所有请求** 都添加这 **3 个 header** 即可。

**app.js**

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createError = <span class="built_in">require</span>(<span class="string">&#x27;http-errors&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;colors&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;morgan&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indexRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> usersRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/users&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// view engine setup</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="string">&#x27;views&#x27;</span>))</span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;jade&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(logger(<span class="string">&#x27;dev&#x27;</span>))</span><br><span class="line">app.use(express.json())</span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.use(cookieParser())</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">&#x27;public&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123; <span class="comment">// 设置header</span></span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;X-Requested-With,Content-Type&#x27;</span>)</span><br><span class="line">	res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="string">&#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;</span>)</span><br><span class="line">	next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, indexRouter)</span><br><span class="line">app.use(<span class="string">&#x27;/users&#x27;</span>, usersRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// catch 404 and forward to error handler</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">	next(createError(<span class="number">404</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error handler</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// set locals, only providing error in development</span></span><br><span class="line">	res.locals.message = err.message</span><br><span class="line">	res.locals.error = req.app.get(<span class="string">&#x27;env&#x27;</span>) === <span class="string">&#x27;development&#x27;</span> ? err : &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// render the error page</span></span><br><span class="line">	res.status(err.status || <span class="number">500</span>)</span><br><span class="line">	res.render(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br></pre></td></tr></table></figure>

## 封装axios

1. 首先在 **src文件夹** 下的 **lib文件夹** 中创建 **axios.js**

   **src/lib/axios.js**

   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; baseURL &#125; <span class="keyword">from</span> <span class="string">&#x27;@/config&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/lib/util&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">baseUrl = baseURL</span>)</span>&#123; <span class="comment">// baseUrl = baseURL 是ES6的默认值写法等同于 baseUrl = baseUrl || baseURL</span></span><br><span class="line">        <span class="built_in">this</span>.baseUrl = baseUrl <span class="comment">// this指向创建的实例，当你使用new HttpRequest创建实例时候，它会把this中定义的变量返回给你</span></span><br><span class="line">        <span class="built_in">this</span>.queue = &#123;&#125; <span class="comment">// 创建队列，每次请求都会向里面添加一个key:value，请求成功后就会去掉这个key:value，直到this.queue中没有属性值时，loading关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认options配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">getInsideConfig</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> config = &#123;</span><br><span class="line">            baseURL: <span class="built_in">this</span>.baseUrl,</span><br><span class="line">            headers: &#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;</span><br><span class="line">    distroy (url) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.queue[url]</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.queue).length) &#123;</span><br><span class="line">          <span class="comment">// Spin.hide()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">instance</span></span> - 通过axios创建的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">url</span></span> - 接口地址</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="function"><span class="title">interceptors</span>(<span class="params">instance, url</span>)</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求拦截器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">config</span></span> - 请求前的控制</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">error</span></span> - 出现错误的时候会提供一个错误信息</span></span><br><span class="line"><span class="comment">         */</span>    </span><br><span class="line">        instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 添加全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.queue).length)&#123;</span><br><span class="line">                <span class="comment">// Spin.show()</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">this</span>.queue[url] = <span class="literal">true</span></span><br><span class="line">            config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = getToken()</span><br><span class="line">            <span class="keyword">return</span> config</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 响应拦截器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">res</span></span> - 服务端返回的东西</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">error</span></span> - 出现错误的时候会提供一个错误信息</span></span><br><span class="line"><span class="comment">         */</span>            </span><br><span class="line">        instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.distroy(url) <span class="comment">// 关闭全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">const</span> &#123; data &#125; = res</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.distroy(url) <span class="comment">// 关闭全局的Lodaing...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error.response.data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">request</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create()</span><br><span class="line">        options = <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.getInsideConfig(), options) <span class="comment">//  Object.assign会将2个对象合并成1个对象，相同属性值会被后者覆盖</span></span><br><span class="line">        <span class="built_in">this</span>.interceptors(instance, options.url) <span class="comment">// 拦截器</span></span><br><span class="line">        <span class="keyword">return</span> instance(options)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HttpRequest</span><br></pre></td></tr></table></figure>

   **constructor方法** 是 **每一个类必须有的方法** ，如果我们不定义这个 **constructor方法** ， **class类** 会默认添加一个 **空的constructor方法（例如：constructor(){}）** ，在 **constructor方法** 中可以 **接收传入的参数** ， 在我们 **创建实例 new HttpRequest('参数')** 时候可以 **在括号内传入参数** ， 然后我们可以在 **constructor方法** 中 **对参数做一些操作** 。

2. 上面把 **baseUrl** 抽离到了 **config文件夹** 里的 **index.js 全局变量** 中

   **src/config/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果当前是生产环境用生产环境地址，如果是开发环境并且在vue.config.js中配置了代理，就用空字符串【&#39;&#39;】，如果未配置代理就用开发环境地址</span><br><span class="line">export const baseURL&#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;http:&#x2F;&#x2F;production.com&#39; : &#39;http:&#x2F;&#x2F;develop.com&#39;</span><br></pre></td></tr></table></figure>

### 使用方法

1. 在 **api文件夹** 中创建 **index.js**

   **src/api/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import HttpRequest from &#39;@&#x2F;lib&#x2F;axios&#39;</span><br><span class="line">const axios &#x3D; new HttpRequest()</span><br><span class="line">export default axios</span><br></pre></td></tr></table></figure>

   在使用时候：我们创建一个储存用户接口的 **uesr.js** 文件

   **src/api/user.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;.&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取用户信息接口</span><br><span class="line">export const getUserInfo &#x3D; (&#123; userId &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return axios.request(&#123;</span><br><span class="line">        url: &#39;&#x2F;getUserInfo&#39;,</span><br><span class="line">        method: &#39;post&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            userId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   然后在 **Home.vue** 页面组件中这样 **调用接口**

   **Home.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;getInfo&quot;&gt;请求数据&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; getUserInfo &#125; from &#39;@&#x2F;api&#x2F;user&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getInfo()&#123;</span><br><span class="line">      getUserInfo(&#123; userId: 21 &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">      &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



ajax.js`中配置了axios.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";`

在jquery的ajax中，如果没加contentType:"application/json"，那么data就应该对应的是json对象，反之，如果加了contentType:"application/json"，那么ajax发送的就必须是字符串

contentType参数指定的是浏览器将发送什么样类型的编码

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">text&#x2F;html ： HTML格式</span><br><span class="line"></span><br><span class="line">    text&#x2F;plain ：纯文本格式      </span><br><span class="line"></span><br><span class="line">    text&#x2F;xml ：  XML格式</span><br><span class="line"></span><br><span class="line">    mage&#x2F;gif ：gif图片</span><br><span class="line"></span><br><span class="line">    image&#x2F;jpeg ：jpg图片格式 </span><br><span class="line"></span><br><span class="line">    image&#x2F;png：png图片格式</span><br><span class="line"></span><br><span class="line">    application&#x2F;json  ：json数据格式</span><br><span class="line"></span><br><span class="line">    application&#x2F;pdf   ：pdf格式  </span><br><span class="line"></span><br><span class="line">    application&#x2F;octet-stream ： 二进制流数据</span><br></pre></td></tr></table></figure>

不指定contentType则代表为默认的application/x-www-form-urlencoded（表单）类型，这种类型有一个好处，它可以支持很多种情况，并能配合查询字符串（key1=value1&key2=vlaue2）的形式发送到服务器。而且这种默认类型可以很好地配合参数processData（默认为true，可以不用管他），该参数为true的时候，开启自动转化功能，**只要是一个合法对象**，都能将该对象**自动地转化成查询字符串**的形式

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data: &#123; &quot;username&quot; : &quot;ccc&quot; &#125; ,  &#x2F;&#x2F;查询字符串的映射形式（即对象），在默认模式下提交时会自动地转化成查询字符串</span><br><span class="line"> data: &quot;username&#x3D;ccc&quot;,   &#x2F;&#x2F;查询字符串形式</span><br></pre></td></tr></table></figure>

指定了contentType : "application/json"后，data就只能是字符串而且必须是json字符串了，首先你指定json格式，那提交格式肯定与json有关，再一个，因为你指定了"application/json"就意味着你放弃了"application/x-www-form-urlencoded"这种默认模式，默认模式虽可以自动地转化对象，不见得"application/json"这种格式就会自动帮你转，而事实证明，它确实不会帮你自动转

@RequestBody这个注解就是专门用来处理**非默认模式**下的请求的。该注解会提取你传过来的**json字符串**(注意是**json字符串**,不是查询字符串)，并将提取到的信息绑定到对象中

有些  关键的属性在Mvc层中反射失败，会导致其他所有属性都为null：比如joindate对应的pojo是Date，本来input框里的值是 Thu Dec 30 00:00:00 CST 1999 ，传到后台用Date接收，但是显然格式不对，于是Date合成出了错，然后坑爹的就来了，因为这个特殊的属性反射失败，Mvc层就将请求打回去然后导致浏览器报错400 bad request ，从而导致其他所有属性都为null。最后把joindate属性注释掉，后台什么属性的值都收到了

总结：在"application/json"的时候，ajax请求对跨域支持似乎不好，默认模式下的ajax成功跨域请求一旦改成了"application/json"就会报跨域请求的错，需要用@RequestBody在请求的参数中才能正常。

在非特殊情况下会有些更倾向application/x-www-form-urlencoded了，**跨域问题**既没有application/json那么多，安全问题也不像application/json那样会有一定概率被一些植入**恶意的回调代码**，而且能**很方便的传输和接受**复杂而又多重嵌套的对象

要调用别人的接口，那么就很可能要指定application/json格式，因为接口提供方就是这么规定的，json的数据格式**传输时带宽会更小**，尤其是在传输数组时，如果数组元素很多，那么application/json传输的数据量就会比application/x-www-form-urlencoded**要少很多**，同时，json的解析速度也会更快



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">在请求或响应被 then 或 <span class="keyword">catch</span> 处理前拦截它们。</span><br><span class="line"><span class="comment">// axios 配置</span></span><br><span class="line">axios.defaults.timeout = <span class="number">10000</span>; <span class="comment">// 设置请求超时为10秒</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;/api&#x27;</span>; <span class="comment">// 默认请求地址前都加/api</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;</span>; <span class="comment">// 请求头的设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置跨域携带用户凭证</span></span><br><span class="line"><span class="comment">//axios.defaults.withCredentials = true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    (config) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">        Toast.loading(&#123;</span><br><span class="line">            message: <span class="string">&quot;加载中...&quot;</span>,</span><br><span class="line">            loadingType: <span class="string">&quot;spinner&quot;</span>,</span><br><span class="line">            forbidClick: <span class="literal">true</span>,</span><br><span class="line">            duration: <span class="number">0</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> openid = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">        config.headers[<span class="string">&quot;openid&quot;</span>] = openid;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">        Toast.clear();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;请求出错&quot;</span> + error)</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;http://elinktech.cn/#/error&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">        Toast.clear(); <span class="comment">//在网络不好时清除加载中</span></span><br><span class="line">        <span class="keyword">const</span> responseCode = res.status;</span><br><span class="line">        <span class="comment">// 拦截器配置</span></span><br><span class="line">        <span class="keyword">if</span> (responseCode === <span class="number">200</span>) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (res.data.code === -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;返回出错了&quot;</span> + res)</span><br><span class="line">                <span class="built_in">window</span>.location.href = <span class="string">&#x27;http://elinktech.cn/#/error&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">                ok: <span class="literal">true</span>,</span><br><span class="line">                data: res.data,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.fail(&#123;</span><br><span class="line">                message: <span class="string">&quot;服务器开小差了，请稍后重试&quot;</span>,</span><br><span class="line">                duration: <span class="number">3000</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">        Toast.clear();</span><br><span class="line">        <span class="keyword">if</span> (error.response?.data?.code === <span class="number">401</span>) &#123;</span><br><span class="line">            <span class="comment">//  localStorage.removeItem(&quot;token&quot;);</span></span><br><span class="line">            <span class="comment">// localStorage.removeItem(&quot;userId&quot;);</span></span><br><span class="line">            <span class="comment">// window.location.reload();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求失败</span></span><br><span class="line">        Toast.fail(&#123;</span><br><span class="line">            message: <span class="string">&quot;请求超时！&quot;</span>,</span><br><span class="line">            duration: <span class="number">3000</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;返回出错&quot;</span> + error)</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;http://elinktech.cn/#/error&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



# 渲染函数（render函数）

在 **Vue** 中使用 **渲染函数** 来 **创建视图模板** ，并且会讲解 **JSX** 的 **语法** ，同时会补充2个内容，第一是 **函数式组件** ，第二是 **作用域插槽** 。

## render函数

**render函数** ：可以用 **函数的方式** 渲染 **dom元素** 到页面中。

下面会讲解2种使用场景：

1. 在 **main.js** 中如何使用
2. 在 **.vue** 文件中使用

### render函数在main.js中使用

**src/main.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39; &#x2F;&#x2F; app组件</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">import Bus from &#39;.&#x2F;lib&#x2F;bus&#39; &#x2F;&#x2F; 引入Bus</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line">Vue.prototype.$bus &#x3D; Bus &#x2F;&#x2F; 挂载Bus到Vue原型链（全局挂载Bus）</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(App) &#x2F;&#x2F; 渲染app组件</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

我们首先在 **main.js** 中学习 **render函数** ， **render** 的 **属性值** 是一个 **回调函数** ，它的参数可以用括号包裹起来，例如这样： **render: (h) => h(App)** ，如果 **只有一个参数就可以不用括号包裹** ， **h这个参数是一个方法** ，这个方法能 **创建一个虚拟节点** ，**这个函数 return 返回一个结果** 。

| 方法名                              | 参数                                                         | 是否必填 |
| :---------------------------------- | :----------------------------------------------------------- | :------- |
| **render函数：render: h => h(App)** | **h函数的第1个参数**：**要渲染的组件，或者一个标签字符串，或者也可以是一个函数** | **是**   |
|                                     | **h函数的第2个参数**： 该参数是一个 **配置对象**，可以 **通过该对象给元素设置属性** ，例如 **div** 标签的 **id、class 等等** | **否**   |
|                                     | **h函数的第3个参数**：该 **参数可以是字符串或者数组**，主要作用是 **给元素添加内容** | **否**   |

1. **h函数的参数1**

   **说明** ： **第1个参数** 是用来传入 **元素标签** 或者 **组件** 。

   1.1. **传入组件** ：**main.js** 中 **h函数** 默认传入的是 **app.vue页面组件**，所以就会 **渲染该组件** ，下面引入之前封装的 **CountTo 组件**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">import Bus from &#39;.&#x2F;lib&#x2F;bus&#39;</span><br><span class="line">import CountTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入CountTo 组件</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line">Vue.prototype.$bus &#x3D; Bus</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(CountTo, &#123;</span><br><span class="line">    &#x2F;&#x2F; &#39;class&#39;: &#39;count-to&#39;, &#x2F;&#x2F; 给组件最外层盒子添加class类名</span><br><span class="line">    &#x2F;&#x2F; 或者这样写</span><br><span class="line">    &#x2F;&#x2F; &#39;class&#39;: [&#39;count-to&#39;, true ? &#39;count-to2&#39; : &#39;&#39;], </span><br><span class="line">    &#x2F;&#x2F; 或者这样写</span><br><span class="line">    &#39;class&#39;: &#123;</span><br><span class="line">      &#39;count-to&#39;: true,</span><br><span class="line">      &#39;count-to2&#39;: 1 &#x3D;&#x3D;&#x3D; 1,</span><br><span class="line">    &#125;, </span><br><span class="line">    attrs: &#123;&#125;, &#x2F;&#x2F; 定义属性id等等</span><br><span class="line">    style: &#123;&#125;, &#x2F;&#x2F; 定义样式</span><br><span class="line">    props: &#123; &#x2F;&#x2F; 添加属性 这里可以理解为就是&lt;count-to :endValue&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">      endValue: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; domProps: &#123; &#x2F;&#x2F; dom的一些属性</span><br><span class="line">    &#x2F;&#x2F;   innerHTML: &#39;11&#39; &#x2F;&#x2F; 可以设置标签的一些内容</span><br><span class="line">    &#x2F;&#x2F; &#125;,</span><br><span class="line">    on: &#123; &#x2F;&#x2F; 添加事件</span><br><span class="line">      &#39;on-animation-end&#39;: (val) &#x3D;&gt; &#123; &#x2F;&#x2F; 事件名</span><br><span class="line">        console.log(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    nativeOn: &#123; &#x2F;&#x2F; 组件内没有定义click事件时，给组件最外层元素绑定一个click事件</span><br><span class="line">      &#39;click&#39;: () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;click&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    directives: [], &#x2F;&#x2F; 可以定义自定义指令</span><br><span class="line">    scopedSlots: &#123;&#125;,</span><br><span class="line">    slot: &#39;&#39;, &#x2F;&#x2F; 插槽</span><br><span class="line">    key: &#39;&#39;, &#x2F;&#x2F; 设置一个值让每个组件的key不相等</span><br><span class="line">    ref: &#39;&#39; &#x2F;&#x2F; ref</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   1.2. **传入字符串** ：也可以像下面写，这样页面中就 **渲染** 出一个 **div标签** 。

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   1.3. **传入函数** ：

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let func &#x3D; ()&#x3D;&gt; &#39;h3&#39;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(func())</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

2. **h函数的参数2**

   **说明** ： **h函数** 的 **第2个参数是个对象** ，用来 **定义元素的一些属性** 。

   2.1. **给元素设置属性** ：

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#123;</span><br><span class="line">    attrs: &#123; &#x2F;&#x2F; 添加属性</span><br><span class="line">      id: &#39;box&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    style: &#123; &#x2F;&#x2F; 添加样式</span><br><span class="line">      color: &#39;red&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

3. **h函数的参数3**

   **说明** ： **h函数的第3个参数可以是字符串或者数组** ，用来 **定义元素的内容** 。

   3.1. **传入字符串**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#123;</span><br><span class="line">    attrs: &#123; &#x2F;&#x2F; 添加属性</span><br><span class="line">      id: &#39;box&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    style: &#123; &#x2F;&#x2F; 添加样式</span><br><span class="line">      color: &#39;red&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#39;我是div的内容&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   **如果不设置样式可以直接忽略h函数的第2个参数** , 直接写内容

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, &#39;123&#39;)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   3.2. **传入数组**

   如果想让内容是 **多个标签** ，就需要 **传入数组**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;, [</span><br><span class="line">    h(&#39;span&#39;, &#39;111&#39;),</span><br><span class="line">    h(&#39;span&#39;, &#39;222&#39;)</span><br><span class="line">  ])</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

   3.3. **循环传入标签**

   如果想实现一个类似 **v-for** 的效果，首先先看 **正常循环列表写法**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul @click&#x3D;&quot;handleClick&quot;&gt;</span><br><span class="line">        &lt;li @click.stop&#x3D;&quot;handleClick&quot; v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;list_item_$&#123;index&#125;&#96;&quot;&gt;&#123;&#123; item.name &#125;&#125; &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default&#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                list: [</span><br><span class="line">                    &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                    &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleClick(event)&#123;</span><br><span class="line">                console.log(event)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   接下来使用 **render函数** 实现上面的 **循环列表跟点击事件**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 点击事件</span><br><span class="line">const handleClick &#x3D; event &#x3D;&gt; &#123;</span><br><span class="line">  console.log(event)</span><br><span class="line">  event.stopPropagation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">let list &#x3D; [</span><br><span class="line">  &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">  &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 循环生成li</span><br><span class="line">const getLiEleArr &#x3D; (h) &#x3D;&gt; &#123;</span><br><span class="line">  return list.map((item, index) &#x3D;&gt; h(&#39;li&#39;, &#123;</span><br><span class="line">    on: &#123;</span><br><span class="line">      &#39;click&#39;: handleClick</span><br><span class="line">    &#125;,</span><br><span class="line">    key: &#96;list_item_$&#123;index&#125;&#96;</span><br><span class="line">  &#125;, item.name))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最终渲染</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(&#39;div&#39;,[</span><br><span class="line">    h(&#39;ul&#39;, &#123;</span><br><span class="line">      on: &#123;</span><br><span class="line">        &#39;click&#39;: handleClick</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, getLiEleArr(h))</span><br><span class="line">  ])</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

### render函数在.vue中使用

有时 **即使你封装好了组件，但是想根据自己的方式去定制组件内的元素以及内容**，这时候就需要 **给组件传入一个render函数**

1. **父组件**

   首先在 **路由列表** 的 **路由对象** 中添加新创建的 **render-page** 页面配置路由

   **src/router/router.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;render-page&#39;,</span><br><span class="line">    name: &#39;&#x2F;render_page&#39;,</span><br><span class="line">    component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;render-page&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

   然后在 **src/views/render-page.vue** 页面 **引入list组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, name)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            return h(&#39;i&#39;, &#123;</span><br><span class="line">                style: &#123;</span><br><span class="line">                    color: &#39;pink&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

2. **子组件**

   **src/components/list/list.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">          &lt;!-- 如果未传入render函数就span标签内容 --&gt;</span><br><span class="line">          &lt;span v-if&#x3D;&quot;!render&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">          </span><br><span class="line">          &lt;!-- 如果传入了render函数，就使用render函数自定义dom的节点来渲染 --&gt;</span><br><span class="line">          &lt;render-dom v-else :render-func&#x3D;&quot;render&quot; :name&#x3D;&quot;item.name&quot;&gt;&lt;&#x2F;render-dom&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 引入函数式组件</span><br><span class="line">import RenderDom from &#39;_c&#x2F;render-dom&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        RenderDom &#x2F;&#x2F; 注册函数式组件</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;,</span><br><span class="line">        render: &#123; &#x2F;&#x2F; render 函数</span><br><span class="line">            type: Function,</span><br><span class="line">            default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   定义一个 **index.js 方便父组件引用**

   **src/components/list/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import List from &#39;.&#x2F;list.vue&#39;</span><br><span class="line">export default List</span><br></pre></td></tr></table></figure>

   在上面的组件中使用到了 **函数式组件** ，这里写的 **函数式组件** 就是使用 **reder函数 自定义一些想要的标签** 然后 **return** 返回一个 **虚拟节点** ， **最终渲染在使用函数式组件的地方** ，**函数式组件详解看下方的文档介绍**。

   **src/components/render-dom.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        name: String, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 函数式组件

**函数式组件** ： **只给它传入数据，它不做任何响应式的操作， 不监听传递给它的状态** ，这个组件 **没有生命周期和钩子函数**，它 **只是作为一个接收参数的函数** ， 当 **functional 设置为 true** 时候，证明 **它是一个没有状态的组件，也没有实例，就是一个对象** ， 当 **把这个对象引入到其他页面，当做一个组件去使用的时候，vue会把它做一个处理，会把 【render函数】里面逻辑返回的【虚拟节点】做一个渲染** 。

**src/components/render-dom.js**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        name: String, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## JSX

**JSX** ：**JSX** 最先是 **react** 提出的， **通过一种形式，在 js 里面写 html 标签，还有一些特定的语法** ，最后会把这个 **字符串** 转译成 **js** ，去用 **render函数** 来做渲染。

### JSX渲染标签字符串

1. **父组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123;name: &#39;小明&#39;&#125;,</span><br><span class="line">                &#123;name: &#39;小黑&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, name)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * render函数方式</span><br><span class="line">             *&#x2F;</span><br><span class="line">            &#x2F;&#x2F; return h(&#39;i&#39;, &#123;</span><br><span class="line">            &#x2F;&#x2F;     style: &#123;</span><br><span class="line">            &#x2F;&#x2F;         color: &#39;pink&#39;</span><br><span class="line">            &#x2F;&#x2F;     &#125;</span><br><span class="line">            &#x2F;&#x2F; &#125;, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * JSX方式</span><br><span class="line">             * JSX与template模板对比</span><br><span class="line">             *   style:</span><br><span class="line">             *      template的标签中写法:style&#x3D;&quot;&#123; color: &#39;pink&#39; &#125;&quot;</span><br><span class="line">             *      JSX写法:style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;</span><br><span class="line">             *      JSX中style不需要添加双引号，属性都需要用&#123;&#125;包裹</span><br><span class="line">             * </span><br><span class="line">             *   事件:</span><br><span class="line">             *      template的标签中写法v-click&#x3D;&quot;handleClick&quot; 或者 @click&#x3D;&quot;handleClick&quot;</span><br><span class="line">             *      JSX写法on-click&#x3D;&#123; this.handleClick &#125;</span><br><span class="line">             *&#x2F;</span><br><span class="line">            return (</span><br><span class="line">                &lt;i on-click&#x3D;&#123; this.handleClick &#125; style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;&gt;&#123; name &#125;&lt;&#x2F;i&gt; </span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        handleClick(event)&#123;</span><br><span class="line">            console.log(event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   使用 **JSX** 时 **render函数** 的 **形参必须是 h** ，不可以改成其他的（例如 **createElement**）。以上代码中引入的 **List组件** 在上面的 **render函数** 文档中有写过，在此处就不再过多陈述。

### JSX渲染组件

1. **父组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot; :render&#x3D;&quot;renderFunc&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line">import CountTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入组件</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123; number: 100 &#125;,</span><br><span class="line">                &#123; number: 45 &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        renderFunc(h, number)&#123; &#x2F;&#x2F; 自定义render函数渲染自己想要的dom节点内容</span><br><span class="line">            return (</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 这里可以引入组件进行渲染，而且不用在components对象中注册</span><br><span class="line">                 * 事件分为2种：原生事件、自定义事件</span><br><span class="line">                 *  html标签：支持原生事件</span><br><span class="line">                 *  组件：支持原生事件(给下面的CountTo组件绑定一个原生click事件,就相当于给组件内的最外层元素绑定了一个click事件，</span><br><span class="line">                 *  写法：nativeOn-事件名称&#x3D;&#123;方法&#125;)、</span><br><span class="line">                 *  自定义事件(写法：on-自定义事件名称&#x3D;&#123;方法&#125;)</span><br><span class="line">                 *  template模板中的事件修饰符在JSX跟render函数中用到需要看文档</span><br><span class="line">                 * *&#x2F; </span><br><span class="line">                &lt;CountTo nativeOn-click&#x3D;&#123;this.handleClick&#125; on-on-animation-end&#x3D;&#123;this.handleEnd&#125; endValue&#x3D;&#123;number&#125; style&#x3D;&#123;&#123;color: &#39;pink&#39;&#125;&#125;&gt;&lt;&#x2F;CountTo&gt; </span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        handleClick(event)&#123;</span><br><span class="line">            console.log(event)</span><br><span class="line">        &#125;,</span><br><span class="line">        handleEnd()&#123;</span><br><span class="line">            console.log(&#39;end!&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   父组件中引入的 **[CountTo组件](https://www.kancloud.cn/wangjiachong/vue_notes/1971966)**

2. **子组件**

   **src/components/list.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li @mousemove&#x3D;&quot;handleMove&quot; v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">          &lt;!-- 如果未传入render函数就span标签内容 --&gt;</span><br><span class="line">          &lt;span v-if&#x3D;&quot;!render&quot;&gt;&#123;&#123; item.number &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">          </span><br><span class="line">          &lt;!-- 如果传入了render函数，就使用render函数自定义dom的节点来渲染 --&gt;</span><br><span class="line">          &lt;render-dom v-else :render-func&#x3D;&quot;render&quot; :number&#x3D;&quot;item.number&quot;&gt;&lt;&#x2F;render-dom&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 引入函数式组件</span><br><span class="line">import RenderDom from &#39;_c&#x2F;render-dom&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        RenderDom &#x2F;&#x2F; 注册函数式组件</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;,</span><br><span class="line">        render: &#123; &#x2F;&#x2F; render 函数</span><br><span class="line">            type: Function,</span><br><span class="line">            default: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleMove(event)&#123;</span><br><span class="line">            &#x2F;&#x2F; 阻止默认行为（文字不可以选中复制）</span><br><span class="line">            event.preventDefault()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

   **list组件** 对应的 **index.js**，用于 **父组件方便引用**

   **src/components/list/index.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import List from &#39;.&#x2F;list.vue&#39;</span><br><span class="line">export default List</span><br></pre></td></tr></table></figure>

   **子组件** 中用到的 **函数式组件 render-dom.js**

   **src/components/render-dom.js**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    functional: true,</span><br><span class="line">    props: &#123;</span><br><span class="line">        number: Number, &#x2F;&#x2F; 组件渲染的文字内容</span><br><span class="line">        renderFunc: Function &#x2F;&#x2F; 传入的render函数</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * render渲染函数</span><br><span class="line">     * @param &#123;Function&#125; h - render函数的回调方法，用于生成dom节点</span><br><span class="line">     * @param &#123;Object&#125; ctx - 指代当前的这个对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    render: (h, ctx) &#x3D;&gt; &#123;</span><br><span class="line">        return ctx.props.renderFunc(h, ctx.props.number)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 作用域插槽

**定制组件内的元素以及内容** ，用 **render函数** 以及 **JSX** 都比较繁琐，接下来用 **作用域插槽** 来实现这个需求。

1. **父组件**

   **src/views/render-page.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;list :list&#x3D;&quot;list&quot;&gt;</span><br><span class="line">            &lt;h3 slot&#x3D;&quot;aa&quot;&gt;我是小明&lt;&#x2F;h3&gt;</span><br><span class="line">            &lt;coun-to slot-scope&#x3D;&quot;count&quot; :end-value&#x3D;&quot;count.number&quot;&gt;&lt;&#x2F;coun-to&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import List from &#39;_c&#x2F;list&#39;</span><br><span class="line">import CounTo from &#39;_c&#x2F;count-to&#39; &#x2F;&#x2F; 引入组件</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            list: [ &#x2F;&#x2F; 数据</span><br><span class="line">                &#123; number: 100 &#125;,</span><br><span class="line">                &#123; number: 45 &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        List,</span><br><span class="line">        CounTo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

2. **子组件**

   **src/components/list.vue**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;&#96;item_$&#123;index&#125;&#96;&quot;&gt;</span><br><span class="line">            &lt;!-- 默认插槽 --&gt;</span><br><span class="line">            &lt;!-- &lt;slot&gt;&lt;&#x2F;slot&gt; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &lt;!-- 具名插槽 --&gt;</span><br><span class="line">            &lt;slot name&#x3D;&quot;aa&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        </span><br><span class="line">            &lt;!-- 作用域插槽 --&gt;</span><br><span class="line">            &lt;slot :number&#x3D;&quot;item.number&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;List&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        list: &#123; &#x2F;&#x2F; 列表内容</span><br><span class="line">            type: Array,</span><br><span class="line">            default: () &#x3D;&gt; []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

3. **插槽总结**

   3.1 **匿名插槽** 应用场景：**组件内** 只需要一个 **插槽** 的情况，可以使用 **匿名插槽** 。

   3.2 **具名插槽** 应用场景：**组件内** 需要多个 **插槽** 的情况，可以使用 **具名插槽** 。

   3.3 **作用域插槽**应用场景：**父组件插槽插入的内容中** 使用到了 **组件内的数据** 。



# render: h => h(App)

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//createElement就是h,一个形参，没有具体意义，可以随意改变书写</span></span><br><span class="line">render:(<span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(App);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

render是一个方法，自带一个形参createElement，这个参数也是一个方法，是用来创建vue 节点的，也就是html模板的，然后渲染(render)到指定的节点上



# VUE的配置



# VUE的路由：Vue Router

vue-router中经常会操作的两个对象route和router两个

## $route对象

表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等

**1.**  **$route.path**   字符串，对应当前路由的路径，总是解析为绝对路径，如"/foo/bar"。

  **2.**  **$route.params**   一个 key/value 对象，包含了 动态片段 和 全匹配片段，   如果没有路由参数，就是一个空对象。

  **3.**  **$route.query**   一个 key/value 对象，表示 URL 查询参数。   例如，对于路径 /foo?user=1，则有$route.query.user == 1，   如果没有查询参数，则是个空对象。

  **4.**  **$route.hash**   当前路由的hash值 (不带#) ，如果没有 hash 值，则为空字符串。锚点*

  **5.**  **$route.fullPath**   完成解析后的 URL，包含查询参数和hash的完整路径。

  **6.**  **$route.matched**   数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。

  **7.**  **$route.name**  当前路径名字

  **8.**  **$route.meta** 路由元信息

  导航钩子的参数：

  router.beforeEach((to,from, next)=>{//to 和from都是 路由信息对象,后面使用路由的钩子函数就容易理解了})

## **$router对象**

$router对象是全局路由的实例，是router构造方法的实例

**路由实例方法：**

#### **1、push**

  1.字符串this.$router.push('home')

2. 对象this.$router.push({path:'home'})

3. 命名的路由this.$router.push({name:'user',params:{userId:123}}) 

  4.带查询参数，变成 /register?plan=123this.$router.push({path:'register',query:{plan:'123'}})

  push方法其实和`<router-link :to="...">`是等同的。

  注意：push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。

使用name，必须使用params，刷新页面，参数会丢失。而使用path，必须使用query，刷新页面不会丢失参数。

#### **2、go**

   页面路由跳转 

   前进或者后退this.$router.go(-1) // 后退

#### 3、replace

  push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，

  不会向 history 栈添加一个新的记录

#### 4.一般使用replace来做404页面

  this.$router.replace('/')

  配置路由时path有时候会加 '/' 有时候不加,以'/'开头的会被当作根路径，就不会一直嵌套之前的路径。

$router对象是全局路由的实例，是router构造方法的实例。



**Vue Router** 是 **Vue** 官方提供的 **路由管理器** ，可以进行 **路由跳转**，以及 **页面之间跳转时传值**，以及 **路由拦截** 等等操作



这里的路由并不是指我们平时所说的硬件路由器，**这里的路由就是SPA（单页应用）的路径管理器**。再通俗的说，vue-router就是[WebApp](https://coding.imooc.com/?c=webapp)的链接路径管理系统。
vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。**路由模块的本质 就是建立起url和页面之间的映射关系**。

至于我们为啥不能用a标签，这是因为用Vue做的都是单页应用（**当你的项目准备打包时，运行`npm run build`时，就会生成dist文件夹，这里面只有静态资源和一个index.html页面**），所以你写的`<a></a>`标签是不起作用的，你必须使用vue-router来进行管理。


实现原理

SPA(single page application):单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。**单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面**;vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。

#### 1、Hash模式：

**vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。** hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说**Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据**

vue Router的跳转问题，就是如果引入了vue-router，例如给一个这样的链接https:www.app/index.html，但是真正在浏览器中输入后执行的时候就变成了 https:www.app/index.html#/

引入了vue-router，引入vue-router后，再点开链接的时候，会自动加上#/，因为vue-router是根据锚点来进行定位的,也就是根据hash值来跳转的（单页面应用）。只要程序中引入了vue-router，跳转的时候会自动加上#/的

#### 2、History模式：

由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入"mode: 'history'",这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main.js文件中</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

当你使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，比较好看！
不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。
所以呢，**你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const routes &#x3D; [ </span><br><span class="line"> &#123;path: &quot;&#x2F;&quot;, name: &quot;homeLink&quot;, component:Home&#125;</span><br><span class="line"> &#123;path: &quot;&#x2F;register&quot;, name: &quot;registerLink&quot;, component: Register&#125;,</span><br><span class="line"> &#123;path: &quot;&#x2F;login&quot;, name: &quot;loginLink&quot;, component: Login&#125;,</span><br><span class="line"> &#123;path: &quot;*&quot;, redirect: &quot;&#x2F;&quot;&#125;]</span><br></pre></td></tr></table></figure>

此处就设置如果URL输入错误或者是URL 匹配不到任何静态资源，就自动跳到到Home页面

#### 3、使用路由模块来实现页面跳转的方式

方式1：直接修改地址栏

方式2：this.$router.push(‘路由地址’)

方式3：`<router-link to="路由地址"></router-link>`










一、验证用户身份

大部分项目，除了登录页、重置密码页、用户协议页以外，页面都需要验证用户身份进行访问。使用 Vue Router 可以配合后端进行双重验证

给需要验证的路由对象添加 meta 字段，里面自定义一个代表验证的字段

（登录）验证身份方法：

1、给需要验证的路由对象添加 meta 字段，里面自定义一个代表验证的字段：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">	  name:&#39;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#39;bar&#39;,</span><br><span class="line">          component: Bar,</span><br><span class="line">          meta: &#123; </span><br><span class="line">              requiresAuth: true &#x2F;&#x2F; 添加该字段，表示进入这个路由是需要登录的</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

2、在全局导航钩子里验证 requiresAuth 字段：

注意事项：

- 使用 beforeEach 在路由变化前验证。验证原理是在跳转前，访问目标路由对象的 requiresAuth 字段判断是否需要验证用户身份，如为是，检测是否有保存用户信息（即用户登录成功后前端保存的信息，例如 token）
- 每个路由都有一个 $route.matched 数组，包含当前路由的父级路由对象和当前路由对象，在组件中可以通过 this.$route.matched 访问
- beforeEach 的 to 参数即目标路由对象 $route，to.matched 即是它的路由数组
- 因此，使用 some 方法，只要路由数组里的任意路由对象需要验证身份，即进行验证
- 验证成功跳转正确页面；失败则跳到登录页，将目标地址附在 url 的 query 里，登录成功就跳转到目标地址

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  if (to.matched.some(record &#x3D;&gt; record.meta.requiresAuth)) &#123;</span><br><span class="line">    if (!auth.loggedIn()) &#123;  &#x2F;&#x2F; 没登录</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: &#39;&#x2F;login&#39;,</span><br><span class="line">        query: &#123; redirect: to.fullPath &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()  &#x2F;&#x2F; 确保一定要调用 next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next() &#x2F;&#x2F; 确保一定要调用 next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

3、拦截 http 请求，验证用户身份

为了防止本地保存的 token 过期，需要拦截 http 请求，为每次请求头加上 token ，然后拦截 http 响应，根据响应内容判断是否需要跳回登录页面重新登录。使用 axios 的方法如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; http request 拦截器</span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    config &#x3D;&gt; &#123;</span><br><span class="line">        if (auth.loggedIn()) &#123; &#x2F;&#x2F; 判断是否存在token，如果存在的话，则每个http header都加上token</span><br><span class="line">            config.headers.Authorization &#x3D; &#96;token $&#123;auth.loggedIn()&#125;&#96;;</span><br><span class="line">        &#125;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;,</span><br><span class="line">    err &#x3D;&gt; &#123;</span><br><span class="line">        return Promise.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http response 拦截器</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    response &#x3D;&gt; &#123;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;,</span><br><span class="line">    error &#x3D;&gt; &#123;</span><br><span class="line">        if (error.response) &#123;</span><br><span class="line">            switch (error.response.status) &#123;</span><br><span class="line">                case 401:</span><br><span class="line">                    &#x2F;&#x2F; Unauthorized</span><br><span class="line">                    &#x2F;&#x2F; 返回 401 清除token信息并跳转到登录页面</span><br><span class="line">                    auth.clear();</span><br><span class="line">                    router.replace(&#123;</span><br><span class="line">                        path: &#39;login&#39;,</span><br><span class="line">                        query: &#123;</span><br><span class="line">                            redirect: router.currentRoute.fullPath</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error.response.data) &#x2F;&#x2F; 返回接口返回的错误信息</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

二、定义用户权限能访问的页面

前端查看权限，也是配合后端进行某些页面的隐藏显示功能。一般应用于综合的办公系统，由 IT 部分配账号，不同部门的人只能看到自己负责的内容，例如行政部不会看到财务数据页面。

实现方法：

1. 与后端商定每个用户角色对应的 level 级别，以数值表示
2. 前端路由每个页面的 meta 对象添加 level 字段，值为数组，里面是有权限访问页面的 level 数值
3. 登录成功，后台返回用户 token 的同时，返回其所属的 level 字段
4. 组件代码比较目标页面的 level 与用户 level，只显示包含在目标 level 数组里的页面
5. 全局导航钩子 beforeEach 里比较目标页面的 level 与用户 level，包含在目标 level 数组里则正确跳转，反之取消跳转并提示权限不足

> 上面第5步是为了防止用户直接在浏览器输入目标地址

三、其他内容控制

可以控制显示路由固定的搭配，例如某个路由地址的 title 是固定的字符串、固定的欢迎语、固定的 favicon 等。在组件里通过 this.$route.meta.xxx 访问。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#39;bar&#39;,</span><br><span class="line">          component: Bar,</span><br><span class="line">          meta: &#123; </span><br><span class="line">              title: &#39;标题&#39;,</span><br><span class="line">              message: &#39;欢迎您&#39;,</span><br><span class="line">              requiresAuth: true &#x2F;&#x2F; 添加该字段，表示进入这个路由是需要登录的</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



动态路由匹配是用于把某种模式匹配到的所有路由，全都映射到同个组件。通过给路由路径一个变量，即变成动态路由，把变化的内容赋值给变量即可。

例如文章详情页是一个组件，只有一个路由，从文章列表页点进来，变化的只是文章 id 而已。将其赋予给设定的变量，然后通过在组件里 watch $route 或者使用 beforeRouteUpdate 导航守卫监测路由变化，传递新的文章 id 获取文章详情即可。在组件里，可以通过`this.$route.params.xx`获取当前文章 id。

一个路由地址可以设置多个变量，适合有分叉情况的内容。例如 path: '/params/:foo/:bar'

> 从文章列表页点进来即传递路由变量，有三种方法：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）&lt;router-link to&#x3D;&quot;&#x2F;params&#x2F;list&#x2F;1&quot;&gt;跳转到 &#x2F;params&#x2F;list&#x2F;1&lt;&#x2F;router-link&gt;&#96;</span><br><span class="line">（2）this.$router.push(&#123; name: &#39;articles&#39;, params: &#123; foo: &#39;list&#39;, bar: 1 &#125; &#125;)&#96;</span><br><span class="line">（3）this.$router.push(&#123; path: &#39;&#x2F;params&#x2F;list&#x2F;1&#39; &#125;) &#x2F;&#x2F; path 不能与 params 同时使用</span><br></pre></td></tr></table></figure>



高级匹配模式

这里主要研究的是动态路由匹配的高级匹配模式，以达到合并差异不大的路由、减少路由数量的目的。

高级匹配即结合简单的正则匹配方法，给予路由更多的限制和操作空间。

1、可选路由参数

路由参数可选，添加与否都对应同一个组件。可以在组件里使用 v-if / v-show 结合 $route.params.xx 展现不同的内容

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a param can be made optional by adding &quot;?&quot;</span><br><span class="line">&#123; path: &#39;&#x2F;optional-params&#x2F;:foo?&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个链接都对应同个组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-params&quot;&gt;&#x2F;optional-params&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-params&#x2F;foo&quot;&gt;&#x2F;optional-params&#x2F;foo&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

2、精确匹配参数

只有参数通过正则匹配，完全符合格式，才能会跳转。例如只有参数是数字/手机号才允许跳转。适用于对第三方不规范格式的数据进行筛选。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a param can be followed by a regex pattern in parens</span><br><span class="line">&#x2F;&#x2F; this route will only be matched if :id is all numbers</span><br><span class="line">&#123; path: &#39;&#x2F;params-with-regex&#x2F;:id(\\d+)&#39; &#125;</span><br><span class="line">&#x2F;&#x2F; 只匹配数字</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;params-with-regex&#x2F;123&quot;&gt;&#x2F;params-with-regex&#x2F;123&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只匹配手机号</span><br><span class="line">&#123; path: &#39;&#x2F;params-with-regex&#x2F;:id(^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$)&#39; &#125;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;params-with-regex&#x2F;13800138000&quot;&gt;&#x2F;params-with-regex&#x2F;13800138000&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

3、匹配任意参数

不对参数格式、数量进行限制，任意参数都可。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; asterisk can match anything</span><br><span class="line">&#123; path: &#39;&#x2F;asterisk&#x2F;*&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个都是同一组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;asterisk&#x2F;foo&quot;&gt;&#x2F;asterisk&#x2F;foo&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;asterisk&#x2F;foo&#x2F;bar&quot;&gt;&#x2F;asterisk&#x2F;foo&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>

4、部分可选参数

结合可选路由参数与多路由参数，其中一部分参数可选。适用于分叉情况下不确定参数数量的情况。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; make part of the path optional by wrapping with parens and add &quot;?&quot;</span><br><span class="line">&#123; path: &#39;&#x2F;optional-group&#x2F;(foo&#x2F;)?bar&#39; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这两个都是同一组件</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-group&#x2F;bar&quot;&gt;&#x2F;optional-group&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to&#x3D;&quot;&#x2F;optional-group&#x2F;foo&#x2F;bar&quot;&gt;&#x2F;optional-group&#x2F;foo&#x2F;bar&lt;&#x2F;router-link&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>





### 路由的跳转

1、router-link （声明式路由）

 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 不带参数</span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;&#125;&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;</span>&gt;</span> //name,path都行, 建议用name  </span><br><span class="line">   // 注意：router-link中链接如果是&#x27;/&#x27;开始就是从根路由开始，如果开始不带&#x27;/&#x27;，则从当前路由开始。</span><br><span class="line"></span><br><span class="line">2.带参数</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;, params: &#123;id:1&#125;&#125;&quot;</span>&gt;</span>  </span><br><span class="line">// params传参数 (类似post)</span><br><span class="line">// 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot; </span><br><span class="line">// 不配置path ,第一次可请求,刷新页面id会消失</span><br><span class="line">// 配置path,刷新页面id会保留</span><br><span class="line"></span><br><span class="line">// html 取参  $route.params.id</span><br><span class="line">// script 取参  this.$route.params.id</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;, query: &#123;id:1&#125;&#125;&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>

  

   2、router.push(编程式路由)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">router.push(&#39;home&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象</span><br><span class="line">router.push(&#123; path: &#39;home&#39; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命名的路由</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 带查询参数，变成 &#x2F;register?plan&#x3D;private</span><br><span class="line">router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</span><br></pre></td></tr></table></figure>

注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userId &#x3D; &#39;123&#39;</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">router.push(&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user</span><br></pre></td></tr></table></figure>

3、this.$router.push() (函数里面调用)

 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.  不带参数</span><br><span class="line"></span><br><span class="line">this.$router.push(&#39;&#x2F;home&#39;)</span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;&#125;)</span><br><span class="line">this.$router.push(&#123;path:&#39;&#x2F;home&#39;&#125;)</span><br><span class="line"></span><br><span class="line">2. query传参 </span><br><span class="line"></span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;)</span><br><span class="line">this.$router.push(&#123;path:&#39;&#x2F;home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; html 取参  $route.query.id</span><br><span class="line">&#x2F;&#x2F; script 取参  this.$route.query.id</span><br><span class="line"></span><br><span class="line">3. params传参</span><br><span class="line"></span><br><span class="line">this.$router.push(&#123;name:&#39;home&#39;,params: &#123;id:&#39;1&#39;&#125;&#125;)  &#x2F;&#x2F; 只能用 name</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 路由配置 path: &quot;&#x2F;home&#x2F;:id&quot; 或者 path: &quot;&#x2F;home:id&quot; ,</span><br><span class="line">&#x2F;&#x2F; 不配置path ,第一次可请求,刷新页面id会消失</span><br><span class="line">&#x2F;&#x2F; 配置path,刷新页面id会保留</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; html 取参  $route.params.id</span><br><span class="line">&#x2F;&#x2F; script 取参  this.$route.params.id</span><br><span class="line"></span><br><span class="line">4. query和params区别</span><br><span class="line">   query类似 get, 跳转之后页面 url后面会拼接参数,类似?id&#x3D;1, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在</span><br><span class="line"></span><br><span class="line">params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失</span><br></pre></td></tr></table></figure>

   

4. this.$router.replace() (用法同上,push)

5. this.$router.go(n) ()


  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$router.go(n)</span><br><span class="line">   向前或者向后跳转n个页面，n可为正整数或负整数</span><br></pre></td></tr></table></figure>

  

  ps : 区别

  this.$router.push
  跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面
  this.$router.replace
  跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)

  this.$router.go(n)
  向前或者向后跳转n个页面，n可为正整数或负整数

  

注意：获取路由上面的参数，用的是$route，后面没有r
params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。
params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。
params、query不设置也可以传参，但是params不设置的时候，刷新页面或者返回参数会丢失，

两者都可以传递参数，区别是什么？
query 传参配置的是path，而params传参配置的是name，在params中配置path无效
query在路由配置不需要设置参数，而params必须设置
query传递的参数会显示在地址栏中
params传参刷新会无效，但是query会保存传递过来的值，刷新不变



**Vue router的query对象里的值的问题**

在使用 $router.push() 时，如果使用了query，则可以在跳转后从query中获取到对应的参数。如果传的是字符串自然没问题，但是如果传的其他类型的数据，在跳转之后是正常的，而跳转之后再刷新一遍页面的话，query里面的属性的值都会变成字符串。例如：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123; name:&#39;product&#39;, query: &#123;canSee: false&#125; &#125;);</span><br></pre></td></tr></table></figure>

　　最初跳转之后，this.$route.query.canSee打印的值是Boolean类型的。然后刷新一下，值就变成了String类型了。个人猜测是因为刷新后query的值是直接从页面URL中取的，而在页面URL上的参数的类型只能是字符串类型。

**解决方法**：

　　1. 在传值之前把要传的参数单独放到一个对象里，在放到query里面，然后进行JSON.stringify()处理，到了目标页面后再进行JSON.parse()处理，还原对象。这种方法的好处是可以一次性处理多个参数，而且适用度高，建议使用这种方法。

　　2. 传值前不做处理，到了目标页面后再单独对原本为非字符串的数据进行JSON.parse()处理。缺点是字符串类型的数据不能如此处理，要确保该数据不是字符串类型的。局限性大，不推荐适用。



### vue项目中跳转到外部链接方法

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;goPage(&#x27;http://www.chao99.top&#x27;)&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    goPage (url) &#123;</span><br><span class="line">            window.location.href = url</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

如果用.push的路由跳转，会在路径外面再加一个基本的url导致出错，例如本地项目：会在外部链接前面加上了http://localhost:8080/#/

一定要注意, 外部链接要加上 http:// , 不然跳转还是当前域名下



## VUE的图片路径

一般都是通过相对路径取到图片然后加载

官方文档没有存放静态的asset 文件了 ,静态现在存放在public 的里面. 但是在public里面去创建一个img 的文件,去放置图片,依然不可以. 

所以 三种办法里面 只有require 使用vuecli3 ,

1、在模板中直接引入图片资源（这种一般是@ 或者./ 去引入）

2、将图片资源放在static文件夹下

3、图片资源在assets文件夹下，data中必须用require加载，否则会当成字符串来处理
(我自己目前就是放在assets 里面. 因为是本地上传的 在做假数据的时候准备做一个预览,或者说以后的默认图片就是它了)
第二种，只要给图片放在static文件夹下即可：原因如下

这里在使用vuecli脚手脚构建工具，目录下会生成一个static目录，表示的是静态目录，推荐大家将img 存放在这个目录下，那么在webpack编译以后，依旧是可以获取到这个目录下的路径，这样就解决了路径不符而导致图片加载不出来的问题！当然项目中用的一般都是绝对路径，少数图片的话，这种方式挺好
但是 重点: vuecli3 没有static 啊!!!



# VUE的模板语法

Vue 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。

Vue 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。

结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上



### 插值

#### 文本

数据绑定最常见的形式就是使用 `{ {...} }`（双大括号）的文本插值：

##### 文本插值

`<div id="app">   <p></p> </div>`

`{ {...} }` 标签的内容将会被替代为对应组件实例中 **message** 属性的值，如果 **message** 属性的值发生了改变，`{ {...} }` 标签内容也会更新。

如果不想改变标签的内容，可以通过使用 **v-once** 指令执行一次性地插值，当数据改变时，插值处的内容不会更新。

`<span v-once>这个将不会改变: { { message } }</span>`

##### Html

使用 v-html 指令用于输出 html 代码：

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v-html 指令</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用双大括号的文本插值: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用 v-html 指令: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> RenderHtmlApp = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      rawHtml: &#x27;<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>这里会显示红色！<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(RenderHtmlApp).mount(<span class="string">&#x27;#example1&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

##### 属性

HTML 属性中的值应使用 v-bind 指令。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

对于布尔属性，常规值为 true 或 false，如果属性值为 null 或 undefined，则该属性不会显示出来。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-bind:disabled&#x3D;&quot;isButtonDisabled&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

以上代码中如果 isButtonDisabled 的值是 null 或 undefined，则 disabled 属性甚至不会被包含在渲染出来的 `<button> `元素中。

以下实例判断 use 的值，如果为 true 使用 class1 类的样式，否则不使用该类：

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v-bind 指令</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;r1&quot;</span>&gt;</span>修改颜色<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;use&quot;</span> <span class="attr">id</span>=<span class="string">&quot;r1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123;&#x27;class1&#x27;: use&#125;&quot;</span>&gt;</span></span><br><span class="line">    v-bind:class 指令</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      use: <span class="literal">false</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(app).mount(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

##### 表达式

Vue.js 都提供了完全的 JavaScript 表达式支持。

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 表达式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;5+5&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span>菜鸟教程<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> HelloVueApp = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      ok: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;RUNOOB!!&#x27;</span>,</span></span><br><span class="line">      id: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(HelloVueApp).mount(<span class="string">&#x27;#hello-vue&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  这是语句，不是表达式：--&gt;</span><br><span class="line">&#123;&#123; var a &#x3D; 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>

### 指令

指令是带有 v- 前缀的特殊属性。

指令用于在表达式的值改变时，将某些行为应用到 DOM 上。如下例子：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-if&#x3D;&quot;seen&quot;&gt;现在你看到我了&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      seen: true  &#x2F;* 改为false，信息就无法显示 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

这里， v-if 指令将根据表达式 seen 的值( true 或 false )来决定是否插入 p 元素。

另外还有其它很多指令，每个都有特殊的功能。例如，v-for 指令可以绑定数组的数据来渲染一个项目列表：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;ol&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;site in sites&quot;&gt;</span><br><span class="line">      &#123;&#123; site.text &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      sites: [</span><br><span class="line">        &#123; text: &#39;Google&#39; &#125;,</span><br><span class="line">        &#123; text: &#39;Runoob&#39; &#125;,</span><br><span class="line">        &#123; text: &#39;Taobao&#39; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

##### 参数

参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;菜鸟教程&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const HelloVueApp &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      url: &#39;https:&#x2F;&#x2F;www.runoob.com&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(HelloVueApp).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。

另一个例子是 v-on 指令，它用于监听 DOM 事件：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a @[event]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

在这里参数是监听的事件名。

##### 修饰符

修饰符是以半角句号 **.** 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，**.prevent** 修饰符告诉 **v-on** 指令对于触发的事件调用 **event.preventDefault()**：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

### 用户输入

在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">双向数据绑定</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Runoob!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

**v-model** 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。

按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。

以下实例在用户点击按钮后对字符串进行反转操作：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">字符串反转</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;&#x2F;title&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue@next&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;reverseMessage&quot;&gt;反转字符串&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">const app &#x3D; &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Runoob!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage() &#123;</span><br><span class="line">      this.message &#x3D; this.message</span><br><span class="line">        .split(&#39;&#39;)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.createApp(app).mount(&#39;#app&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

### 缩写

#### v-bind 缩写

Vue.js 为两个最为常用的指令提供了特别的缩写：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

#### v-on 缩写

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

# VUE的条件语句



# VUE的循环语句



# VUE的组件



# VUE的计算属性



# VUE的监听属性



# VUE的样式绑定



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;vue根据绑定值判断应用具体的哪个css样式</span><br><span class="line">&lt;div :class&#x3D;&quot;from?&#39;loginShop&#39;:&#39;loginOperating&#39;&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



# VUE的事件处理

### VUE的方法

方法名: async function () {}

async 方法名() {}



# VUE中用到的一些关键字

### let、var和const

ECMAScript是一个国际通过的标准化脚本语言。JavaScript由ECMAScript和DOM、BOM三者组成。可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。

1. var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。可以修改，如果不初始化会输出undefined，不会报错
2. let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不可在声明之前调用，必须先定义再使用，否则会报错。不能定义同名变量。
3. const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。

**let和const属于局部变量，不会出现变量提升的情况，全局定义的let和const变量，不属于顶层变量，不属于window的属性**。let和const不允许重复声明，let和const不会绑定全局作用域

变量提升：可以在变量定义前使用定义过的变量。

暂时性死区（TDZ）：在运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。常见于：let、const、import、class、typeof等

**let和const定义的变量都会被提升，但是不会被初始化，不能被引用**



### fullPath和path

- $route.fullPath

  - type: `string`
    The full resolved URL including query and hash.

- $route.path

  - type: `string`
    A string that equals the path of the current route, always resolved as an absolute path. e.g. “/foo/bar”.

fullPath能缓存路由跳转后面携带的参数，刷新后依旧存在， 在PC端能起作用

而 path则不能缓存路由跳转后面携带的参数，所以path  能在`只有两层数据结构的`移动端起作用
   原因：

一般，移动端App 只能往里面走，表面和切换的页面是第一层， 点击功能按钮进去的是第二层。
这种层级的关系其实 是具有跳转作用，所以在第一层获取的数据，与第二层来回切换没问题。但是你第二层到第三层一来回切换，路由跳转携带的参数就丢失了。

fullPath匹配路由，path匹配路径。

例如：

路由是：`/path/one`
真正路径是：`/path/true`

那么此时path为`/path/true`，而fullPath为`/path/one`



### this和that

在Vue中this始终指向Vue，但axios中this为undefined

![这里写图片描述](https://img-blog.csdn.net/20171102210352732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzgyMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

若需要赋值给变量用以渲染数据，可以通过=>函数，这时this为Vue

![这里写图片描述](https://img-blog.csdn.net/20171102210527538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAzNzgyMjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

或者可以直接通过： 
let that = this 
将this保存在that中，再在函数中使用that均可 



个人理解：一般情况下，this就是此vue的页面，可以调用此页面的函数。但是涉及到异步axios时，this没有指向了。需要（）=>{}，在{}里this才会指代vue。

如果不使用（）=>{}方法，可以进行双向绑定：let that = this  ，将this保存在that中，再在函数中使用that均就可以了



async和await分别表示异步和等待，语义更加明确



解决异步调用：从最早的回调函数，到 Promise 对象，再到 Generator 函数，再到async





### return

return不论是什么，都是直接返回，即使是语句或者函数也不会执行的！是函数就返回该函数！

下面从一个例子来加深对return用法的理解：

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(‘xxxx’)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; <span class="keyword">return</span> res.data.result.info &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在axios和ajax中经常会用到return，从上面的代码可以看到有两个return，每个return的作用都需要理解：

第一个return后面跟的是axios配置，这个return就是将整个axios返回出来；

第二个return是在axios请求成功后将响应数据返回出来，即第二个return就是将axios异步请求的数据返回出来。



函数中有ajax和axios调用的有异步和同步，是异步的话里面如果有return，在函数外层（函数是指getTable()）调用的时候会取不到数据，除非换成同步。如果想异步取到数据，就需要在函数外层也加个return，相当于把ajax或者axios 整个配置返回出来，返回出来的数据格式是[object,promise]，所以函数执行获得的数据格式就是[object,promise]，然后使用.then()的形式将里面返回的数据拿出来!

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> getTable().then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="built_in">this</span>.tableData = res&#125;) <span class="comment">//此出先调用getTable()拿到axios的数据，然后在.then()出来结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

此段代码的目的是将axios异步请求的结果返回出来，因为是异步所以不能直接在axios里return数据，所以需要在axios外层也加个return，这样就可以拿到了。









### set：this.$set

由于JavaScript的限制，Vue不能检测以下变动的数组,页面不会刷新：

1.当你利用索引值直接设置一个项时。`vm.items[indexOfItem]=newValue`

2.当你修改数组的长度时。`vm.items.length=newLength`

使用Vue.set、vm.$set()或者数组的splice方法。使数值改变后，页面进行刷新后的效果展示

注：$set()方法调用时，页面会全部更新一遍



# VUE定义全局变量

在项目中，经常会复用一些变量和函数，比如用户的登录token，用户信息等。这时需要将它们设为全局，全局变量和全局函数之间有一些相通之处。

## 定义全局变量

原理：使用模块（.js或.vue文件）来管理全局变量，最后使用`export`暴露出去 （最好导出的格式为对象，方便在其他地方调用），当其它地方需要使用时，用`import`导入该模块

1、使用全局变量专用模块，挂载到main.js文件上面

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">全局变量模块Global.vue定义如下：</span><br><span class="line"><span class="keyword">const</span> token=<span class="string">&#x27;12345678&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> userStatus=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    token, <span class="comment">// 用户token身份</span></span><br><span class="line">    userStatus <span class="comment">// 用户登录状态</span></span><br><span class="line">&#125;</span><br><span class="line">模块里的变量用<span class="keyword">export</span>暴露出去，当其它地方需要使用时，引入模块便可。</span><br><span class="line"></span><br><span class="line">使用全局变量：</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">global</span> <span class="keyword">from</span> <span class="string">&#x27;../../components/Global&#x27;</span><span class="comment">//引用模块进来</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">         token:<span class="built_in">global</span>.token,<span class="comment">//将全局变量赋值到data里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2、全局变量模块挂载到Vue.prototype上

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Global.vue文件同上，在项目入口的main.js里配置：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">global</span> <span class="keyword">from</span> <span class="string">&#x27;../../components/Global&#x27;</span></span><br><span class="line">Vue.prototype.GLOBAL = <span class="built_in">global</span></span><br><span class="line">挂载之后，在需要引用全局变量的模块处，不需再导入全局变量模块，而是直接用<span class="built_in">this</span>就可以引用了，如下:</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">     token: <span class="built_in">this</span>.GLOBAL.token,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

方法一跟方法二的主要区别是，方法二全局只需要导入一次就可以，简单方便。

3、使用vuex定义全局变量

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态。因此可以存放着全局量。</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js文件里定义vuex</span></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// state.js里面存放全局变量，并且暴露出去</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  token：<span class="string">&#x27;12345678&#x27;</span>,</span><br><span class="line">  language: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> state</span><br><span class="line"></span><br><span class="line">使用的时候，在需要引用全局变量的模块处直接使用<span class="built_in">this</span>.$store调用</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">getInternation</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$store.state.language === <span class="string">&#x27;en&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.internation = <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.$store.state.language === <span class="string">&#x27;zh_CN&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.internation = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

因为Vuex有点繁琐，有点杀鸡用牛刀的感觉。因此认为并没有必要使用它。

## 定义全局函数

原理：在main.js里面通过Vue.prototype将函数挂载到Vue实例上面，通过this.函数名，来运行函数。

1、在main.js文件直接定义方法

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">简单的函数可以直接写在main.js文件里定义。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将方法挂载到vue原型上</span></span><br><span class="line">Vue.prototype.changeData = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;执行成功&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用的时候组件里直接调用。</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接通过this运行函数，这里this是vue实例对象</span></span><br><span class="line"><span class="built_in">this</span>.changeData();</span><br></pre></td></tr></table></figure>

2、使用全局函数专用模块，挂载到main.js上面

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">base.js文件，文件位置可以放在跟main.js同一级，方便引用（这点可以依据个人习惯决定）。</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">    Vue.prototype.changeData = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;执行成功&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main.js引入并使用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base <span class="keyword">from</span> <span class="string">&#x27;./base&#x27;</span></span><br><span class="line">Vue.use(base);</span><br><span class="line">所有的组件里就可以调用该函数。</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.changeData();</span><br></pre></td></tr></table></figure>



# VUE的生命周期

生命周期：

​    beforecreate : 一般使用场景是在加 loading事件 的时候
​    created ：处于loading结束后，还做一些初始化，实现函数自执行（data数据已经初始化，但是DOM结构渲染完成，组件没有加载）
​    beforemount：处于组件创建完成，但未开始执行操作
​    mounted (安装)：处于发起后端请求，获取数据，配合路由钩子执行操作（DOM渲染完成，组件挂载完成 ）
​    beforeupdate、updated：处于数据更新的前后
​    beforeDestroy：当前组件还在的时候，想删除组件
​    destroyed ：当前组件已被销毁，清空相关内容

![clipboard.png](8.6.VUE/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVjlSR1A_dz0xMjAwJmg9MzAzOQ)

created 与 mounted 的区别

created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

mounted 与 methods 的区别

mounted 是生命周期方法之一，会在对应生命周期时执行。

methods 是Vue实例对象上绑定的方法，供当前Vue组件作用域内使用，未调用不会执行，只执行逻辑，返回值可有可无。

computed 与 watched 的区别

computed 是计算属性，也可以理解为一个方法。其中计算的结果如果不发生改变就不会触发，且必须返回一个值并在DOM中绑定的才能取得值。他可以自动获取数据的改变。

watched 属性是手动定义的所需监听的值，不同的数据可以在其中多次定义监听值，这时会消耗一定性能，他并不能像computed那样自动改变。



activated 生命周期在keep-alive 组件激活时调用（在挂载后和更新前被调用的）。被`<keep-alive>`包裹的组件其会被缓存

服务器端渲染期间不调用该生命周期

通常和deactivated周期一起使用

`<keep-alive>`包裹动态组件的时候，会缓存不活动的组件实例，而不是摧毁他们。其是一个抽象的组件，自身不会渲染一个DOM元素，也不会出现在父组件链中。

activated()函数就是一个页面激活后的钩子函数，一进入页面就触发；

所以当我们运用了组件缓存时，如果想每次切换都发送一次请求的话，需要把请求函数写在activated中，而写在created或mounted中其只会在首次加载该组件的时候起作用

按自己的话说：actived相当于是一个缓存，当为false的时候，相当于没有actived，不会起任何作用。当为true时，第一次加载时会执行created，mounted，actived函数，当之后再执行的时候，不会执行created，mounted，只会执行actived

keep-alive组件除了actived，还有deactived函数钩子：

actived是keep-alive组件激活时使用

deactived是keep-alive组件停用时调用

使用：

1.在router中设置需要缓存的组件

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meta: &#123;</span><br><span class="line">        keepAlive : true </span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

2.`<keep-alive>`包裹需要缓存组件

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--app.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;!--需要缓存组件--&gt;</span><br><span class="line">        &lt;keep-alive&gt;</span><br><span class="line">            &lt;!--router-view组件是一个 functional 组件，渲染路径匹配到的视图组件--&gt;</span><br><span class="line">          &lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">        &lt;&#x2F;keep-alive&gt;</span><br><span class="line">        &lt;!--不需要缓存组件--&gt;</span><br><span class="line">        &lt;router-view v-if&#x3D;&quot;!$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">        &lt;moduleFooter&gt;&lt;&#x2F;moduleFooter&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

3.vue页面使用：第一次进入，钩子的触发顺序created-> mounted-> activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated
4.还可以动态控制是否缓存组件，代码如下：

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 设置下一个路由的 meta</span></span><br><span class="line">  to.meta.keepAlive = <span class="literal">false</span>; <span class="comment">// 不缓存，即刷新</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



# `==`和`===`的区别

1`==`'1';这个等式是成立的；
1`===`'1';这个等式是不成立的。
`==`只判断数值，`===`既判断数值，也判断类型。



# 对象的拷贝

Object.assign()对象的拷贝

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span><br><span class="line">Object.assign(target, ...sources)    【target：目标对象】，【souce：源对象（可多个）】</span><br><span class="line">举个栗子：</span><br><span class="line">const object1 &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 &#x3D; Object.assign(&#123;c: 4, d: 5&#125;, object1);</span><br><span class="line"></span><br><span class="line">console.log(object2.c, object2.d);</span><br><span class="line">console.log(object1)  &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(object2)  &#x2F;&#x2F; &#123; c: 3, d: 5, a: 1, b: 2 &#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性</span><br><span class="line">2.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标</span><br><span class="line">对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如</span><br><span class="line">果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到</span><br><span class="line">原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</span><br></pre></td></tr></table></figure>

Object.assign()对象的深拷贝

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。</span><br><span class="line">let obj1 &#x3D; &#123; a: 0 , b: &#123; c: 0&#125;&#125;; </span><br><span class="line">let obj2 &#x3D; Object.assign(&#123;&#125;, obj1); </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 0, b: &#123; c: 0&#125;&#125; </span><br><span class="line"></span><br><span class="line">obj1.a &#x3D; 1; </span><br><span class="line">console.log(JSON.stringify(obj1)); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 0&#125;&#125; </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 0, b: &#123; c: 0&#125;&#125; </span><br><span class="line"></span><br><span class="line">obj2.a &#x3D; 2; </span><br><span class="line">console.log(JSON.stringify(obj1)); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 0&#125;&#125; </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 2, b: &#123; c: 0&#125;&#125;</span><br><span class="line"> </span><br><span class="line">obj2.b.c &#x3D; 3; </span><br><span class="line">console.log(JSON.stringify(obj1)); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 3&#125;&#125; </span><br><span class="line">console.log(JSON.stringify(obj2)); &#x2F;&#x2F; &#123; a: 2, b: &#123; c: 3&#125;&#125; </span><br><span class="line">最后一次赋值的时候，b是值是对象的引用，只要修改任意一个，其他的也会受影响</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deep Clone （深拷贝）</span><br><span class="line">obj1 &#x3D; &#123; a: 0 , b: &#123; c: 0&#125;&#125;; </span><br><span class="line">let obj3 &#x3D; JSON.parse(JSON.stringify(obj1)); </span><br><span class="line">obj1.a &#x3D; 4; </span><br><span class="line">obj1.b.c &#x3D; 4; </span><br><span class="line">console.log(JSON.stringify(obj3)); &#x2F;&#x2F; &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br></pre></td></tr></table></figure>

对象的合并

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const o1 &#x3D; &#123; a: 1 &#125;;</span><br><span class="line">const o2 &#x3D; &#123; b: 2 &#125;;</span><br><span class="line">const o3 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Object.assign(o1, o2, o3);</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(o1);  &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span><br><span class="line">其实就是对象的拷贝，o1就是目标对象，后面的是源对象，后面的属性等会拷贝到目标对象</span><br></pre></td></tr></table></figure>

合并具有相同属性的对象

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const o1 &#x3D; &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class="line">const o2 &#x3D; &#123; b: 2, c: 2 &#125;;</span><br><span class="line">const o3 &#x3D; &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Object.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">1.属性被后续参数中具有相同属性的其他对象覆盖。</span><br><span class="line">2.目标对象的属性与源对象的属性相同，源的会覆盖目标的属性</span><br></pre></td></tr></table></figure>

继承属性和不可枚举属性是不能拷贝

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; Object.create(&#123;foo: 1&#125;, &#123; &#x2F;&#x2F; foo 是个继承属性。</span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: 2  &#x2F;&#x2F; bar 是个不可枚举属性。</span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        enumerable: true  &#x2F;&#x2F; baz 是个自身可枚举属性。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">创建对象时，如果没有设置enumerable的值，默认为false（不可枚举属性），设置为true，则为可枚举属性</span><br><span class="line">const copy &#x3D; Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); &#x2F;&#x2F; &#123; baz: 3 &#125;</span><br></pre></td></tr></table></figure>

原始类型会被包装为对象

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const v1 &#x3D; &quot;abc&quot;;</span><br><span class="line">const v2 &#x3D; true;</span><br><span class="line">const v3 &#x3D; 10;</span><br><span class="line">const v4 &#x3D; Symbol(&quot;foo&quot;)</span><br><span class="line"></span><br><span class="line">const obj &#x3D; Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); </span><br><span class="line">&#x2F;&#x2F; 原始类型会被包装，null 和 undefined 会被忽略。</span><br><span class="line">&#x2F;&#x2F; 注意，只有字符串的包装对象才可能有自身可枚举属性。</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure>

异常会打断后续拷贝任务

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    writable: false</span><br><span class="line">&#125;); &#x2F;&#x2F; target 的 foo 属性是个只读属性。</span><br><span class="line"></span><br><span class="line">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class="line">&#x2F;&#x2F; TypeError: &quot;foo&quot; is read-only</span><br><span class="line">&#x2F;&#x2F; 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class="line"></span><br><span class="line">console.log(target.bar);  &#x2F;&#x2F; 2，说明第一个源对象拷贝成功了。</span><br><span class="line">console.log(target.foo2); &#x2F;&#x2F; 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class="line">console.log(target.foo);  &#x2F;&#x2F; 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class="line">console.log(target.foo3); &#x2F;&#x2F; undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class="line">console.log(target.baz);  &#x2F;&#x2F; undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure>



# rules方法

用于前端校验数据，校验表单，可以用rules模块





# 关于VUE的data里的数据问题

Vue 不允许在已经创建的实例上动态添加新的根级响应式属性。也就是说创建过后，data中不允许添加根数据

## 1. 对对象处理

- Vue可以检测到对象属性的修改，不能检测到对象属性的添加和删除，也就是说这种方式处理后，vue不能检察到数据变化，不能进行渲染更新，Vue可以使用Vue.set 和 Vue.delete实现

1. **Vue.set**
   Vue.set 方法用于设置对象的属性，它可以解决 Vue 无法检测添加属性的限制，语法格式如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set( target, key, value )</span><br></pre></td></tr></table></figure>

1. **Vue.delete**
   Vue.delete 用于删除动态添加的属性 语法格式：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.delete( target, key )</span><br></pre></td></tr></table></figure>

## 2. 对数组的处理

- vue中的被包装的观察数组能够触发视图更新
- 有push(),pop(),shift(),unshift(),splice(),sort(),reverse()
- 不能检测到下面数组变化：
  1）直接用索引设置属性，如 vm.item[0] = { }
  2）修改数组长度，如vm.items.length = 0
- 用$set
  Vue 包含一组观察数组的变异方法，它们将会触发视图更新，包含以下方法：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">push() 接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度</span><br><span class="line">pop() 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项</span><br><span class="line">shift() 移除数组中的第一个项并返回该项，同时数组的长度减1</span><br><span class="line">unshift() 在数组前端添加任意个项并返回新数组长度</span><br><span class="line">splice() 删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员</span><br><span class="line">sort() 调用每个数组项的toString()方法，然后比较得到的字符串排序，返回经过排序之后的数组</span><br><span class="line">reverse() 用于反转数组的顺序，返回经过排序之后的数组</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123;message: &#39;Foo&#39; &#125;,</span><br><span class="line">      &#123;message: &#39;Bar&#39; &#125;,</span><br><span class="line">      &#123;message: &#39;Baz&#39; &#125;</span><br><span class="line">    ],</span><br><span class="line">    addValue:&#123;message:&#39;zyb&#39;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    push()&#123;</span><br><span class="line">      this.items.push(this.addValue)</span><br><span class="line">    &#125;,</span><br><span class="line">    pop()&#123;</span><br><span class="line">      this.items.pop()</span><br><span class="line">    &#125;,</span><br><span class="line">    shift()&#123;</span><br><span class="line">      this.items.shift()</span><br><span class="line">    &#125;,</span><br><span class="line">    unshift()&#123;</span><br><span class="line">      this.items.unshift(this.addValue)</span><br><span class="line">    &#125;,</span><br><span class="line">    splice()&#123;</span><br><span class="line">      this.items.splice(0,1)</span><br><span class="line">    &#125;,</span><br><span class="line">    sort()&#123;</span><br><span class="line">     this.items.sort()</span><br><span class="line">    &#125;,</span><br><span class="line">    reverse()&#123;</span><br><span class="line">      this.items.reverse()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

### 变异方法与非变异方法

变异方法(mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异(non-mutating method)方法，例如：map(), filter(), concat(), slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组。同样页面会重新渲染
以下两种方式都可以实现和vm.items[indexOfItem]=newValue相同的效果， 同时也将触发状态更新

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">concat() 先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</span><br><span class="line">slice() 基于当前数组中一个或多个项创建一个新数组，接受一个或两个参数，即要返回项的起始和结束位置，最后返回新数组。</span><br><span class="line">map() 对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组、</span><br><span class="line">filter() 对数组中的每一项运行给定函数，该函数会返回true的项组成的数组</span><br></pre></td></tr></table></figure>

## 3.注意

$set()方法更新时，页面会全部更新一遍，包括其他数据
某个数据更新，会更新渲染所有数据



# 刷新页面

1、this.$router.go(0)

这种方法页面会一瞬间的白屏，体验不是很好，虽然只是一行代码的事

2、location.reload()

这种也是一样，画面一闪，效果总不是很好

3、跳转空白页再跳回原页面

在需要页面刷新的地方写上：this.$router.push('/emptyPage')，跳转到一个空白页。在emptyPage.vue里beforeRouteEnter 钩子里控制页面跳转，从而达到刷新的效果

beforeRouteEnter (to, from, next) {
   next(vm => {
    vm.$router.replace(from.path)
   })
}。

这种画面虽不会一闪，但是能看见路由快速变化。

4、控制`<router-view>`的显示隐藏

默认`<router-view v-if="isRouterAlive" />`isRouterAlive肯定是true，在需要刷新的时候把这个值设为false，接着再重新设为true：

this.isRouterAlive = false
this.$nextTick(function () {
 this.isRouterAlive = true
})
这种方法从画面上是看不出破绽的。也可以搭配provide、inject使用。例如：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;router-view v-if&#x3D;&quot;isRouterAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"> &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">  name: &#39;app&#39;,</span><br><span class="line">  provide()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      reload:this.reload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      isRouterAlive:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    reload()&#123;</span><br><span class="line">      this.isRouterAlive &#x3D;false;</span><br><span class="line">      this.$nextTick(function()&#123;</span><br><span class="line">        this.isRouterAlive&#x3D;true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>


然后在需要刷新的页面引入依赖：inject: ['reload'],

在需要执行的地方直接调用方法即可：this.reload()。

我的业务需求是在home里，页面右上角，在我的里面点击修改个人资料成功后，页面1就要刷新一下，如果是在app里面搭配provide、inject这样用的话，会出现一个问题，就是所有的弹窗以及menu部分就都不见了。还没有找到为什么，，

后来发现，我的需求不通过刷新页面也可以解决，就是利用VUE组件通信，监听事件发生，然后重新调一下获取数据的接口就行。

也就是说：

1、给Vue的原型上添加一个bus属性

main.js：Vue.prototype.$bus = new Vue()

2、home页面进行修改个人资料操作时触发事件，

home.vue： changeProfile （） {this.$bus.$emit('change')}

3、页面1里监听如果执行了操作，就调取页面1需要重新加载的数据接口。

mounted () {
 this.$bus.$on('change', ()=> {
  this.doSomething()
 })
},
对于我的需求来说，页面刷新的第四种方法和利用组件通信都能解决我的问题，前者更简单后者更专业，也更强大




# VUE项目的运行

1.先加载依赖包：控制台直接输入` npm install`

也可以webstorm软件进去右下角会出现一个` npm install`，直接点击

install的意思是安装前端用到的依赖包，运行之后，会生成一个node_modules文件。

2.本地运行项目可以控制台执行命令: `npm run serve`代表执行本地运行项目，此时运行的端口号默认为8080，后端的接口配置为.env.development（测试环境）文件下的端口号。

也可以使用webstorm自带的工具：右上角选“+”，找到npm，在npm的edit界面：Command设置为`run`，Scripts为 ` serve`，（记得选当前文件的package.json）默认端口号为8080，也可以在Environment里自己写，port=XXXX（端口号自己随便设置）

![image-20210412195648588](C:\Users\swx\AppData\Roaming\Typora\typora-user-images\image-20210412195648588.png)

运行后出现localhost：8080一般就成功了。

3.打包时控制台输入命令：`npm run build`，代表打包，完成后会生成一个dist文件夹，就是打包后的项目，部署到服务器即发布成功。build会执行.env.production（生产环境）下的配置

dist文件夹：

css文件夹下的.css文件是项目要用到的css文件,当你做webpack打包的时候，会把所有的css样式打包到这里
css文件夹下的.css.map文件是一个Source map文件，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。目的是帮助我们调试被压缩过的css代码，只是方便我们开发的时候做调试使用。
js文件夹下的.js.map依然是Source map文件，方便我们开发时调试js代码使用。
app.js文件里放的是项目中各个页面的逻辑代码
manifest.js文件可以理解为webpack打包生成的一个配置文件，我们一般不需要关心它
vendor.js放的是各个页面各个组件公用的一些代码
index.html使我们前端代码入口的一个html文件




      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/8.6.VUE/" data-id="ckw61se0i007moswd8pw112z0" data-title="VUE" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/07/12.1.spring/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          spring
        
      </div>
    </a>
  
  
    <a href="/2021/04/07/2.1.Typora%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Typora使用快捷键</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>