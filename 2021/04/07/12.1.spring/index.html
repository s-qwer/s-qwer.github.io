<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>spring | swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题;而Spring Boot 是基于Spring的一套快">
<meta property="og:type" content="article">
<meta property="og:title" content="spring">
<meta property="og:url" content="https://s-qwer.github.io/2021/04/07/12.1.spring/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题;而Spring Boot 是基于Spring的一套快">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s-qwer.github.io/12.1.spring/image-20210922142605980.png">
<meta property="og:image" content="https://s-qwer.github.io/12.1.spring/20191018160134977.png">
<meta property="og:image" content="https://s-qwer.github.io/12.1.spring/20191018160429867.png">
<meta property="og:image" content="https://s-qwer.github.io/12.1.spring/20190606170140759.jpg">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/1097735/201703/1097735-20170302105956954-82157382.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/1097735/201703/1097735-20170302110921157-936863400.png">
<meta property="og:image" content="https://s-qwer.github.io/12.1.spring/20200822102819511.png">
<meta property="og:image" content="https://s-qwer.github.io/12.1.spring/20200822112024130.gif">
<meta property="article:published_time" content="2021-04-07T11:42:00.000Z">
<meta property="article:modified_time" content="2021-11-07T06:50:27.033Z">
<meta property="article:author" content="swx">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s-qwer.github.io/12.1.spring/image-20210922142605980.png">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-12.1.spring" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/12.1.spring/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:42:00.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      spring
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题;而Spring Boot 是基于Spring的一套快速开发整合包，Spring Boot遵循的也是约定优于配置原则,它的目的在于实现自动配置，降低项目搭建的复杂度;Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>
<p>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p>
<p>　Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</p>
<p>2.1.2 Spring的初衷</p>
<p>1、JAVA EE开发应该更加简单。</p>
<p>2、使用接口而不是使用类，是更好的编程习惯。Spring将使用接口的复杂度几乎降低到了零。</p>
<p>3、为JavaBean提供了一个更好的应用配置框架。</p>
<p>4、更多地强调面向对象的设计，而不是现行的技术如JAVA EE。</p>
<p>5、尽量减少不必要的异常捕捉。</p>
<p>6、使应用程序更加容易测试。</p>
<p>2.1.3 Spring的目标</p>
<p>1、可以令人方便愉快的使用Spring。</p>
<p>2、应用程序代码并不依赖于Spring APIs。</p>
<p>3、Spring不和现有的解决方案竞争，而是致力于将它们融合在一起。</p>
<p>2.1.4　Spring的基本组成</p>
<p>1、最完善的轻量级核心框架。</p>
<p>2、通用的事务管理抽象层。</p>
<p>3、JDBC抽象层。</p>
<p>4、集成了Toplink, Hibernate, JDO, and iBATIS SQL Maps。</p>
<p>5、AOP功能。</p>
<p>6、灵活的MVC Web应用框架。</p>
<p>2.1.５　Spring的发展</p>
<p>Spring框架几乎涉及到了Java企业级服务开发的所有方面，也几乎针对所有开发常用的模式、中间件、数据库进行了整合适配。</p>
<p>之前在聊互联网架构模式的时候我谈到过，很多时候我们写一个业务把逻辑写死写出来是比较容易的，但是把这个逻辑提取成模式进而打包成一个框架来给大家使用，这是比较难的。因为我们只有经历过足够多的场景后才能提取出普适的功能框架，大部分人才能用上，而且我们需要针对核心功能开放出可配置的部分，满足小部分人进一步定制和扩展功能的需要。</p>
<p>Spring框架经历了几个阶段：</p>
<p>1.第一个阶段推出的Core、Security、Data是把单体应用开发服务好。不仅仅提供了便捷的数据库访问、Web MVC等必要功能，而且通过AOP、IOC两大利器让我们的程序内在能够做到低耦合可扩展。</p>
<p>2.第二个阶段推出的Boot的意义不仅仅是加速了开发效率而且能让我们的程序从可用变为好用，应用程序核心业务逻辑可能只有70%的工作量，要让程序在线上跑的愉快还有30%的监控日志打点等工作量需要去做。</p>
<p>3.第三个阶段推出的Cloud的意义在于推动了微服务架构的落地。让不具备开发微服务基础套件的小型互联网公司也能享受到免费的开箱即用的微服务解决方案。其实很多人不是看了微服务的架构思想去寻找解决方案，而是了解到了Spring Cloud才去了解微服务思想从而落地的。</p>
<p>4.目前属于第四个阶段，大力发展Cloud Dataflow+容器。Dataflow的思想是不管是做实时消息处理的服务还是临时运行的任务，都可以认为是服务的组件，如果可以有一套DSL来定义这些组件之间的交互方式，然后在容器中进行自由组合、部署、伸缩，那么架构会非常灵活。下图是Dataflow管理界面的一个示意图。</p>
<p>Spring的发展可以看到互联网架构的发展，Spring给我们带来相当多的技术启发，从软件设计模式的启发慢慢到了架构的启发，甚至我觉得Spring是为Java开发打造了架构风格的模板，接下去Spring继续发展2到3年有望成为架构标准，我在想这个时候应用架构师何去何从？</p>
<p><img src="/12.1.spring/image-20210922142605980.png" alt="image-20210922142605980"></p>
<p>在Spring4.x中增加了新的特性：如果类只提供了一个带参数的构造方法，则不需要对对其内部的属性写@Autowired注解，Spring会自动为你注入属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看spring的版本</span></span><br><span class="line">String springVersion = SpringVersion.getVersion();</span><br><span class="line">String springBootVersion = SpringBootVersion.getVersion();</span><br><span class="line">System.out.println(springVersion);</span><br><span class="line">System.out.println(springBootVersion);</span><br></pre></td></tr></table></figure>

<p>只要用了spring框架，肯定到处都是@Autowired。4.3之后的功能，如果只有一个构造方法，自动用这个构造方法注入配合lombok的@RequiredArgsConstructor使用体验很好：</p>
<p>我们平时开发中的bean大部分都不写构造函数，系统默认一个无参构造函数，这就符合这一条件。</p>
<p><img src="/12.1.spring/20191018160134977.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101816003785.png"></p>
<p>此时helloService已经注入了，但是有些人会说以前加个@Autowired就行了，现在还要加个构造方法，更麻烦了，这时可以使用lombok插件，类上加@AllArgsConstructor就行了。</p>
<p><img src="/12.1.spring/20191018160429867.png" alt="在这里插入图片描述"></p>
<p>在编写代码的时候，使用@Autowired注解是，发现IDE报的一个警告，如下：</p>
<p><img src="/12.1.spring/20190606170140759.jpg" alt="img"> </p>
<p>Spring Team recommends “Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies”.</p>
<p>翻译：</p>
<p>Spring建议”总是在您的bean中使用构造函数建立依赖注入。总是使用断言强制依赖”。</p>
<p>这段代码警告原来的写法是：</p>
<p>@Autowired<br>private EnterpriseDbService service;<br>建议后写成下面的样子：</p>
<p>private final EnterpriseDbService service;<br>@Autowired<br>public EnterpriseDbController(EnterpriseDbService service) {<br> this.service = service;<br>}<br>奇怪，为何会有这样的建议。</p>
<p>我们知道：@Autowired 可以对成员变量、方法以及构造函数进行注释。那么对成员变量和构造函数进行注释又有什么区别呢？</p>
<p>@Autowired注入bean，相当于在配置文件中配置bean，并且使用setter注入。而对构造函数进行注释，就相当于是使用构造函数进行依赖注入了吧。莫非是这两种注入方法的不同。</p>
<p>以下是：@Autowired和构造方法执行的顺序解析</p>
<p>先看一段代码，下面的代码能运行成功吗？</p>
<p>@Autowired<br>private User user;<br>private String school;<br>public UserAccountServiceImpl(){<br> this.school = user.getSchool();<br>}<br>答案是不能。</p>
<p>因为Java类会先执行构造方法，然后再给注解了@Autowired 的user注入值，所以在执行构造方法的时候，就会报错。</p>
<p>报错信息可能会像下面：</p>
<p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘…’ defined in file [….class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate […]: Constructor threw exception; nested exception is java.lang.NullPointerException<br>报错信息说：创建Bean时出错，出错原因是实例化bean失败，因为bean时构造方法出错，在构造方法里抛出了空指针异常。</p>
<p>解决办法是，使用构造器注入，如下：</p>
<p>private User user;<br>private String school;<br>@Autowired<br>public UserAccountServiceImpl(User user){<br> this.user = user;<br> this.school = user.getSchool();<br>}<br>可以看出，使用构造器注入的方法，可以明确成员变量的加载顺序。</p>
<p>PS：Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法–&gt;@Autowired</p>
<p>@Autowired和构造方法执行的顺序解析</p>
<p>先看一段代码，下面的代码能运行成功吗？</p>
<p> @Autowired<br>    private User user;<br>    private String school;</p>
<pre><code>public UserAccountServiceImpl()&#123;
    this.school = user.getSchool();
&#125;
</code></pre>
<p>答案是不能。因为Java类会先执行构造方法，然后再给注解了@Autowired 的user注入值，所以在执行构造方法的时候，就会报错。<br>报错信息可能会像下面：</p>
<p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘…’ defined in file [….class]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate […]: Constructor threw exception; nested exception is java.lang.NullPointerException</p>
<p>报错信息说：创建Bean时出错，出错原因是实例化bean失败，因为bean时构造方法出错，在构造方法里抛出了空指针异常。</p>
<p>解决办法是，使用构造器注入，如下：</p>
<p> private User user;<br>    private String school;</p>
<pre><code>@Autowired
public UserAccountServiceImpl(User user)&#123;
    this.user = user;
    this.school = user.getSchool();
&#125;
</code></pre>
<p>那么最开始Spring建议，为何要将成员变量加上final类型呢？</p>
<p>网上有解释如下：spring配置默认的bean的scope是singleton，也就是启动后一直有。通过设置bean的scope属性为prototype来声明该对象为动态创建。但是，如果你的service本身是singleton，注入只执行一次。</p>
<p>@Autowired本身就是单例模式，只会在程序启动时执行一次，即使不定义final也不会初始化第二次，所以这个final是没有意义的吧。</p>
<p>可能是为了防止，在程序运行的时候，又执行了一遍构造函数；</p>
<p>或者是更容易让人理解的意思，加上final只会在程序启动的时候初始化一次，并且在程序运行的时候不会再改变。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired 注释可以在 setter 方法中被用于自动连接 bean，就像 @Autowired 注释，容器，一个属性或者任意命名的可能带有多个参数的方法。</p>
<p>可以在属性中使用 @Autowired 注释来除去 setter 方法。当时使用 为自动连接属性传递的时候，Spring 会将这些传递过来的值或者引用自动分配给那些属性</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>踩到一个坑，有一个接口，在这个接口的实现类里，需要用到@Autowired注解，一时大意，没有在实现类上加上@Component注解，导致了Spring报错，找不到这个类</p>
<p>一旦使用关于Spring的注解出现在类里，例如我在实现类中用到了@Autowired注解，被注解的这个类是从Spring容器中取出来的，那调用的实现类也需要被Spring容器管理，加上@Component</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;conversionImpl&quot;)</span></span><br><span class="line"><span class="comment">//其实默认的spring中的Bean id 为 conversionImpl(首字母小写)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConversionImpl</span> <span class="keyword">implements</span> <span class="title">Conversion</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient redisClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>介绍</p>
<p>开发中难免会遇到这个这个注解@Component</p>
<p>@Controller 控制器（注入服务）<br> 用于标注控制层，相当于struts中的action层</p>
<p>@Service 服务（注入dao）<br> 用于标注服务层，主要用来进行业务的逻辑处理</p>
<p>@Repository（实现dao访问）<br> 用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件</p>
<p>@Component （把普通pojo实例化到spring容器中，相当于配置文件中的 ）</p>
<p>泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</p>
<h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type1">异常处理方式一. @ExceptionHandler</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type2">异常处理方式二. 实现HandlerExceptionResolver接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvbinbin2yujie/p/10574812.html#type3">异常处理方式三. @ControllerAdvice+@ExceptionHandler</a></li>
</ol>
<p>spring的启动</p>
<p>Spring 是一个控制反转依赖管理的容器，作为 Java Web 的开发人员，基本没有不熟悉 Spring 技术栈的，尽管在依赖注入领域，Java Web 领域不乏其他优秀的框架，如 google 开源的依赖管理框架 guice，如 Jersey web 框架等。但 Spring 已经是 Java Web 领域使用最多，应用最广泛的 Java 框架。</p>
<p>此文将专注讲解如何在 Spring 容器启动时实现我们自己想要实现的逻辑。我们时常会遇到在 Spring 启动的时候必须完成一些初始化的操作，如创建定时任务，创建连接池等。</p>
<p>本文将介绍以下几种 Spring 启动监听方式：</p>
<ul>
<li>Bean 构造函数方式</li>
<li>使用 @PostConstruct 注解</li>
<li>实现 InitializingBean 接口</li>
<li>监听 ApplicationListener 事件</li>
<li>使用 Constructor 注入方式</li>
<li>实现 SpringBoot 的 CommandLineRunner 接口</li>
<li>SmartLifecycle 机制</li>
</ul>
<h2 id="spring装填bean"><a href="#spring装填bean" class="headerlink" title="spring装填bean"></a>spring装填bean</h2><p>我们知道如果我们要在一个类使用<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javaee">spring</a>提供的bean对象，我们需要把这个类注入到spring容器中，交给spring容器进行管理，但是在实际当中，我们往往会碰到在一个普通的<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/javase">Java</a>类中，想直接使用spring提供的其他对象或者说有一些不需要交给spring管理，但是需要用到spring里的一些对象。如果这是spring框架的独立应用程序，我们通过</p>
<p>ApplicationContext ac = new FileSystemXmlApplicationContext(“applicationContext.xml”);<br>ac.getBean(“beanId”); </p>
<p>这样的方式就可以很轻易的获取我们所需要的对象。</p>
<p>但是往往我们所做的都是Web Application，这时我们启动spring容器是通过在web.xml文件中配置，这样就不适合使用上面的方式在普通类去获取对象了，因为这样做就相当于加载了两次spring容器，而我们想是否可以通过在启动web服务器的时候，就把Application放在某一个类中，我们通过这个类在获取，这样就可以在普通类获取spring bean对象了，让我们接着往下看</p>
<p><strong>普通类调用Spring bean对象:</strong></p>
<p>可以参考：<a target="_blank" rel="noopener" href="http://412887952-qq-com.iteye.com/blog/1479445">http://412887952-qq-com.iteye.com/blog/1479445</a></p>
<p>这里有更多这方面的介绍，比较详细</p>
<p>下面介绍在springboot中是如何使用的</p>
<p><strong>1.在Spring Boot可以扫描的包下</strong></p>
<p><strong>写的工具类为SpringUtil，实现ApplicationContextAware接口，并加入Component注解，让spring扫描到该bean</strong></p>
<p>springutil:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.util;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class SpringUtil implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        if(SpringUtil.applicationContext &#x3D;&#x3D; null) &#123;</span><br><span class="line">            SpringUtil.applicationContext &#x3D; applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------me.shijunjie.util.SpringUtil------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ApplicationContext配置成功,在普通类可以通过调用SpringUtils.getAppContext()获取applicationContext对象,applicationContext&#x3D;&quot;+SpringUtil.applicationContext+&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取applicationContext</span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name获取 Bean.</span><br><span class="line">    public static Object getBean(String name)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过class获取Bean.</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name,以及Clazz返回指定的Bean</span><br><span class="line">    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>为了测试，我们再启动的时候先通过代码方式给spring容器中注入一个bean，入下所示</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.entity.Demo2;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class BeanConfig &#123;</span><br><span class="line">    @Bean(name&#x3D;&quot;testDemo&quot;)</span><br><span class="line">    public Demo2 generateDemo() &#123;</span><br><span class="line">        Demo2 demo &#x3D; new Demo2();</span><br><span class="line">        demo.setId(12345);</span><br><span class="line">        demo.setName(&quot;test&quot;);</span><br><span class="line">        return demo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>然后我们编写测试controller，并从刚才写的springutil中获取这个bean</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.util.SpringUtil;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;application&quot;)</span><br><span class="line">public class TestApplicationController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;&#x2F;test1&quot;)</span><br><span class="line">    public Object testSpringUtil1() &#123;</span><br><span class="line">        return SpringUtil.getBean(&quot;testDemo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>测试</p>
<p>启动web应用，打开浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8080/application/test1%EF%BC%8C%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F">http://localhost:8080/application/test1，测试成功</a></p>
<p><img src="https://images2015.cnblogs.com/blog/1097735/201703/1097735-20170302105956954-82157382.png" alt="img"></p>
<p><strong>2 不在Spring Boot的扫描包下方式一</strong></p>
<p>这种情况处理起来也很简单，先编写SpringUtil类，同样需要实现接口：ApplicationContextAware，具体编码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.util;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line">public class SpringUtil2 implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        if(SpringUtil2.applicationContext &#x3D;&#x3D; null) &#123;</span><br><span class="line">            SpringUtil2.applicationContext &#x3D; applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------me.shijunjie.util.SpringUtil------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ApplicationContext配置成功,在普通类可以通过调用SpringUtils.getAppContext()获取applicationContext对象,applicationContext&#x3D;&quot;+SpringUtil2.applicationContext+&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------------------------------------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取applicationContext</span><br><span class="line">    public static ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name获取 Bean.</span><br><span class="line">    public static Object getBean(String name)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过class获取Bean.</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过name,以及Clazz返回指定的Bean</span><br><span class="line">    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123;</span><br><span class="line">        return getApplicationContext().getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Bean注解，在App.java类中将SpringUtil注解进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.context.web.SpringBootServletInitializer;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.util.SpringUtil2;</span><br><span class="line"></span><br><span class="line">@ComponentScan(basePackages&#x3D;&#123;&quot;me.shijunjie&quot;&#125;) &#x2F;&#x2F; 扫描该包路径下的所有spring组件</span><br><span class="line">&#x2F;*@EnableJpaRepositories(&quot;me.shijunjie.dao&quot;) &#x2F;&#x2F; JPA扫描该包路径下的Repositorie</span><br><span class="line">*&#x2F;&#x2F;*@EntityScan(&quot;me.shijunjie.entity&quot;) &#x2F;&#x2F; 扫描实体类</span><br><span class="line">*&#x2F;@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class App extends SpringBootServletInitializer&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public SpringUtil2 getSpringUtil2() &#123;</span><br><span class="line">        return new SpringUtil2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试（使用热部署的需要重启服务器）</p>
<p>启动web应用，打开浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8080/application/test2%EF%BC%8C%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F">http://localhost:8080/application/test2，测试成功</a></p>
<p><img src="https://images2015.cnblogs.com/blog/1097735/201703/1097735-20170302110921157-936863400.png" alt="img"></p>
<p>除此以外，也可以在<a href="mailto:主要是在App.java中使用@Import">App.java</a>中使用@Import进行导入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package me.shijunjie.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.context.web.SpringBootServletInitializer;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Import;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line">import me.shijunjie.util.SpringUtil2;</span><br><span class="line"></span><br><span class="line">@ComponentScan(basePackages&#x3D;&#123;&quot;me.shijunjie&quot;&#125;) &#x2F;&#x2F; 扫描该包路径下的所有spring组件</span><br><span class="line">&#x2F;*@EnableJpaRepositories(&quot;me.shijunjie.dao&quot;) &#x2F;&#x2F; JPA扫描该包路径下的Repositorie</span><br><span class="line">*&#x2F;&#x2F;*@EntityScan(&quot;me.shijunjie.entity&quot;) &#x2F;&#x2F; 扫描实体类</span><br><span class="line">*&#x2F;@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">@Import(SpringUtil2.class)</span><br><span class="line">public class App extends SpringBootServletInitializer&#123;</span><br><span class="line">    &#x2F;*@Bean</span><br><span class="line">    public SpringUtil2 getSpringUtil2() &#123;</span><br><span class="line">        return new SpringUtil2();</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跑出结果和上面相同</p>
<h2 id="原始构造函数"><a href="#原始构造函数" class="headerlink" title="原始构造函数"></a>原始构造函数</h2><p>如果没有 Spring 容器，不依赖于 Spring 的实现，回归 Java 类实现本身，我们可以在静态代码块，在类构造函数中实现相应的逻辑，Java 类的初始化顺序依次是<code>静态变量</code> &gt; <code>静态代码块</code> &gt; <code>全局变量</code> &gt; <code>初始化代码块</code> &gt; <code>构造器</code>。</p>
<p>比如，Log4j 的初始化，就是在 <code>LogManager</code> 的静态代码块中实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line"></span><br><span class="line">    Hierarchy h &#x3D; new Hierarchy(new RootLogger((Level) Level.DEBUG));</span><br><span class="line">    repositorySelector &#x3D; new DefaultRepositorySelector(h);</span><br><span class="line"></span><br><span class="line">    String override &#x3D;OptionConverter.getSystemProperty(DEFAULT_INIT_OVERRIDE_KEY,null);</span><br><span class="line"></span><br><span class="line">    if(override &#x3D;&#x3D; null || &quot;false&quot;.equalsIgnoreCase(override)) &#123;</span><br><span class="line">          String configurationOptionStr &#x3D; OptionConverter.getSystemProperty(DEFAULT_CONFIGURATION_KEY, null);</span><br><span class="line">          String configuratorClassName &#x3D; OptionConverter.getSystemProperty(CONFIGURATOR_CLASS_KEY, null);</span><br><span class="line"></span><br><span class="line">          URL url &#x3D; null;</span><br><span class="line"></span><br><span class="line">          if(configurationOptionStr &#x3D;&#x3D; null) &#123;</span><br><span class="line">            url &#x3D; Loader.getResource(DEFAULT_XML_CONFIGURATION_FILE);</span><br><span class="line">            if(url &#x3D;&#x3D; null) &#123;</span><br><span class="line">              url &#x3D; Loader.getResource(DEFAULT_CONFIGURATION_FILE);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              url &#x3D; new URL(configurationOptionStr);</span><br><span class="line">            &#125; catch (MalformedURLException ex) &#123;</span><br><span class="line">              url &#x3D; Loader.getResource(configurationOptionStr);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if(url !&#x3D; null) &#123;</span><br><span class="line">            LogLog.debug(&quot;Using URL [&quot;+url+&quot;] for automatic log4j configuration.&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                OptionConverter.selectAndConfigure(url, configuratorClassName,LogManager.getLoggerRepository());</span><br><span class="line">            &#125; catch (NoClassDefFoundError e) &#123;</span><br><span class="line">                LogLog.warn(&quot;Error during default initialization&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              LogLog.debug(&quot;Could not find resource: [&quot;+configurationOptionStr+&quot;].&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">            LogLog.debug(&quot;Default initialization of overridden by &quot; +  DEFAULT_INIT_OVERRIDE_KEY + &quot;property.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如在构造函数中实现相应的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment env;</span><br><span class="line"></span><br><span class="line">    public CustomBean() &#123;</span><br><span class="line">        env.getActiveProfiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里考验一下各位，上面的代码是否可以正常运行。—— 不行，构造函数中的<code>env</code>将会发生<code>NullPointException</code>异常。这是因为在 Spring 中将先初始化 Bean，也就是会先调用类的构造函数，然后才注入成员变量依赖的 Bean（<code>@Autowired</code>和<code>@Resource</code>注解修饰的成员变量），注意<code>@Value</code>等注解的配置的注入也是在构造函数之后。</p>
<h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>在 Spring 中，我们可以使用<code>@PostConstruct</code>在 Bean 初始化之后实现相应的初始化逻辑，<code>@PostConstruct</code>修饰的方法将在 Bean 初始化完成之后执行，此时 Bean 的依赖也已经注入完成，因此可以在方法中调用注入的依赖 Bean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment env;</span><br><span class="line"></span><br><span class="line">    @PostConstruce</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        env.getActiveProfiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>@PostConstruct</code>相对应的，如果想在 Bean 注销时完成一些清扫工作，如关闭线程池等，可以使用<code>@PreDestroy</code>注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ExecutorService executor &#x3D; Executors.newFixedThreadPool(1)</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        env.getActiveProfiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h2><p>实现 Spring 的<code>InitializingBean</code>接口同样可以实现以上在 Bean 初始化完成之后执行相应逻辑的功能，实现<code>InitializingBean</code>接口，在<code>afterPropertiesSet</code>方法中实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomBean implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOG</span><br><span class="line">      &#x3D; Logger.getLogger(InitializingBeanExampleBean.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        LOG.info(environment.getDefaultProfiles());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h2><p>我们可以在 Spring 容器初始化的时候实现我们想要的初始化逻辑。这时我们就可以使用到 Spring 的初始化事件。Spring 有一套完整的事件机制，在 Spring 启动的时候，Spring 容器本身预设了很多事件，在 Spring 初始化的整个过程中在相应的节点触发相应的事件，我们可以通过监听这些事件来实现我们的初始化逻辑。Spring 的事件实现如下：</p>
<ul>
<li>ApplicationEvent，事件对象，由 ApplicationContext 发布，不同的实现类代表不同的事件类型。</li>
<li>ApplicationListener，监听对象，任何实现了此接口的 Bean 都会收到相应的事件通知。实现了 ApplicationListener 接口之后，需要实现方法 onApplicationEvent()，在容器将所有的 Bean 都初始化完成之后，就会执行该方法。</li>
</ul>
<p>与 Spring Context 生命周期相关的几个事件有以下几个：</p>
<ul>
<li>ApplicationStartingEvent: 这个事件在 Spring Boot 应用运行开始时，且进行任何处理之前发送（除了监听器和初始化器注册之外）。</li>
<li>ContextRefreshedEvent: ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。</li>
<li>ContextStartedEvent: 当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被触发。你可以查询你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</li>
<li>ApplicationReadyEvent: 这个事件在任何 application/ command-line runners 调用之后发送。</li>
<li>ContextClosedEvent: 当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被触发。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</li>
<li>ContextStoppedEvent: Spring 最后完成的事件。</li>
</ul>
<p>因此，如果我们想在 Spring 启动的时候实现一些相应的逻辑，可以找到 Spring 启动过程中符合我们需要的事件，通过监听相应的事件来完成我们的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class StartupApplicationListenerExample implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">        log.info(&quot;Subject ContextRefreshedEvent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了通过实现<code>ApplicationListener</code>接口来监听相应的事件，Spring 的事件机制也实现了通过<code>@EventListener</code>注解来监听相对应事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class StartupApplicationListenerExample &#123;</span><br><span class="line"></span><br><span class="line">    @EventListener</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">        log.info(&quot;Subject ContextRefreshedEvent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Event 是一套完善的进程内事件发布订阅机制，我们除了用来监听 Spring 内置的事件，也可以使用 Spring Event 实现自定义的事件发布订阅功能。</p>
<h2 id="Constructor-注入"><a href="#Constructor-注入" class="headerlink" title="Constructor 注入"></a>Constructor 注入</h2><p>在学习 Spring 的注入机制的时候，我们都知道 Spring 可以通过构造函数、Setter 和反射成员变量注入等方式。上面我们在成员变量上通过<code>@Autoware</code>注解注入依赖 Bean，但是在 Bean 的构造函数函数中却无法使用到注入的 Bean（因为 Bean 还未注入），其实我们也是使用 Spring 的构造函数注入方式， 这也是 Spring 推荐的注入机制（在我们使用 IDEA 的时候，如果没有关闭相应的代码 Warning 机制，会发现在成员变量上的<code>@Autoware</code>是黄色的，也就是 idea 不建议的代码）。Spring 更推荐构造函数注入的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class ConstructorBean &#123;</span><br><span class="line"></span><br><span class="line">    private final Environment environment;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public LogicInConstructorExampleBean(Environment environment) &#123;</span><br><span class="line">        this.environment &#x3D; environment;</span><br><span class="line">        log.info(Arrays.asList(environment.getDefaultProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><p>如果我们的项目使用的是 Spring Boot，那么可以使用 Spring Boot 提供的 <code>CommandLineRunner</code> 接口来实现初始化逻辑，Spring Boot 将在启动初始化完成之后调用实现了<code>CommandLineRunner</code>的接口的<code>run</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommandLineAppStartupRunner implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String...args) throws Exception &#123;</span><br><span class="line">        log.info(&quot;Increment counter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，多个<code>CommandLineRunner</code>实现，可以通过<code>@Order</code>来控制它们的执行顺序。</p>
<h2 id="SmartLifecycle"><a href="#SmartLifecycle" class="headerlink" title="SmartLifecycle"></a>SmartLifecycle</h2><p>还有一种更高级的方法来实现我们的逻辑。这可以 Spring 高级开发必备技能哦。SmartLifecycle 不仅仅能在初始化后执行一个逻辑，还能再关闭前执行一个逻辑，并且也可以控制多个 <code>SmartLifecycle</code> 的执行顺序，就像这个类名表示的一样，这是一个智能的生命周期管理接口。</p>
<ul>
<li>start()：bean 初始化完毕后，该方法会被执行。</li>
<li>stop()：容器关闭后，spring 容器发现当前对象实现了 SmartLifecycle，就调用 stop(Runnable)， 如果只是实现了 Lifecycle，就调用 stop()。</li>
<li>isRunning：当前状态，用来判你的断组件是否在运行。</li>
<li>getPhase：控制多个 SmartLifecycle 的回调顺序的，返回值越小越靠前执行 start() 方法，越靠后执行 stop() 方法。</li>
<li>isAutoStartup()：start 方法被执行前先看此方法返回值，返回 false 就不执行 start 方法了。</li>
<li>stop(Runnable)：容器关闭后，spring 容器发现当前对象实现了 SmartLifecycle，就调用 stop(Runnable)， 如果只是实现了 Lifecycle，就调用 stop()。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SmartLifecycleExample implements SmartLifecycle &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        isRunning &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getPhase() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认为 0</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAutoStartup() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认为 false</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isRunning() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认返回 false</span><br><span class="line">        return isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop(Runnable callback) &#123;</span><br><span class="line">        System.out.println(&quot;stop(Runnable)&quot;);</span><br><span class="line">        callback.run();</span><br><span class="line">        isRunning &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;stop&quot;);</span><br><span class="line"></span><br><span class="line">        isRunning &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Aspect、-Before、-After-注解实现-AOP-切面功能"><a href="#Spring-Aspect、-Before、-After-注解实现-AOP-切面功能" class="headerlink" title="Spring @Aspect、@Before、@After 注解实现 AOP 切面功能"></a>Spring @Aspect、@Before、@After 注解实现 AOP 切面功能</h2><p>Spring AOP 注解概述<br>1、Spring 的 AOP 功能除了在配置文件中配置一大堆的配置，比如切入点、表达式、通知等等以外，使用注解的方式更为方便快捷，特别是 Spring boot 出现以后，基本不再使用原先的 beans.xml 等配置文件了，而都推荐注解编程。</p>
<table>
<thead>
<tr>
<th>@Aspect</th>
<th>切面声明，标注在类、接口（包括注解类型）或枚举上。</th>
</tr>
</thead>
<tbody><tr>
<td>@Pointcut</td>
<td>切入点声明，即切入到哪些目标类的目标方法。<br />value 属性指定切入点表达式，默认为 “”，用于被通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式</td>
</tr>
<tr>
<td>@Before</td>
<td>前置通知, 在目标方法(切入点)执行之前执行。<br />value 属性绑定通知的切入点表达式，可以关联切入点声明，也可以直接设置切入点表达式<br />注意：如果在此回调方法中抛出异常，则目标方法不会再执行，会继续执行后置通知 -&gt; 异常通知。</td>
</tr>
<tr>
<td>@After</td>
<td>后置通知, 在目标方法(切入点)执行之后执行</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>返回通知, 在目标方法(切入点)返回结果之后执行，在 @After 的后面执行<br />pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 “”</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>异常通知, 在方法抛出异常之后执行, 意味着跳过返回通知<br />pointcut 属性绑定通知的切入点表达式，优先级高于 value，默认为 “”<br />注意：如果目标方法自己 try-catch 了异常，而没有继续往外抛，则不会进入此回调函数</td>
</tr>
<tr>
<td>@Around</td>
<td>环绕通知：目标方法执行前后分别执行一些代码，类似拦截器，可以控制目标方法是否继续执行。<br />通常用于统计方法耗时，参数校验等等操作。<br />环绕通知早于前置通知，晚于返回通知</td>
</tr>
<tr>
<td>2、上面这些 AOP 注解都是位于如下所示的 aspectjweaver 依赖中：</td>
<td></td>
</tr>
</tbody></table>
<p><img src="/12.1.spring/20200822102819511.png" alt="img"></p>
<p>3、对于习惯了 Spring 全家桶编程的人来说，并不是需要直接引入 aspectjweaver 依赖，因为 spring-boot-starter-aop 组件默认已经引用了 aspectjweaver 来实现  AOP 功能。换句话说 Spring 的 AOP 功能就是依赖的 aspectjweaver ！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-aop --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;dependency&gt;    </span><br></pre></td></tr></table></figure>

<p>@Aspect 快速入门<br>1、@Aspect 常见用于记录日志、异常集中处理、权限验证、Web 参数校验、事务处理等等</p>
<p>2、要想把一个类变成切面类，只需3步：</p>
<p>1）在类上使用 @Aspect 注解使之成为切面类</p>
<p>2）切面类需要交由 Sprign 容器管理，所以类上还需要有 @Service、@Repository、@Controller、@Component  等注解<br>2）在切面类中自定义方法接收通知</p>
<p>3、AOP 的含义就不再累述了，下面直接上示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.lang3.time.StopWatch;</span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.Signature;</span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.aspectj.lang.reflect.SourceLocation;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line"> * 切面注解 Aspect 使用入门</span><br><span class="line"></span><br><span class="line"> * 1、@Aspect：声明本类为切面类</span><br><span class="line"></span><br><span class="line"> * 2、@Component：将本类交由 Spring 容器管理</span><br><span class="line"></span><br><span class="line"> * 3、@Order：指定切入执行顺序，数值越小，切面执行顺序越靠前，默认为 Integer.MAX_VALUE</span><br><span class="line">   *</span><br><span class="line"></span><br><span class="line"> * @author wangMaoXiong</span><br><span class="line"></span><br><span class="line"> * @version 1.0</span><br><span class="line"></span><br><span class="line"> * @date 2020&#x2F;8&#x2F;20 19:22</span><br><span class="line">   *&#x2F;</span><br><span class="line">   @Aspect</span><br><span class="line">   @Order(value &#x3D; 999)</span><br><span class="line">   @Component</span><br><span class="line">   public class AspectHelloWorld &#123;</span><br><span class="line">   private static final Logger LOG &#x3D; LoggerFactory.getLogger(AspectHelloWorld.class);</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * @Pointcut ：切入点声明，即切入到哪些目标方法。value 属性指定切入点表达式，默认为 &quot;&quot;。</span><br><span class="line"></span><br><span class="line">    * 用于被下面的通知注解引用，这样通知注解只需要关联此切入点声明即可，无需再重复写切入点表达式</span><br><span class="line"></span><br><span class="line">    * &lt;p&gt;</span><br><span class="line"></span><br><span class="line">    * 切入点表达式常用格式举例如下：</span><br><span class="line"></span><br><span class="line">    * - * com.wmx.aspect.EmpService.*(..))：表示 com.wmx.aspect.EmpService 类中的任意方法</span><br><span class="line"></span><br><span class="line">    * - * com.wmx.aspect.*.*(..))：表示 com.wmx.aspect 包(不含子包)下任意类中的任意方法</span><br><span class="line"></span><br><span class="line">    * - * com.wmx.aspect..*.*(..))：表示 com.wmx.aspect 包及其子包下任意类中的任意方法</span><br><span class="line"></span><br><span class="line">    * &lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    * value 的 execution 可以有多个，使用 || 隔开.</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @Pointcut(value &#x3D;</span><br><span class="line">          &quot;execution(* com.wmx.hb.controller.DeptController.*(..)) &quot; +</span><br><span class="line">                  &quot;|| execution(* com.wmx.hb.controller.EmpController.*(..))&quot;)</span><br><span class="line">      private void aspectPointcut() &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 前置通知：目标方法执行之前执行以下方法体的内容。</span><br><span class="line"></span><br><span class="line">    * value：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line"></span><br><span class="line">    * &lt;br&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    * * @param joinPoint：提供对连接点处可用状态和有关它的静态信息的反射访问&lt;br&#x2F;&gt; &lt;p&gt;</span><br><span class="line"></span><br><span class="line">    * * * Object[] getArgs()：返回此连接点处（目标方法）的参数，目标方法无参数时，返回空数组</span><br><span class="line"></span><br><span class="line">    * * * Signature getSignature()：返回连接点处的签名。</span><br><span class="line"></span><br><span class="line">    * * * Object getTarget()：返回目标对象</span><br><span class="line"></span><br><span class="line">    * * * Object getThis()：返回当前正在执行的对象</span><br><span class="line"></span><br><span class="line">    * * * StaticPart getStaticPart()：返回一个封装此连接点的静态部分的对象。</span><br><span class="line"></span><br><span class="line">    * * * SourceLocation getSourceLocation()：返回与连接点对应的源位置</span><br><span class="line"></span><br><span class="line">    * * * String toLongString()：返回连接点的扩展字符串表示形式。</span><br><span class="line"></span><br><span class="line">    * * * String toShortString()：返回连接点的缩写字符串表示形式。</span><br><span class="line"></span><br><span class="line">    * * * String getKind()：返回表示连接点类型的字符串</span><br><span class="line"></span><br><span class="line">    * * * &lt;&#x2F;p&gt;</span><br><span class="line">          *&#x2F;</span><br><span class="line">          @Before(value &#x3D; &quot;aspectPointcut()&quot;)</span><br><span class="line">          public void aspectBefore(JoinPoint joinPoint) &#123;</span><br><span class="line">          Object[] args &#x3D; joinPoint.getArgs();</span><br><span class="line">          Signature signature &#x3D; joinPoint.getSignature();</span><br><span class="line">          Object target &#x3D; joinPoint.getTarget();</span><br><span class="line">          Object aThis &#x3D; joinPoint.getThis();</span><br><span class="line">          JoinPoint.StaticPart staticPart &#x3D; joinPoint.getStaticPart();</span><br><span class="line">          SourceLocation sourceLocation &#x3D; joinPoint.getSourceLocation();</span><br><span class="line">          String longString &#x3D; joinPoint.toLongString();</span><br><span class="line">          String shortString &#x3D; joinPoint.toShortString();</span><br><span class="line"></span><br><span class="line">        LOG.debug(&quot;【前置通知】&quot; +</span><br><span class="line">                        &quot;args&#x3D;&#123;&#125;,signature&#x3D;&#123;&#125;,target&#x3D;&#123;&#125;,aThis&#x3D;&#123;&#125;,staticPart&#x3D;&#123;&#125;,&quot; +</span><br><span class="line">                        &quot;sourceLocation&#x3D;&#123;&#125;,longString&#x3D;&#123;&#125;,shortString&#x3D;&#123;&#125;&quot;</span><br><span class="line">                , Arrays.asList(args), signature, target, aThis, staticPart, sourceLocation, longString, shortString);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 后置通知：目标方法执行之后执行以下方法体的内容，不管目标方法是否发生异常。</span><br><span class="line">    * value：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @After(value &#x3D; &quot;aspectPointcut()&quot;)</span><br><span class="line">      public void aspectAfter(JoinPoint joinPoint) &#123;</span><br><span class="line">      LOG.debug(&quot;【后置通知】kind&#x3D;&#123;&#125;&quot;, joinPoint.getKind());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 返回通知：目标方法返回后执行以下代码</span><br><span class="line">    * value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line">    * pointcut 属性：绑定通知的切入点表达式，优先级高于 value，默认为 &quot;&quot;</span><br><span class="line">    * returning 属性：通知签名中要将返回值绑定到的参数的名称，默认为 &quot;&quot;</span><br><span class="line">      *</span><br><span class="line">    * @param joinPoint ：提供对连接点处可用状态和有关它的静态信息的反射访问</span><br><span class="line">    * @param result    ：目标方法返回的值，参数名称与 returning 属性值一致。无返回值时，这里 result 会为 null.</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @AfterReturning(pointcut &#x3D; &quot;aspectPointcut()&quot;, returning &#x3D; &quot;result&quot;)</span><br><span class="line">      public void aspectAfterReturning(JoinPoint joinPoint, Object result) &#123;</span><br><span class="line">      LOG.debug(&quot;【返回通知】,shortString&#x3D;&#123;&#125;,result&#x3D;&quot;, joinPoint.toShortString(), result);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 异常通知：目标方法发生异常的时候执行以下代码，此时返回通知不会再触发</span><br><span class="line">    * value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line">    * pointcut 属性：绑定通知的切入点表达式，优先级高于 value，默认为 &quot;&quot;</span><br><span class="line">    * throwing 属性：与方法中的异常参数名称一致，</span><br><span class="line">      *</span><br><span class="line">    * @param ex：捕获的异常对象，名称与 throwing 属性值一致</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @AfterThrowing(pointcut &#x3D; &quot;aspectPointcut()&quot;, throwing &#x3D; &quot;ex&quot;)</span><br><span class="line">      public void aspectAfterThrowing(JoinPoint jp, Exception ex) &#123;</span><br><span class="line">      String methodName &#x3D; jp.getSignature().getName();</span><br><span class="line">      if (ex instanceof ArithmeticException) &#123;</span><br><span class="line">          LOG.error(&quot;【异常通知】&quot; + methodName + &quot;方法算术异常（ArithmeticException）：&quot; + ex.getMessage());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          LOG.error(&quot;【异常通知】&quot; + methodName + &quot;方法异常：&quot; + ex.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 环绕通知</span><br><span class="line"></span><br><span class="line">    * 1、@Around 的 value 属性：绑定通知的切入点表达式。可以关联切入点声明，也可以直接设置切入点表达式</span><br><span class="line"></span><br><span class="line">    * 2、Object ProceedingJoinPoint.proceed(Object[] args) 方法：继续下一个通知或目标方法调用，返回处理结果，如果目标方法发生异常，则 proceed 会抛异常.</span><br><span class="line"></span><br><span class="line">    * 3、假如目标方法是控制层接口，则本方法的异常捕获与否都不会影响目标方法的事务回滚</span><br><span class="line"></span><br><span class="line">    * 4、假如目标方法是控制层接口，本方法 try-catch 了异常后没有继续往外抛，则全局异常处理 @RestControllerAdvice 中不会再触发</span><br><span class="line">      *</span><br><span class="line"></span><br><span class="line">    * @param joinPoint</span><br><span class="line"></span><br><span class="line">    * @return</span><br><span class="line"></span><br><span class="line">    * @throws Throwable</span><br><span class="line">      *&#x2F;</span><br><span class="line">      @Around(value &#x3D; &quot;aspectPointcut()&quot;)</span><br><span class="line">      public Object handleControllerMethod(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">      this.checkRequestParam(joinPoint);</span><br><span class="line"></span><br><span class="line">      StopWatch stopWatch &#x3D; StopWatch.createStarted();</span><br><span class="line">      LOG.debug(&quot;【环绕通知】执行接口开始，方法&#x3D;&#123;&#125;，参数&#x3D;&#123;&#125; &quot;, joinPoint.getSignature(), Arrays.asList(joinPoint.getArgs()).toString());</span><br><span class="line">      &#x2F;&#x2F;继续下一个通知或目标方法调用，返回处理结果，如果目标方法发生异常，则 proceed 会抛异常.</span><br><span class="line">      &#x2F;&#x2F;如果在调用目标方法或者下一个切面通知前抛出异常，则不会再继续往后走.</span><br><span class="line">      Object proceed &#x3D; joinPoint.proceed(joinPoint.getArgs());</span><br><span class="line"></span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      long watchTime &#x3D; stopWatch.getTime();</span><br><span class="line">      LOG.debug(&quot;【环绕通知】执行接口结束，方法&#x3D;&#123;&#125;, 返回值&#x3D;&#123;&#125;,耗时&#x3D;&#123;&#125; (毫秒)&quot;, joinPoint.getSignature(), proceed, watchTime);</span><br><span class="line">      return proceed;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"></span><br><span class="line">    * 参数校验，防止 SQL 注入</span><br><span class="line">      *</span><br><span class="line">    * @param joinPoint</span><br><span class="line">      *&#x2F;</span><br><span class="line">      private void checkRequestParam(ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line">      Object[] args &#x3D; joinPoint.getArgs();</span><br><span class="line">      if (args &#x3D;&#x3D; null || args.length &lt;&#x3D; 0) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      String params &#x3D; Arrays.toString(joinPoint.getArgs()).toUpperCase();</span><br><span class="line">      String[] keywords &#x3D; &#123;&quot;DELETE &quot;, &quot;UPDATE &quot;, &quot;SELECT &quot;, &quot;INSERT &quot;, &quot;SET &quot;, &quot;SUBSTR(&quot;, &quot;COUNT(&quot;, &quot;DROP &quot;,</span><br><span class="line">              &quot;TRUNCATE &quot;, &quot;INTO &quot;, &quot;DECLARE &quot;, &quot;EXEC &quot;, &quot;EXECUTE &quot;, &quot; AND &quot;, &quot; OR &quot;, &quot;--&quot;&#125;;</span><br><span class="line">      for (String keyword : keywords) &#123;</span><br><span class="line">          if (params.contains(keyword)) &#123;</span><br><span class="line">              LOG.warn(&quot;参数存在SQL注入风险，其中包含非法字符 &#123;&#125;.&quot;, keyword);</span><br><span class="line">              throw new RuntimeException(&quot;参数存在SQL注入风险：params&#x3D;&quot; + params);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/12.1.spring/20200822112024130.gif" alt="img"></p>
<p>如上所示在不修改原来业务层代码的基础上，就可以使用 AOP 功能，在目标方法执行前后或者异常时都能捕获然后执行。</p>
<p>execution 切点表达式<br>1、@Pointcut 切入点声明注解，以及所有的通知注解都可以通过 value 属性或者 pointcut 属性指定切入点表达式。</p>
<p>2、切入点表达式通过 execution 函数匹配连接点，语法：execution([方法修饰符]  返回类型  方法路径(参数类型) [异常类型])</p>
<p>3、切入点表达式的写法比较灵活，比如：* 号表示任意一个，.. 表示任意多个，还可以使用 &amp;&amp;、||、! 进行逻辑运算.实际开发中常用：</p>
<table>
<thead>
<tr>
<th>execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(Integer))</th>
<th>匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，且带有一个 Integer 类型参数。</th>
</tr>
</thead>
<tbody><tr>
<td>execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(*))</td>
<td>匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，且带有一个任意类型参数。</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect.EmpServiceImpl.findEmpById(..))</td>
<td>匹配 com.wmx.aspect.EmpService 类中的 findEmpById 方法，参数不限</td>
</tr>
<tr>
<td>execution(* grp.basic3.se.service.SEBasAgencyService3.editAgencyInfo(..)) || execution(* grp.basic3.se.service.SEBasAgencyService3.adjustAgencyInfo(..))</td>
<td>匹配 editAgencyInfo 方法或者 adjustAgencyInfo 方法</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect.EmpService.*(..))</td>
<td>匹配 com.wmx.aspect.EmpService 类中的任意方法</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect.<em>.</em>(..))</td>
<td>匹配 com.wmx.aspect 包(不含子包)下任意类中的任意方法</td>
</tr>
<tr>
<td>execution(* com.wmx.aspect..<em>.</em>(..))</td>
<td>匹配 com.wmx.aspect 包及其子包下任意类中的任意方法</td>
</tr>
<tr>
<td>execution(* grp.pm..<em>Controller.</em>(..))</td>
<td>匹配 grp.pm 包下任意子孙包中以 “Controller” 结尾的类中的所有方法</td>
</tr>
</tbody></table>
<ul>
<li>execution：用于匹配方法执行的连接点；</li>
<li>within：用于匹配指定类型内的方法执行；</li>
<li>this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；    </li>
<li>target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；</li>
<li>args：用于匹配当前执行的方法传入的参数为指定类型的执行方法；</li>
<li>@within：用于匹配所以持有指定注解类型内的方法；</li>
<li>@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；</li>
<li>@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；</li>
<li>@annotation：用于匹配当前执行方法持有指定注解的方法；</li>
</ul>
<h2 id="SpEL表达式"><a href="#SpEL表达式" class="headerlink" title="SpEL表达式"></a><strong>SpEL表达式</strong></h2><p>SpEL（Spring Expression Language），即Spring表达式语言，是比JSP的EL更强大的一种表达式语言</p>
<p>它可以在运行时查询和操作数据，尤其是数组列表型数据，因此可以缩减代码量，优化代码结构</p>
<p>SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression</p>
<p>1.@Value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@Value能修饰成员变量和方法形参</span><br><span class="line">&#x2F;&#x2F;#&#123;&#125;内就是表达式的内容</span><br><span class="line">@Value(&quot;#&#123;表达式&#125;&quot;)</span><br><span class="line">public String arg;</span><br></pre></td></tr></table></figure>

<p>2.<bean>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;xxx&quot; class&#x3D;&quot;com.java.XXXXX.xx&quot;&gt;</span><br><span class="line">    &lt;!-- 同@Value,#&#123;&#125;内是表达式的值，可放在property或constructor-arg内 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;arg&quot; value&#x3D;&quot;#&#123;表达式&#125;&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>代码块中使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.expression.Expression;</span><br><span class="line">import org.springframework.expression.ExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"> </span><br><span class="line">public class SpELTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;创建ExpressionParser解析表达式</span><br><span class="line">        ExpressionParser parser &#x3D; new SpelExpressionParser();</span><br><span class="line">        &#x2F;&#x2F;表达式放置</span><br><span class="line">        Expression exp &#x3D; parser.parseExpression(&quot;表达式&quot;);</span><br><span class="line">        &#x2F;&#x2F;执行表达式，默认容器是spring本身的容器：ApplicationContext</span><br><span class="line">        Object value &#x3D; exp.getValue();</span><br><span class="line">        </span><br><span class="line">        &#x2F;**如果使用其他的容器，则用下面的方法*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;创建一个虚拟的容器EvaluationContext</span><br><span class="line">        StandardEvaluationContext ctx &#x3D; new StandardEvaluationContext();</span><br><span class="line">        &#x2F;&#x2F;向容器内添加bean</span><br><span class="line">        BeanA beanA &#x3D; new BeanA();</span><br><span class="line">        ctx.setVariable(&quot;bean_id&quot;, beanA);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;setRootObject并非必须；一个EvaluationContext只能有一个RootObject，引用它的属性时，可以不加前缀</span><br><span class="line">        ctx.setRootObject(XXX);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;getValue有参数ctx，从新的容器中根据SpEL表达式获取所需的值</span><br><span class="line">        Object value &#x3D; exp.getValue(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.#{…}和${…}</p>
<ul>
<li>#{…} 用于执行SpEl表达式，并将内容赋值给属性</li>
<li>${…} 主要用于加载外部属性文件中的值</li>
<li>#{…} 和${…} 可以混合使用，但是必须<code>#&#123;&#125;外面，$&#123;&#125;在里面</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果属性文件没有spelDefault.value，则会报错</span><br><span class="line">   &#x2F;&#x2F;  @Value(&quot;$&#123;spelDefault.value&#125;&quot;)</span><br><span class="line">   &#x2F;&#x2F;  private String spelDefault2;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 使用default.value设置值，如果不存在则使用默认值</span><br><span class="line">   @Value(&quot;$&#123;spelDefault.value:127.0.0.1&#125;&quot;)</span><br><span class="line">   private String spelDefault;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SpEL：调用字符串Hello World的concat方法</span><br><span class="line">@Value(&quot;#&#123;&#39;Hello World&#39;.concat(&#39;!&#39;)&#125;&quot;)</span><br><span class="line">private String helloWorld;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; SpEL: 调用字符串的getBytes方法，然后调用length属性</span><br><span class="line">@Value(&quot;#&#123;&#39;Hello World&#39;.bytes.length&#125;&quot;)</span><br><span class="line">private String helloWorldbytes;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&#123;...&#125;和#&#123;...&#125;可以混合使用，如下文代码执行顺序：通过$&#123;server.name&#125;从属性文件中获取值并进行替换，然后就变成了 执行SpEL表达式&#123;‘server1,server2,server3’.split(‘,’)&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; SpEL: 传入一个字符串，根据&quot;,&quot;切分后插入列表中， #&#123;&#125;和$&#123;&#125;配置使用(注意单引号，注意不能反过来$&#123;&#125;在外面，#&#123;&#125;在里面)</span><br><span class="line">    @Value(&quot;#&#123;&#39;$&#123;server.name&#125;&#39;.split(&#39;,&#39;)&#125;&quot;)</span><br><span class="line">    private List&lt;String&gt; servers;</span><br><span class="line">    </span><br><span class="line">	&#x2F;&#x2F; SpEL: 注意不能反过来$&#123;&#125;在外面，#&#123;&#125;在里面，这个会执行失败</span><br><span class="line">    @Value(&quot;$&#123;#&#123;&#39;HelloWorld&#39;.concat(&#39;_&#39;)&#125;&#125;&quot;)</span><br><span class="line">    private List&lt;String&gt; servers2;    </span><br><span class="line">因为spring执行$&#123;&#125;是时机要早于#&#123;&#125;。在本例中，Spring会尝试从属性中查找#&#123;‘HelloWorld’.concat(‘_’)&#125;，那么肯定找不到，由上文已知如果找不到，然后报错。所以$&#123;&#125;在外面，#&#123;&#125;在里面是非法操作    </span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/07/12.1.spring/" data-id="ckvrw5fqk006r5gwdgmd06o6d" data-title="spring" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/07/13.1.mybatis/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          mybatis
        
      </div>
    </a>
  
  
    <a href="/2021/04/07/8.6.VUE/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">VUE</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>