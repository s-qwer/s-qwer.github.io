<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>SpringBoot | swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Spring Boot 是基于Spring的一套快速开发整合包。 Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置），这样我们就可以简单的开始。多数SpringBoot应用只需要很少的Spring配置。 2.3.2 用途介绍 Spring Bo">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot">
<meta property="og:url" content="https://s-qwer.github.io/2021/04/17/12.3.SpringBoot/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="Spring Boot 是基于Spring的一套快速开发整合包。 Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置），这样我们就可以简单的开始。多数SpringBoot应用只需要很少的Spring配置。 2.3.2 用途介绍 Spring Bo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/image-20210816141410343.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwFK8l2otg0LzIn17yFGT5Odud0qic2e8xVR4lXmvibuDE39cRakXQDicxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/1353055-20190723115827369-137054437.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/1353055-20190723120750063-1637394085.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/1353055-20190723121014479-355020614.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/1353055-20190723121259049-1268764937.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/1353055-20190723115133055-806425816.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/1353055-20190723121249738-1640041332.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/1353055-20190723113653670-484594019.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/9b44287bd9e642abfc8edcd09a51b87a.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/1055208-20180316120820674-2029592173.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/2599320-5bdab563c3050406.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/1055208-20180309165042456-532167462.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/1055208-20180309165117679-1753916897.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwiakI4r3b9jZ4o76vYGkxmwSmRibQ5POBwGyFLM7Frakdc6Bshjn9iaOqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vweu8mKjeLr2ObBktFVLyrZvYT8icicxjyibTGsrvRKAayHPbYPItCOwMpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwpsl2q2cwqbRhADxVWeglaIWQp4G9dz9QaJBibOIPH9PsmEkdIK1ejDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwjenFeGzxSpZRluvzRoXakJpxEdlXQeRwhKY4dHSfSvzLWwkb3mMXAw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwmKY2G35mehPDl0JLbWGSGBVhCicJsVgzqDuFVd2elK6XGCicTSHU6ibfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwCiasLxHPa4CgF4ialicAuzygfKaNbe8BUXXDD0eWemaDzKh9C1S91nHSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vw1B6tqzEX4bo1m5pBvDkKo0D9VwZiagnRibxW1ek1VVERMuRkN4Sib3Mgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/2411352-1b8c22fae3f6a072.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/20190610231257254.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/20190610231539914.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/20190610231757330.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/20190610233854182.png">
<meta property="og:image" content="https://s-qwer.github.io/12.3.SpringBoot/20181220165535820.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwQ0g16A0M2u8FtjicATQWpxfqRqAAIxpexYh0nYoZTVbxWyVdyKSy0iaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwfSJ3M2E2CH295oCIWdKYiayZPz4B3RFGibX5tHLlUqCYABKqiaLASDvWg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwmSnFVzD1lv7yyqibGtymFIjf9ickz8Ak2vRCergkAOdK7gzCXNAMBQicA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200811152649433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjgyMjQ4NA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190801203834598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM5Mjk4NjI1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190801204126964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM5Mjk4NjI1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019080120463896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM5Mjk4NjI1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190801205736116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM5Mjk4NjI1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190801205931712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM5Mjk4NjI1,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2021-04-17T05:05:53.000Z">
<meta property="article:modified_time" content="2021-11-08T09:57:48.873Z">
<meta property="article:author" content="swx">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s-qwer.github.io/12.3.SpringBoot/image-20210816141410343.png">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-12.3.SpringBoot" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/12.3.SpringBoot/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T05:05:53.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      SpringBoot
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Spring Boot 是基于Spring的一套快速开发整合包。</p>
<p>Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置），这样我们就可以简单的开始。多数SpringBoot应用只需要很少的Spring配置。</p>
<p>2.3.2 用途介绍</p>
<p>Spring Boot的核心思想就是约定大于配置,一切自动完成。采用 Spring Boot可以大大的简化你的开发模式,所有你想集成的常用框架,它都有对应的组件支持。你甚至都不用额外的WEB容器，直接生成jar包执行即可，因为spring-boot-starter-web模块中包含有一个内置tomcat，可以直接提供容器使用；基于Spring Boot，不是说原来的配置没有了，而是Spring Boot有一套默认配置，我们可以把它看做比较通用的约定，而Spring Boot遵循的也是约定优于配置原则，同时，如果你需要使用到Spring以往提供的各种复杂但功能强大的配置功能，SpringBoot一样支持</p>
<p>在Spring Boot中，你会发现你引入的所有包都是starter形式，如：</p>
<p>·  spring-boot-starter-web-services，针对SOAP Web Services</p>
<p>·  spring-boot-starter-web，针对Web应用与网络接口</p>
<p>·  spring-boot-starter-jdbc，针对JDBC</p>
<p>·  spring-boot-starter-data-jpa，一套JPA应用框架</p>
<p>·  spring-boot-starter-cache，针对缓存支持</p>
<p>·  等等</p>
<p>Spring Boot对starter的解释如下：</p>
<p>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go</p>
<p>这句话的译意为：</p>
<p>Starters是一系列极其方便的依赖描述，通过在你的项目中包含这些starter，你可以一站式获得你所需要的服务，而无需像以往那样copy各种示例配置及代码，然后调试，真正做到开箱即用；比如你想使用Spring JPA进行数据操作，只需要在你的项目依赖中引入spring-boot-starter-data-jpa即可。</p>
<p>2.3.3 主要目标</p>
<p>1.为所有Spring的开发提供一个从根本上更快的入门体验</p>
<p>2.开箱即用，但通过自己设置参数，即可快速摆脱这种方式。</p>
<p>3.提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等</p>
<p>4.绝对没有代码生成，也无需 XML 配置。</p>
<p>SpringBoot会使用内置的tomcat</p>
<p>SpringBoot的启动主要是通过实例化SpringApplication来启动的，启动过程主要做了以下几件事情：配置属性、获取监听器，发布应用开始启动事件初、始化输入参数、配置环境，输出banner、<strong>创建上下文</strong>、预处理上下文、<strong>刷新上下文</strong>、再刷新上下文、发布应用已经启动事件、发布应用启动完成事件。在SpringBoot中启动tomcat的工作在刷新上下这一步。而tomcat的启动主要是实例化两个组件：Connector、Container，一个tomcat实例就是一个Server，一个Server包含多个Service，也就是多个应用程序，每个Service包含多个Connector和一个Container，而一个Container下又包含多个子容器</p>
<h2 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h2><p>约定优于配置（convention over configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性</p>
<p>1.开发人员仅需规定应用中不符合约定的部分<br>2.在没有规定配置的地方，采用默认配置，以力求最简配置为核心思想<br>总的来说，上面两条都遵循了推荐默认配置的思想。当存在特殊需求的时候，自定义配置即可。这样可以大大的减少配置工作，这就是所谓的“约定”。</p>
<p>spring boot中的约定：</p>
<p>1.Maven的目录结构。默认有resources文件夹,存放资源配置文件。src-main-resources,src-main-java。默认的编译生成的类都在targe文件夹下面<br>2.spring boot默认的配置文件必须是，也只能是application.命名的yml文件或者properties文件，且唯一<br>3.application.yml中默认属性。数据库连接信息必须是以spring: datasource: 为前缀；多环境配置。该属性可以根据运行环境自动读取不同的配置文件；端口号、请求路径等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># 配置端口</span><br><span class="line">server:</span><br><span class="line">  port: 9005</span><br><span class="line">  servlet:</span><br><span class="line">    #context-path: &#x2F;api</span><br><span class="line">    application-display-name: swx</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: swx-wx-program</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  mvc:</span><br><span class="line">    static-path-pattern: &#x2F;api&#x2F;swx&#x2F;data&#x2F;**</span><br><span class="line">  resources:</span><br><span class="line">    static-locations: classpath:&#x2F;METAINF&#x2F;resources&#x2F;,classpath:&#x2F;resources&#x2F;,classpath:&#x2F;static&#x2F;,classpath:&#x2F;public&#x2F;,file:$&#123;attachment.filePath&#125;</span><br><span class="line">  # 配置数据源</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;swx?useUnicode&#x3D;yes&amp;characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;true&amp;serverTimezone&#x3D;GMT%2B8</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    # 使用druid数据源</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    #   数据源其他配置</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line">  redis:</span><br><span class="line">    pool:</span><br><span class="line">      max-active: 8</span><br><span class="line">      max-wait: 3</span><br><span class="line">      max-idle: 8</span><br><span class="line">      min-idle: 0</span><br><span class="line">    timeout: 6000</span><br><span class="line">    host: 192.168.0.1</span><br><span class="line">    port: 6379</span><br><span class="line"></span><br><span class="line"># 关闭安全验证</span><br><span class="line">management:</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      enabled: true</span><br><span class="line">  security:</span><br><span class="line">    enabled: false</span><br><span class="line"># mybatis-plus相关配置</span><br><span class="line">mybatis-plus:</span><br><span class="line">  # xml扫描，多个目录用逗号或者分号分隔（告诉 Mapper 所对应的 XML 文件位置）</span><br><span class="line">  mapper-locations: classpath:**&#x2F;*Mapper.xml</span><br><span class="line">  # 以下配置均有默认值,可以不设置</span><br><span class="line">  global-config:</span><br><span class="line">    #主键类型  0:&quot;数据库ID自增&quot;, 1:&quot;用户输入ID&quot;,2:&quot;全局唯一ID (数字类型唯一ID)&quot;, 3:&quot;全局唯一ID UUID&quot;;</span><br><span class="line">    id-type: 0</span><br><span class="line">    #字段策略 0:&quot;忽略判断&quot;,1:&quot;非 NULL 判断&quot;),2:&quot;非空判断&quot;</span><br><span class="line">    field-strategy: 2</span><br><span class="line">    #驼峰下划线转换</span><br><span class="line">    db-column-underline: true</span><br><span class="line">    #刷新mapper 调试神器</span><br><span class="line">    refresh-mapper: false</span><br><span class="line">  configuration:</span><br><span class="line">    # 是否开启自动驼峰命名规则映射:从数据库列名到Java属性驼峰命名的类似映射</span><br><span class="line">    map-underscore-to-camel-case: true</span><br><span class="line">    cache-enabled: false</span><br><span class="line">    # 如果查询结果中包含空值的列，则 MyBatis 在映射的时候，不会映射这个字段</span><br><span class="line">    #call-setters-on-nulls: true</span><br><span class="line">    # 这个配置会将执行的sql在控制台打印出来，在开发或测试的时候可以用</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">    # 解决oracle更新数据为null时无法转换报错，mysql不会出现此情况</span><br><span class="line">    jdbc-type-for-null: &#39;null&#39;</span><br><span class="line"></span><br><span class="line">#请求服务器地址的基础路径</span><br><span class="line">baseUrl: </span><br><span class="line">#前端项目路径地址</span><br><span class="line">baseWebUrl: </span><br><span class="line"></span><br><span class="line">attachment:</span><br><span class="line">  filePath: &#x2F;swx&#x2F;data&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/12.3.SpringBoot/image-20210816141410343.png" alt="image-20210816141410343"></p>
<h2 id="配置注解"><a href="#配置注解" class="headerlink" title="配置注解"></a><strong>配置注解</strong></h2><h3 id="主配置类"><a href="#主配置类" class="headerlink" title="主配置类"></a>主配置类</h3><h4 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1.@SpringBootApplication"></a>1.@SpringBootApplication</h4><p>Spring boot的主配置类，Spring boot的启动类</p>
<p>@SpringBootApplication是一个复合注解，包含了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan这三个注解，大多数情况下，这3个注解会被同时使用，基于最佳实践，这三个注解就被做了包装@SpringBootApplication注解。</p>
<p>springboot中有着SpringBootServletInitializer这样一个组件，它关系着程序的初始化</p>
<p>Springboot启动项目方式:</p>
<p>1.application.xml启动</p>
<p>默认application启动，在创建项目时自动生成application启动类，直接run执行即可</p>
<p>2.使用外置tomcat启动</p>
<p>默认启动类要继承SpringBootServletInitiailzer类，并复写configure()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileuploadApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SpringApplication.run(FileuploadApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.configure(builder);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>需要添加本地tomcat并进行配置</p>
<p>SpringBootServletInitializer的执行过程，简单来说就是通过SpringApplicationBuilder构建并封装SpringApplication对象，并最终调用SpringApplication的run方法的过程。</p>
<p>spring boot就是为了简化开发的，也就是用注解的方式取代了传统的xml配置。</p>
<p>SpringBootServletInitializer就是原有的web.xml文件的替代。</p>
<p>使用了嵌入式Servlet,默认是不支持jsp。</p>
<p>SpringBootServletInitializer 可以使用外部的Servlet容器，使用步骤：</p>
<p>·必须创建war项目，需要创建好web项目的目录。</p>
<p>·嵌入式Tomcat依赖scope指定provided。</p>
<p>·编写SpringBootServletInitializer类子类,并重写configure方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ServletInitializer extends SpringBootServletInitializer</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder application)</span><br><span class="line">    &#123;</span><br><span class="line">        return application.sources(SpringBoot04WebJspApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>·开始启动服务器。</p>
<p>jar包和war包启动区别</p>
<p>jar包:执行SpringBootApplication的run方法,启动IOC容器,然后创建嵌入式Servlet容器</p>
<p>war包: 先是启动Servlet服务器,服务器启动Springboot应用(springBootServletInitizer),然后启动IOC容器</p>
<p>SpringBootServletInitializer实例执行onStartup方法的时候会通过createRootApplicationContext方法来执行run方法，接下来的过程就同以jar包形式启动的应用的run过程一样了，在内部会创建IOC容器并返回，只是以war包形式的应用在创建IOC容器过程中，不再创建Servlet容器了。</p>
<h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>标注当前类是配置类<br>会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到srping容器中，并且实例名就是方法名 继承自@Configuration。</p>
<h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>自动配置的注解<br>自动配置的注解，根据我们添加的组件jar来完成一些默认配置 我们做微服时会添加spring-boot-starter-web这个组件jar的pom依赖，这样配置会默认配置springmvc 和tomcat</p>
<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>扫描当前包及其子包下被@Component，@Controller，@Service，@Repository<br>扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到spring容器中进行管理。 等价于context:component-scan的xml配置文件中的配置项</p>
<h4 id="2-ServletComponentScan"><a href="#2-ServletComponentScan" class="headerlink" title="2.@ServletComponentScan"></a>2.@ServletComponentScan</h4><p>filter的实现，用在Spring boot的启动类</p>
<p>Servlet、Filter、Listener 可以直接通过 @WebServlet、@WebFilter、@WebListener 注解自动注册，这样通过注解servlet ，拦截器，监听器的功能而无需其他配置，所以项目中使用到了filter的实现，用到了这个注解。</p>
<h4 id="3-MapperScan-“dao路径”"><a href="#3-MapperScan-“dao路径”" class="headerlink" title="3.@MapperScan(“dao路径”)"></a>3.@MapperScan(“dao路径”)</h4><p>整合Mybatis，用在Spring boot的启动类    @mapper</p>
<p>@Mapper注解与@MapperScan注解有什么关联呢？</p>
<ol>
<li>使用@Mapper，最终Mybatis会有一个拦截器，会自动的把@Mapper注解的接口生成动态代理类。</li>
<li>使用@MapperScan配置一个或多个包路径，自动的扫描这些包路径下的类，自动的为它们生成动态代理类。</li>
<li>@Mapper注解针对的是一个接口一个接口的使用，太麻烦了。</li>
<li>@MapperScan注解针对的是一个或多个包中的所有接口，相比@Mapper注解来说非常简单。</li>
</ol>
<h4 id="4-EnableScheduling"><a href="#4-EnableScheduling" class="headerlink" title="4.@EnableScheduling"></a>4.@EnableScheduling</h4><p>允许schedul定时任务，表明此类是一个定时计划类</p>
<p>@Scheduled(fixedRate = 5000) ：要执行的具体计划任务</p>
<p>参数</p>
<p>1.cron:cron表达式语句</p>
<p>2.zone:时区，接收一个java.util.TimeZone#ID。默认空字符串，即取服务器所在的时区</p>
<p>3.fixedDelay：上一次执行完毕多长时间点后多长时间再执行</p>
<p>4.fixedDelayString：与fixedDelay意思相同，只是使用字符串的形式，支持占位符</p>
<p>5.fixedRate：与上一次开始执行时间点之后多长时间再执行</p>
<p>6.fixedRateString：与fixedRate意思相同，只是使用字符串的形式，支持占位符</p>
<p>7.initialDelay：第一次延迟多长时间后再执行</p>
<p>8.initialDelayString :与initialDelay意思相同，只是使用字符串的形式，支持占位符</p>
<h4 id="5-EnableCaching"><a href="#5-EnableCaching" class="headerlink" title="5.@EnableCaching"></a>5.@EnableCaching</h4><p>使用缓存</p>
<h4 id="6-EnableTransactionManagement"><a href="#6-EnableTransactionManagement" class="headerlink" title="6.@EnableTransactionManagement"></a>6.@EnableTransactionManagement</h4><p>开启事务注解支持</p>
<h3 id="单元测试常用注解"><a href="#单元测试常用注解" class="headerlink" title="单元测试常用注解"></a>单元测试常用注解</h3><h4 id="RunWith-SpringJUnit4ClassRunner-class-、-SpringRunner-class"><a href="#RunWith-SpringJUnit4ClassRunner-class-、-SpringRunner-class" class="headerlink" title="@RunWith(SpringJUnit4ClassRunner.class)、(SpringRunner.class)"></a>@RunWith(SpringJUnit4ClassRunner.class)、(SpringRunner.class)</h4><p>测试类，让测试运行于Spring测试环境。<br>SpringRunner 继承了SpringJUnit4ClassRunner，没有扩展任何功能；使用SpringRunner，名字简短而已</p>
<h4 id="SpringBootTest"><a href="#SpringBootTest" class="headerlink" title="@SpringBootTest"></a>@SpringBootTest</h4><p>Springboot环境下测试</p>
<h4 id="Test"><a href="#Test" class="headerlink" title="@Test"></a>@Test</h4><p>junit单元测试，单元测试方法上    ，方法要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void 方法名() &#123;&#125;     &#x2F;&#x2F;公共方法、无返回值、方法无参数</span><br></pre></td></tr></table></figure>

<pre><code>@Ignore：表示这个方法不进行单元测试
@Before: 在每个方法执行运行
@After：在每个方法之后运行
</code></pre>
<h4 id="Before"><a href="#Before" class="headerlink" title="@Before"></a>@Before</h4><p>预加载，测试方法前        </p>
<h4 id="WebAppConfiguration"><a href="#WebAppConfiguration" class="headerlink" title="@WebAppConfiguration"></a>@WebAppConfiguration</h4><p>web应用测试</p>
<h3 id="Controller常用注解"><a href="#Controller常用注解" class="headerlink" title="Controller常用注解"></a>Controller常用注解</h3><h4 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h4><p>用于Controller标识，@Controller 和@ResponseBody的结合<br>@Controller 表明这个类是一个控制器类，和 @RequestMapping 来配合使用拦截请求，如果不在method中注明请求的方式，默认是拦截get和post请求。这样请求会完成后转向一个视图解析器。但是在大多微服务搭建的时候，前后端会做分离。所以请求后端只关注数据处理，后端返回json数据的话，需要配合 @ResponseBody 注解来完成。</p>
<h4 id="GetMapping、PostMapping、PutMapping、DeleteMapping"><a href="#GetMapping、PostMapping、PutMapping、DeleteMapping" class="headerlink" title="@GetMapping、PostMapping、PutMapping、DeleteMapping"></a>@GetMapping、PostMapping、PutMapping、DeleteMapping</h4><p>rest风格</p>
<table>
<thead>
<tr>
<th>普通风格</th>
<th>Rest风格</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping(value=“”,method = RequestMethod.GET)</td>
<td>@GetMapping(value =“”)</td>
</tr>
</tbody></table>
<p>@GetMapping    Get请求<br>@PostMapping    Post请求<br>@PutMapping    订单确认<br>@DeleteMapping    取消订单</p>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>按类型自动注入</p>
<h3 id="Restful之swagger"><a href="#Restful之swagger" class="headerlink" title="Restful之swagger"></a>Restful之swagger</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- swagger是当前最好用的Restful --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;$&#123;swagger2.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;swagger2.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Api-value-“订单Controller”-tags-“订单Controller”"><a href="#Api-value-“订单Controller”-tags-“订单Controller”" class="headerlink" title="@Api(value = “订单Controller”, tags = {“订单Controller”})"></a>@Api(value = “订单Controller”, tags = {“订单Controller”})</h4><p>value - 字段说明，description - 注释说明这个类</p>
<h4 id="ApiOperation-value-“订单确认接口”"><a href="#ApiOperation-value-“订单确认接口”" class="headerlink" title="@ApiOperation(value = “订单确认接口”)"></a>@ApiOperation(value = “订单确认接口”)</h4><p>在restful风格方法上配合使用<br>@ApiOperation(value = “订单取消接口”)<br>@DeleteMapping(value = “/order/{orderId}”)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">作用范围			API									使用位置</span><br><span class="line">对象属性			@ApiModelProperty					用在参数对象的字段上</span><br><span class="line">协议集描述		    @Api							    用在Conntroller类上</span><br><span class="line">协议描述			@ApiOperation						用在controller方法上</span><br><span class="line">Response集		  @ApiResponses						  用在controller方法上</span><br><span class="line">Response	       @ApiResponse							用在@ApiResponses里面</span><br><span class="line">非对象参数集			@ApilmplicitParams					用在controller方法上</span><br><span class="line">非对象参数描述			@ApiImplicitParam					用在@ApiImplicitParams的方法里边</span><br><span class="line">描述返回对象的意义		@ApiModel							用在返回对象类上</span><br></pre></td></tr></table></figure>

<h3 id="配置文件相关"><a href="#配置文件相关" class="headerlink" title="配置文件相关"></a>配置文件相关</h3><h4 id="Value-“-spring-datasource-druid-url-”"><a href="#Value-“-spring-datasource-druid-url-”" class="headerlink" title="@Value(“${spring.datasource.druid.url}”)"></a>@Value(“${spring.datasource.druid.url}”)</h4><p>注入配置文件中的值</p>
<p>​        </p>
<h4 id="ImportResource-Import-PropertySource"><a href="#ImportResource-Import-PropertySource" class="headerlink" title="@ImportResource         @Import        @PropertySource"></a>@ImportResource         @Import        @PropertySource</h4><p>用来导入自定义的一些配置文件</p>
<h4 id="ImportResource-locations-导入其他xml配置文件，需要标准在主配置类上。"><a href="#ImportResource-locations-导入其他xml配置文件，需要标准在主配置类上。" class="headerlink" title="@ImportResource(locations={}) 导入其他xml配置文件，需要标准在主配置类上。"></a>@ImportResource(locations={}) 导入其他xml配置文件，需要标准在主配置类上。</h4><p>导入property的配置文件 @PropertySource指定文件路径，这个相当于使用spring的标签来完成配置项的引入。</p>
<p>@import注解是一个可以将普通类导入到spring容器中做管理</p>
<h4 id="EnableAsync-proxyTargetClass-true"><a href="#EnableAsync-proxyTargetClass-true" class="headerlink" title="@EnableAsync(proxyTargetClass = true)"></a>@EnableAsync(proxyTargetClass = true)</h4><p>异步代理，构建异步线程池</p>
<p>使用@EnableAsync来开启异步的支持，使用@Async来对某个方法进行异步执行</p>
<p>在定时器里可以设置多个不同线程的任务同时完成不同的事情</p>
<h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>配置类</p>
<h4 id="Bean-“analysisExecutor”"><a href="#Bean-“analysisExecutor”" class="headerlink" title="@Bean(“analysisExecutor”)"></a>@Bean(“analysisExecutor”)</h4><p>相当于<bean></bean>，标注在方法上，方法返回值就是bean类型，bean的id默认为方法名，可以通过给@bean注解加value属性值改变id。</p>
<h4 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h4><p>切面，事务</p>
<h4 id="Scope-“prototype”"><a href="#Scope-“prototype”" class="headerlink" title="@Scope(“prototype”)"></a>@Scope(“prototype”)</h4><p>bean的作用范围，多例，httpclientConfig</p>
<h4 id="EnableRedisHttpSession-maxInactiveIntervalInSeconds-1800-redisFlushMode-RedisFlushMode-ON-SAVE-redisNamespace-“dscSession”"><a href="#EnableRedisHttpSession-maxInactiveIntervalInSeconds-1800-redisFlushMode-RedisFlushMode-ON-SAVE-redisNamespace-“dscSession”" class="headerlink" title="@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800,redisFlushMode = RedisFlushMode.ON_SAVE, redisNamespace = “dscSession”)"></a>@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800,redisFlushMode = RedisFlushMode.ON_SAVE, redisNamespace = “dscSession”)</h4><p>redissession 默认30分钟失效</p>
<h4 id="EnableWebMvc"><a href="#EnableWebMvc" class="headerlink" title="@EnableWebMvc"></a>@EnableWebMvc</h4><p>用于spring mvc 配置类，启用springmvc</p>
<h4 id="EnableSwagger2"><a href="#EnableSwagger2" class="headerlink" title="@EnableSwagger2"></a>@EnableSwagger2</h4><p>restful风格，使用Swagger2</p>
<h3 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h3><p>@Param(“ids”) Integer[] ids, @Param(“userId”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapper接口中有多个参数</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h4><p>全局异常处理<br>全局数据绑定<br>全局数据预处理</p>
<h4 id="ExceptionHandler-BindException-class"><a href="#ExceptionHandler-BindException-class" class="headerlink" title="@ExceptionHandler(BindException.class)"></a>@ExceptionHandler(BindException.class)</h4><p>1、@ExceptionHandler不需要写在目标方法上，而是写在通知处理方法上<br>2、@ExceptionHandler自动拦截所设置的异常  作用范围这个controller,<br>—这种情况一般定义个父类，然后每个controller继承即可</p>
<h3 id="lombok插件使用"><a href="#lombok插件使用" class="headerlink" title="lombok插件使用"></a>lombok插件使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h4><p>首先在idea中安装lombok插件<br>@Data : 注解在类上,<br>就不用再去手写Getter,Setter,equals,canEqual,hasCode,toString等方法了，<br>注解后在编译时会自动加进去</p>
<h4 id="NoArgsConstructor-Getter-Setter"><a href="#NoArgsConstructor-Getter-Setter" class="headerlink" title="@NoArgsConstructor     @Getter      @Setter"></a>@NoArgsConstructor     @Getter      @Setter</h4><p>使用后创建一个无参构造函数、getter、setter</p>
<h4 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h4><p>使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数</p>
<h4 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h4><p>关于Builder较为复杂一些，Builder的作用之一是为了解决在某个类有很多构造函数的情况，也省去写很多构造函数的麻烦，<br>在设计模式中的思想是：用一个内部类去实例化一个对象，避免一个类出现过多构造函数，</p>
<h4 id="Accessors"><a href="#Accessors" class="headerlink" title="@Accessors"></a>@Accessors</h4><p>存取器。通过该注解可以控制getter和setter方法的形式，默认为false</p>
<p>1.fluent为一个布尔值，如果为true生成的get/set方法则没有set/get前缀，默认为false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Accessors(fluent &#x3D; true)</span><br><span class="line">class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 生成的getter和setter方法如下，方法体略</span><br><span class="line">    public Integer id()&#123;&#125;</span><br><span class="line">    public User id(Integer id)&#123;&#125;</span><br><span class="line">    public String name()&#123;&#125;</span><br><span class="line">    public User name(String name)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.chain为一个布尔值，如果为true生成的set方法返回this，为false生成的set方法是void类型。默认为false，除非当fluent为true时，chain默认则为true。<br>这个比较常用，由于set方法返回的是this对象，常用来实现链式编程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.setName(&quot;张三&quot;).setAge(12).setHeight(175)</span><br></pre></td></tr></table></figure>

<p>3.prefix为一系列string类型，可以指定前缀，生成get/set方法时会去掉指定的前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Accessors(prefix &#x3D; &quot;m&quot;)</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private int mNum;</span><br><span class="line">&#125;</span><br><span class="line">生成的get方法为getNum()，而不是getMNum()</span><br></pre></td></tr></table></figure>



<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><h4 id="ConditionalOnProperty-prefix-“dsc”-name-“ticketWatcherMaster”-havingValue-“true”"><a href="#ConditionalOnProperty-prefix-“dsc”-name-“ticketWatcherMaster”-havingValue-“true”" class="headerlink" title="@ConditionalOnProperty(prefix = “dsc”, name=“ticketWatcherMaster”, havingValue = “true”)"></a>@ConditionalOnProperty(prefix = “dsc”, name=“ticketWatcherMaster”, havingValue = “true”)</h4><p>监控转换队列是否有超时ticket,如果超时自动补偿ticket</p>
<h4 id="Scheduled-cron-“0-0-2-”"><a href="#Scheduled-cron-“0-0-2-”" class="headerlink" title="@Scheduled(cron = “0 0/2 * * * ?”)"></a>@Scheduled(cron = “0 0/2 * * * ?”)</h4><p>定期监控,补偿超时的ticket,2分钟执行一次,延迟60秒启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*&quot;0 0 12 * * ?&quot; 每天中午十二点触发 </span><br><span class="line">&quot;0 15 10 ? * *&quot; 每天早上10：15触发 </span><br><span class="line">&quot;0 15 10 * * ?&quot; 每天早上10：15触发 </span><br><span class="line">&quot;0 15 10 * * ? *&quot; 每天早上10：15触发 </span><br><span class="line">&quot;0 15 10 * * ? 2005&quot; 2005年的每天早上10：15触发</span><br><span class="line">&quot;0 * 14 * * ?&quot; 每天从下午2点开始到2点59分每分钟一次触发 </span><br><span class="line">&quot;0 0&#x2F;5 14 * * ?&quot; 每天从下午2点开始到2：55分结束每5分钟一次触发</span><br><span class="line">&quot;0 0&#x2F;5 14,18 * * ?&quot; 每天的下午2点至2：55和6点至6点55分两个时间段内每5分钟一次触发 </span><br><span class="line">&quot;0 0-5 14 * * ?&quot;  每天14:00至14:05每分钟一次触发 </span><br><span class="line">&quot;0 10,44 14 ? 3 WED&quot; 三月的每周三的14：10和14：44触发 </span><br><span class="line">&quot;0 15 10 ? * MON-FRI&quot; 每个周一、周二、周三、周四、周五的10：15触发 </span><br><span class="line">&quot;0 15 10 15 * ?&quot; 每月15号的10：15触发 </span><br><span class="line">&quot;0 15 10 L * ?&quot; 每月的最后一天的10：15触发 </span><br><span class="line">&quot;0 15 10 ? * 6L&quot; 每月最后一个周五的10：15触发 </span><br><span class="line">&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月最后一个周五的10：15触发</span><br><span class="line">&quot;0 15 10 ? * 6#3&quot; 每月的第三个周五的10：15触发*&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="WebListener"><a href="#WebListener" class="headerlink" title="@WebListener"></a>@WebListener</h4><p>启动监听器 web监听</p>
<h3 id="事务通知"><a href="#事务通知" class="headerlink" title="事务通知"></a>事务通知</h3><h4 id="Pointcut-value-“execution-com-yozo-dsc-web…-…-”"><a href="#Pointcut-value-“execution-com-yozo-dsc-web…-…-”" class="headerlink" title="@Pointcut(value = “execution(* com.yozo.dsc.web….(…))”)"></a>@Pointcut(value = “execution(* com.yozo.dsc.web….(…))”)</h4><p>切点</p>
<h4 id="AfterReturning-value-“webRequest-”"><a href="#AfterReturning-value-“webRequest-”" class="headerlink" title="@AfterReturning(value = “webRequest()”)"></a>@AfterReturning(value = “webRequest()”)</h4><p>后置通知</p>
<h4 id="Around-value-“getFileHeaderBOByHead-”"><a href="#Around-value-“getFileHeaderBOByHead-”" class="headerlink" title="@Around(value = “getFileHeaderBOByHead()”)"></a>@Around(value = “getFileHeaderBOByHead()”)</h4><p>环绕通知</p>
<h4 id="Before-value-“onlineConvert-amp-amp-args-domainBo-dscOnlineParamBo-”"><a href="#Before-value-“onlineConvert-amp-amp-args-domainBo-dscOnlineParamBo-”" class="headerlink" title="@Before(value = “onlineConvert() &amp;&amp; args(domainBo,dscOnlineParamBo)”)"></a>@Before(value = “onlineConvert() &amp;&amp; args(domainBo,dscOnlineParamBo)”)</h4><p>前置通知</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化邮箱线程池</span><br></pre></td></tr></table></figure>

<h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><h4 id="RocketMQMessageListener-topic-MQConstant-ConvertFinishMqTopic-consumerGroup-“-rocketmq-consumer-group-”-consumeMode-ConsumeMode-CONCURRENTLY-messageModel-MessageModel-CLUSTERING"><a href="#RocketMQMessageListener-topic-MQConstant-ConvertFinishMqTopic-consumerGroup-“-rocketmq-consumer-group-”-consumeMode-ConsumeMode-CONCURRENTLY-messageModel-MessageModel-CLUSTERING" class="headerlink" title="@RocketMQMessageListener(topic = MQConstant.ConvertFinishMqTopic, consumerGroup = “${rocketmq.consumer.group}”, consumeMode = ConsumeMode.CONCURRENTLY, messageModel = MessageModel.CLUSTERING)"></a>@RocketMQMessageListener(topic = MQConstant.ConvertFinishMqTopic, consumerGroup = “${rocketmq.consumer.group}”, consumeMode = ConsumeMode.CONCURRENTLY, messageModel = MessageModel.CLUSTERING)</h4><p>RocketMQ监听</p>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><h4 id="ConditionalOnBean-RedisConfig-class"><a href="#ConditionalOnBean-RedisConfig-class" class="headerlink" title="@ConditionalOnBean(RedisConfig.class)"></a>@ConditionalOnBean(RedisConfig.class)</h4><h4 id="Qualifier-“dscRedisTemplate”"><a href="#Qualifier-“dscRedisTemplate”" class="headerlink" title="@Qualifier(“dscRedisTemplate”)"></a>@Qualifier(“dscRedisTemplate”)</h4><h4 id="Service-“redisService”"><a href="#Service-“redisService”" class="headerlink" title="@Service(“redisService”)"></a>@Service(“redisService”)</h4><h3 id="Configuration-amp-Bean"><a href="#Configuration-amp-Bean" class="headerlink" title="@Configuration &amp; @Bean"></a><strong>@Configuration &amp; @Bean</strong></h3><p>Spring Boot不同于传统的Spring，它不提倡使用配置文件，而是使用配置类来代替配置文件，所以该注解就是用于将一个类指定为配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置类中使用方法对组件进行注册，它的效果等价于：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wwj.springboot.bean.User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是 Spring Boot 默认会以方法名作为组件的id，也可以在 <code>@Bean()</code> 中指定value值作为组件的id。</p>
<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a><strong>@Import</strong></h3><p>在Spring中，我们可以使用@Component、@Controller、@Service、@Repository注解进行组件的注册，而对于一些第三方的类，我们无法在类上添加这些注解，为此，我们可以使用@Import注解将其注册到容器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="meta">@Import(User.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过@Import注解注册的组件，其id为全类名。</p>
<h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a><strong>@Conditional</strong></h3><p>该注解为条件装配注解，大量运用于SpringBoot底层，由该注解衍生出来的注解非常多：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwFK8l2otg0LzIn17yFGT5Odud0qic2e8xVR4lXmvibuDE39cRakXQDicxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里以@ConditionalOnBean和@ConditionalOnMissingBean举例。其中@ConditionalOnBean注解的作用是判断当前容器中是否拥有指定的Bean，若有才生效，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dog&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;user&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(name = &quot;dog&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若如此，则SpringBoot在注册User对象之前，会先判断容器中是否已经有id为 <code>dog</code> 的对象，若有才创建，否则不创建。@ConditionalOnBean注解共有三种方式判断容器中是否已经存在指定的对象，除了可以判断组件的id外，也能够通过判断组件的全类名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(type = &quot;com.wwj.springboot.bean.Dog&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以通过判断组件的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(value = Dog.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尤其需要注意的是，因为代码是从上至下依次执行的，所以在注册组件时的顺序要特别注意，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;user&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(value = Dog.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dog&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段程序中，SpringBoot会先注册User对象，而此时Dog对象还没有被注册，所以会导致User对象无法注册。</p>
<p>而@ConditionalOnMissingBean注解的作用与@ConditionalOnBean注解正好相反，它会判断当前容器中是否不存在指定的Bean，若不存在则生效，否则不生效。</p>
<p>这些注解除了能够标注在方法上，还能作用于类上，当被标注在类上时，若条件成立，则配置类的所有注册方法生效；若条件不成立，则配置类的所有注册方法均不成立。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(value = Dog.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dog&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a><strong>@ImportResource</strong></h3><p>该注解用于导入资源，比如现在有一个Spring的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ls&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wwj.springboot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;tom&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wwj.springboot.bean.Dog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tom&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若是想将其转化为配置类，代码少一点倒还好说，当配置文件中注册的Bean非常多时，采用人工的方式显然不是一个好的办法，为此，SpringBoot提供了@ImportResource注解，该注解可以将Spring的配置文件直接导入到容器中，自动完成组件注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:bean.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dog&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><strong>@ConfigurationProperties</strong></h3><p>该注解用于配置绑定，也大量运用于SpringBoot底层。首先在配置文件中编写两个键值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.name=zhangsan</span><br><span class="line">user.age=<span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>然后使用该注解将其绑定到User类上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但结果却有些出乎意料：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;name=<span class="string">&#x27;Administrator&#x27;</span>, age=<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为我们将前缀 <code>prefix</code> 指定为了user，而user可能和我们的系统配置产生了重复，所以导致了这个问题，此时我们只需将前缀修改一下即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前缀修改了，配置文件的内容也需要做相应的修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">users.name=zhangsan</span><br><span class="line">users.age=<span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，若是想实现配置绑定，就必须要将这个待绑定的类注册到容器中，比如使用@Component注解，当然，SpringBoot也提供了一个注解与其配套使用，它就是：<code>@EnableConfigurationProperties</code> </p>
<p>该注解必须标注在配置类上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(User.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用是开启指定类的配置绑定功能，它的底层其实也是通过@Import注解实现的，此时User类就无需将其注册到容器中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Boot 会自动将属性值绑定到 User 类，并将其注册到容器中。Spring Boot 相关的技术文章我整理成了 PDF，关注微信公众号「Java后端」回复「666」下载这一本技术栈手册。</p>
<h3 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h3><p>@Cacheable 注解在方法上，表示该方法的返回结果是可以缓存的</p>
<h3 id="Async"><a href="#Async" class="headerlink" title="@Async"></a>@Async</h3><p>当访问的接口较慢或者做耗时任务时，不想程序一直卡在耗时任务上，想程序能够并行执行，我们可以使用<strong>多线程</strong>来并行的处理任务</p>
<h4 id="在SpringBoot中使用-Async："><a href="#在SpringBoot中使用-Async：" class="headerlink" title="在SpringBoot中使用@Async："></a>在SpringBoot中使用@Async：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br></pre></td><td class="code"><pre><span class="line">一、异步配置（配置里主要写无返回值的异常处理）</span><br><span class="line">1.基于Java配置的启用方式：需要一个注解 @EnableAsync 开启 @Async 的功能，SpringBoot 可以放在 Application 上，也可以放其他配置文件上：</span><br><span class="line">@Configuration</span><br><span class="line">@EnableAsync</span><br><span class="line">public class SpringAsyncConfig &#123; ... &#125;</span><br><span class="line">2.基于XML配置文件的启用方式：（不常用）</span><br><span class="line">&lt;task:executor id&#x3D;&quot;myexecutor&quot; pool-size&#x3D;&quot;5&quot;  &#x2F;&gt;</span><br><span class="line">&lt;task:annotation-driven executor&#x3D;&quot;myexecutor&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二、线程池配置</span><br><span class="line">执行的线程池默认情况下找唯一的 org.springframework.core.task.TaskExecutor，或者一个 Bean 的 Name 为 taskExecutor 的java.util.concurrent.Executor 作为执行任务的线程池。如果都没有的话，会创建 SimpleAsyncTaskExecutor 线程池来处理异步方法调用，当然 @Async 注解支持一个 String 参数，来指定一个 Bean 的 Name，类型是 Executor 或 TaskExecutor，表示使用这个指定的线程池来执行这个异步任务</span><br><span class="line">@Configuration</span><br><span class="line">public class ThreadPoolConfig &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * logger</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static Logger logger &#x3D; LoggerFactory.getLogger(ThreadPoolConfig.class);</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;asyncThreadPool.corePoolSize&#125;&quot;)</span><br><span class="line">    private int corePoolSize;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;asyncThreadPool.maxPoolSize&#125;&quot;)</span><br><span class="line">    private int maxPoolSize;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;asyncThreadPool.queueCapacity&#125;&quot;)</span><br><span class="line">    private int queueCapacity;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;asyncThreadPool.keepAliveSeconds&#125;&quot;)</span><br><span class="line">    private int keepAliveSeconds;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;asyncThreadPool.awaitTerminationSeconds&#125;&quot;)</span><br><span class="line">    private int awaitTerminationSeconds;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;asyncThreadPool.threadNamePrefix&#125;&quot;)</span><br><span class="line">    private String threadNamePrefix;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 线程池配置</span><br><span class="line">     * @param</span><br><span class="line">     * @return java.util.concurrent.Executor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean(name &#x3D; &quot;threadPoolTaskExecutor&quot;)</span><br><span class="line">    public ThreadPoolTaskExecutor threadPoolTaskExecutor() &#123;</span><br><span class="line">        logger.info(&quot;---------- 线程池开始加载 ----------&quot;);</span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor &#x3D; new ThreadPoolTaskExecutor();</span><br><span class="line">        &#x2F;&#x2F; 核心线程池大小</span><br><span class="line">        threadPoolTaskExecutor.setCorePoolSize(corePoolSize);</span><br><span class="line">        &#x2F;&#x2F; 最大线程数</span><br><span class="line">        threadPoolTaskExecutor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        &#x2F;&#x2F; 队列容量</span><br><span class="line">        threadPoolTaskExecutor.setQueueCapacity(keepAliveSeconds);</span><br><span class="line">        &#x2F;&#x2F; 活跃时间</span><br><span class="line">        threadPoolTaskExecutor.setKeepAliveSeconds(queueCapacity);</span><br><span class="line">        &#x2F;&#x2F; 主线程等待子线程执行时间</span><br><span class="line">        threadPoolTaskExecutor.setAwaitTerminationSeconds(awaitTerminationSeconds);</span><br><span class="line">        &#x2F;&#x2F; 线程名字前缀</span><br><span class="line">        threadPoolTaskExecutor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line">        &#x2F;&#x2F; RejectedExecutionHandler:当pool已经达到max-size的时候，如何处理新任务</span><br><span class="line">        &#x2F;&#x2F; CallerRunsPolicy:不在新线程中执行任务，而是由调用者所在的线程来执行</span><br><span class="line">        threadPoolTaskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        threadPoolTaskExecutor.initialize();</span><br><span class="line">        logger.info(&quot;---------- 线程池加载完成 ----------&quot;);</span><br><span class="line">        return threadPoolTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">三、异常处理</span><br><span class="line">异常处理，@Async 标记的方法只能是 void 或者 Future 返回值，在无返回值的异步调用中，异步处理抛出异常，默认是SimpleAsyncUncaughtExceptionHandler 的 handleUncaughtException() 会捕获指定异常，只是简单的输出了错误日志(一般需要自定义配置异常处理)，原有任务还会继续运行，直到结束(具有 void 返回类型的方法不能将任何异常发送回调用者，默认情况下此类未捕获异常只会输出错误日志)</span><br><span class="line">在有返回值的异步调用中，异步处理抛出了异常，会直接返回主线程处理，异步任务结束执行，主线程也会被异步方法中的异常中断结束执行</span><br><span class="line">@Configuration</span><br><span class="line">@EnableAsync</span><br><span class="line">public class AsyncConfig implements AsyncConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * logger</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(AsyncConfig.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 这里不实现了，使用 ThreadPoolConfig 里的线程池即可</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     * @return java.util.concurrent.Executor</span><br><span class="line">     * @throws</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;*@Override</span><br><span class="line">    public Executor getAsyncExecutor() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 只能捕获无返回值的异步方法，有返回值的被主线程处理</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     * @return org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler</span><br><span class="line">     * @throws</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123;</span><br><span class="line">        return new CustomAsyncExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;***</span><br><span class="line">     * 处理异步方法中未捕获的异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleUncaughtException(Throwable throwable, Method method, Object... obj) &#123;</span><br><span class="line">            logger.info(&quot;Exception message - &#123;&#125;&quot;, throwable.getMessage());</span><br><span class="line">            logger.info(&quot;Method name - &#123;&#125;&quot;, method.getName());</span><br><span class="line">            logger.info(&quot;Parameter values - &#123;&#125;&quot;, Arrays.toString(obj));</span><br><span class="line">            if (throwable instanceof Exception) &#123;</span><br><span class="line">                Exception exception &#x3D; (Exception) throwable;</span><br><span class="line">                logger.info(&quot;exception:&#123;&#125;&quot;, exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">四、实际使用</span><br><span class="line">&#x2F;**</span><br><span class="line"> * AsyncController</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;async&quot;)</span><br><span class="line">public class AsyncController &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * logger</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static Logger logger &#x3D; LoggerFactory.getLogger(AsyncController.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SmsUtil smsUtil;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 可以看到无返回值异步方法出现异常，主线程还是继续执行完成</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     * @return void</span><br><span class="line">     * @throws</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;run1&quot;)</span><br><span class="line">    public String run1() throws Exception &#123;</span><br><span class="line">        asyncService.task1();</span><br><span class="line">        logger.info(&quot;run1开始执行&quot;);</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        logger.info(&quot;run1执行完成&quot;);</span><br><span class="line">        return &quot;run1 success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 可以看到有返回值异步方法出现异常，异常抛给主线程处理，导致主线程也被中断执行</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     * @return java.lang.String</span><br><span class="line">     * @throws</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;run2&quot;)</span><br><span class="line">    public String run2() throws Exception &#123;</span><br><span class="line">        Future&lt;String&gt; future &#x3D; asyncService.task2();</span><br><span class="line">        &#x2F;&#x2F; get()方法阻塞主线程，直到执行完成</span><br><span class="line">        String result &#x3D; future.get();</span><br><span class="line">        logger.info(&quot;run2开始执行&quot;);</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        logger.info(&quot;run2执行完成&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 多个异步执行</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     * @return java.lang.String</span><br><span class="line">     * @throws</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;run3&quot;)</span><br><span class="line">    public String run3() throws Exception &#123;</span><br><span class="line">        logger.info(&quot;run3开始执行&quot;);</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        Future&lt;String&gt; future3 &#x3D; asyncService.task3();</span><br><span class="line">        Future&lt;String&gt; future4 &#x3D; asyncService.task4();</span><br><span class="line">        &#x2F;&#x2F; 调用返回结果通过future.get()获取</span><br><span class="line">        logger.info(future3.get());</span><br><span class="line">        logger.info(future4.get());</span><br><span class="line">        &#x2F;&#x2F; 先判断是否执行完成</span><br><span class="line">        boolean run3Done &#x3D; Boolean.FALSE;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (future3.isDone() &amp;&amp; future4.isDone()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行完成</span><br><span class="line">                run3Done &#x3D; Boolean.TRUE;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (future3.isCancelled() || future4.isCancelled()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 取消情况</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (run3Done) &#123;</span><br><span class="line">            logger.info(future3.get());</span><br><span class="line">            logger.info(future4.get());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 其他异常情况</span><br><span class="line">        &#125;</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        logger.info(&quot;run3执行完成，执行时间: &#123;&#125;&quot;, end - start);</span><br><span class="line">        return &quot;run3 success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 工具类异步</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     * @return java.lang.String</span><br><span class="line">     * @throws</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;sms&quot;)</span><br><span class="line">    public String sms() throws Exception &#123;</span><br><span class="line">        logger.info(&quot;run1开始执行&quot;);</span><br><span class="line">        smsUtil.sendCode(&quot;15912347896&quot;, &quot;135333&quot;);</span><br><span class="line">        logger.info(&quot;run1执行完成&quot;);</span><br><span class="line">        return &quot;send sms success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * AsyncServiceImpl</span><br><span class="line"> * 有返回值时，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Service</span><br><span class="line">public class AsyncServiceImpl implements AsyncService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * logger</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static Logger logger &#x3D; LoggerFactory.getLogger(AsyncServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Async(&quot;threadPoolTaskExecutor&quot;)</span><br><span class="line">    public void task1() throws Exception &#123;</span><br><span class="line">        logger.info(&quot;task1开始执行&quot;);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        logger.info(&quot;task1执行结束&quot;);</span><br><span class="line">        throw new RuntimeException(&quot;出现异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Async(&quot;threadPoolTaskExecutor&quot;)</span><br><span class="line">    public Future&lt;String&gt; task2() throws Exception &#123;</span><br><span class="line">        logger.info(&quot;task2开始执行&quot;);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        logger.info(&quot;task2执行结束&quot;);</span><br><span class="line">        throw new RuntimeException(&quot;出现异常&quot;);</span><br><span class="line">        &#x2F;&#x2F; return new AsyncResult&lt;String&gt;(&quot;task2 success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Async(&quot;threadPoolTaskExecutor&quot;)</span><br><span class="line">    public Future&lt;String&gt; task3() throws Exception &#123;</span><br><span class="line">        logger.info(&quot;task3开始执行&quot;);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        logger.info(&quot;task3执行结束&quot;);</span><br><span class="line">        return new AsyncResult&lt;String&gt;(&quot;task3 success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Async(&quot;threadPoolTaskExecutor&quot;)</span><br><span class="line">    public Future&lt;String&gt; task4() throws Exception &#123;</span><br><span class="line">        logger.info(&quot;task4开始执行&quot;);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        logger.info(&quot;task4执行结束&quot;);</span><br><span class="line">        return new AsyncResult&lt;String&gt;(&quot;task4 success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * SmsUtil</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class SmsUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(SmsUtil.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 异步发送短信</span><br><span class="line">     *</span><br><span class="line">     * @param phone</span><br><span class="line">     * @param code</span><br><span class="line">     * @return void</span><br><span class="line">     * @throws</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Async</span><br><span class="line">    public void sendCode(String phone, String code) &#123;</span><br><span class="line">        logger.info(&quot;开始发送验证码...&quot;);</span><br><span class="line">        &#x2F;&#x2F; 模拟调用接口发验证码的耗时</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(&quot;发送成功: &#123;&#125;&quot;, phone);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">五、注意事项</span><br><span class="line">1.仅适用于 public 方法</span><br><span class="line">2.在同一个类中调用异步方法将无法正常工作(self-invocation)</span><br></pre></td></tr></table></figure>



<h4 id="基于-Async调用中的异常处理机制"><a href="#基于-Async调用中的异常处理机制" class="headerlink" title="基于@Async调用中的异常处理机制"></a>基于@Async调用中的异常处理机制</h4><p>在异步方法中，如果出现异常，对于调用者caller而言，是无法感知的。如果确实需要进行异常处理，则按照如下方法来进行处理：</p>
<pre><code>1.自定义实现AsyncTaskExecutor的任务执行器
在这里定义处理具体异常的逻辑和方式。

2.配置由自定义的TaskExecutor替代内置的任务执行器
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class ExceptionHandlingAsyncTaskExecutor implements AsyncTaskExecutor &#123;</span><br><span class="line">    private AsyncTaskExecutor executor;</span><br><span class="line">    public ExceptionHandlingAsyncTaskExecutor(AsyncTaskExecutor executor) &#123;</span><br><span class="line">        this.executor &#x3D; executor;</span><br><span class="line">     &#125;</span><br><span class="line">      &#x2F;&#x2F;&#x2F;&#x2F;用独立的线程来包装，@Async其本质就是如此</span><br><span class="line">    public void execute(Runnable task) &#123;</span><br><span class="line">      executor.execute(createWrappedRunnable(task));</span><br><span class="line">    &#125;</span><br><span class="line">    public void execute(Runnable task, long startTimeout) &#123;</span><br><span class="line">        &#x2F;用独立的线程来包装，@Async其本质就是如此</span><br><span class="line">       executor.execute(createWrappedRunnable(task), startTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">    public Future submit(Runnable task) &#123; return executor.submit(createWrappedRunnable(task));</span><br><span class="line">       &#x2F;&#x2F;用独立的线程来包装，@Async其本质就是如此。</span><br><span class="line">    &#125;</span><br><span class="line">    public Future submit(final Callable task) &#123;</span><br><span class="line">      &#x2F;&#x2F;用独立的线程来包装，@Async其本质就是如此。</span><br><span class="line">       return executor.submit(createCallable(task));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Callable createCallable(final Callable task) &#123;</span><br><span class="line">        return new Callable() &#123;</span><br><span class="line">            public T call() throws Exception &#123;</span><br><span class="line">                 try &#123;</span><br><span class="line">                     return task.call();</span><br><span class="line">                 &#125; catch (Exception ex) &#123;</span><br><span class="line">                     handle(ex);</span><br><span class="line">                     throw ex;</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Runnable createWrappedRunnable(final Runnable task) &#123;</span><br><span class="line">         return new Runnable() &#123;</span><br><span class="line">             public void run() &#123;</span><br><span class="line">                 try &#123;</span><br><span class="line">                     task.run();</span><br><span class="line">                  &#125; catch (Exception ex) &#123;</span><br><span class="line">                     handle(ex);</span><br><span class="line">                   &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    private void handle(Exception ex) &#123;</span><br><span class="line">      &#x2F;&#x2F;具体的异常逻辑处理的地方</span><br><span class="line">      System.err.println(&quot;Error during @Async execution: &quot; + ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现其实实现了AsyncTaskExecutor, 用独立的线程来执行具体的每个方法操作。在createCallable和createWrapperRunnable中，定义了异常的处理方式和机制。</p>
<p>handle()就是我们需要关注的异常处理的地方</p>
<p>配置文件中的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:annotation-driven executor&#x3D;&quot;exceptionHandlingTaskExecutor&quot; scheduler&#x3D;&quot;defaultTaskScheduler&quot; &#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;exceptionHandlingTaskExecutor&quot; class&#x3D;&quot;nl.jborsje.blog.examples.ExceptionHandlingAsyncTaskExecutor&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref&#x3D;&quot;defaultTaskExecutor&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;task:executor id&#x3D;&quot;defaultTaskExecutor&quot; pool-size&#x3D;&quot;5&quot; &#x2F;&gt;</span><br><span class="line">&lt;task:scheduler id&#x3D;&quot;defaultTaskScheduler&quot; pool-size&#x3D;&quot;1&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>这里的配置使用自定义的taskExecutor来替代缺省的TaskExecutor</p>
<p>@Async调用中的事务处理机制</p>
<p>在@Async标注的方法，同时也适用了@Transactional进行了标注；在其调用<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/mysql">数据库</a>操作之时，将无法产生事务管理的控制，原因就在于其是基于异步处理的操作。</p>
<p>那该如何给这些操作添加事务管理呢？可以将需要事务管理操作的方法放置到异步方法内部，在内部被调用的方法上添加@Transactional.</p>
<p>例如：  </p>
<p>方法A，使用了@Async/@Transactional来标注，但是无法产生事务控制的目的。</p>
<p>方法B，使用了@Async来标注，  B中调用了C、D，C/D分别使用@Transactional做了标注，则可实现事务控制的目的。</p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">1.java的代码是同步顺序执行，当我们需要执行异步操作时我们需要创建一个新线程去执行</span><br><span class="line">&#x2F;**</span><br><span class="line">     * 任务类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    class Task implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：异步任务&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F;新建线程并执行任务类</span><br><span class="line">        new Thread(new Task()).start();</span><br><span class="line">        </span><br><span class="line">java1.8之后用lambda</span><br><span class="line">        &#x2F;&#x2F;新建线程并执行任务类</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：异步任务&quot;);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">2.除了显式的new Thread，我们也可以通过线程池获取线程</span><br><span class="line">	@Autowired</span><br><span class="line">    AsyncTaskExecutor asyncTaskExecutor;&#x2F;&#x2F;注入线程池对象</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过线程池对象提交异步任务</span><br><span class="line">    asyncTaskExecutor.submit(() -&gt; &#123;</span><br><span class="line">        log.info(&quot;异步任务开始&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;省略异步任务业务逻辑...</span><br><span class="line"></span><br><span class="line">        log.info(&quot;异步任务结束&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">3.用@Async测试：</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@EnableAsync&#x2F;&#x2F;开启异步调用</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootAsyncApplication &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TestService testService;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootAsyncApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 启动成功</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public ApplicationRunner applicationRunner() &#123;</span><br><span class="line">        return applicationArguments -&gt; &#123;</span><br><span class="line">            long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：开始调用异步业务&quot;);</span><br><span class="line">            &#x2F;&#x2F;无返回值</span><br><span class="line">&#x2F;&#x2F;            testService.asyncTask();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;有返回值，但主线程不需要用到返回值</span><br><span class="line">&#x2F;&#x2F;            Future&lt;String&gt; future &#x3D; testService.asyncTask(&quot;huanzi-qch&quot;);</span><br><span class="line">            &#x2F;&#x2F;有返回值，且主线程需要用到返回值</span><br><span class="line">&#x2F;&#x2F;            System.out.println(Thread.currentThread().getName() + &quot;：返回值：&quot; + testService.asyncTask(&quot;huanzi-qch&quot;).get());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;事务测试，事务正常提交</span><br><span class="line">&#x2F;&#x2F;            testService.asyncTaskForTransaction(false);</span><br><span class="line">            &#x2F;&#x2F;事务测试，模拟异常事务回滚</span><br><span class="line">&#x2F;&#x2F;            testService.asyncTaskForTransaction(true);</span><br><span class="line"></span><br><span class="line">            long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：调用异步业务结束，耗时：&quot; + (endTime - startTime));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">测试业务类TestService</span><br><span class="line">public interface TestService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 异步调用，无返回值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void asyncTask();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 异步调用，有返回值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Future&lt;String&gt; asyncTask(String s);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 异步调用，无返回值，事务测试</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void asyncTaskForTransaction(Boolean exFlag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class TestServiceImpl implements TestService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TbUserRepository tbUserRepository;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    @Override</span><br><span class="line">    public void asyncTask() &#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;模拟耗时</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;：void asyncTask()，耗时：&quot; + (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async(&quot;asyncTaskExecutor&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public Future&lt;String&gt; asyncTask(String s) &#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;模拟耗时</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;：Future&lt;String&gt; asyncTask(String s)，耗时：&quot; + (endTime - startTime));</span><br><span class="line">        return AsyncResult.forValue(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async(&quot;asyncTaskExecutor&quot;)</span><br><span class="line">    @Transactional</span><br><span class="line">    @Override</span><br><span class="line">    public void asyncTaskForTransaction(Boolean exFlag) &#123;</span><br><span class="line">        &#x2F;&#x2F;新增一个用户</span><br><span class="line">        TbUser tbUser &#x3D; new TbUser();</span><br><span class="line">        tbUser.setUsername(&quot;huanzi-qch&quot;);</span><br><span class="line">        tbUser.setPassword(&quot;123456&quot;);</span><br><span class="line">        tbUserRepository.save(tbUser);</span><br><span class="line"></span><br><span class="line">        if(exFlag)&#123;</span><br><span class="line">            &#x2F;&#x2F;模拟异常</span><br><span class="line">            throw new RuntimeException(&quot;模拟异常&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 线程池的配置</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class AsyncConfig &#123;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_POOL_SIZE &#x3D; 50;</span><br><span class="line"></span><br><span class="line">    private static final int CORE_POOL_SIZE &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;asyncTaskExecutor&quot;)</span><br><span class="line">    public AsyncTaskExecutor asyncTaskExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor asyncTaskExecutor &#x3D; new ThreadPoolTaskExecutor();</span><br><span class="line">        asyncTaskExecutor.setMaxPoolSize(MAX_POOL_SIZE);&#x2F;&#x2F;最大线程数</span><br><span class="line">        asyncTaskExecutor.setCorePoolSize(CORE_POOL_SIZE);&#x2F;&#x2F;核心线程数 </span><br><span class="line">        asyncTaskExecutor.setThreadNamePrefix(&quot;async-task-thread-pool-&quot;);&#x2F;&#x2F;线程名称前缀</span><br><span class="line">        asyncTaskExecutor.setKeepAliveSeconds(60);&#x2F;&#x2F;空闲线程保留时间</span><br><span class="line">        asyncTaskExecutor.setQueueCapacity(200);&#x2F;&#x2F;队列容量</span><br><span class="line">        asyncTaskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());&#x2F;&#x2F;线程池对拒绝任务的处理策略：这里采用了CallerRunsPolicy策略，当线程池没有处理能力的时候，该策略会直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务</span><br><span class="line">        asyncTaskExecutor.initialize();</span><br><span class="line">        return asyncTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">配置好后，@Async会默认从线程池获取线程，当然也可以显式的指定@Async(&quot;asyncTaskExecutor&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无返回值的测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 启动成功</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public ApplicationRunner applicationRunner() &#123;</span><br><span class="line">        return applicationArguments -&gt; &#123;</span><br><span class="line">            long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：开始调用异步业务&quot;);</span><br><span class="line">            &#x2F;&#x2F;无返回值</span><br><span class="line">            testService.asyncTask();</span><br><span class="line">            long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：调用异步业务结束，耗时：&quot; + (endTime - startTime));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/12.3.SpringBoot/1353055-20190723115827369-137054437.png" alt="img"></p>
<p>有返回值，但主线程不需要用到返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 启动成功</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public ApplicationRunner applicationRunner() &#123;</span><br><span class="line">        return applicationArguments -&gt; &#123;</span><br><span class="line">            long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：开始调用异步业务&quot;);&#x2F;&#x2F;有返回值，但主线程不需要用到返回值</span><br><span class="line">            Future&lt;String&gt; future &#x3D; testService.asyncTask(&quot;huanzi-qch&quot;);</span><br><span class="line"></span><br><span class="line">            long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：调用异步业务结束，耗时：&quot; + (endTime - startTime));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/12.3.SpringBoot/1353055-20190723120750063-1637394085.png" alt="img"></p>
<p>有返回值，且主线程需要用到返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 启动成功</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public ApplicationRunner applicationRunner() &#123;</span><br><span class="line">        return applicationArguments -&gt; &#123;</span><br><span class="line">            long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：开始调用异步业务&quot;);</span><br><span class="line">&#x2F;&#x2F;有返回值，且主线程需要用到返回值</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：返回值：&quot; + testService.asyncTask(&quot;huanzi-qch&quot;).get());</span><br><span class="line"></span><br><span class="line">            long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：调用异步业务结束，耗时：&quot; + (endTime - startTime));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/12.3.SpringBoot/1353055-20190723121014479-355020614.png" alt="img"></p>
<p>可以发现，有返回值的情况下，虽然异步业务逻辑是由新线程执行，但如果在主线程操作返回值对象，主线程会等待，还是顺序执行</p>
<p>事务测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 启动成功</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public ApplicationRunner applicationRunner() &#123;</span><br><span class="line">        return applicationArguments -&gt; &#123;</span><br><span class="line">            long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：开始调用异步业务&quot;);&#x2F;&#x2F;事务测试，事务正常提交</span><br><span class="line">            testService.asyncTaskForTransaction(false);</span><br><span class="line"></span><br><span class="line">            long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：调用异步业务结束，耗时：&quot; + (endTime - startTime));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">数据库正确插入</span><br></pre></td></tr></table></figure>

<p><img src="/12.3.SpringBoot/1353055-20190723121259049-1268764937.png" alt="img"></p>
<p><img src="/12.3.SpringBoot/1353055-20190723115133055-806425816.png" alt="img"></p>
<p>模拟异常，事务回滚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 启动成功</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public ApplicationRunner applicationRunner() &#123;</span><br><span class="line">        return applicationArguments -&gt; &#123;</span><br><span class="line">            long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：开始调用异步业务&quot;);</span><br><span class="line">&#x2F;&#x2F;事务测试，模拟异常事务回滚</span><br><span class="line">            testService.asyncTaskForTransaction(true);</span><br><span class="line"></span><br><span class="line">            long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：调用异步业务结束，耗时：&quot; + (endTime - startTime));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">数据库正确回滚</span><br></pre></td></tr></table></figure>

<p><img src="/12.3.SpringBoot/1353055-20190723121249738-1640041332.png" alt="img"></p>
<p><img src="/12.3.SpringBoot/1353055-20190723113653670-484594019.png" alt="img"></p>
<h3 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h3><p>Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能</p>
<p>@Profile:指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件</p>
<ol>
<li>加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中。默认是default环境</li>
<li>写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效</li>
</ol>
<h2 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>JDBC的数据库连接池使用javax.sql.DataSource来表示，DataSource只是一个接口，该接口通常由服务器（Weblogic,WebSphere,Tomcat）提供实现，也有一些开源组织提供实现，如：DBCP数据库连接池、C3P0数据库连接池、Proxpool数据库连接池.</p>
<p>对象采用池化的原因：采用池化的本意是通过减少对象生成的次数，减少花在对象初始化上面的开销，从而提高整体性能。</p>
<p>使用数据库连接池的优点：</p>
<p>1）资源重用：</p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p>2）更快的系统反应速度</p>
<p>数据库连接池在初始化过程中，往往<strong>已经创建了若干数据库连接置于连接池中备用</strong>。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间。</p>
<p>3）新的资源分配手段</p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源。</p>
<p>4）统一的连接管理，避免数据库连接泄露</p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露。</p>
<p>Springboot默认数据库连接池为 Tomcat JDBC Pool </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#初始化连接</span><br><span class="line">spring.datasource.initial-size=<span class="number">10</span></span><br><span class="line">#最大空闲连接</span><br><span class="line">spring.datasource.max-idle=<span class="number">20</span></span><br><span class="line">#最小空闲连接</span><br><span class="line">spring.datasource.min-idle=<span class="number">5</span></span><br><span class="line">#最大连接数量</span><br><span class="line">spring.datasource.max-active=<span class="number">50</span></span><br><span class="line">#是否在自动回收超时连接的时候打印连接的超时错误</span><br><span class="line">spring.datasource.log-abandoned=<span class="keyword">true</span></span><br><span class="line">#是否自动回收超时连接</span><br><span class="line">spring.datasource.remove-abandoned=<span class="keyword">true</span></span><br><span class="line">#超时时间(以秒数为单位)</span><br><span class="line">spring.datasource.remove-abandoned-timeout=<span class="number">180</span></span><br><span class="line">##&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;</span><br><span class="line">spring.datasource.max-wait=<span class="number">1000</span></span><br><span class="line">spring.datasource.test-<span class="keyword">while</span>-idle=<span class="keyword">true</span></span><br><span class="line">#检测数据库的查询语句</span><br><span class="line">spring.datasource.validation-query=select <span class="number">1</span> from dual</span><br><span class="line">spring.datasource.test-on-borrow=<span class="keyword">true</span></span><br><span class="line">#每隔五分钟检测空闲超过10分钟的连接</span><br><span class="line">spring.datasource.min-evictable-idle-time-millis=<span class="number">600000</span></span><br><span class="line">spring.datasource.time-between-eviction-runs-millis=<span class="number">300000</span></span><br></pre></td></tr></table></figure>

<p>wait_timeout需要设置成很大一个值：</p>
<p>如果wait_timeout设置成很小，如1分钟。因为服务器1分钟就把空闲连接断开了，客户端过了5分钟再去检查连接情况，那有什么意义？先前就是没理解被误导了，把timeBetweenEvictionRunsMillis设置了一个比较大的值，所以一直有问题。包括所说的8小时问题也是源于此（mysql数据库默认是空闲8小时断开）</p>
<p>连接池配置中的timeBetweenEvictionRunsMillis和minEvictableIdleTimeMillis的时间小于或者等于mysql数据库中wait_timeout的时间</p>
<h3 id="多数据库源配置"><a href="#多数据库源配置" class="headerlink" title="多数据库源配置"></a>多数据库源配置</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aizen-sousuke/p/11756279.html">https://www.cnblogs.com/aizen-sousuke/p/11756279.html</a></p>
<p>maven依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-starter-web</span><br><span class="line">mybatis-plus-boot-starter</span><br><span class="line">dynamic-datasource-spring-boot-starter # 配置动态数据源</span><br><span class="line">druid-spring-boot-starter # 阿里的数据库连接池</span><br><span class="line">mysql-connector-java</span><br><span class="line">lombok      </span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.配置文件application.properties，配置了2个库的连接</span><br><span class="line">#配置数据源</span><br><span class="line">datasource:</span><br><span class="line">	dynamic:</span><br><span class="line">		primary: first # 配置默认数据库</span><br><span class="line">		datasource:</span><br><span class="line">        	first: # 数据源1配置</span><br><span class="line">          		username: root</span><br><span class="line">          		password: root</span><br><span class="line">          		url: jdbc:mysql:&#x2F;&#x2F;39.101.193.57:3306&#x2F;yxtl_db_admin?useUnicode&#x3D;yes&amp;characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;true&amp;serverTimezone&#x3D;GMT%2B8</span><br><span class="line">          		driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">        	second: # 数据源2配置</span><br><span class="line">          		username: root</span><br><span class="line">          		password: root</span><br><span class="line">          		url: jdbc:mysql:&#x2F;&#x2F;39.101.193.57:3306&#x2F;yxtl_db_lora?useUnicode&#x3D;yes&amp;characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;true&amp;serverTimezone&#x3D;GMT%2B8</span><br><span class="line">          		driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">		durid:</span><br><span class="line">        	initial-size: 1</span><br><span class="line">        	max-active: 20</span><br><span class="line">        	min-idle: 1</span><br><span class="line">        	max-wait: 60000  </span><br><span class="line">autoconfigure:</span><br><span class="line">    exclude:  com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure # 去除druid配置</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;DruidDataSourceAutoConfigure会注入一个DataSourceWrapper，其会在原生的spring.datasource下找 url, username, password 等。动态数据源 URL 等配置是在 dynamic 下，因此需要排除，否则会报错。排除方式有两种，一种是上述配置文件排除，还有一种可以在项目启动类排除：</span><br><span class="line">@SpringBootApplication(exclude &#x3D; DruidDataSourceAutoConfigure.class)</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    SpringApplication.run(Application.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.配置启动类</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&#123;&quot;com.swx.business.mapper.first&quot;, &quot;com.swx.business.mapper.second&quot;&#125;)</span><br><span class="line">@EnableSwagger2</span><br><span class="line">@EnableCaching</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.项目中使用：给使用非默认数据源添加注解@DS。加上  @DS(&quot;second&quot;) 表示使用的是第二个数据库源</span><br><span class="line">@DS 可以注解在方法上和类上，同时存在方法注解优先于类上注解。</span><br><span class="line">注解在 service 实现或 mapper 接口方法上，不要同时在 service 和 mapper 注解</span><br></pre></td></tr></table></figure>





<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存不关心方法的执行逻辑，它能确定的是：对于同一个方法，如果参数相同，那么返回结果也是相同的。但是如果参数不同，缓存只能假设结果是不同的，所以对于同一个方法，你的程序运行过程中，使用了多少种参数组合调用过该方法，理论上就会生成多少个缓存的 key（当然，这些组合的参数指的是与生成 key 相关的）</p>
<h3 id="cacheNames-value"><a href="#cacheNames-value" class="headerlink" title="cacheNames/value"></a>cacheNames/value</h3><p>@Cacheable 提供两个参数来指定缓存名：value、cacheNames，二者选其一即可 <code>@Cacheable(&quot;menu&quot;)</code> </p>
<p>@Cacheable 支持同一个方法关联多个缓存。这种情况下，当执行方法之前，这些关联的每一个缓存都会被检查，而且只要至少其中一个缓存命中了，那么这个缓存中的值就会被返回 <code>@Cacheable(&#123;&quot;menu&quot;, &quot;menuById&quot;&#125;)</code></p>
<h3 id="key-amp-keyGenerator"><a href="#key-amp-keyGenerator" class="headerlink" title="key&amp;keyGenerator"></a>key&amp;keyGenerator</h3><p>一个缓存名对应一个被注解的方法，但是一个方法可能传入不同的参数，那么结果也就会不同，需要用到 key 。</p>
<p>在 spring 中，key 的生成有两种方式：显式指定和使用 keyGenerator 自动生成</p>
<p>1.spring 官方更推荐显式指定 key 的方式，即指定 @Cacheable 的 key 参数，使用SpEL（Spring Expression Language，Spring 表达式语言）</p>
<p> <code>@Cacheable(value = &#123;&quot;menuById&quot;&#125;, key = &quot;#id&quot;)</code> </p>
<p><code>@Cacheable(value = &#123;&quot;menuById&quot;&#125;, key = &quot;&#39;id-&#39; + #menu.id&quot;)</code></p>
<p><code>@Cacheable(value = &#123;&quot;menuById&quot;&#125;, key = &quot;&#39;hash&#39; + #menu.hashCode()&quot;)</code></p>
<p><img src="/12.3.SpringBoot/9b44287bd9e642abfc8edcd09a51b87a.png" alt="img"></p>
<p>2.当我们在声明 @Cacheable 时不指定 key 参数，则该缓存名下的所有 key 会使用 KeyGenerator 根据参数 自动生成。spring 有一个默认的 SimpleKeyGenerator ，在 spring boot 自动化配置中，这个会被默认注入。生成规则如下：</p>
<p>　　　　　　a. 如果该缓存方法没有参数，返回 SimpleKey.EMPTY ；</p>
<p>　　　　　　b. 如果该缓存方法有一个参数，返回该参数的实例 ；</p>
<p>　　　　　　c. 如果该缓存方法有多个参数，返回一个包含所有参数的 SimpleKey ；</p>
<p>　　　　默认的 key 生成器要求参数具有有效的 hashCode() 和 equals() 方法实现。另外，keyGenerator 也支持自定义， 并通过 keyGenerator 来指定。关于 KeyGenerator，其实就是使用 hashCode 进行加乘运算。跟 String 和 ArrayList 的 hash 计算类似。</p>
<p> 注：key 和 keyGenerator 参数是互斥的，同时指定两个会导致异常</p>
<h3 id="cacheManager"><a href="#cacheManager" class="headerlink" title="cacheManager"></a>cacheManager</h3><p>CacheManager，缓存管理器是用来管理（检索）一类缓存的。通常来讲，缓存管理器是与缓存组件类型相关联的。我们知道，spring 缓存抽象的目的是为使用不同缓存组件类型提供统一的访问接口，以向开发者屏蔽各种缓存组件的差异性。那么  CacheManager 就是承担了这种屏蔽的功能。spring 为其支持的每一种缓存的组件类型提供了一个默认的 manager，如：RedisCacheManager 管理 redis 相关的缓存的检索、EhCacheManager 管理 ehCache 相关的缓等。</p>
<p>cacheResolver</p>
<p>　　CacheResolver，缓存解析器是用来管理缓存管理器的，CacheResolver 保持一个 cacheManager 的引用，并通过它来检索缓存。CacheResolver 与 CacheManager 的关系有点类似于 KeyGenerator 跟 key。spring 默认提供了一个 SimpleCacheResolver，开发者可以自定义并通过 @Bean 来注入自定义的解析器，以实现更灵活的检索。</p>
<p>　　大多数情况下，我们的系统只会配置一种缓存，所以我们并不需要显式指定 cacheManager 或者 cacheResolver。但是 spring 允许我们的系统同时配置多种缓存组件，这种情况下，我们需要指定。指定的方式是使用 @Cacheable 的 cacheManager 或者 cacheResolver 参数。</p>
<p>　　注意：按照官方文档，cacheManager 和 cacheResolver 是互斥参数，同时指定两个可能会导致异常。</p>
<h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p>是否同步，true/false。在一个多线程的环境中，某些操作可能被相同的参数并发地调用，这样同一个 value 值可能被多次计算（或多次访问 db），这样就达不到缓存的目的。针对这些可能高并发的操作，我们可以使用 sync 参数来告诉底层的缓存提供者将缓存的入口锁住，这样就只能有一个线程计算操作的结果值，而其它线程需要等待，这样就避免了 n-1 次数据库访问。</p>
<p>　　sync = true 可以有效的避免缓存击穿的问题</p>
<h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><p>调用前判断，缓存的条件。有时候，我们可能并不想对一个方法的所有调用情况进行缓存，我们可能想要根据调用方法时候的某些参数值，来确定是否需要将结果进行缓存或者从缓存中取结果。比如当我根据年龄查询用户的时候，我只想要缓存年龄大于 35 的查询结果。那么 condition 能实现这种效果。</p>
<p>　　condition 接收一个结果为 true 或 false 的表达式，表达式同样支持 SpEL 。如果表达式结果为 true，则调用方法时会执行正常的缓存逻辑（查缓存-有就返回-没有就执行方法-方法返回不空就添加缓存）；否则，调用方法时就好像该方法没有声明缓存一样（即无论传入了什么参数或者缓存中有些什么值，都会执行方法，并且结果不放入缓存）</p>
<p><code>@Cacheable(value = &#123;&quot;menuById&quot;&#125;, key = &quot;#id&quot;, condition = &quot;#conditionValue &gt; 1&quot;)</code></p>
<h3 id="unless"><a href="#unless" class="headerlink" title="unless"></a>unless</h3><p>执行后判断，不缓存的条件。unless 接收一个结果为 true 或 false 的表达式，表达式支持 SpEL。当结果为 true 时，不缓存</p>
<p><code>@Cacheable(value = &#123;&quot;menuById&quot;&#125;, key = &quot;#id&quot;, unless = &quot;#result.type == &#39;folder&#39;&quot;)</code></p>
<p>condition 不指定相当于 true，unless 不指定相当于 false</p>
<p>　　　　当 condition = false，一定不会缓存；</p>
<p>　　　　当 condition = true，且 unless = true，不缓存；</p>
<p>　　　　当 condition = true，且 unless = false，缓存；</p>
<p>实际使用遇到的问题：</p>
<p>1.同一个类，其中一个方法调用另一个注解缓存的方法时，不走缓存。</p>
<p>2.缓存的对象会存往redis，存入redis的对象必须实现序列化接口，否则存入的是乱码或者二进制字符。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h3><p>事务的打开、回滚和提交是由事务管理器来完成的。在Spring中，事务管理器的顶层接口为PlatformTransactionManager，Spring也定义了一些其他的接口和类。</p>
<p>在Spring Boot中，当你依赖于<strong>mybatis-spring-boot-starter</strong>之后，它会自动创建一个<strong>DataSource­ TransactionManager</strong>对象作为事务管理器；</p>
<p>如果依赖于<strong>spring-boot-starter-data-jpa</strong>，则它会自动创建<strong>JpaTransactionManager</strong>对象作为事务管理器，所以我们一般不需要自己创建事务管理器而直接使用它们即可</p>
<h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><p>声明式事务，@Transactional 注解应该只被应用到 <strong>public</strong> 方法上，这是由 Spring AOP 的本质决定的，</p>
<p>涉及到两张表以上的更新或者删除操作，为了保证数据库的一致性，需要添加 @Transactional事务注解，否则程序会抛出异常</p>
<p>（@Scheduled 和@Transactional不能同时存在一个类里面）</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line">    <span class="comment">// 通过 bean name 指定事务管理器</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 同 value 属性</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 传播行为</span></span><br><span class="line">    <span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line">    <span class="comment">// 隔离级别</span></span><br><span class="line">    <span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line">    <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line">    <span class="comment">// 是否只读事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">// 方法在发生指定异常时回滚，默认是所有异常都回滚</span></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 方法在发生指定异常名称时回滚，默认是所有异常都回滚</span></span><br><span class="line">    String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 方法在发生指定异常时不回滚，默认是所有异常都回滚</span></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 方法在发生指定异常名称时不回滚，默认是所有异常都回滚</span></span><br><span class="line">    String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/12.3.SpringBoot/1055208-20180316120820674-2029592173.png" alt="img"></p>
<p><img src="/12.3.SpringBoot/2599320-5bdab563c3050406.png" alt="img"></p>
<p>@Transaction 默认配置适合80%的配置，特殊场景的配置需要手动配置参数</p>
<p>Spring的默认的事务规则是<strong>遇到运行异常（RuntimeException）和程序错误（Error）才会回滚</strong>。</p>
<h4 id="其他异常回滚"><a href="#其他异常回滚" class="headerlink" title="其他异常回滚"></a>其他异常回滚</h4><p>Spring默认情况下会对(RuntimeException)及其子类来进行回滚,在遇见Exception及其子类的时候则不会进行回滚操作</p>
<p>如果想针对<strong>非检测异常</strong>（即运行异常）进行事务回滚，可以在@Transactional 注解里使用，@Transactional(rollbackFor=Exception.class) 属性明确指定异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">@Transactional(rollbackFor &#x3D; &#123;SQLException.class&#125;)</span><br><span class="line">public void rollback() throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; update db</span><br><span class="line">    throw new SQLException(&quot;exception&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遇到SQLException时会回滚，遇到RuntimeException和Error也会回滚。（相当于设置后是添加了属性）</p>
<h4 id="嵌套回滚"><a href="#嵌套回滚" class="headerlink" title="嵌套回滚"></a>嵌套回滚</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// updateA</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        selfProxy.innelTransaction()</span><br><span class="line">    &#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//updateC</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innelTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// updateB</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">会回滚，因为内部事务触发回滚，当前事务被标记为 rollback-only，</span><br><span class="line">当外部事务提交的时候，Spring抛出以下异常，同时回滚外部事务</span><br><span class="line">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure>

<h4 id="事务传播性"><a href="#事务传播性" class="headerlink" title="事务传播性"></a>事务传播性</h4><p>@Transaction中的propagation的可以配置事务的传播性</p>
<p>常用的传播行为是REQUIRED、REQUIRES_NEW、NESTED三种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要事务。它是默认传播行为，如果当前存在事务，就沿用当前事务，否则新建一个事务运行子方法</span></span><br><span class="line">    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line">    <span class="comment">// 支持事务，如果当前存在事务,就沿用当前事务,如果不存在 ，则继续采用无事务的方式运行子方法</span></span><br><span class="line">    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line">    <span class="comment">// 必须使用事务，如果当前没有事务，则会抛出异常，如果存在当前事务 ，就沿用当前事务</span></span><br><span class="line">    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line">    <span class="comment">// 无论当前事务是否存在，都会创建新事务运行方法，这样新事务就可以拥有新的锁和隔离级别等特性，与当前事务相互独立</span></span><br><span class="line">    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line">    <span class="comment">// 不支持事务，当前存在事务时，将挂起事务，运行方法</span></span><br><span class="line">    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line">    <span class="comment">// 不支持事务，如果当前方法存在事务，则抛出异常，否则继续使用无事务机制运行</span></span><br><span class="line">    NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line">    <span class="comment">// 在当前方法调用子方法时，如果子方法发生异常，只回滚子方法执行过的 SQL，而不回滚当前方法的事务</span></span><br><span class="line">    NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="keyword">int</span> value) &#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.value; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在事务中读取最新配置</p>
<p>有时候需要在一个事务中，读取最新数据（默认是读取事务开始前的快照）。其实很简单，只要使用上面PROPAGATION_NOT_SUPPORTED传播性就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void transaction() throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    selfProxy.queryNewValue();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">@Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</span><br><span class="line">public void queryNewValue() throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F;查询数据中的最新值</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h4><p>1.如果你在方法中有try{}catch(Exception e){}处理，那么try里面的代码块就脱离了事务的管理，若要事务生效需要在catch中throw new RuntimeException (“xxxxxx”)</p>
<p>2.在@Transactional注解的方法中，再调用本类中的其他方法method2时，那么method2方法上的@Transactional注解是不会生效的！（也就是下面这个内部调用事务方法模块所讲的解决方法）</p>
<h4 id="内部调用事务方法"><a href="#内部调用事务方法" class="headerlink" title="内部调用事务方法"></a>内部调用事务方法</h4><p>事务注解的实质就是在创建一个动态代理，在调用事务方法前开启事务，在事务方法结束以后决定是事务提交还是回滚</p>
<p>Spring数据库事务的实现原理是AOP，而AOP的原理是动态代理。在事务自调用的过程中，是类自身的调用即通过this.指向的目标对象，而不是代理对象去调用，那么就不会产生AOP，这样Spring就不能把你的代码织入到约定的流程中，于是就产生了@Transactional自调用失效的场景。</p>
<p>因此，直接在类内部中调用事务方法，是不会经过动态代理的</p>
<p><img src="/12.3.SpringBoot/1055208-20180309165042456-532167462.png" alt="img"></p>
<p>因此，如果要使方法B点事务生效：</p>
<p><img src="/12.3.SpringBoot/1055208-20180309165117679-1753916897.png" alt="img"></p>
<p>解决方法1：需要在内部调用方法B的时候，找到当前类的代理类，用代理类去调用方法B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MyService&#123;</span><br><span class="line">    @Transactional</span><br><span class="line">    public void transaction()&#123;</span><br><span class="line">        &#x2F;&#x2F; do something</span><br><span class="line">        ((MyService) AopContext.currentProxy()).queryNewValue();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</span><br><span class="line">    public void queryNewValue()&#123;</span><br><span class="line">        &#x2F;&#x2F;查询数据中的最新值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通过AopContext.currentProxy()可以拿到当前类的代理类，但是要使用这个时候，必须在启动类上加上</span><br><span class="line">@EnableAspectJAutoProxy(exposeProxy&#x3D;true)</span><br></pre></td></tr></table></figure>

<p>解决办法2：在spring中拿Bean的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MyService&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyService self;</span><br><span class="line">    @Transactional</span><br><span class="line">    public void transaction() &#123;</span><br><span class="line">        &#x2F;&#x2F; do something</span><br><span class="line">        self.queryNewValue();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</span><br><span class="line">    public void queryNewValue() &#123;</span><br><span class="line">        &#x2F;&#x2F;查询数据中的最新值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips:spring现在对一些循环依赖是提供支持的，简单来说，满足：</p>
<p>1.Bean是单例<br>2.注入的方式不是构造函数注入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">通过BeanFactory</span><br><span class="line">@Service</span><br><span class="line">public class MyService implements BeanFactoryAware&#123;</span><br><span class="line">    private MyService self;</span><br><span class="line">      </span><br><span class="line">    @Transactional</span><br><span class="line">    public void transaction()&#123;</span><br><span class="line">        &#x2F;&#x2F; do something</span><br><span class="line">        self.queryNewValue();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</span><br><span class="line">    public void queryNewValue() &#123;</span><br><span class="line">        &#x2F;&#x2F;查询数据中的最新值</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">     @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        self &#x3D; beanFactory.getBean(MyService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1.使用@Transaction注解的方法，必须用public来修饰。<br>2.其实不止是@Transaction，其他类似@Cacheable,@Retryable等依赖spring proxy也必须使用上述方式达到内部调用。<br>3.@Transactional,@Async放在同一个类中，如果使用Autowire注入会循环依赖，而使用BeanFactoryAware会使得@Transactional无效</p>
<p>4.@Transactional注解保证的是每个方法处在一个事务，如果有try一定在catch中抛出运行时异常</p>
<p>5.this.本方法的调用，被调用方法上注解是不生效的，因为无法再次进行切面增强</p>
<p>6.不仅是执行两个以上增删改数据时需要加事务，如果是<strong>两条查询语句，一个增删改语句和一个额外操作</strong>，都需要加事务来预防出现查询时不一致，额外操作失败导致语句执行不回滚的情况</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>在需要事务回滚的时候，最好还是抛出RuntimeException,并且不要在代码中捕获此类异常</p>
<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a><strong>自动配置原理</strong></h2><p>有了前面的注解基础之后，我们就能够更深入地了解Spring Boot的自动配置原理，自动配置正是建立在这些强大的注解之上的。</p>
<p>我们首先观察一下主启动类上的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻阅源码可以得知，@SpringBootApplication注解其实是由三个注解组成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中@SpringBootConfiguration底层是@Configuration注解，它表示主启动类是一个配置类；而@ComponentScan是扫描注解，它默认扫描的是主启动类当前包及其子包下的组件；最关键的就是@EnableAutoConfiguration注解了，该注解便实现了自动配置。</p>
<p>查看@EnableAutoConfiguration注解的源码，又会发现它是由两个注解组合而成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续查看@AutoConfigurationPackage注解的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Import注解我们非常熟悉，它是用来导入一个组件的，然而它比较特殊：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 Registrar 组件中有两个方法，它是用来导入一系列组件的，而该注解又被间接标注在了启动类上，所以它会将主启动类所在包及其子包下的所有组件均注册到容器中。</p>
<p>接下来我们继续看@EnableAutoConfiguration的第二个合成注解：@Import({AutoConfigurationImportSelector.class}) 该注解也向容器中注册了一个组件，翻阅该组件的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是用来选择导入哪些组件的，该方法又调用了getAutoConfigurationEntry()方法得到需要导入的组件，所以我们查看该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.<span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = <span class="keyword">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">        <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在getCandidateConfigurations()方法处打一个断点，通过debug运行后我们可以发现，configurations集合中就已经得到了127个自动配置类：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwiakI4r3b9jZ4o76vYGkxmwSmRibQ5POBwGyFLM7Frakdc6Bshjn9iaOqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>那么这些类究竟从何而来呢？我们需要探究一下getCandidateConfigurations()方法做了什么操作，它其实是调用了loadFactoryNames()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br></pre></td></tr></table></figure>

<p>最终调用的是loadSpringFactories()方法来得到一个Map集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它其实是从 META-INF/spring.factories 文件中获取的组件，我们可以看看导入的依赖中：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vweu8mKjeLr2ObBktFVLyrZvYT8icicxjyibTGsrvRKAayHPbYPItCOwMpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在spring-boot-autoconfigure-2.3.7.RELEASE.jar的META-INF目录下就有一个spring.factories文件，打开看看文件内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>文件里的内容其实就是在最开始需要注册的组件，这些组件都是一些配置类，只要项目一启动，Spring Boot就会将这些配置类全部注册到容器中。</p>
<h3 id="按需开启自动配置"><a href="#按需开启自动配置" class="headerlink" title="按需开启自动配置"></a><strong>按需开启自动配置</strong></h3><p>虽然配置类会被 Spring Boot 自动注册到容器中，但并不是每个配置类都会默认生效，SpringBoot会根据当前的场景按需开启自动配置。比如Thymeleaf模板引擎的自动配置类：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwpsl2q2cwqbRhADxVWeglaIWQp4G9dz9QaJBibOIPH9PsmEkdIK1ejDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>@ConditionalOnClass注解的作用是检查当前项目是否有指定的.class文件，若有则生效；否则不生效。因为我们并未引入Thymeleaf的依赖，导致TemplateMode.class和SpringTemplatengine.class都是不存在的，所以ThymeleafAutoCinfiguration并不会生效。</p>
<h3 id="修改默认配置"><a href="#修改默认配置" class="headerlink" title="修改默认配置"></a><strong>修改默认配置</strong></h3><p>既然SpringBoot帮助我们进行了大量的自动配置，那么对于特殊的一些应用场景，我们该如何修改它的默认配置呢？如果你不了解SpringBoot的配置原理，那么当你需要修改默认配置时，你肯定是束手无策的。我们可以找到SpringMVC的默认配置，看看SpringBoot是如何帮我们进行配置的：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwjenFeGzxSpZRluvzRoXakJpxEdlXQeRwhKY4dHSfSvzLWwkb3mMXAw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>@EnableConfigurationPropertie(WebMvcProperties.class)注解在之前也有介绍，它是用来开启指定类的配置绑定的，所以我们来看看WebMvcProperties类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;spring.mvc&quot;)</span><br><span class="line">public class WebMvcProperties &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置绑定的前缀时spring.mvc，所以我们若是想修改SpringBoot的默认配置，则必须要将前缀写为spring.mvc，至于我们可以修改哪些配置，只需要查看该类中有哪些成员变量即可，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static class View &#123;</span><br><span class="line">    </span><br><span class="line">    private String prefix;</span><br><span class="line"></span><br><span class="line">    private String suffix;</span><br><span class="line"></span><br><span class="line">    public String getPrefix() &#123;</span><br><span class="line">        return this.prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrefix(String prefix) &#123;</span><br><span class="line">        this.prefix &#x3D; prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSuffix() &#123;</span><br><span class="line">        return this.suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSuffix(String suffix) &#123;</span><br><span class="line">        this.suffix &#x3D; suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在WebMvcProperties类中有这样一个内部类，内部类中有prefix和suffix两个成员变量，它们是分别用来设置视图的前缀和后缀的，所以我们若想进行配置，则需要在配置文件中这样编写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.view.prefix&#x3D;&#x2F;views&#x2F;</span><br><span class="line">spring.mvc.view.suffix&#x3D;.html</span><br></pre></td></tr></table></figure>

<p>传统的Spring开发Web需要编写大量的配置，而使用SpringBoot将免去编写配置的操作，直接面向业务逻辑开发，一起来看看该如何使用SpringBoot进行Web开发吧！</p>
<h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a><strong>Web开发</strong></h2><h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a><strong>静态资源处理</strong></h3><p>Spring Boot默认设置了几个静态资源目录：</p>
<ul>
<li>/static</li>
<li>/public</li>
<li>/resources</li>
<li>/META-INF/resources</li>
</ul>
<p>这几个目录需要建立在类路径下，若如此做，则放置在这些目录下的静态资源可以被直接访问到。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwmKY2G35mehPDl0JLbWGSGBVhCicJsVgzqDuFVd2elK6XGCicTSHU6ibfQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>也可以通过配置来设置资源的访问前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.static-path-pattern&#x3D;&#x2F;res</span><br></pre></td></tr></table></figure>

<p>此时若想访问静态资源，就必须添加res前缀才行。</p>
<p>我们还可以修改Spring Boot的默认资源路径，只需添加配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.web.resources.static-locations&#x3D;classpath:&#x2F;myImg</span><br></pre></td></tr></table></figure>

<p>若如此做，则我们只能将静态资源放在myImg目录下，之前的所有静态资源目录都将失效。</p>
<p><strong>欢迎页</strong></p>
<p>Spring Boot提供了两种方式来实现欢迎页，第一种便是在资源目录放置欢迎页：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;SpringBoot Index!&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>访问结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwCiasLxHPa4CgF4ialicAuzygfKaNbe8BUXXDD0eWemaDzKh9C1S91nHSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>第二种方式是通过Controller处理/index请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String toIndex()&#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Favicon"><a href="#Favicon" class="headerlink" title="Favicon"></a><strong>Favicon</strong></h3><p>Spring Boot也提供了自动设置网站图标的方式，只需要将名为 <code>favicon.ico</code> 的图片放在静态资源目录下即可：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vw1B6tqzEX4bo1m5pBvDkKo0D9VwZiagnRibxW1ek1VVERMuRkN4Sib3Mgw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Rest映射</strong></p>
<p>在Spring Boot中，默认已经注册了HiddenHttpMethodFilter，所以可以直接编写Rest风格的url，只需在表单中添加一个_method属性的请求域即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;get&quot;&gt;</span><br><span class="line">        &lt;input value&#x3D;&quot;Get提交&quot; type&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">        &lt;input value&#x3D;&quot;Post提交&quot; type&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_method&quot; value&#x3D;&quot;DELETE&quot;&gt;</span><br><span class="line">        &lt;input value&#x3D;&quot;Delete提交&quot; type&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_method&quot; value&#x3D;&quot;PUT&quot;&gt;</span><br><span class="line">        &lt;input value&#x3D;&quot;Put提交&quot; type&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>编写Controller处理请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    public String getUser()&#123;</span><br><span class="line">        return &quot;Get&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    public String postUser()&#123;</span><br><span class="line">        return &quot;Post&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    public String deleteUser()&#123;</span><br><span class="line">        return &quot;Delete&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    public String putUser()&#123;</span><br><span class="line">        return &quot;Put&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后需要在配置文件中开启对Rest的支持：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.hiddenmethod.filter.enabled&#x3D;true</span><br></pre></td></tr></table></figure>



<h2 id="常用参数及注解"><a href="#常用参数及注解" class="headerlink" title="常用参数及注解"></a><strong>常用参数及注解</strong></h2><p>下面介绍Web开发中的一些常用参数和注解。</p>
<h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a><strong>@PathVariable</strong></h3><p>该注解用于获取路径变量，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public String getUser(@PathVariable(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">    return id + &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时若请求url为<a target="_blank" rel="noopener" href="http://localhost:8080/user/2%EF%BC%8C%E5%88%99%E8%8E%B7%E5%8F%96%E5%88%B0id%E5%80%BC%E4%B8%BA2%E3%80%82">http://localhost:8080/user/2，则获取到id值为2。</a></p>
<h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a><strong>@RequestHeader</strong></h3><p>该注解用于获取请求头，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;header&quot;)</span><br><span class="line">public String getHeader(@RequestHeader(&quot;User-Agent&quot;) String userAgent)&#123;</span><br><span class="line">    return userAgent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它还能够通过一个Map集合获取所有的请求头信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;header&quot;)</span><br><span class="line">public Map&lt;String, String&gt; getHeader(@RequestHeader Map&lt;String,String&gt; headers)&#123;</span><br><span class="line">    return headers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><strong>@RequestParam</strong></h3><p>该注解用于获取请求参数，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;param&quot;)</span><br><span class="line">public String getParam(@RequestParam(&quot;name&quot;) String name,</span><br><span class="line">                       @RequestParam(&quot;age&quot;) Integer age)&#123;</span><br><span class="line">    return name + &quot;:&quot; + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时若请求url为<a target="_blank" rel="noopener" href="http://localhost:8080/param?name=zhangsan&amp;age=20%EF%BC%8C%E5%88%99%E5%BE%97%E5%88%B0%E5%80%BC%60zhangsan:20%60">http://localhost:8080/param?name=zhangsan&amp;age=20，则得到值`zhangsan:20`</a> 。</p>
<h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a><strong>@CookieValue</strong></h3><p>该注解用于获取Cookie值，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;cookie&quot;)</span><br><span class="line">public String getCookie(@CookieValue(&quot;Idea-8296e76f&quot;) String cookie) &#123;</span><br><span class="line">    return cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它还可以通过Cookie键名获取一个Cookie对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;cookie&quot;)</span><br><span class="line">public String getCookie(@CookieValue(&quot;Idea-8296e76f&quot;) Cookie cookie) &#123;</span><br><span class="line">    return cookie.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a><strong>@RequestBody</strong></h3><p>该注解用于获取获取请求体的值，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;body&quot;)</span><br><span class="line">public String getBody(@RequestBody String content) &#123;</span><br><span class="line">    return content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然是获取请求体的值，那么只有Post请求才有请求体，所以编写一个表单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;body&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">        账号:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        密码:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot;&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>通过该表单提交数据后，得到 <code>username=admin&amp;password=123</code> 。</p>
<h3 id="RequestAttribute"><a href="#RequestAttribute" class="headerlink" title="@RequestAttribute"></a><strong>@RequestAttribute</strong></h3><p>该注解用于获取request域的数据，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;success&quot;)</span><br><span class="line">public String success(@RequestAttribute(&quot;msg&quot;) String msg)&#123;</span><br><span class="line">    return msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过键名即可获取request域中的数据。</p>
<h3 id="MatrixVariable"><a href="#MatrixVariable" class="headerlink" title="@MatrixVariable"></a><strong>@MatrixVariable</strong></h3><p>该注解用于获取矩阵变量，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;matrix&#x2F;&#123;path&#125;&quot;)</span><br><span class="line">public String getMatrix(@MatrixVariable(&quot;name&quot;) String name,</span><br><span class="line">                        @MatrixVariable(&quot;age&quot;) Integer age,</span><br><span class="line">                        @PathVariable(&quot;path&quot;) String path) &#123;</span><br><span class="line">    return path + &quot;---&quot; + name + &quot;:&quot; + age;</span><br></pre></td></tr></table></figure>

<p>对于该注解的使用，需要注意几点，首先矩阵变量是绑定在路径中的，所以请求映射中一定要携带一个${path}；其次在SpringBoot中默认禁用掉了矩阵变量的功能，所以我们还需要手动去开启该功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebMvcConfigurer webMvcConfigurer()&#123;</span><br><span class="line">        return new WebMvcConfigurer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void configurePathMatch(PathMatchConfigurer configurer) &#123;</span><br><span class="line">                UrlPathHelper urlPathHelper &#x3D; new UrlPathHelper();</span><br><span class="line">                </span><br><span class="line">                urlPathHelper.setRemoveSemicolonContent(false);</span><br><span class="line">                configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时访问请求url：<a target="_blank" rel="noopener" href="http://localhost:8080/matrix/test;name=zhangsan;age=20%EF%BC%8C">http://localhost:8080/matrix/test;name=zhangsan;age=20，</a> 得到结果：<code>test---zhangsan:20</code> 。</p>
<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>模板引擎是为了解决用户界面（显示）与业务数据（内容）分离而产生的。他可以生成特定格式的文档，常用的如格式如HTML、xml以及其他格式的文本格式。其工作模式如下：</p>
<p><img src="/12.3.SpringBoot/2411352-1b8c22fae3f6a072.png" alt="img"></p>
<p>常用的模板引擎：</p>
<p>jsp：是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。</p>
<p>Thymeleaf : 主要渲染xml，HTML，HTML5而且与springboot整合。</p>
<p>Velocity：不仅可以用于界面展示（HTML.xml等）还可以生成输入java代码，SQL语句等文本格式。</p>
<p>FreeMarker：功能与Velocity差不多，但是语法更加强大，使用方便。</p>
<p>1、FreeMarker是一个用Java语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与Web容器无关，即在Web运行时，它并不知道Servlet或HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成XML，JSP或Java 等，在spring4.0中推荐使用thymeleaf来做前端模版引擎。</p>
<p>2、JSP技术spring boot 官方是不推荐的，原因有三：</p>
<p>2.1. 在tomcat上，jsp不能在嵌套的tomcat容器解析即不能在打包成可执行的jar的情况下解析</p>
<p>2.2. Jetty 嵌套的容器不支持jsp</p>
<p>2.3. Undertow</p>
<p>3、反正就是spring推荐themleaf，就学学themleaf。</p>
<p>18.8.31</p>
<p>在java领域，表现层技术主要有三种：jsp、freemarker、velocity。</p>
<p>jsp是大家最熟悉的技术</p>
<p>优点：</p>
<p>1、功能强大，可以写java代码</p>
<p>2、支持jsp标签(jsp tag)</p>
<p>3、支持表达式语言(el)</p>
<p>4、官方标准，用户群广，丰富的第三方jsp标签库</p>
<p>5、性能良好。jsp编译成class文件执行，有很好的性能表现</p>
<p>缺点：</p>
<p>jsp没有明显缺点，非要挑点骨头那就是，由于可以编写java代码，如使用不当容易破坏mvc结构。</p>
<p>velocity是较早出现的用于代替jsp的模板语言</p>
<p>优点：</p>
<p>1、不能编写java代码，可以实现严格的mvc分离</p>
<p>2、性能良好，据说比jsp性能还要好些</p>
<p>3、使用表达式语言，据说jsp的表达式语言就是学velocity的</p>
<p>缺点：</p>
<p>1、不是官方标准</p>
<p>2、用户群体和第三方标签库没有jsp多。</p>
<p>3、对jsp标签支持不够好</p>
<p>4、已经很久很久没有维护了。</p>
<p>freemarker</p>
<p>优点：</p>
<p>1、不能编写java代码，可以实现严格的mvc分离</p>
<p>2、性能非常不错</p>
<p>3、对jsp标签支持良好</p>
<p>4、内置大量常用功能，使用非常方便</p>
<p>5、宏定义(类似jsp标签)非常方便</p>
<p>6、使用表达式语言</p>
<p>缺点：</p>
<p>1、不是官方标准</p>
<p>2、用户群体和第三方标签库没有jsp多</p>
<p>选择freemarker的原因：</p>
<p>1、性能。velocity应该是最好的，其次是jsp，普通的页面freemarker性能最差(虽然只是几毫秒到十几毫秒的差距)。但是在复杂页面上(包含大量判断、日期金额格式化)的页面上，freemarker的性能比使用tag和el的jsp好。</p>
<p>2、宏定义比jsp tag方便</p>
<p>3、内置大量常用功能。比如html过滤，日期金额格式化等等，使用非常方便</p>
<p>4、支持jsp标签</p>
<p>5、可以实现严格的mvc分离</p>
<p>thymeleaf</p>
<p>Thymeleaf是个XML/XHTML/HTML5模板引擎，可以用于Web与非Web应用。Thymeleaf就是jsp的高端升级版</p>
<p>Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM(文档对象模型)上执行预先制定好的逻辑。Thymeleaf的可扩展性也非常棒。你可以使用它定义自己的模板属性集合，这样就可以计算自定义表达式并使用自定义逻辑。这意味着Thymeleaf还可以作为模板引擎框架。</p>
<p>thymeleaf优点：静态html嵌入标签属性，浏览器可以直接打开模板文件，便于前后端联调。springboot官方推荐方案。</p>
<p>thymeleaf缺点：模板必须符合xml规范，就这一点就可以判死刑！太不方便了！js脚本必须加入/</p>
<p>spring  boot  使用两个模板引擎<br>一 freemaker (来自学成在线第四天的页面静态化)<br>静态化之后上传到 gridFs 服务器上</p>
<p>目录如下</p>
<p><img src="/12.3.SpringBoot/20190610231257254.png" alt="img"></p>
<p>1.配置文件</p>
<p>application.yml</p>
<p><img src="/12.3.SpringBoot/20190610231539914.png" alt="img"></p>
<p>resources下templates 下 index_banner.ftl 模板页面</p>
<p><img src="/12.3.SpringBoot/20190610231757330.png" alt="img"></p>
<p>2.在test测试下写一个测试类   GridFsTest</p>
<p>@SpringBootTest<br>@RunWith(SpringRunner.class)<br>public class GridFsTest {</p>
<pre><code>@Autowired
GridFsTemplate gridFsTemplate;
 
@Autowired
GridFSBucket gridFSBucket;
 
//存文件
@Test
public void testStore() throws FileNotFoundException &#123;
    //定义file
    File file =new File(&quot;d:/index_banner.ftl&quot;);
    //定义fileInputStream
    FileInputStream fileInputStream = new FileInputStream(file);
    ObjectId objectId = gridFsTemplate.store(fileInputStream, &quot;index_banner.ftl&quot;);
    System.out.println(objectId);
&#125;
 
//取文件
@Test
public void queryFile() throws IOException &#123;
    //根据文件id查询文件
    GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where(&quot;_id&quot;).is(&quot;5ce799bf840d5e6d88a0a0f7&quot;)));
 
    //打开一个下载流对象
    GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
    //创建GridFsResource对象，获取流
    GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream);
    //从流中取数据
    String content = IOUtils.toString(gridFsResource.getInputStream(), &quot;utf-8&quot;);
    System.out.println(content);
 
&#125;
</code></pre>
<p>}<br>详细解析页面静态化的流程实质是什么。。。。。。。。。。。。。。。。。。。。</p>
<p>二.thymeleaf<br>   自己写的博客，使用的就是这个技术，但是看着有点麻烦，以后查看博客的时候再看使用</p>
<p>使用spring  框架使用freemaker<br>freemaker<br>（来自平优购的day12 的 商品详情页）感觉跟上面的spring boot集成的模式是一模一样的呀</p>
<p><img src="/12.3.SpringBoot/20190610233854182.png" alt="img"></p>
<p>最基础的配置文件，以及代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.3.3生成文件</span><br><span class="line">使用步骤：</span><br><span class="line">第一步：创建一个 Configuration 对象，直接 new 一个对象。构造方法的参数就是 freemarker的版本号。</span><br><span class="line">第二步：设置模板文件所在的路径。</span><br><span class="line">第三步：设置模板文件使用的字符集。一般就是 utf-8.</span><br><span class="line">第四步：加载一个模板，创建一个模板对象。</span><br><span class="line">第五步：创建一个模板使用的数据集，可以是 pojo 也可以是 map。一般是 Map。</span><br><span class="line">第六步：创建一个 Writer 对象，一般创建一 FileWriter 对象，指定生成的文件名。</span><br><span class="line">第七步：调用模板对象的 process 方法输出文件。</span><br><span class="line"></span><br><span class="line">第八步：关闭流</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line">创建Test类 main方法如下：</span><br><span class="line">	     &#x2F;&#x2F;1.创建配置类</span><br><span class="line">		Configuration configuration&#x3D;new Configuration(Configuration.getVersion());</span><br><span class="line">		&#x2F;&#x2F;2.设置模板所在的目录 </span><br><span class="line">		configuration.setDirectoryForTemplateLoading(new File(&quot;D:&#x2F;pinyougou_work&#x2F;freemarkerDemo&#x2F;src&#x2F;main&#x2F;resources&#x2F;&quot;));</span><br><span class="line">		&#x2F;&#x2F;3.设置字符集</span><br><span class="line">		configuration.setDefaultEncoding(&quot;utf-8&quot;);</span><br><span class="line">		&#x2F;&#x2F;4.加载模板</span><br><span class="line">		Template template &#x3D; configuration.getTemplate(&quot;test.ftl&quot;);</span><br><span class="line">		&#x2F;&#x2F;5.创建数据模型</span><br><span class="line">		Map map&#x3D;new HashMap();</span><br><span class="line">		map.put(&quot;name&quot;, &quot;张三 &quot;);</span><br><span class="line">		map.put(&quot;message&quot;, &quot;欢迎来到神奇的品优购世界！&quot;);</span><br><span class="line">		&#x2F;&#x2F;6.创建Writer对象</span><br><span class="line">		Writer out &#x3D;new FileWriter(new File(&quot;d:\\test.html&quot;));</span><br><span class="line">		&#x2F;&#x2F;7.输出</span><br><span class="line">		template.process(map, out);</span><br><span class="line">		&#x2F;&#x2F;8.关闭Writer对象</span><br><span class="line">		out.close();</span><br></pre></td></tr></table></figure>

<p>执行后，在D盘根目录即可看到生成的test.html ，打开看看<br>其实静态化的流程都是一样的，</p>
<p>只是在第四步的时候，是注入 模板对象@Autotuy  ReTemplate  reTemplate，</p>
<p>第五步的时候是注入其他的依赖   获取页面详情页所需要的数据  然后  数据+模板引擎=新的页面</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>创建定时任务主要有两种创建方式：一、基于注解(@Scheduled) 二、基于接口（SchedulingConfigurer）</p>
<h3 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h3><p>一个<strong>cron表达式</strong>有至少6个（也可能7个）有空格分隔的时间元素。crontab参数<code>* * * * * * *</code></p>
<p>第一个*  second: 区间为 0 – 59    <code>, - * /</code></p>
<p>第二个*  minute: 区间为 0 – 59  <code>, - * /</code></p>
<p>第三个*  hour: 区间为0 – 23  <code>, - * /</code><br>第四个*  day-of-month: 区间为0 – 31  <code>, - * / ? L W C</code><br>第五个*  month: 区间为1 – 12 或JAN-DEC    1 是1月  12是12月  <code>, - * /</code><br>第六个*  Day-of-week: 区间为0 – 7 或SUN-SAT   周日可以是0或7  <code>, - * / ? L C #</code></p>
<p>第七个* （可选）year：区间为1970-2099  <code>, - * /</code></p>
<p>1.有些子表达式能包含一些范围或列表</p>
<p>例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”</p>
<p>2.<code>* </code>字符代表所有可能的值：表示匹配该域的任意值，假如在Minutes域使用*, 即表示每分钟都会触发事件</p>
<p>3.<code>/</code>字符用来指定数值的增量：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次.</p>
<p>4.<code>？</code>字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值（也就是第四位和第六位只能指定一个值，另一个不指定的就为？）</p>
<p>只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。</p>
<p>例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用<em>，如果使用</em>表示不管星期几都会触发，实际上并不是这样。</p>
<p>5.<code>-</code>表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 </p>
<p>6.<code>,</code>表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次</p>
<p>7.<code>L</code>字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写</p>
<p>在天（月）子表达式中，“L”表示一个月的最后一天</p>
<p>在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT</p>
<p>如果在“L”前有具体的内容，它就具有其他的含义了</p>
<p>例如：</p>
<p>在DayofWeek域使用5L,意味着在最后的一个星期四触发</p>
<p>“6L”表示这个月的倒数第６天，“ＦＲＩＬ”表示这个月的最一个星期五</p>
<p>注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>
<p><code>W</code>表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。</p>
<p>例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份</p>
<p><code>LW</code> 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五</p>
<p><code>#</code>用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三</p>
<h3 id="一、静态定时任务（基于注解）"><a href="#一、静态定时任务（基于注解）" class="headerlink" title="一、静态定时任务（基于注解）"></a>一、静态定时任务（基于注解）</h3><p>基于注解@Scheduled默认为单线程，开启多个任务时，任务的执行时机会受上一个任务执行时间的影响</p>
<p>当定时任务增多，如果一个任务卡死，会导致其他任务也无法执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration &#x2F;&#x2F;1.主要用于标记配置类，兼备Component的效果。</span><br><span class="line">@EnableScheduling &#x2F;&#x2F; 2.开启定时任务</span><br><span class="line">public class SimpleScheduleConfig &#123;</span><br><span class="line">    &#x2F;&#x2F;3.添加定时任务</span><br><span class="line">    @Scheduled(cron &#x3D; &quot;0&#x2F;5 * * * * ?&quot;)</span><br><span class="line">    private void configureTasks() &#123;</span><br><span class="line">        System.out.println(&quot;执行定时任务1: &quot; + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动应用，可以看到控制台的信息打印出了语句。</p>
<p>使用Scheduled 很方便，但缺点是当我们调整了执行周期的时候，需要重启应用才能生效，这多少有些不方便。为了达到实时生效的效果，可以使用接口来完成定时任务。</p>
<h3 id="二、动态定时任务（基于接口）"><a href="#二、动态定时任务（基于接口）" class="headerlink" title="二、动态定时任务（基于接口）"></a>二、动态定时任务（基于接口）</h3><p>数据库准备好数据之后，编写定时任务，注意这里添加的是TriggerTask，目的是循环读取我们在数据库设置好的执行周期，以及执行相关定时任务的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteScheduleConfig</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapper</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CronMapper</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Select(&quot;select cron from cron limit 1&quot;)</span></span><br><span class="line">        <span class="function">String <span class="title">getCron</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    CronMapper cronMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行定时任务.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">                <span class="comment">//1.添加任务内容(Runnable)</span></span><br><span class="line">                () -&gt; System.out.println(<span class="string">&quot;执行定时任务2: &quot;</span> + LocalDateTime.now().toLocalTime()),</span><br><span class="line">                <span class="comment">//2.设置执行周期(Trigger)</span></span><br><span class="line">                triggerContext -&gt; &#123;</span><br><span class="line">                    <span class="comment">//2.1 从数据库获取执行周期</span></span><br><span class="line">                    String cron = cronMapper.getCron();</span><br><span class="line">                    <span class="comment">//2.2 合法性校验.</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(cron)) &#123;</span><br><span class="line">                        <span class="comment">// Omitted Code .. 省略代码</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.3 返回执行周期(Date)</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> CronTrigger(cron).nextExecutionTime(triggerContext);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： 如果在数据库修改时格式出现错误，则定时任务会停止，即使重新修改正确；此时只能重新启动项目才能恢复</p>
<h3 id="三、多线程定时任务"><a href="#三、多线程定时任务" class="headerlink" title="三、多线程定时任务"></a>三、多线程定时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component注解用于对那些比较中立的类进行注释；</span></span><br><span class="line"><span class="comment">//相对与在持久层、业务层和控制层分别采用 @Repository、@Service 和 @Controller 对分层中的类进行注释</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>   <span class="comment">// 1.开启定时任务</span></span><br><span class="line"><span class="meta">@EnableAsync</span>        <span class="comment">// 2.开启多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadScheduleTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Async</span></span><br><span class="line">        <span class="meta">@Scheduled(fixedDelay = 1000)</span>  <span class="comment">//间隔1秒</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第一个定时任务开始 : &quot;</span> + LocalDateTime.now().toLocalTime() + <span class="string">&quot;\r\n线程 : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            System.out.println();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Async</span></span><br><span class="line">        <span class="meta">@Scheduled(fixedDelay = 2000)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第二个定时任务开始 : &quot;</span> + LocalDateTime.now().toLocalTime() + <span class="string">&quot;\r\n线程 : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/12.3.SpringBoot/20181220165535820.png" alt="在这里插入图片描述"></p>
<p>每一个任务都是在不同的线程中，第一个定时任务和第二个定时任务互不影响；</p>
<p>并且，由于开启了多线程，第一个任务的执行时间也不受其本身执行时间的限制，所以需要注意可能会出现重复操作导致数据异常</p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h3 id="Timer："><a href="#Timer：" class="headerlink" title="Timer："></a>Timer：</h3><p>这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。</p>
<p>在java中一个完整的定时任务可以用Timer和TimerTask两个类配合完成。</p>
<p>Timer是一种工具，线程用其安排在后台线程中执行的任务，可安排任务执行一次或者定期重复执行。</p>
<p>TimerTask是由Timer安排执行一次或者重复执行的任务。</p>
<p>Timer中提供了四个方法：</p>
<p>（1）schedule(TimerTask task,Date time)——安排在指定的时间执行指定的任务</p>
<p>（2）schedule(TimerTask task,Date firstTime,long period)——安排指定的任务在指定的时间开始进行重复的固定延迟执行</p>
<p>（3）schedule(TimerTask task,long delay)——安排在指定延迟后执行指定的任务</p>
<p>（4）schedule(TimerTask task,long delay,long period)——安排指定的任务在指定的延迟后开始进行重复的固定速率执行</p>
<p>注意：Timer对于系统时间的改变非常敏感，它对调度的支持是基于绝对时间而不是相对时间。</p>
<p>Timer线程是不会捕获异常的，多线程并行处理定时任务时，Timer运行多个TimerTask时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止运行。同时Timer也不会重新恢复线程的执行，它会错误的认为整个Timer线程都会取消，已经被安排但尚未执行的TimerTask也不会再执行了，新的任务也不能被调度。因此，如果TimerTask抛出未检查的异常，Timer将会产生无法预料的行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTimer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;task  run:&quot;</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">//安排指定的任务在指定的时间开始进行重复的固定延迟执行。这里是每3秒执行一次</span></span><br><span class="line">        timer.schedule(timerTask,<span class="number">10</span>,<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ScheduledExecutorService："><a href="#ScheduledExecutorService：" class="headerlink" title="ScheduledExecutorService："></a>ScheduledExecutorService：</h3><p>jdk自带的一个类；是基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。</p>
<p>Timer是基于绝对时间的，对系统时间比较敏感，而ScheduledExecutor则是基于相对时间。</p>
<p>Timer的内部只有一个线程，如果有多个任务的话就会顺序执行，这样我们的延迟时间和循环时间就会出现问题。而ScheduledThreadPoolExecutor内部是个线程池，可以支持多个任务并发执行，在对延迟任务和循环任务要求严格的时候，就需要考虑使用ScheduledExecutor了。</p>
<p>针对Timer类存在的缺陷，Java 5 推出了基于线程池设计的 ScheduledExecutor，ScheduledExecutor的设计思想是每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发的，相互之间不会受到干扰，只有当任务的时间到来时，ScheduledExecutor才会真正启动一个线程，其余时间ScheduledExecutor都是处于轮询任务的状态。如果我们设定的调度周期小于任务运行时间，该任务会被重复添加到一个延时任务队列，所以同一时间任务队列中会有多个任务待调度，线程池会首先获取优先级高的任务执行。效果就是任务运行多长时间，调度时间就会变为多久，因为添加到任务队列的任务的延时时间每次都是负数，所以会被立刻执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScheduledExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        <span class="comment">// 参数：1、任务体 2、首次执行的延时时间</span></span><br><span class="line">        <span class="comment">//      3、任务执行间隔 4、间隔时间单位</span></span><br><span class="line">        service.scheduleAtFixedRate(()-&gt;System.out.println(<span class="string">&quot;task ScheduledExecutorService &quot;</span>+<span class="keyword">new</span> Date()), <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Spring-Task："><a href="#Spring-Task：" class="headerlink" title="Spring Task："></a>Spring Task：</h3><p>Spring3.0以后自带的task，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。</p>
<p>也就是上面的那个定时器</p>
<p>Spring提供的注解，优点就是配置简单，依赖少，缺点是同一个task，如果前一个还没跑完后面一个就不会触发，不同的task也不能同时运行。因为scheduler的默认线程数为1，配置pool-size为2的话，会导致同一个task前一个还没跑完后面又被触发的问题，不支持集群等。</p>
<h3 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h3><p>Quartz 是一个完全由 Java 编写的开源作业调度框架，它可以集成在几乎任何Java应用程序中进行作业调度。</p>
<p>Quartz 可以与 J2EE 与 J2SE 应用程序相结合也可以单独使用。</p>
<p>Quartz 允许程序开发人员根据时间的间隔来调度作业。</p>
<p>Quartz 实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。</p>
<p>Quartz的运行环境</p>
<p>Quartz 可以运行嵌入在另一个独立式应用程序。</p>
<p>Quartz 可以在应用程序服务器(或 servlet 容器)内被实例化，并且参与 XA 事务。</p>
<p>Quartz 可以作为一个独立的程序运行(其自己的 Java 虚拟机内)，可以通过 RMI 使用。</p>
<p>Quartz 可以被实例化，作为独立的项目集群(负载平衡和故障转移功能)，用于作业的执行。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a><strong>拦截器</strong></h2><p>一个完善的Web应用一定要考虑安全问题，比如，只有登录上系统的用户才能查看系统内的资源，或者只有具备相关权限，才能访问对应的资源，为此，我们需要学习一下拦截器，通过拦截器我们就能够实现这些安全认证。</p>
<p>这里以登录检查为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        HttpSession session &#x3D; request.getSession();</span><br><span class="line">        </span><br><span class="line">        Object user &#x3D; session.getAttribute(&quot;user&quot;);</span><br><span class="line">        if(user !&#x3D; null)&#123;</span><br><span class="line">            </span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        response.sendRedirect(&quot;&#x2F;toLogin&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写好拦截器后需要将其配置到容器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyWebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        </span><br><span class="line">        registry.addInterceptor(new LoginInterceptor())</span><br><span class="line">                .addPathPatterns(&quot;&#x2F;**&quot;) </span><br><span class="line">                .excludePathPatterns(&quot;toLogin&quot;, &quot;&#x2F;css&#x2F;**&quot;, &quot;&#x2F;js&#x2F;**&quot;, &quot;&#x2F;fonts&#x2F;**&quot;, &quot;&#x2F;images&#x2F;**&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要指定该拦截器需要拦截哪些资源，需要放行哪些资源，这样一个简单的登录校验就完成了。</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a><strong>文件上传</strong></h2><p>Spring Boot中该如何实现文件上传呢？现有如下的一个表单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;upload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;f&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>编写控制方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class FileController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;upload&quot;)</span><br><span class="line">    public String upload(@RequestPart(&quot;f&quot;) MultipartFile file)&#123;</span><br><span class="line">        String name &#x3D; file.getOriginalFilename();</span><br><span class="line">        long size &#x3D; file.getSize();</span><br><span class="line">        return name + &quot;:&quot; + size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过@RequestPart注解即可将上传的文件封装到MultipartFile中，通过该对象便可以获取到文件的所有信息。输出结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwQ0g16A0M2u8FtjicATQWpxfqRqAAIxpexYh0nYoZTVbxWyVdyKSy0iaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>若是上传多个文件，则先修改表单信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&#x2F;upload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;f&quot; multiple&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>在文件框位置添加multiple属性即可支持多文件上传，然后修改控制器代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;upload&quot;)</span><br><span class="line">public String upload(@RequestPart(&quot;f&quot;) MultipartFile[] file)&#123;</span><br><span class="line">    return file.length + &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是需要将上传的文件保存到服务器，则可以如此做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;upload&quot;)</span><br><span class="line">public String upload(@RequestPart(&quot;f&quot;) MultipartFile[] file) throws IOException &#123;</span><br><span class="line">    for (MultipartFile multipartFile : file) &#123;</span><br><span class="line">        if(!multipartFile.isEmpty())&#123;</span><br><span class="line">            </span><br><span class="line">            String filename &#x3D; multipartFile.getOriginalFilename();</span><br><span class="line">            </span><br><span class="line">            multipartFile.transferTo(new File(&quot;E:\\&quot; + filename));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Spring Boot默认的文件上传大小限制为1MB，所以只要文件稍微大了一点就会上传失败，为此，可以修改SpringBoot的默认配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.servlet.multipart.max-file-size&#x3D;30MB # 配置单个文件上传大小限制</span><br><span class="line">spring.servlet.multipart.max-request-size&#x3D;100MB # 配置总文件上传大小限制</span><br></pre></td></tr></table></figure>



<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a><strong>错误处理</strong></h2><p>默认情况下，SpringBoot应用出现了异常或错误会自动跳转至/error页面，也就是这个熟悉的页面：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwfSJ3M2E2CH295oCIWdKYiayZPz4B3RFGibX5tHLlUqCYABKqiaLASDvWg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然而一般情况下，我们都不会选择出异常时显示这个页面，而是想要显示我们自己定制的页面，为此，我们可以在/static或/templates目录下新建一个error目录，并在/error目录下放置命名为4xx、5xx的页面，SpringBoot会自动帮助我们解析。 </p>
<p>此时当出现5xx的异常时，SpringBoot会自动跳转至5xx.html页面，当然你也可以对每个状态码都做一个页面进行对应，比如放置500.html、501.html、502.html文件，当服务器出现对应的异常时，就会跳转至对应的页面。</p>
<h2 id="健康检查、审计、统计和监控"><a href="#健康检查、审计、统计和监控" class="headerlink" title="健康检查、审计、统计和监控"></a>健康检查、审计、统计和监控</h2><p>Spring Boot Actuator可以帮助你监控和管理Spring Boot应用，比如健康检查、审计、统计和HTTP追踪等。所有的这些特性可以通过JMX或者HTTP endpoints来获得</p>
<p>Actuator同时还可以与外部应用监控系统整合，比如 Prometheus, Graphite, DataDog, Influx, Wavefront, New Relic等。这些系统提供了非常好的仪表盘、图标、分析和告警等功能，使得你可以通过统一的接口轻松的监控和管理你的应用。</p>
<p>Actuator使用Micrometer来整合上面提到的外部应用监控系统。这使得只要通过非常小的配置就可以集成任何应用监控系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>Actuator创建了所谓的<strong>endpoint</strong>来暴露HTTP或者JMX来监控和管理应用</p>
<p><code>/health</code>endpoint，提供了关于应用健康的基础信息。</p>
<p><code>/metrics</code>endpoints展示了几个有用的度量信息，比如JVM内存使用情况、系统CPU使用情况、打开的文件等等。</p>
<p><code>/loggers</code>endpoint展示了应用的日志和可以让你在运行时改变日志等级</p>
<p><strong>值得注意的是，每一个actuator endpoint可以被显式的打开和关闭。此外，这些endpoints也需要通过HTTP或者JMX暴露出来，使得它们能被远程进入</strong></p>
<h2 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a><strong>数据层</strong></h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><strong>JDBC</strong></h3><p>若想使用原生的JDBC进行开发，SpringBoot已经为我们配置好了JDBC的相关信息，只需要引入依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.1.49&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>Spring Boot 底层自动配置了HikariDataSource数据源，所以我们只需指定数据源的地址、用户名和密码即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;123456</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<p>因为SpringBoot已经自动配置好了JdbcTemplate，所以我们直接使用就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class SpringbootApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        List&lt;String&gt; names &#x3D; jdbcTemplate.queryForList(&quot;select name from student&quot;,String.class);</span><br><span class="line">        for (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a><strong>Druid</strong></h3><p>若是不想使用Spring Boot底层的数据源，我们也可以修改默认配置，以Druid数据源为例，首先引入依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.10&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>并对Druid进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 开启Druid的监控页功能</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled&#x3D;true</span><br><span class="line"># 开启防火墙功能</span><br><span class="line">spring.datasource.druid.filter-class-names&#x3D;stat,wall</span><br><span class="line"># 配置监控页的用户名和密码</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username&#x3D;admin</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password&#x3D;123</span><br><span class="line"># 开启Druid的Web监控功能</span><br><span class="line">spring.datasource.druid.web-stat-filter.enabled&#x3D;true</span><br><span class="line"># 配置监控哪些请求</span><br><span class="line">spring.datasource.druid.web-stat-filter.url-pattern&#x3D;...</span><br></pre></td></tr></table></figure>

<p>此时访问<a target="_blank" rel="noopener" href="http://localhost:8080/druid%EF%BC%8C%E5%B0%86%E4%BC%9A%E6%9D%A5%E5%88%B0Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B5%EF%BC%9A">http://localhost:8080/druid，将会来到Druid的监控页：</a></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsjuQ9hhKup7oUdNM5yHX5vwmSnFVzD1lv7yyqibGtymFIjf9ickz8Ak2vRCergkAOdK7gzCXNAMBQicA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><strong>MyBatis</strong></h3><p>接下来我们将整合MyBatis框架，并介绍它的简单使用。首先引入依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>然后编写Mapper接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line"></span><br><span class="line">    Student getStu(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写Mappe配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;DTD Mapper 3.0&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.wwj.springboot.dao.StudentMapper&quot;&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;getStu&quot; resultType&#x3D;&quot;com.wwj.springboot.bean.Student&quot;&gt;</span><br><span class="line">        select * from student where id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>最后配置一下MyBatis：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 配置Mapper配置文件的位置</span><br><span class="line">mybatis.mapper-locations&#x3D;classpath:mappers</span><br></pre></td></tr></table></figure>

<p>这样就可以使用MyBatis了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class SpringbootApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        Student stu &#x3D; studentMapper.getStu(1);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><p>若是想要整合Redis，也非常地简单，首先引入依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>然后进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 主机地址</span><br><span class="line">spring.redis.host&#x3D;172.16.136.196</span><br></pre></td></tr></table></figure>

<p>只需要配置Redis的主机地址就可以操作Redis了，操作步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class SpringbootApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; operations &#x3D; redisTemplate.opsForValue();</span><br><span class="line">        operations.set(&quot;name&quot;,&quot;zhangsan&quot;);</span><br><span class="line">        String name &#x3D; operations.get(&quot;name&quot;);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是想使用Jedis操作Redis，则需要导入Jedis的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>并配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.client-type&#x3D;jedis</span><br></pre></td></tr></table></figure>





<h2 id="Filter-ThreadLocal"><a href="#Filter-ThreadLocal" class="headerlink" title="Filter+ThreadLocal"></a>Filter+ThreadLocal</h2><p>由于jwt的出现，使请求方法的参数中不再携带用户的标识，而是将含有用户信息的token放入请求头中，在该请求进入业务之前就要进行层层过滤拦截，这时候就会牵扯出来了一个问题，如何在当前请求的线程中保存该请求用户的信息。</p>
<ol>
<li><p>ThreadLocal<br>ThreadLocal叫做线程变量，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<p>所以设计思路是，我们可以将每个访问的请求拦截下，为其分配线程变量，就先是全局变量一样，在这次请求访问的所有作用域处都可以从中拿出变量进行使用：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 存储/获取当前线程的用户信息工具类</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UserUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程变量，存放user实体类信息，即使是静态的与其他线程也是隔离的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; userThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从当前线程变量中获取用户信息</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getLoginUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       User user = userThreadLocal.get();</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前登录用户的ID</span></span><br><span class="line"><span class="comment">    * 未登录返回null</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getLoginUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      User user = userThreadLocal.get();</span><br><span class="line">      <span class="keyword">if</span> (user != <span class="keyword">null</span> &amp;&amp; user.getId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> user.getId();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为当前的线程变量赋值上用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLoginUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    userThreadLocal.set(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除线程变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userThreadLocal.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们可以看出LocalThread的应用场景：</p>
<p>1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</p>
<p>2、线程间数据隔离</p>
<p>3、进行事务操作，用于存储线程事务信息。</p>
<p>4、数据库连接，Session会话管理。</p>
<ol start="2">
<li>Filter中的使用</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口业务均在api下</span></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;testFilter&quot;,urlPatterns = &#123;&quot;/api/*&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(AccessInterceptor.class);</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">     HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">     String token = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">     <span class="comment">// 拿到token后，可以自行处理，这里假设从token获取到了id</span></span><br><span class="line">     <span class="keyword">if</span>(userId != <span class="keyword">null</span>)&#123;</span><br><span class="line">         User user = userService.getById(userId);</span><br><span class="line">         UserUtils.setLoginUser(user);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		UserUtils.setLoginUser(<span class="keyword">null</span>);  </span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">//执行,在后续的拦截器中还可以再进行权限拦截</span></span><br><span class="line">     filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>在拦截器中的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// access为自定义权限注解，if条件指该接口访问权限至少要登录（具备token）</span></span><br><span class="line">     <span class="keyword">if</span> (access.level().getCode() &gt;= AccessLevel.LOGIN.getCode()) &#123;</span><br><span class="line">     	<span class="comment">//这里可以直接在拦截器中再次获取用户信息</span></span><br><span class="line">         User user = UserUtils.getLoginUser();</span><br><span class="line">         <span class="keyword">if</span> (user == <span class="keyword">null</span> || user.getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">             response.setStatus(<span class="number">401</span>);</span><br><span class="line">             logger.info(<span class="string">&quot;access &quot;</span> + method.getName() + <span class="string">&quot; Not logged in&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (user.getType() &lt; access.level().getCode()) &#123;</span><br><span class="line">             response.setStatus(<span class="number">403</span>);</span><br><span class="line">             logger.info(<span class="string">&quot;access &quot;</span> + method.getName() + <span class="string">&quot; No authority&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. Controller&#x2F;Service层的使用</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;在Controller或是Service中依然可以通过线程变量或取该用户信息</span><br><span class="line">User user &#x3D; UserUtils.getLoginUser();</span><br><span class="line">long userId &#x3D; UserUtils.getLoginUserId();</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。使用起来确实十分方便，但是也要有注意的地方：</p>
<p><img src="https://img-blog.csdnimg.cn/20200811152649433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjgyMjQ4NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>上图详细的说明了ThreadLocal和Thread以及ThreadLocalMap三者之间的关系。</p>
<p>1、Thread中有一个map，即ThreadLocalMap。</p>
<p>2、ThreadLocalMap的key是ThreadLocal，值是我们自己赋值的。</p>
<p>3、ThreadLocal是一个弱引用，当为null时侯，会被当成垃圾回收。</p>
<p>4、如果我们ThreadLocal是null了，也就是要被垃圾回收器回收了，但是此时我们的ThreadLocalMap生命周期和Thread的一样，它不会回收，这时候就出现了一个现象。那就是ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。</p>
<p>解决办法：使用完ThreadLocal后，即拦截器的后处理，执行remove操作，避免出现内存溢出情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    UserUtils.removeUser();  <span class="comment">//其中调用的就是 userThreadLocal.remove();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="ApplicationRunner（一个spring容器启动完成执行的类）"><a href="#ApplicationRunner（一个spring容器启动完成执行的类）" class="headerlink" title="ApplicationRunner（一个spring容器启动完成执行的类）"></a>ApplicationRunner（一个spring容器启动完成执行的类）</h2><p>在项目中，可能会遇到这样一个问题：在项目启动完成之后，紧接着执行一段代码。<br>在SpringBoot中，提供了一个接口：<strong>ApplicationRunner</strong>。<br>该接口中，只有一个run方法，他执行的时机是：<strong>spring容器启动完成之后，就会紧接着执行这个接口实现类的run方法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PublishEndpoint implements ApplicationRunner&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run(ApplicationArguments applicationArguments) throws Exception &#123;</span><br><span class="line">	&#x2F;&#x2F;do something</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几点说明：</p>
<ul>
<li>这个实现类，要注入到spring容器中，这里使用了@Component注解；</li>
<li>在同一个项目中，可以定义多个ApplicationRunner的实现类，他们的执行顺序通过注解@Order注解或者再实现Ordered接口来实现。</li>
<li>run方法的参数：ApplicationArguments可以获取到当前项目执行的命令参数。（比如把这个项目打成jar执行的时候，带的参数可以通过ApplicationArguments获取到）；</li>
<li>由于该方法是在容器启动完成之后，才执行的，所以，这里可以从spring容器中拿到其他已经注入的bean。</li>
</ul>
<h2 id="新建一个springboot项目"><a href="#新建一个springboot项目" class="headerlink" title="新建一个springboot项目"></a>新建一个springboot项目</h2><p>一、创建项目</p>
<p>1.File-&gt;new-&gt;project；</p>
<p><img src="https://img-blog.csdnimg.cn/20190801203834598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM5Mjk4NjI1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>2.选择“Spring Initializr”，点击next；（jdk1.8默认即可）</p>
<p><img src="https://img-blog.csdnimg.cn/20190801204126964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM5Mjk4NjI1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>选择default可能会因为网速导致项目新建失败。</p>
<p>不选择默认的Default，而是适用Custom，输入aliyun的镜像节点：<a target="_blank" rel="noopener" href="http://start.aliyun.com/">http://start.aliyun.com</a></p>
<p>3.完善项目信息，组名可不做修改，项目名可做修改；最终建的项目名为：test，src-&gt;main-&gt;java下包名会是：com-&gt;example-&gt;test；点击next；</p>
<p><img src="https://img-blog.csdnimg.cn/2019080120463896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM5Mjk4NjI1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>4.Web下勾选Spring Web Start，（网上创建springboot项目多是勾选Web选项，而较高版本的Springboot没有此选项，勾选Spring Web Start即可，2.1.8版本是Spring Web）；Template Englines勾选Thymeleaf；SQL勾选：MySQL Driver，JDBC API 和 MyBatis Framework三项；点击next；</p>
<p><img src="https://img-blog.csdnimg.cn/20190801205736116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM5Mjk4NjI1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>5.选择项目路径，点击finish；打开新的窗口；</p>
<p><img src="https://img-blog.csdnimg.cn/20190801205931712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM5Mjk4NjI1,size_16,color_FFFFFF,t_70" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/12.3.SpringBoot/" data-id="ckvrw5ftx007u5gwd1elx3kkp" data-title="SpringBoot" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/17/12.2.SpringMVC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          SpringMVC
        
      </div>
    </a>
  
  
    <a href="/2021/04/17/12.4.SpringCloud/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">SpringCloud</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>