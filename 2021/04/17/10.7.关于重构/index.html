<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>关于重构 | swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="什么是重构？Martin Fowler曾出版了两本有关重构的书籍，他认为： 重构指的是，在不改变代码的外部行为，只改善其内部结构的方式下，修改软件系统的过程。重构是一种有条理的清理代码的方式，可以最大程度地减少引入bug的机会。本质上，重构意味着在代码编写完成后，改进代码的设计。 重构有什么好处？首先，重构可以将混乱、不正确和&#x2F;或重复的代码转换成整洁的代码。它可以解决多位开发人员协同工作时可能引发">
<meta property="og:type" content="article">
<meta property="og:title" content="关于重构">
<meta property="og:url" content="https://s-qwer.github.io/2021/04/17/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="什么是重构？Martin Fowler曾出版了两本有关重构的书籍，他认为： 重构指的是，在不改变代码的外部行为，只改善其内部结构的方式下，修改软件系统的过程。重构是一种有条理的清理代码的方式，可以最大程度地减少引入bug的机会。本质上，重构意味着在代码编写完成后，改进代码的设计。 重构有什么好处？首先，重构可以将混乱、不正确和&#x2F;或重复的代码转换成整洁的代码。它可以解决多位开发人员协同工作时可能引发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAughAuEz9WJKmOEboib3KY1y335WhibibfKKEic84Md2OlBMT0UxxICJs15MOBWP5zulrkg2x6icPO3ZqtA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720141907210.png">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142318893.png">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142334301.png">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142346463.png">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142358859.png">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142117537.png">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/640">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720143839909.png">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144034337.png">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144200655.png">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144601409.png">
<meta property="og:image" content="https://s-qwer.github.io/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144618190.png">
<meta property="article:published_time" content="2021-04-17T05:16:25.000Z">
<meta property="article:modified_time" content="2021-07-20T06:46:19.743Z">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAughAuEz9WJKmOEboib3KY1y335WhibibfKKEic84Md2OlBMT0UxxICJs15MOBWP5zulrkg2x6icPO3ZqtA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-10.7.关于重构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T05:16:25.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      关于重构
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="什么是重构？"><a href="#什么是重构？" class="headerlink" title="什么是重构？"></a><strong>什么是重构？</strong></h1><p>Martin Fowler曾出版了两本有关重构的书籍，他认为：</p>
<p>重构指的是，在不改变代码的外部行为，只改善其内部结构的方式下，修改软件系统的过程。重构是一种有条理的清理代码的方式，可以最大程度地减少引入bug的机会。本质上，重构意味着在代码编写完成后，改进代码的设计。</p>
<h1 id="重构有什么好处？"><a href="#重构有什么好处？" class="headerlink" title="重构有什么好处？"></a><strong>重构有什么好处？</strong></h1><p>首先，重构可以将混乱、不正确和/或重复的代码转换成整洁的代码。它可以解决多位开发人员协同工作时可能引发的代码标准化问题。重构可以提高可读性，改善源代码的可维护性以及整体结构和功能。重构可以使代码更易于扩展和添加新功能。删除不必要的代码（比如重复代码）可以减少代码所使用的内存，并加快执行速度。 </p>
<p>例如，在2014年，Kickstarter的工程师面临着一个巨大的挑战：由于用户数量呈指迅速增长，导致查询性能下降。为此，他们将MySQL查询重构为Redis，减少了100毫秒的加载时间，从而减少了加载时间的差异并提高了网站的整体速度。</p>
<h1 id="技术负债与重构"><a href="#技术负债与重构" class="headerlink" title="技术负债与重构"></a><strong>技术负债与重构</strong></h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAughAuEz9WJKmOEboib3KY1y335WhibibfKKEic84Md2OlBMT0UxxICJs15MOBWP5zulrkg2x6icPO3ZqtA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>简而言之，重构是消除或减少技术负债的一种方式。</p>
<p>重构对于长期维持的代码质量、安全性和性能至关重要。如果没有定期的重构，开发人员就会承受巨大的技术负债。重构代码的机会越少，技术负债就会越多，开发新功能也会变得越来越难。</p>
<h1 id="重构的指标"><a href="#重构的指标" class="headerlink" title="重构的指标"></a><strong>重构的指标</strong></h1><p>我们可以通过各种指标，衡量重构代码的优先级。在指标的帮助下，我们可以有条不紊地计划重构，每一次都专心完成最重要的任务。</p>
<p>此外，你需要通过指标来衡量重构的效果。我们不仅需要重构低效的代码，而且还可以通过修改低效代码增加价值。为了获得真正的价值，你需要进行测试，包括单元测试和功能测试。除此之外，还有一些其他方面的指标，比如发现的bug数减少，以及降低循环复杂性（重构的目标是降低复杂性）。高度复杂的方法或功能（比如超过350行的方法或功能）就是良好的重构对象。</p>
<p>此外，我们还需要考虑，如何将重构融合到更广泛的团队目标或有关工作流和任务的里程碑中。</p>
<h1 id="代码重构示例"><a href="#代码重构示例" class="headerlink" title="代码重构示例"></a><strong>代码重构示例</strong></h1><p>代码重构的示例非常多，为了简洁起见，我们介绍以下几种：</p>
<p><strong>红色，绿色和重构</strong></p>
<p>重构与单元测试息息相关。最常见的形式之一就是敏捷方法固有的测试驱动开发（Test-Driven Development，即TDD）。你可以在编写代码之前先编写测试。从本质上来说，应该由测试来驱动程序，说明代码应该执行的操作。</p>
<p>红色，绿色和重构是测试驱动开发的一个示例：</p>
<ul>
<li>红色：编写没有实现代码的测试套件，必然会失败。</li>
<li>绿色：编写实现代码，刚刚好可以通过测试套件。</li>
<li>重构：寻找优化和改进代码的方法。</li>
</ul>
<p><strong>提取方法（又名提取函数）</strong></p>
<p>将代码片段从现有方法移到新方法中，而新方法的名称明确说明了其功能。这种技术有助于降低复杂性并提高代码的可读性。</p>
<p><strong>提取变量</strong> </p>
<p>如果遇到难以理解的表达式，或者该表达式在整个代码中重复了多次，则可以通过提取变量重构，将表达式或其中一部分放入一个复杂度较低且更易于理解的变量中。这样可以减少复杂性和代码重复。</p>
<p><strong>按抽象建立分支</strong></p>
<p>按抽象建立分支可以逐步对软件系统进行大规模地修改，而你则可以一边修改代码，一边定期发布系统。这种方法可以降低在分支上重构代码的复杂性，避免在合并代码时出现问题。</p>
<p><strong>方法组合</strong></p>
<p>代码过长不便于理解，而且也不方便修改。方法组合指的是一系列的操作，将方法改成顺序结构并删除重复的代码。这些操作包括内联方法、内联模板、用查询代替模板、拆分临时变量以及删除对参数的赋值等。</p>
<h1 id="重构代码的工具"><a href="#重构代码的工具" class="headerlink" title="重构代码的工具"></a><strong>重构代码的工具</strong></h1><p>你需要专业的重构工具吗？Martin Fowler表示，自动化的工具有帮助但不是必需的。他指出：</p>
<p>“许多语言都有IDE，可以自动执行许多常见的重构。这些是非常有价值的工具，可以帮助我更快地重构代码。但是，这些工具不是必不可少的，我经常在没有工具支持的情况下编写程序，每次只迈出一小步，并通过频繁的测试来发现错误。”</p>
<p>许多开发环境都可以自动化重构，一些常见的重构工具包括：</p>
<ul>
<li>Visual studio intellicode</li>
<li>Eclipse IDE</li>
<li>Spring Tool Suite 4</li>
<li>Rider</li>
<li>IntelliJ IDEA</li>
<li>SonarQube</li>
</ul>
<h1 id="重构与工程经理的难题"><a href="#重构与工程经理的难题" class="headerlink" title="重构与工程经理的难题"></a><strong>重构与工程经理的难题</strong></h1><p>为了解决引发重构需求的问题，首先我们需要弄清楚公司的运营方式。在着手重构之前，请先回答下列几个问题：</p>
<ul>
<li>哪些任务最优先？</li>
<li>开发的速度如何？</li>
<li>开发人员是否感觉到了快速交付代码的压力？</li>
<li>解决技术负债的流程都有哪些？</li>
<li>实施了哪些类型的代码审核？</li>
<li>团队成员是否具备适当的重构技能？</li>
<li>公司的文档标准是什么？</li>
</ul>
<p>如果不解决引发重构需求的根本问题，那么问题只会愈演愈糟。</p>
<h1 id="高级管理层对重构的支持"><a href="#高级管理层对重构的支持" class="headerlink" title="高级管理层对重构的支持"></a><strong>高级管理层对重构的支持</strong></h1><p>你们公司可能并没有在基础设施和维护上投入太多资金。</p>
<p>可能会有人说，应该将花费在重构上的时间投入到新功能开发上。</p>
<p>但是，我们仍然应该看一看重构的好处，以及它们与工作流程、客户、收入和业务增长的关系。重构得当可以改善代码，交付有效更新以及急需的功能，从而吸引新客户和回头客。即使在成功发布产品之后，软件公司也可以通过这种方式保持竞争力。 </p>
<p>为了获取高层管理的支持，还有一个更好的方法，即量化团队当前花费在修复原始代码中的错误或bug上的时间。具体一点，比如每天一个小时？每天两个小时？持续记录一个星期，你就会惊讶地发现原来团队每年需要花费数周或数月时间来修复遗留的代码。</p>
<h1 id="团队支持与重构：一个Sprint还是马拉松？"><a href="#团队支持与重构：一个Sprint还是马拉松？" class="headerlink" title="团队支持与重构：一个Sprint还是马拉松？"></a><strong>团队支持与重构：一个Sprint还是马拉松？</strong></h1><p>很难在团队内部开展重构工作？提及重构就会哀声载道？顺利开展重构的最重要的标志就是有计划、有目标以及有文档记录的行动。Ron Jeffries（极限编程的三大创始人之一）将重构比喻为清道：</p>
<p>“花些时间清出一条道来，那么下一次我们就可以直奔我们要构建的下一个功能，而无需绕过杂草和灌木丛。”</p>
<p>但是，他强调指出，糟糕的代码需要花费很长的时间来清理，而且重构应该经过深思熟虑：</p>
<p>“如果我们只改进手头的代码，而忽略目前不涉及的代码，那么以后必然会走回头路。”</p>
<p>在同一个Sprint中，我们经常发现后面的功能用到了我们之前清理过的代码。我们就会立即享受重构的好处。如果我们等积攒了一堆技术负债，再开始重构，那么我们享受的好处会延迟，甚至可能会在一些没大有用的地方浪费精力。</p>
<p>产品工程师兼首席技术官Andreas Klinger是Fix-it Friday的粉丝，他表示：</p>
<p>“Fix-it Friday的规则很简单：除非当前的项目十万火急，否则周五的工作就应该是重构。让工程师选择他们的工作。我们不应该因为微观管理而抹杀这种乐趣。有些人会尝试新的库。有些人会修复积压的bug。这两种工作都很好。我们尝试鼓励大家平衡这些任务。”</p>
<p>无论采用哪种方法，你都需要慎重思考，询问团队哪些代码最影响他们的效率。</p>
<ul>
<li>修复哪些代码对你的其他代码产生的影响最大？</li>
<li>解决哪些问题得到的回报最多？</li>
</ul>
<p>你不太可能找到一整块专门的时间来重构代码，重构代码必然会牺牲你花费在其他项目上的时间，但请不要低估定期坚持开展小范围的重构带来的影响。聚沙成塔，集腋成裘，最终你会获得丰厚的回报。</p>
<h1 id="文档与重构"><a href="#文档与重构" class="headerlink" title="文档与重构"></a><strong>文档与重构</strong></h1><p>标准化命名约定之类的文档可以让每个人都达成共识。Xerox的高级开发人员的研究发现，缺乏文档是重构最大的难题之一。</p>
<p>记录重构的工作内容不仅可以记录花费的时间，而且还可以为将来的团队成员提供说明。</p>
<p>最后，你还通过文档记录下自己的成功：重构带来的最大成功是什么？这些可以成为代码审核的考虑因素吗？</p>
<p><strong>需求案例</strong></p>
<p><strong>项目需求</strong></p>
<p>项目开发阶段，有一个关于下单发货的需求：如果今天下午 3 点前进行下单，那么发货时间是明天，如果今天下午 3 点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加 1 天为发货时间。</p>
<p><strong>思考与重构</strong></p>
<p>我相信这个需求看似很简单，无论怎么写都可以完成。</p>
<p>很多人可能看到这个需求，就动手开始写 Calendar 或 Date 进行计算，从而完成需求。</p>
<p>而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用 Calendar 或 Date 去解决，一定要看场景。</p>
<p>对于时间的计算我们要考虑 joda-time 这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。</p>
<p>请读者先考虑这个需求如何用 Java 代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final DateTime DISTRIBUTION_TIME_SPLIT_TIME &#x3D; new DateTime().withTime(15,0,0,0);</span><br><span class="line">private Date calculateDistributionTimeByOrderCreateTime(Date orderCreateTime)&#123;</span><br><span class="line">    DateTime orderCreateDateTime &#x3D; new DateTime(orderCreateTime);</span><br><span class="line">    Date tomorrow &#x3D; orderCreateDateTime.plusDays(1).toDate();</span><br><span class="line">    Date theDayAfterTomorrow &#x3D; orderCreateDateTime.plusDays(2).toDate();</span><br><span class="line">    return orderCreateDateTime.isAfter(DISTRIBUTION_TIME_SPLIT_TIME) ? wrapDistributionTime(theDayAfterTomorrow) : wrapDistributionTime(tomorrow);</span><br><span class="line">&#125;</span><br><span class="line">private Date wrapDistributionTime(Date distributionTime)&#123;</span><br><span class="line">    DateTime currentDistributionDateTime &#x3D; new DateTime(distributionTime);</span><br><span class="line">    DateTime plusOneDay &#x3D; currentDistributionDateTime.plusDays(1);</span><br><span class="line">    boolean isSunday &#x3D; (DateTimeConstants.SUNDAY &#x3D;&#x3D; currentDistributionDateTime.getDayOfWeek());</span><br><span class="line">    return isSunday ? plusOneDay.toDate() : currentDistributionDateTime.toDate() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回，这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了 3 遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。</p>
<p><strong>提高方法</strong></p>
<p>如果你做了 3 年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写 Java 的程序员，就好好的思考和重构代码吧。</p>
<p>写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的 Java 程序员。</p>
<p>提高代码水平最好的方法就是有条理的重构！(注意：是有条理的重构)</p>
<p><strong>设计模式</strong></p>
<p>设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。</p>
<p>我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。</p>
<p><strong>业务驱动技术 or 技术驱动业务</strong></p>
<p>业务驱动技术 or 技术驱动业务 ？ 其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个 Java 程序员，我们应该如何判断自己所处于的位置.</p>
<p><strong>业务驱动技术：</strong>如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。</p>
<p><strong>技术驱动业务：</strong>如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益，比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。</p>
<p>我相信大部分人还都处于业务驱动技术的方向吧。</p>
<p>所以你既然不能驱动业务，那就请拥抱业务变化吧。</p>
<p><strong>代码设计</strong></p>
<p>一直在做 Java 后端的项目，经常会有一些变动，我相信大家也都遇到过。</p>
<p>比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。</p>
<p>慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。</p>
<p>说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。</p>
<p>Java 编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计!</p>
<p><strong>你真的优秀吗？</strong></p>
<p>真不好意思，我取了一个这么无聊的标题。</p>
<p>国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边 code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？</p>
<p>“平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？</p>
<p>答案就是:</p>
<ol>
<li>多看成熟框架的源码</li>
<li>多回头看自己的代码</li>
<li>勤于重构</li>
</ol>
<p>你真的优秀吗？ 如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。</p>
<p>即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写java代码的程序员了。</p>
<h1 id="为什么要重构？"><a href="#为什么要重构？" class="headerlink" title="为什么要重构？"></a>为什么要重构？</h1><p>项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。</p>
<p>造成这样的原因往往有以下几点：</p>
<ol>
<li>编码之前缺乏有效的设计</li>
<li>成本上的考虑，在原功能堆砌式编程</li>
<li>缺乏有效代码质量监督机制</li>
</ol>
<p>对于此类问题，业界已有有很好的解决思路：通过持续不断的重构将代码中的“坏味道”清除掉。</p>
<h1 id="什么是重构"><a href="#什么是重构" class="headerlink" title="什么是重构"></a>什么是重构</h1><p>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。<br>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p>
<p>根据重构的规模可以大致分为大型重构和小型重构：</p>
<p><strong>大型重构</strong>：对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入bug的风险也会相对比较大。</p>
<p><strong>小型重构</strong>：对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名和注释、消除超大类或函数、提取重复代码等等。小型重构更多的是使用统一的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入bug的风险相对来说也会比较小。什么时候重构 新功能开发、修bug或者代码review中出现“代码坏味道”，我们就应该及时进行重构。持续在日常开发中进行小重构，能够降低重构和测试的成本。</p>
<p>代码的坏地方：</p>
<p><strong>代码重复</strong></p>
<ul>
<li>实现逻辑相同、执行流程相同</li>
</ul>
<p><strong>方法过长</strong></p>
<ul>
<li>方法中的语句不在同一个抽象层级</li>
<li>逻辑难以理解，需要大量的注释</li>
<li>面向过程编程而非面向对象</li>
</ul>
<p><strong>过大的类</strong></p>
<ul>
<li>类做了太多的事情</li>
<li>包含过多的实例变量和方法</li>
<li>类的命名不足以描述所做的事情</li>
</ul>
<p><strong>逻辑分散</strong></p>
<ul>
<li>发散式变化：某个类经常因为不同的原因在不同的方向上发生变化</li>
<li>散弹式修改：发生某种变化时，需要在多个类中做修改</li>
</ul>
<p><strong>严重的情结依恋</strong></p>
<ul>
<li>某个类的方法过多的使用其他类的成员</li>
</ul>
<p><strong>数据泥团/基本类型偏执</strong></p>
<ul>
<li>两个类、方法签名中包含相同的字段或参数</li>
<li>应该使用类但使用基本类型，比如表示数值与币种的Money类、起始值与结束值的Range类</li>
</ul>
<p><strong>不合理的继承体系</strong></p>
<ul>
<li>继承打破了封装性，子类依赖其父类中特定功能的实现细节</li>
<li>子类必须跟着其父类的更新而演变，除非父类是专门为了扩展而设计，并且有很好的文档说明</li>
</ul>
<p><strong>过多的条件判断</strong></p>
<p><strong>过长的参数列</strong></p>
<p><strong>临时变量过多</strong></p>
<p><strong>令人迷惑的暂时字段</strong></p>
<ul>
<li>某个实例变量仅为某种特定情况而设置</li>
<li>将实例变量与相应的方法提取到新的类中</li>
</ul>
<p><strong>纯数据类</strong></p>
<ul>
<li>仅包含字段和访问（读写）这些字段的方法</li>
<li>此类被称为数据容器，应保持最小可变性</li>
</ul>
<p><strong>不恰当的命名</strong></p>
<ul>
<li>命名无法准确描述做的事情</li>
<li>命名不符合约定俗称的惯例</li>
</ul>
<p><strong>过多的注释</strong></p>
<p>带来的问题：</p>
<ul>
<li><strong>难以复用</strong></li>
<li>系统关联性过多，导致很难分离可重用部分</li>
<li><strong>难于变化</strong></li>
<li>一处变化导致其他很多部分的修改，不利于系统稳定</li>
<li><strong>难于理解</strong></li>
<li>命名杂乱，结构混乱，难于阅读和理解</li>
<li><strong>难以测试</strong></li>
<li>分支、依赖较多，难以覆盖全面</li>
</ul>
<p>好代码的评价标准</p>
<p>可维护性、可读性、可扩展性</p>
<p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p>
<h1 id="如何重构"><a href="#如何重构" class="headerlink" title="如何重构"></a>如何重构</h1><p><strong>SOLID原则</strong></p>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720141907210.png" alt="image-20210720141907210"></p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类只负责完成一个职责或者功能，不要存在多于一种导致类变更的原因。</p>
<p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>
<h3 id="开放-关闭原则"><a href="#开放-关闭原则" class="headerlink" title="开放-关闭原则"></a>开放-关闭原则</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p>
<p>开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</p>
<p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p>
<p>子类可以扩展父类的功能，但不能改变父类原有的功能</p>
<blockquote>
<p>父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。</p>
</blockquote>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>调用方不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<h3 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h3><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>一个对象应该对其他对象保持最少的了解</p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，告诉我们要对扩展开放，对修改关闭。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h1><blockquote>
<p>设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。</p>
</blockquote>
<ul>
<li><strong>创建型</strong>：主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码</li>
<li><strong>结构型</strong>：主要通过类或对象的不同组合，解耦不同功能的耦合</li>
<li><strong>行为型</strong>：主要解决的是类或对象之间的交互行为的耦合</li>
</ul>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142318893.png" alt="image-20210720142318893"></p>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142334301.png" alt="image-20210720142334301"></p>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142346463.png" alt="image-20210720142346463"></p>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142358859.png" alt="image-20210720142358859"></p>
<h1 id="代码分层"><a href="#代码分层" class="headerlink" title="代码分层"></a><strong>代码分层</strong></h1><p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720142117537.png" alt="image-20210720142117537"></p>
<p><strong>模块结构说明</strong></p>
<ul>
<li>server_main：配置层，负责整个项目的module管理，maven配置管理、资源管理等；</li>
<li>server_application：应用接入层，承接外部流量入口，例如：RPC接口实现、消息处理、定时任务等；不要在此包含业务逻辑；</li>
<li>server_biz：核心业务层，用例服务、领域实体、领域事件等</li>
<li>server_irepository：资源接口层，负责资源接口的暴露</li>
<li>server_repository：资源层，负责资源的proxy访问，统一外部资源访问，隔离变化。注意：这里强调的是弱业务性，强数据性；</li>
<li>server_common：公共层，vo、工具等</li>
</ul>
<p>代码开发要遵守各层的规范，并注意层级之间的依赖关系。</p>
<h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a><strong>命名规范</strong></h1><p>一个好的命名应该要满足以下两个约束：</p>
<ul>
<li>准确描述所做得事情</li>
<li>格式符合通用的惯例</li>
</ul>
<p>如果你觉得一个类或方法难以命名的时候，可能是其承载的功能太多了，需要进一步拆分。</p>
<h3 id="约定俗称的惯例"><a href="#约定俗称的惯例" class="headerlink" title="约定俗称的惯例"></a>约定俗称的惯例</h3><p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/640" alt="图片"></p>
<h3 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h3><blockquote>
<p>类名使用大驼峰命名形式，类命通常使用名词或名词短语。接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。</p>
</blockquote>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720143839909.png" alt="image-20210720143839909"></p>
<h3 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h3><blockquote>
<p>方法命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p>
</blockquote>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144034337.png" alt="image-20210720144034337"></p>
<h1 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a><strong>重构技巧</strong></h1><h3 id="提炼方法"><a href="#提炼方法" class="headerlink" title="提炼方法"></a>提炼方法</h3><p>多个方法代码重复、方法中代码过长或者方法中的语句不在一个抽象层级。<br>方法是代码复用的最小粒度，方法过长不利于复用，可读性低，提炼方法往往是重构工作的第一步。</p>
<p><strong>意图导向编程</strong>：把处理某件事的流程和具体做事的实现方式分开。</p>
<ul>
<li>把一个问题分解为一系列功能性步骤，并假定这些功能步骤已经实现</li>
<li>我们只需把把各个函数组织在一起即可解决这一问题</li>
<li>在组织好整个功能后，我们在分别实现各个方法函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">  * 1、交易信息开始于一串标准ASCII字符串。 </span><br><span class="line">  * 2、这个信息字符串必须转换成一个字符串的数组，数组存放的此次交易的领域语言中所包含的词汇元素（token)。 </span><br><span class="line">  * 3、每一个词汇必须标准化。 </span><br><span class="line">  * 4、包含超过150个词汇元素的交易，应该采用不同于小型交易的方式（不同的算法）来提交，以提高效率。 </span><br><span class="line">  * 5、如果提交成功，API返回”true”；失败，则返回”false”。 </span><br><span class="line">  *&#x2F;</span><br><span class="line">public class Transaction &#123;    </span><br><span class="line">  public Boolean commit(String command) &#123;        </span><br><span class="line">    Boolean result &#x3D; true;        </span><br><span class="line">    String[] tokens &#x3D; tokenize(command);        </span><br><span class="line">    normalizeTokens(tokens);        </span><br><span class="line">    if (isALargeTransaction(tokens)) &#123;            </span><br><span class="line">      result &#x3D; processLargeTransaction(tokens);        </span><br><span class="line">    &#125; else &#123;            </span><br><span class="line">      result &#x3D; processSmallTransaction(tokens);        </span><br><span class="line">    &#125;        </span><br><span class="line">    return result;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以函数对象取代函数"><a href="#以函数对象取代函数" class="headerlink" title="以函数对象取代函数"></a>以函数对象取代函数</h3><p>将函数放进一个单独对象中，如此一来局部变量就变成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。</p>
<h3 id="引入参数对象"><a href="#引入参数对象" class="headerlink" title="引入参数对象"></a>引入参数对象</h3><h3 id="方法参数比较多时，将参数封装为参数对象"><a href="#方法参数比较多时，将参数封装为参数对象" class="headerlink" title="方法参数比较多时，将参数封装为参数对象"></a>方法参数比较多时，将参数封装为参数对象</h3><h3 id="移除对参数的赋值"><a href="#移除对参数的赋值" class="headerlink" title="移除对参数的赋值"></a>移除对参数的赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int discount(int inputVal, int quantity, int yearToDate) &#123;</span><br><span class="line">  if (inputVal &gt; 50) inputVal -&#x3D; 2;</span><br><span class="line">  if (quantity &gt; 100) inputVal -&#x3D; 1;</span><br><span class="line">  if (yearToDate &gt; 10000) inputVal -&#x3D; 4;</span><br><span class="line">  return inputVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int discount(int inputVal, int quantity, int yearToDate) &#123; </span><br><span class="line">  int result &#x3D; inputVal;</span><br><span class="line">  if (inputVal &gt; 50) result -&#x3D; 2; </span><br><span class="line">  if (quantity &gt; 100) result -&#x3D; 1; </span><br><span class="line">  if (yearToDate &gt; 10000) result -&#x3D; 4; </span><br><span class="line">  return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将查询与修改分离"><a href="#将查询与修改分离" class="headerlink" title="将查询与修改分离"></a>将查询与修改分离</h3><p>任何有返回值的方法，都不应该有副作用</p>
<ul>
<li>不要在convert中调用写操作，避免副作用</li>
<li>常见的例外：将查询结果缓存到本地</li>
</ul>
<h3 id="移除不必要临时变量"><a href="#移除不必要临时变量" class="headerlink" title="移除不必要临时变量"></a>移除不必要临时变量</h3><p>临时变量仅使用一次或者取值逻辑成本很低的情况下</p>
<h3 id="引入解释性变量"><a href="#引入解释性变量" class="headerlink" title="引入解释性变量"></a>引入解释性变量</h3><p>将复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if ((platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1) </span><br><span class="line">    &amp;&amp; (browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1) &amp;&amp; wasInitialized() &amp;&amp; resize &gt; 0) &#123;   </span><br><span class="line">  &#x2F;&#x2F; do something </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">final boolean isMacOs &#x3D; platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1; </span><br><span class="line">final boolean isIEBrowser &#x3D; browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1; </span><br><span class="line">final boolean wasResized &#x3D; resize &gt; 0; </span><br><span class="line">if (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123;   </span><br><span class="line">  &#x2F;&#x2F; do something </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用卫语句替代嵌套条件判断"><a href="#使用卫语句替代嵌套条件判断" class="headerlink" title="使用卫语句替代嵌套条件判断"></a>使用卫语句替代嵌套条件判断</h3><p>把复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的if - then-else语句，转换为多个if语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;未使用卫语句</span><br><span class="line">public void getHello(int type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (type &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (type &#x3D;&#x3D; 3) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                setHello();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用卫语句</span><br><span class="line">public void getHello(int type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (type &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (type &#x3D;&#x3D; 3) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    setHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用多态替代条件判断断"><a href="#使用多态替代条件判断断" class="headerlink" title="使用多态替代条件判断断"></a>使用多态替代条件判断断</h3><p>当存在这样一类条件表达式，它根据对象类型的不同选择不同的行为。可以将这种表达式的每个分支放进一个子类内的复写函数中，然后将原始函数声明为抽象函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int calculate(int a, int b, String operator) &#123;</span><br><span class="line">    int result &#x3D; Integer.MIN_VALUE;</span><br><span class="line"> </span><br><span class="line">    if (&quot;add&quot;.equals(operator)) &#123;</span><br><span class="line">        result &#x3D; a + b;</span><br><span class="line">    &#125; else if (&quot;multiply&quot;.equals(operator)) &#123;</span><br><span class="line">        result &#x3D; a * b;</span><br><span class="line">    &#125; else if (&quot;divide&quot;.equals(operator)) &#123;</span><br><span class="line">        result &#x3D; a &#x2F; b;</span><br><span class="line">    &#125; else if (&quot;subtract&quot;.equals(operator)) &#123;</span><br><span class="line">        result &#x3D; a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当出现大量类型检查和判断时，if else（或switch）语句的体积会比较臃肿，这无疑降低了代码的可读性。 另外，if else（或switch）本身就是一个“变化点”，当需要扩展新的类型时，我们不得不追加if else（或switch）语句块，以及相应的逻辑，这无疑降低了程序的可扩展性，也违反了面向对象的开闭原则。</p>
<blockquote>
<p>基于这种场景，我们可以考虑使用“多态”来代替冗长的条件判断，将if else（或switch）中的“变化点”封装到子类中。这样，就不需要使用if else（或switch）语句了，取而代之的是子类多态的实例，从而使得提高代码的可读性和可扩展性。很多设计模式使用都是这种套路，比如策略模式、状态模式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface Operation &#123; </span><br><span class="line">  int apply(int a, int b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Addition implements Operation &#123; </span><br><span class="line">  @Override </span><br><span class="line">  public int apply(int a, int b) &#123; </span><br><span class="line">    return a + b; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OperatorFactory &#123;</span><br><span class="line">    private final static Map&lt;String, Operation&gt; operationMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    static &#123;</span><br><span class="line">        operationMap.put(&quot;add&quot;, new Addition());</span><br><span class="line">        operationMap.put(&quot;divide&quot;, new Division());</span><br><span class="line">        &#x2F;&#x2F; more operators</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Operation getOperation(String operator) &#123;</span><br><span class="line">        return operationMap.get(operator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int calculate(int a, int b, String operator) &#123;</span><br><span class="line">    if (OperatorFactory .getOperation &#x3D;&#x3D; null) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Invalid Operator&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return OperatorFactory .getOperation(operator).apply(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用异常替代返回错误码"><a href="#使用异常替代返回错误码" class="headerlink" title="使用异常替代返回错误码"></a>使用异常替代返回错误码</h3><p>非正常业务状态的处理，使用抛出异常的方式代替返回错误码</p>
<ul>
<li><p>不要使用异常处理用于正常的业务流程控制</p>
</li>
<li><ul>
<li>异常处理的性能成本非常高</li>
</ul>
</li>
<li><p>尽量使用标准异常</p>
</li>
<li><p>避免在finally语句块中抛出异常</p>
</li>
<li><ul>
<li>如果同时抛出两个异常，则第一个异常的调用栈会丢失</li>
<li>finally块中应只做关闭资源这类的事情</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用错误码</span><br><span class="line">public boolean withdraw(int amount) &#123;</span><br><span class="line">    if (balance &lt; amount) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        balance -&#x3D; amount;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用异常</span><br><span class="line">public void withdraw(int amount) &#123;</span><br><span class="line">    if (amount &gt; balance) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;amount too large&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">    balance -&#x3D; amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引入断言"><a href="#引入断言" class="headerlink" title="引入断言"></a>引入断言</h3><p>某一段代码需要对程序状态做出某种假设，以断言明确表现这种假设。</p>
<ul>
<li>不要滥用断言，不要使用它来检查“应该为真”的条件，只使用它来检查“一定必须为真”的条件</li>
<li>如果断言所指示的约束条件不能满足，代码是否仍能正常运行？如果可以就去掉断言</li>
</ul>
<h3 id="引入Null对象或特殊对象"><a href="#引入Null对象或特殊对象" class="headerlink" title="引入Null对象或特殊对象"></a>引入Null对象或特殊对象</h3><p>当使用一个方法返回的对象时，而这个对象可能为空，这个时候需要对这个对象进行操作前，需要进行判空，否则就会报空指针。当这种判断频繁的出现在各处代码之中，就会影响代码的美观程度和可读性，甚至增加Bug的几率。</p>
<p>空引用的问题在Java中无法避免，但可以通过代码编程技巧（引入空对象）来改善这一问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;空对象的例子</span><br><span class="line">public class OperatorFactory &#123; </span><br><span class="line">  static Map&lt;String, Operation&gt; operationMap &#x3D; new HashMap&lt;&gt;(); </span><br><span class="line">  static &#123; </span><br><span class="line">    operationMap.put(&quot;add&quot;, new Addition()); </span><br><span class="line">    operationMap.put(&quot;divide&quot;, new Division()); </span><br><span class="line">    &#x2F;&#x2F; more operators </span><br><span class="line">  &#125; </span><br><span class="line">  public static Optional&lt;Operation&gt; getOperation(String operator) &#123; </span><br><span class="line">    return Optional.ofNullable(operationMap.get(operator)); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">public int calculate(int a, int b, String operator) &#123; </span><br><span class="line">  Operation targetOperation &#x3D; OperatorFactory.getOperation(operator) </span><br><span class="line">     .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Invalid Operator&quot;)); </span><br><span class="line">  return targetOperation.apply(a, b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;特殊对象的例子</span><br><span class="line">public class InvalidOp implements Operation &#123; </span><br><span class="line">  @Override </span><br><span class="line">  public int apply(int a, int b)  &#123; </span><br><span class="line">    throw new IllegalArgumentException(&quot;Invalid Operator&quot;);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提炼类"><a href="#提炼类" class="headerlink" title="提炼类"></a>提炼类</h3><p>根据单一职责原则，一个类应该有明确的责任边界。但在实际工作中，类会不断的扩展。当给某个类添加一项新责任时，你会觉得不值得分离出一个单独的类。于是，随着责任不断增加，这个类包含了大量的数据和函数，逻辑复杂不易理解。</p>
<p>此时你需要考虑将哪些部分分离到一个单独的类中，可以依据高内聚低耦合的原则。如果某些数据和方法总是一起出现，或者某些数据经常同时变化，这就表明它们应该放到一个类中。另一种信号是类的子类化方式：如果你发现子类化只影响类的部分特性，或者类的特性需要以不同方式来子类化，这就意味着你需要分解原来的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原始类</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String officeAreaCode;</span><br><span class="line">    private String officeNumber;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTelephoneNumber() &#123;</span><br><span class="line">        return (&quot;(&quot; + officeAreaCode + &quot;)&quot; + officeNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getOfficeAreaCode() &#123;</span><br><span class="line">        return officeAreaCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOfficeAreaCode(String arg) &#123;</span><br><span class="line">        officeAreaCode &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getOfficeNumber() &#123;</span><br><span class="line">        return officeNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOfficeNumber(String arg) &#123;</span><br><span class="line">        officeNumber &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新提炼的类（以对象替换数据值）</span><br><span class="line">public class TelephoneNumber &#123;</span><br><span class="line">    private String areaCode;</span><br><span class="line">    private String number;</span><br><span class="line"></span><br><span class="line">    public String getTelephnoeNumber() &#123;</span><br><span class="line">        return (&quot;(&quot; + getAreaCode() + &quot;)&quot; + number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String getAreaCode() &#123;</span><br><span class="line">        return areaCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setAreaCode(String arg) &#123;</span><br><span class="line">        areaCode &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setNumber(String arg) &#123;</span><br><span class="line">        number &#x3D; arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合优先于继承"><a href="#组合优先于继承" class="headerlink" title="组合优先于继承"></a>组合优先于继承</h3><p>继承使实现代码重用的有力手段，但这并非总是完成这项工作的最佳工具，使用不当会导致软件变得很脆弱。与方法调用不同的是，继承打破了封装性。子类依赖于其父类中特定功能的实现细节，如果父类的实现随着发行版本的不同而变化，子类可能会遭到破坏，即使他的代码完全没有改变。</p>
<p>举例说明，假设有一个程序使用HashSet，为了调优该程序的性能，需要统计HashSet自从它创建以来添加了多少个元素。为了提供该功能，我们编写一个HashSet的变体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Inappropriate use of inheritance!</span><br><span class="line">public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; The number of attempted element insertions</span><br><span class="line">    private int addCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet(int initCap, float loadFactor) &#123;</span><br><span class="line">        super(initCap, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount +&#x3D; c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称为组合，因为现有的类变成了新类的一个组件。这样得到的类将会非常稳固，它不依赖现有类的实现细节。即使现有的类添加了新的方法，也不会影响新的类。许多设计模式使用就是这种套路，比如代理模式、装饰者模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reusable forwarding class</span><br><span class="line">public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123;</span><br><span class="line">    private final Set&lt;E&gt; s;</span><br><span class="line">    public ForwardingSet(Set&lt;E&gt; s) &#123; this.s &#x3D; s; &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123; return s.size(); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123; return s.isEmpty(); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(Object o) &#123; return s.contains(o); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123; return s.iterator(); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object[] toArray() &#123; return s.toArray(); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123; return s.toArray(a); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) &#123; return s.add(e); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean remove(Object o) &#123; return s.remove(o); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean containsAll(Collection&lt;?&gt; c) &#123; return s.containsAll(c); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return s.addAll(c); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c) &#123; return s.retainAll(c); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c) &#123; return s.removeAll(c); &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123; s.clear(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Wrappter class - uses composition in place of inheritance</span><br><span class="line">public class InstrumentedHashSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123;</span><br><span class="line">    private int addCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet1(Set&lt;E&gt; s) &#123;</span><br><span class="line">        super(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount +&#x3D; c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承与组合如何取舍</strong></p>
<ul>
<li>只有当子类真正是父类的子类型时，才适合继承。对于两个类A和B，只有两者之间确实存在“is-a”关系的时候，类B才应该继承A；</li>
<li>在包的内部使用继承是非常安全的，子类和父类的实现都处在同一个程序员的控制之下；</li>
<li>对于专门为了继承而设计并且具有很好的文档说明的类来说，使用继承也是非常安全的；</li>
<li>其他情况就应该优先考虑组合的方式来实现</li>
</ul>
<h3 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h3><p>Java提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。自从Java8为接口增加缺省方法（default method），这两种机制都允许为实例方法提供实现。主要区别在于，为了实现由抽象类定义的类型，类必须称为抽象类的一个子类。因为Java只允许单继承，所以用抽象类作为类型定义受到了限制。</p>
<p>接口相比于抽象类的优势：</p>
<ul>
<li>现有的类可以很容易被更新，以实现新的接口。</li>
<li>接口是定义混合类型（比如Comparable）的理想选择。</li>
<li>接口允许构造非层次结构的类型框架。</li>
</ul>
<p>接口虽然提供了缺省方法，但接口仍有有以下局限性：</p>
<ul>
<li>接口的变量修饰符只能是public static final的</li>
<li>接口的方法修饰符只能是public的</li>
<li>接口不存在构造函数，也不存在this</li>
<li>可以给现有接口增加缺省方法，但不能确保这些方法在之前存在的实现中都能良好运行。</li>
<li>因为这些默认方法是被注入到现有实现中的，它们的实现者并不知道，也没有许可</li>
</ul>
<p>接口缺省方法的设计目的和优势在于：</p>
<p><strong>为了接口的演化</strong></p>
<ul>
<li>Java 8 之前我们知道，一个接口的所有方法其子类必须实现（当然，这个子类不是一个抽象类），但是 java 8 之后接口的默认方法可以选择不实现，如上的操作是可以通过编译期编译的。这样就避免了由 Java 7 升级到 Java 8 时项目编译报错了。Java8在核心集合接口中增加了许多新的缺省方法，主要是为了便于使用lambda。</li>
</ul>
<p><strong>可以减少第三方工具类的创建</strong></p>
<ul>
<li>例如在 List 等集合接口中都有一些默认方法，List 接口中默认提供 replaceAll(UnaryOperator)、sort(Comparator)、、spliterator()等默认方法，这些方法在接口内部创建，避免了为了这些方法而专门去创建相应的工具类。</li>
</ul>
<p><strong>可以避免创建基类</strong></p>
<ul>
<li>在 Java 8 之前我们可能需要创建一个基类来实现代码复用，而默认方法的出现，可以不必要去创建基类。</li>
</ul>
<p><strong>由于接口的局限性和设计目的的不同，接口并不能完全替换抽象类。但是通过对接口提供一个抽象的骨架实现类，可以把接口和抽象类的优点结合起来。</strong> 接口负责定义类型，或许还提供一些缺省方法，而骨架实现类则负责实现除基本类型接口方法之外，剩下的非基本类型接口方法。扩展骨架实现占了实现接口之外的大部分工作。这就是模板方法（Template Method）设计模式。</p>
<p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144200655.png" alt="image-20210720144200655"></p>
<p>接口Protocol：定义了RPC协议层两个主要的方法，export暴露服务和refer引用服务</p>
<p>抽象类AbstractProtocol：封装了暴露服务之后的Exporter和引用服务之后的Invoker实例，并实现了服务销毁的逻辑</p>
<p>具体实现类XxxProtocol：实现export暴露服务和refer引用服务具体逻辑</p>
<h3 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h3><p>声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）类或者接口。泛型类和接口统称为泛型（generic type）。泛型从Java 5引入，提供了编译时类型安全检测机制。泛型的本质是参数化类型，通过一个参数来表示所操作的数据类型，并且可以限制这个参数的类型范围。泛型的好处就是编译期类型检测，避免类型转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 比较三个值并返回最大值</span><br><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z) &#123;   </span><br><span class="line">  T max &#x3D; x; </span><br><span class="line">  &#x2F;&#x2F; 假设x是初始最大值   </span><br><span class="line">  if ( y.compareTo( max ) &gt; 0 ) &#123;      </span><br><span class="line">    max &#x3D; y; &#x2F;&#x2F;y 更大  </span><br><span class="line">  &#125;   if ( z.compareTo( max ) &gt; 0 ) &#123;     </span><br><span class="line">    max &#x3D; z; &#x2F;&#x2F; 现在 z 更大              </span><br><span class="line">  &#125;   return max; &#x2F;&#x2F; 返回最大对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main( String args[] ) &#123;   </span><br><span class="line">  System.out.printf( &quot;%d, %d 和 %d 中最大的数为 %d\n\n&quot;,  3, 4, 5, maximum( 3, 4, 5 ));   </span><br><span class="line">  System.out.printf( &quot;%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n&quot;,  6.6, 8.8, 7.7,  maximum( 6.6, 8.8, 7.7 ));   </span><br><span class="line">  System.out.printf( &quot;%s, %s 和 %s 中最大的数为 %s\n&quot;,&quot;pear&quot;, &quot;apple&quot;, &quot;orange&quot;, maximum( &quot;pear&quot;, &quot;apple&quot;, &quot;orange&quot; ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要使用原生态类型"><a href="#不要使用原生态类型" class="headerlink" title="不要使用原生态类型"></a>不要使用原生态类型</h4><p>由于为了保持Java代码的兼容性，支持和原生态类型转换，并使用擦除机制实现的泛型。但是使用原生态类型就会失去泛型的优势，会受到编译器警告。</p>
<h4 id="要尽可能地消除每一个非受检警告"><a href="#要尽可能地消除每一个非受检警告" class="headerlink" title="要尽可能地消除每一个非受检警告"></a>要尽可能地消除每一个非受检警告</h4><p>每一条警告都表示可能在运行时抛出ClassCastException异常。要尽最大的努力去消除这些警告。如果无法消除但是可以证明引起警告的代码是安全的，就可以在尽可能小的范围中，使用＠SuppressWarnings(“unchecked”)注解来禁止警告，但是要把禁止的原因记录下来。</p>
<h4 id="利用有限制通配符来提升API的灵活性"><a href="#利用有限制通配符来提升API的灵活性" class="headerlink" title="利用有限制通配符来提升API的灵活性"></a>利用有限制通配符来提升API的灵活性</h4><p>参数化类型不支持协变的，即对于任何两个不同的类型Type1和Type2而言，List既不是List的子类型，也不是它的超类。为了解决这个问题，提高灵活性，Java提供了一种特殊的参数化类型，称作有限制的通配符类型，即List&lt;? extends E&gt;和List&lt;? super E&gt;。使用原则是producer-extends，consumer-super（PECS）。如果即是生产者，又是消费者，就没有必要使用通配符了。</p>
<p>还有一种特殊的无限制通配符List&lt;?&gt;，表示某种类型但不确定。常用作泛型的引用，不可向其添加除Null以外的任何对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;List&lt;? extends E&gt;</span><br><span class="line">&#x2F;&#x2F; Number 可以认为 是Number 的 &quot;子类&quot;</span><br><span class="line">List&lt;? extends Number&gt; numberArray &#x3D; new ArrayList&lt;Number&gt;(); </span><br><span class="line">&#x2F;&#x2F; Integer 是 Number 的子类</span><br><span class="line">List&lt;? extends Number&gt; numberArray &#x3D; new ArrayList&lt;Integer&gt;(); </span><br><span class="line">&#x2F;&#x2F; Double 是 Number 的子类</span><br><span class="line">List&lt;? extends Number&gt; numberArray &#x3D; new ArrayList&lt;Double&gt;();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;List&lt;? super E&gt;</span><br><span class="line">&#x2F;&#x2F; Integer 可以认为是 Integer 的 &quot;父类&quot;</span><br><span class="line">List&lt;? super Integer&gt; array &#x3D; new ArrayList&lt;Integer&gt;();、</span><br><span class="line">&#x2F;&#x2F; Number 是 Integer 的 父类</span><br><span class="line">List&lt;? super Integer&gt; array &#x3D; new ArrayList&lt;Number&gt;();</span><br><span class="line">&#x2F;&#x2F; Object 是 Integer 的 父类</span><br><span class="line">List&lt;? super Integer&gt; array &#x3D; new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;    </span><br><span class="line">  int srcSize &#x3D; src.size();    </span><br><span class="line">  if (srcSize &gt; dest.size())        </span><br><span class="line">   throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);    </span><br><span class="line">  if (srcSize &lt; COPY_THRESHOLD || (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) &#123;        </span><br><span class="line">    for (int i&#x3D;0; i&lt;srcSize; i++)            </span><br><span class="line">    dest.set(i, src.get(i));    </span><br><span class="line">  &#125; else &#123;        </span><br><span class="line">    ListIterator&lt;? super T&gt; di&#x3D;dest.listIterator();        </span><br><span class="line">    ListIterator&lt;? extends T&gt; si&#x3D;src.listIterator();        </span><br><span class="line">    for (int i&#x3D;0; i&lt;srcSize; i++) &#123;            </span><br><span class="line">      di.next();            </span><br><span class="line">      di.set(si.next());        </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员类优于非静态成员类"><a href="#静态成员类优于非静态成员类" class="headerlink" title="静态成员类优于非静态成员类"></a>静态成员类优于非静态成员类</h3><p>嵌套类（nested class）是指定义在另一个类的内部的类。<strong>嵌套类存在的目的只是为了它的外部类提供服务，如果其他的环境也会用到的话，应该成为一个顶层类（top-level class）。</strong> 嵌套类有四种：静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名类（anonymous class）和 局部类（local class）。除了第一种之外，其他三种都称为内部类（inner class）。</p>
<h4 id="匿名类（anonymous-class）"><a href="#匿名类（anonymous-class）" class="headerlink" title="匿名类（anonymous class）"></a>匿名类（anonymous class）</h4><p>没有名字，声明的同时进行实例化，只能使用一次。当出现在非静态的环境中，会持有外部类实例的引用。通常用于创建函数对象和过程对象，不过现在会优先考虑lambda。</p>
<h4 id="局部类（local-class）"><a href="#局部类（local-class）" class="headerlink" title="局部类（local class）"></a>局部类（local class）</h4><p>任何可以声明局部变量的地方都可以声明局部类，同时遵循同样的作用域规则。跟匿名类不同的是，有名字可以重复使用。不过实际很少使用局部类。</p>
<h4 id="静态成员类（static-member-class）"><a href="#静态成员类（static-member-class）" class="headerlink" title="静态成员类（static member class）"></a>静态成员类（static member class）</h4><p>最简单的一种嵌套类，声明在另一个类的内部，是这个类的静态成员，遵循同样的可访问性规则。常见的用法是作为公有的辅助类，只有与它的外部类一起使用才有意义。</p>
<h4 id="非静态成员类（nonstatic-member-class）"><a href="#非静态成员类（nonstatic-member-class）" class="headerlink" title="非静态成员类（nonstatic member class）"></a>非静态成员类（nonstatic member class）</h4><p>尽管语法上，跟静态成员类的唯一区别就是类的声明不包含static，但两者有很大的不同。非静态成员类的每个实例都隐含地与外部类的实例相关联，可以访问外部类的成员属性和方法。另外必须先创建外部类的实例之后才能创建非静态成员类的实例。</p>
<p>总而言之，这四种嵌套类都有自己的用途。假设这个嵌套类属于一个方法的内部，如果只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类。如果一个嵌套类需要在单个方法之外仍然可见，或者它太长了，不适合放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的，否则就做成静态的。</p>
<h3 id="优先使用模板-工具类"><a href="#优先使用模板-工具类" class="headerlink" title="优先使用模板/工具类"></a>优先使用模板/工具类</h3><p>通过对常见场景的代码逻辑进行抽象封装，形成相应的模板工具类，可以大大减少重复代码，专注于业务逻辑，提高代码质量。</p>
<h3 id="分离对象的创建与使用"><a href="#分离对象的创建与使用" class="headerlink" title="分离对象的创建与使用"></a>分离对象的创建与使用</h3><p>面向对象编程相对于面向过程，多了实例化这一步，而对象的创建必须要指定具体类型。我们常见的做法是“哪里用到，就在哪里创建”，使用实例和创建实例的是同一段代码。这似乎使代码更具有可读性，但是某些情况下造成了不必要的耦合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class BusinessObject &#123;</span><br><span class="line"> public void actionMethond &#123;</span><br><span class="line">     &#x2F;&#x2F;Other things</span><br><span class="line">     Service myServiceObj &#x3D; new Service();</span><br><span class="line">       myServiceObj.doService();</span><br><span class="line">       &#x2F;&#x2F;Other things</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BusinessObject &#123;</span><br><span class="line"> public void actionMethond &#123;</span><br><span class="line">     &#x2F;&#x2F;Other things</span><br><span class="line">     Service myServiceObj &#x3D; new ServiceImpl();</span><br><span class="line">       myServiceObj.doService();</span><br><span class="line">       &#x2F;&#x2F;Other things</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BusinessObject &#123;</span><br><span class="line">   private Service myServiceObj;</span><br><span class="line">   public BusinessObject(Service aService) &#123;</span><br><span class="line">       myServiceObj &#x3D; aService;</span><br><span class="line">    &#125;</span><br><span class="line"> public void actionMethond &#123;</span><br><span class="line">     &#x2F;&#x2F;Other things</span><br><span class="line">       myServiceObj.doService();</span><br><span class="line">       &#x2F;&#x2F;Other things</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BusinessObject &#123;</span><br><span class="line">   private Service myServiceObj;</span><br><span class="line">   public BusinessObject() &#123;</span><br><span class="line">       myServiceObj &#x3D; ServiceFactory;</span><br><span class="line">    &#125;</span><br><span class="line"> public void actionMethond &#123;</span><br><span class="line">     &#x2F;&#x2F;Other things</span><br><span class="line">       myServiceObj.doService();</span><br><span class="line">       &#x2F;&#x2F;Other things</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的创建者耦合的是对象的具体类型，而对象的使用者耦合的是对象的接口。也就是说，创建者关心的是这个对象是什么，而使用者关心的是它能干什么。这两者应该视为独立的考量，它们往往会因为不同的原因而改变。</p>
</blockquote>
<p>当对象的类型涉及多态、对象创建复杂（依赖较多）可以考虑将对象的创建过程分离出来，使得使用者不用关注对象的创建细节。设计模式中创建型模式的出发点就是如此，实际项目中可以使用工厂模式、构建器、依赖注入的方式。</p>
<h3 id="可访问性最小化"><a href="#可访问性最小化" class="headerlink" title="可访问性最小化"></a>可访问性最小化</h3><p>区分一个组件设计得好不好，一个很重要的因素在于，它对于外部组件而言，是否隐藏了其内部数据和实现细节。Java提供了访问控制机制来决定类、接口和成员的可访问性。实体的可访问性由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符（private、protected、public）共同决定的。</p>
<p>对于顶层的（非嵌套的）类和接口，只有两种的访问级别：包级私有的（没有public修饰）和公有的（public修饰）。</p>
<p>对于成员（实例/域、方法、嵌套类和嵌套接口）由四种的访问级别，可访问性如下递增：</p>
<ul>
<li>私有的（private修饰）–只有在声明该成员的顶层类内部才可以访问这个成员；</li>
<li>包级私有的（默认）–声明该成员的包内部的任何类都可以访问这个成员；</li>
<li>受保护的（protected修饰）–声明该成员的类的子类可以访问这个成员，并且声明该成员的包内部的任何类也可以访问这个成员；</li>
<li>公有的（public修饰）–在任何地方都可以访问该成员；</li>
</ul>
<p>正确地使用这些修饰符对于实现信息隐藏是非常关键的，原则就是：尽可能地使每个类和成员不被外界访问（私有或包级私有）。这样好处就是在以后的发行版本中，可以对它进行修改、替换或者删除，而无须担心会影响现有的客户端程序。</p>
<ul>
<li>如果类或接口能够做成包级私有的，它就应该被做成包级私有的；</li>
<li>如果一个包级私有的顶层类或接口只是在某一个类的内部被用到，就应该考虑使它成为那个类的私有嵌套类；</li>
<li>公有类不应直接暴露实例域，应该提供相应的方法以保留将来改变该类的内部表示法的灵活性；</li>
<li>当确定了类的公有API之后，应该把其他的成员都变成私有的；</li>
<li>如果同一个包下的类之间存在比较多的访问时，就要考虑重新设计以减少这种耦合；</li>
</ul>
<h3 id="可变性最小化"><a href="#可变性最小化" class="headerlink" title="可变性最小化"></a>可变性最小化</h3><p>不可变类是指其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例时提供，并在对象的整个生命周期内固定不变。不可变类好处就是简单易用、线程安全、可自由共享而不容易出错。Java平台类库中包含许多不可变的类，比如String、基本类型包装类、BigDecimal等。</p>
<p><strong>为了使类成为不可变，要遵循下面五条规则：</strong></p>
<ul>
<li><p>声明所有的域都是私有的</p>
</li>
<li><p>声明所有的域都是final的</p>
</li>
<li><ul>
<li><em>如果一个指向新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必须确保正确的行为</em></li>
</ul>
</li>
<li><p>不提供任何会修改对象状态的方法</p>
</li>
<li><p>保证类不会被扩展（防止子类化，类声明为final）</p>
</li>
<li><ul>
<li><em>防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为</em></li>
</ul>
</li>
<li><p>确保对任何可变组件的互斥访问</p>
</li>
<li><ul>
<li><em>如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象引用。在构造器、访问方法和readObject 方法中使用保护性拷贝技术</em></li>
</ul>
</li>
</ul>
<p><strong>可变性最小化的一些建议：</strong></p>
<ul>
<li>除非有很好的理由要让类成为可变的类，否则它就应该是不可变的；</li>
<li>如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性；</li>
<li>除非有令人信服的理由要使域变成非final的，否则要使每个域都是private final的；</li>
<li>构造器应该创建完全初始化的对象，并建立起所有的约束关系；</li>
</ul>
<h1 id="质量如何保证"><a href="#质量如何保证" class="headerlink" title="质量如何保证"></a>质量如何保证</h1><h2 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h2><blockquote>
<p>测试驱动开发（TDD）要求以测试作为开发过程的中心，要求在编写任何代码之前，首先编写用于产码行为的测试，而编写的代码又要以使测试通过为目标。TDD要求测试可以完全自动化地运行，并在对代码重构前后必须运行测试。</p>
</blockquote>
<p>TDD的最终目标是整洁可用的代码（clean code that works）。大多数的开发者大部分时间无法得到整洁可用的代码。办法是分而治之。首先解决目标中的“可用”问题，然后再解决“代码的整洁”问题。这与体系结构驱动（architecture-driven）的开发相反。</p>
<p>采用TDD另一个好处就是让我们拥有一套伴随代码产生的详尽的自动化测试集。将来无论出于任何原因（需求、重构、性能改进）需要对代码进行维护时，在这套测试集的驱动下工作，我们代码将会一直是健壮的。</p>
<h2 id="TDD的开发周期"><a href="#TDD的开发周期" class="headerlink" title="TDD的开发周期"></a>TDD的开发周期</h2><p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144601409.png" alt="image-20210720144601409"></p>
<p>添加一个测试 -&gt; 运行所有测试并检查测试结果 -&gt; 编写代码以通过测试 -&gt; 运行所有测试且全部通过 -&gt; 重构代码，以消除重复设计，优化设计结构</p>
<h2 id="两个基本的原则"><a href="#两个基本的原则" class="headerlink" title="两个基本的原则"></a>两个基本的原则</h2><ul>
<li>仅在测试失败时才编写代码并且只编写刚好使测试通过的代码</li>
<li>编写下一个测试之前消除现有的重复设计，优化设计结构</li>
</ul>
<p>关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“整洁”目标，每次只关注一件事！</p>
<h2 id="分层测试点"><a href="#分层测试点" class="headerlink" title="分层测试点"></a>分层测试点</h2><p><img src="/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/image-20210720144618190.png" alt="image-20210720144618190"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/17/10.7.%E5%85%B3%E4%BA%8E%E9%87%8D%E6%9E%84/" data-id="ckxho8wmi006th8vw79wifzfz" data-title="关于重构" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/17/8.4.%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BJS/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          网页前端之JS
        
      </div>
    </a>
  
  
    <a href="/2021/04/17/12.2.SpringMVC/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">SpringMVC</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/20/Jenkins/">Jenkins</a>
          </li>
        
          <li>
            <a href="/2021/12/17/SpringBootSecurity/">SpringBootSecurity</a>
          </li>
        
          <li>
            <a href="/2021/12/16/SpringBootActuator/">SpringBootActuator</a>
          </li>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>