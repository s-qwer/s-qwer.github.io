<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-19.4.SVN" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/19.4.SVN/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:40:24.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/19.4.SVN/">SVN</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SVN-版本控制"><a href="#SVN-版本控制" class="headerlink" title="*SVN-版本控制*"></a><em><strong>*SVN-版本控制*</strong></em></h1><p>SVN是Subversion的简称，是一个自由开源的版本控制系统。</p>
<p>Subversion将文件存放在中心版本库里，这个版本库很像一个普通的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/566090.htm">文件服务器</a>，不同的是，它可以记录每一次文件和目录的修改情况，这样就可以借此将<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/185060.htm">数据恢复</a>到以前的版本，并可以查看数据的更改细节</p>
<p>早期版本控制使用的是CVS,后来SVN替代了CVS,随着android兴起，出现Git版本控制工具</p>
<p><img src="/19.4.SVN/wps1.jpg" alt="img"> </p>
<p>问题: 怎样让系统允许用户共享信息，而不会让他们因意外而互相干扰？</p>
<p><em><strong>*1.*</strong>***</em>*复制*<strong><strong><strong>*-*</strong></strong></strong>*修改*<strong><strong><strong>*-*</strong></strong></strong>*合并方案*<strong><strong><strong>*(Subversion*</strong></strong></strong>*默认的模式****<em><strong>*)*</strong></em></p>
<p>在这种模型里，每一个客户读取项目配置库建立一个私有工作副本——版本库中文件和目录的本地映射。用户并行工作，修改各自的工作副本，最终，各个私有的复制合并在一起，成为最终的版本，这种系统通常可以辅助合并操作，但是最终要靠人工去确定正误。</p>
<p><em><strong>*2.*</strong>***</em>*锁定*<strong><strong><strong>*-*</strong></strong></strong>*修改*<strong><strong><strong>*-*</strong></strong></strong>*解锁方案****</p>
<p>在这样的模型里，在一个时间段里配置库的一个文件只允许被一个人修改。 此模式不适合软件开发这种工作。</p>
<p>SVN架构</p>
<p><img src="/19.4.SVN/wps2.jpg" alt="img"> </p>
<p>Subversion支持<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1634.htm">Linux</a>和<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/4821.htm">Windows</a>，更多是安装在Linux下。</p>
<p>svn服务器有2种运行方式：<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2106199.htm">独立服务器</a>（source download，这种是个安装包，解压后就可以用）和借助<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/28283.htm">apache</a>（binary packages，这种是二进制的文件，针对不同的操作系统有不同的版本，下载安装就可以用，后面用的就是这个）运行。两种方式各有利弊，用户可以自行选择。</p>
<p>svn存储版本数据也有2种方式：<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1303712.htm">BDB</a>(一种<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/121511.htm">事务</a>安全型表类型，需要数据库)和<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1633161.htm">FSFS</a>(一种不需要数据库的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/51839.htm">存储系统</a>)。因为BDB方式在服务器中断时，有可能锁住数据，所以还是FSFS方式更安全一点，我们用的就是FSFS，类似于文件</p>
<h1 id="SVN的使用"><a href="#SVN的使用" class="headerlink" title="*SVN的使用*"></a><em><strong>*SVN的使用*</strong></em></h1><p>SVN是一种集中式管理代码的版本控制系统，原理就是把代码都保存到一个固定的位置（仓库），每次从这个位置拷贝更新代码，进行编辑；再把修改后的代码提交到该目录中。多人协作开发也是如此。因此需要一个类似Oracle或者Mysql的服务器用于保存和管理库文件（要保存的代码等文件）的服务端——VisualSVN Server（windows上用）。还需要一个用户的操作端，用于提交更新检出代码，常用的有Eclipse的Svn插件，以及TortoiseSVN（小乌龟）。</p>
<p>SubVersion 官网：<a target="_blank" rel="noopener" href="http://subversion.apache.org/">http://subversion.apache.org/</a></p>
<p>服务器端-VisualSVN安装与配置</p>
<p>1.VisualSVN下载：</p>
<p><img src="/19.4.SVN/wps3.jpg" alt="img"> </p>
<p>下载好后点击下一步，next进行安装</p>
<p>2.VisualSVN安装与创建仓库</p>
<p><img src="/19.4.SVN/wps4.jpg" alt="img"> </p>
<p>标准版就行，企业版会收费</p>
<p><img src="/19.4.SVN/wps5.jpg" alt="img"> </p>
<p>在开始运行中录入 services.msc</p>
<p><img src="/19.4.SVN/wps6.jpg" alt="img"> </p>
<p>这个服务要开启</p>
<p>然后在C盘中的program files下的VisualSVN Server下的bin下的visualSVN Server Manager文件</p>
<p>也可以在开始运行中查找visualSVN Server Manager就可以打开图形化管理界面</p>
<p><img src="/19.4.SVN/wps7.jpg" alt="img"> </p>
<p>3.VisualSVN创建工程目录</p>
<p><img src="/19.4.SVN/wps8.jpg" alt="img"> </p>
<p>选择fsfs类型，名字，权限，下一步</p>
<p>4.VisualSVN权限控制</p>
<p>创建用户</p>
<p><img src="/19.4.SVN/wps9.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps10.jpg" alt="img"> </p>
<p>创建完成之后，可以点击工程名然后右击复制URL路径，浏览器访问就可以看到仓库。可以右击properties选择用户的权限。</p>
<p>创建组：可能会有很多用户，不便于管理，所以创建了组</p>
<p><img src="/19.4.SVN/wps11.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps12.jpg" alt="img"> </p>
<p>分配权限</p>
<p><img src="/19.4.SVN/wps13.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps14.jpg" alt="img"> </p>
<p>客户端-TortoiseSVN安装与使用</p>
<p>它是一个基于windows系统的svn图形化界面</p>
<p>1.TortoiseSVN下载</p>
<p>可以在<a target="_blank" rel="noopener" href="http://subversion.apache.org/%E4%B8%8B%E6%89%BE%E5%88%B0%E4%B8%8B%E8%BD%BD">http://subversion.apache.org/下找到下载</a></p>
<p><img src="/19.4.SVN/wps15.jpg" alt="img"> </p>
<p>2.TortoiseSVN安装</p>
<p>安装后需要重启电脑</p>
<p>检查是否安装成功</p>
<p><img src="/19.4.SVN/wps16.jpg" alt="img"> </p>
<p>3.Tortoise SVN常用操作</p>
<p>浏览仓库</p>
<p><img src="/19.4.SVN/wps17.jpg" alt="img"> </p>
<p>这个URL是服务器端的copy的URL</p>
<p><img src="/19.4.SVN/wps18.jpg" alt="img"> </p>
<p>正常情况下，在浏览仓库时会要求录入username与password，第二次访问的时候不需要输入，已保存</p>
<p>我们可以清空svn客户端的缓存：</p>
<p>新建一个文件夹，右击选择</p>
<p><img src="/19.4.SVN/wps19.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps20.jpg" alt="img"> </p>
<p>这样再访问，checkout的时候就需要输入用户名和密码</p>
<p><img src="/19.4.SVN/wps21.jpg" alt="img"> </p>
<p>Checkout：检出svn服务器上的项目</p>
<p>可以先创建一个自己的文件夹，在里面右击选择仓库</p>
<p><img src="/19.4.SVN/wps22.jpg" alt="img"> </p>
<p>在本地位置的后面加\bos</p>
<p>注意：检出后会有一个.svn隐藏目录，这个目录不要随意修改，相当于是配置信息</p>
<p><img src="/19.4.SVN/wps23.jpg" alt="img"> </p>
<p>Add</p>
<p>在这个文件夹中新建一个文件：</p>
<p><img src="/19.4.SVN/wps24.jpg" alt="img"> </p>
<p>这样图标的文件代表它没有由svn管理，可以右击选择</p>
<p><img src="/19.4.SVN/wps25.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps26.jpg" alt="img"> </p>
<p>这个代表的是它要添加到svn服务器（并没有传到服务器，必须要提交才可以）</p>
<p>Commit</p>
<p>上面那个文件右击后会有commit</p>
<p><img src="/19.4.SVN/wps27.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps28.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps29.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps30.jpg" alt="img">代表添加成功</p>
<p>Update</p>
<p>Update，它是更新操作,可以将svn服务器上的内容更新到本地</p>
<p><img src="/19.4.SVN/wps31.jpg" alt="img"> </p>
<p>更新(还原)到历史版本</p>
<p>查看当前日志</p>
<p><img src="/19.4.SVN/wps32.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps33.jpg" alt="img"> </p>
<p>也可以通过下面的方式来更新历史版本</p>
<p><img src="/19.4.SVN/wps34.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps35.jpg" alt="img"> </p>
<p>选择show log的版本，ok</p>
<p>Delete</p>
<p>标记删除操作，本地文件会删除，但是父目录会出现感叹号。我们需要在它的父目录进行提交，才能真正从服务器删除</p>
<p><img src="/19.4.SVN/wps36.jpg" alt="img"> </p>
<p>导入导出</p>
<p><img src="/19.4.SVN/wps37.jpg" alt="img"> </p>
<p>Import：将本地资源导入到svn服务器</p>
<p>Export：导出项目，和checkout的区别,它不存在.svn隐藏文件（只是把其中的内容download下来）</p>
<p>冲突问题与解决（重要）</p>
<p>多个用户同时操作同一个文件时，就可能产生冲突情况。同时提交会出现</p>
<p><img src="/19.4.SVN/wps38.jpg" alt="img"> </p>
<p>然后文件夹会多出来几个文件：</p>
<p><img src="/19.4.SVN/wps39.jpg" alt="img"> </p>
<p>HelloWorld.java 它是服务器上的文件与本地文件合并</p>
<p>HelloWorld.java.mine 本地修改后的文件</p>
<p>HelloWorld.java.r4 修改前的文件</p>
<p>HelloWorld.java.r5 对方修改后的文件</p>
<p>这个冲突产生后如何解决，我们可以采用手动Merge：</p>
<p>选择带感叹号的文件右击</p>
<p><img src="/19.4.SVN/wps40.jpg" alt="img"> </p>
<p>保存，标记已解决冲突。解决冲突后，重新commit.</p>
<h1 id="客户端-Eclipse-SVN插件安装与使用-重要"><a href="#客户端-Eclipse-SVN插件安装与使用-重要" class="headerlink" title="*客户端-Eclipse SVN插件安装与使用(重要)*"></a><em><strong>*客户端-Eclipse SVN插件安装与使用(重要)*</strong></em></h1><p>下载与安装SVN插件</p>
<p>在网页上搜索svn eclipse 官网下载一个svn插件,将它直接复制到eclipse安装目录下的dropins中</p>
<p>我们怎样可以知道svn插件安装成功：</p>
<p>在eclipse中的window下的preferences中搜索svn</p>
<p><img src="/19.4.SVN/wps41.jpg" alt="img"> </p>
<p>Eclipse SVN插件使用</p>
<p>浏览仓库，将eclipse工程导入到svn服务器</p>
<p><img src="/19.4.SVN/wps42.jpg" alt="img"> </p>
<p>在svn资源库研究</p>
<p><img src="/19.4.SVN/wps43.jpg" alt="img"> </p>
<p>输入服务器工程的URL</p>
<p>怎样将eclipse中的工程导入到svn仓库，可以在工程上右键</p>
<p><img src="/19.4.SVN/wps44.jpg" alt="img"> </p>
<p>选择服务器的URL。完成后，它其实没有真正的导入，需要我们右击在进行提交才真正导入到svn仓库</p>
<p>Checkout 导出 导入</p>
<p>选择SVN资源库研究，点击项目下的文件夹右击，可以进行检出，导出，导入等操作</p>
<p><img src="/19.4.SVN/wps45.jpg" alt="img"> </p>
<p>Add  commit  update 更新到历史版本</p>
<p><img src="/19.4.SVN/wps46.jpg" alt="img"> </p>
<p>Eclipse的svn插件解决冲突</p>
<p><img src="/19.4.SVN/wps47.jpg" alt="img"> </p>
<p>产生了冲突 </p>
<p>我们在工程上执行更新操作，就可以查看到冲突的文件</p>
<p><img src="/19.4.SVN/wps48.jpg" alt="img"> </p>
<p>解决冲突</p>
<p><img src="/19.4.SVN/wps49.jpg" alt="img"> </p>
<p>选择编辑冲突，进行编辑时，左边是自己的，右边的东西可以选中，然后点击右上角的图标进行操作。</p>
<p>编辑完成后进行保存，再标记为冲突解决</p>
<p><img src="/19.4.SVN/wps50.jpg" alt="img"> </p>
<p>然后在提交</p>
<p>理论篇(了解)命令行的方式</p>
<p>服务器-SubVersion安装与配置</p>
<p>官网上的source download下载的安装包解压后的目录结构</p>
<p><img src="/19.4.SVN/wps51.jpg" alt="img"> </p>
<p>bin目录存放svn相关命令</p>
<p>​    svnadmin:给服务器管理员使用，创建仓库，帐户等</p>
<p>​    svnserve:启动svn服务器</p>
<p>​    svn:客户端命令工具</p>
<p>iconv目录存放svn依赖插件</p>
<p>licenses 目录存放版权信息文件</p>
<p>share存放国际化文件</p>
<p>当安装完成后，默认情况下会将subversion安装目录bin加入到环境变量path中，如果没有，需要手动添加（这里有一个VisualSVN Server的bin目录，还有现在下载的subversion的bin目录）</p>
<p><img src="/19.4.SVN/wps52.jpg" alt="img"> </p>
<p>查看服务器版本号：svnserve –version （注意电脑上有一个VisualSVN Server，还有一个subversion）</p>
<p><img src="/19.4.SVN/wps53.jpg" alt="img"> </p>
<p>启动svn服务器</p>
<p>\1. 在服务器指定目录建立仓库  d:/my-reps</p>
<p>svnadmin create itcast</p>
<p>查看仓库目录结构</p>
<p><img src="/19.4.SVN/wps54.jpg" alt="img"> </p>
<p>conf 存放当前仓库的配置文件</p>
<p>db 存放仓库版本的控制文件</p>
<p>hooks 仓库脚本</p>
<p>locks 锁文件</p>
<p>\2. 启动服务</p>
<p>svnserve –d –r 路径</p>
<p><img src="/19.4.SVN/wps55.jpg" alt="img"> </p>
<p>\3. 测试客户端连接服务器，默认端口3690</p>
<p>svn checkout svn://localhost/itcast</p>
<p>客户端-命令行方式</p>
<p>1.checkout</p>
<p>svn checkout svn://localhost/itcast 默认端口3690</p>
<p>2.add</p>
<p><img src="/19.4.SVN/wps56.jpg" alt="img"> </p>
<p>3.commit</p>
<p><img src="/19.4.SVN/wps57.jpg" alt="img"> </p>
<p>直接提交会出错的原因:1.没有日志信息</p>
<p><img src="/19.4.SVN/wps58.jpg" alt="img"> </p>
<p>-m添加日志信息，还会出错的原因:权限问题</p>
<p>我们可以在D:\my-reps\itcast 查找到conf/ svnserve.conf文件，修改其中的权限write，再进行命令输入</p>
<p><img src="/19.4.SVN/wps59.jpg" alt="img"> </p>
<p>4.Update操作</p>
<p><img src="/19.4.SVN/wps60.jpg" alt="img"> </p>
<p>扩展篇（开发中的svn目录规范）</p>
<p>svn目录规范</p>
<p>在visualSVN中创建仓库时，可以选择svn目录结构</p>
<p><img src="/19.4.SVN/wps61.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps62.jpg" alt="img"> </p>
<p>Trunk 主干目录，此目录下的文件为基准文件</p>
<p>Branches 用于开发的分支目录</p>
<p>Tags 用于发布的版本目录（一般为只读）</p>
<p>假设有一个项目OA,我们完成了1.0版本，这时就可以打一个tags</p>
<p>后续我们在OA项目上添加一个新的模块(及时通讯),我们就可以开一个分支,又有一个公司需要在我们OA基础上添加财务管理模块，我们又可以打一个分支。这些分支都在Branches中</p>
<p>我们后续针对OA的1.0版本在升级，我们不需要原来附加功能,就可以在原来的主干Trunk上继续开发，形成OA2.0版本，开发完成后就可以在打一个tags</p>
<p>打一个分支或标记</p>
<p><img src="/19.4.SVN/wps63.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps64.jpg" alt="img"> </p>
<p>分支的定义规则:</p>
<p>​    Project name+日期时间+功能点</p>
<p>Tags的定义规则</p>
<p>​    Project name+版本号</p>
<p>​    版本号定义为三段数字编号</p>
<p>​    xxx.xxx.xxx</p>
<p>​    第一个:革命性的产品升级版</p>
<p>​    第二个:新功能版</p>
<p>​    第三个:修正bug</p>
<p>切换主干，分支与标记</p>
<p><img src="/19.4.SVN/wps65.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps66.jpg" alt="img"> </p>
<p>Tags一般是只读，它代表的是发布的版本，所以我们不要进行改变。</p>
<p>主干与分支的合并</p>
<p>如果要将主干内容合并到分支上，我们需要在分支的工作副本上操作。</p>
<p>如果要将分支的改变合并到主干上，我们需要在主干的工作副本上操作。</p>
<p>我们的需要是将分支的改变合并到主干上：</p>
<p><img src="/19.4.SVN/wps67.jpg" alt="img"> </p>
<p><img src="/19.4.SVN/wps68.jpg" alt="img"> </p>
<p>注意:在合并时要选择在相应的版本号，合并后，可能会出现冲突，将冲突解决，commit就可以。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/19.4.SVN/" data-id="ckno8ff4x000zswwdcqi9d3uo" data-title="SVN" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9.9.WEB之上传和下载" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:30:56.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/">WEB之上传和下载</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="文件上传"><a href="#文件上传" class="headerlink" title="*文件上传*"></a><em><strong>*文件上传*</strong></em></h1><p>文件上传：将本地的文件通过流写入到服务器的过程。</p>
<p>文件上传的技术：</p>
<p>JSPSmartUpload    ：应用在JSP上的文件上传和下载的组件。</p>
<p>FileUpload：应用在Java环境上的文件上传的功能。</p>
<p>Servlet3.0：提供文件上传的功能（前面我们选得都是2.5版本）</p>
<p>Struts2：提供文件上传的功能</p>
<p>文件上传的三个要素：</p>
<p>表单的提交的方式需要是POST</p>
<p>表单中需要有<input type=”file”>元素，需要有name属性和值。</p>
<p>表单enctype=”multipart/form-data”</p>
<p>写一个JSP，再写一个表单form，method为post提交，设置文件上传项，name属性和值，<em><strong>*Content-Type: application/x-www-form-urlencoded*</strong>***</em>*是默认的，改为****enctype=”multipart/form-data”，用HTTPWathch进行抓包分析：</p>
<p>没有设置enctype属性</p>
<p>POST /web06/jsp/upload.jsp HTTP/1.1</p>
<p>Accept: text/html, application/xhtml+xml, <em>/</em></p>
<p>X-HttpWatch-RID: 22006-10011</p>
<p>Referer: <a target="_blank" rel="noopener" href="http://localhost:8080/web06/jsp/upload.jsp">http://localhost:8080/web06/jsp/upload.jsp</a></p>
<p>Accept-Language: zh-CN</p>
<p>User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</p>
<p><em><strong>*Content-Type: application/x-www-form-urlencoded*</strong></em></p>
<p>Accept-Encoding: gzip, deflate</p>
<p>Host: localhost:8080</p>
<p>Content-Length: 53</p>
<p>DNT: 1</p>
<p>Connection: Keep-Alive</p>
<p>Cache-Control: no-cache</p>
<p>Cookie: JSESSIONID=D51DCB996556C94861B2C72C4D978010</p>
<p>info=info&amp;upload=C%3A%5CUsers%5Cjt%5CDesktop%5Caa.txt</p>
<p>没有文件上传中的文件的具体内容</p>
<p>设置enctype属性：</p>
<p>POST /web06/jsp/upload.jsp HTTP/1.1</p>
<p>Accept: text/html, application/xhtml+xml, <em>/</em></p>
<p>X-HttpWatch-RID: 22006-10026</p>
<p>Referer: <a target="_blank" rel="noopener" href="http://localhost:8080/web06/jsp/upload.jsp">http://localhost:8080/web06/jsp/upload.jsp</a></p>
<p>Accept-Language: zh-CN</p>
<p>User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</p>
<p><em><strong>*Content-Type: multipart/form-data;*</strong></em> boundary=—————————7e139d10110a64</p>
<p>Accept-Encoding: gzip, deflate</p>
<p>Host: localhost:8080</p>
<p>Content-Length: 322</p>
<p>DNT: 1</p>
<p>Connection: Keep-Alive</p>
<p>Cache-Control: no-cache</p>
<p>Cookie: JSESSIONID=D51DCB996556C94861B2C72C4D978010</p>
<p>—————————–7e139d10110a64</p>
<p>Content-Disposition: form-data; name=”info”</p>
<p>aaa</p>
<p>—————————–7e139d10110a64</p>
<p>Content-Disposition: form-data; name=”upload”; filename=”C:\Users\jt\Desktop\aa.txt”</p>
<p>Content-Type: text/plain</p>
<p>hello world！！！</p>
<p>—————————–7e139d10110a64–</p>
<p>—————————–7e139d10110a64代表分割线，将内容分割（分为2块就是三个分割线），–代表结束</p>
<p>文件上传的原理分析：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps31.jpg" alt="img"> </p>
<p>//普通项的aaa是jsp页面上写的名字。普通项就是表单中的其他内容，文件上传项是文件上传的相关内容。</p>
<p>进行一个文件的上传：</p>
<p>1.引入文件上传的相关的jar包</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps32.jpg" alt="img"> </p>
<p>2.编写文件上传的JSP页面</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps33.jpg" alt="img"> </p>
<p>3.编写文件上传的Servlet</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps34.jpg" alt="img"> </p>
<p>上传的内容没有在工程里，而是直接在文件下。</p>
<p>文件上传的API</p>
<p>1.DiskFileItemFactory：磁盘文件项工厂</p>
<p>构造方法：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps35.jpg" alt="img"> </p>
<p>DiskFileItemFactory()和DiskFileItemFactory(int sizeThreshold,File repostory)</p>
<p>sizeThreshold:设置文件上传的缓冲区的大小，默认值为10kb。</p>
<p>repository:设置文件上传过程中产生临时文件（如果超过了缓冲区的大小，就会产生临时文件）存放的路径。</p>
<p>方法：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps36.jpg" alt="img"> </p>
<p>setSizeThreshold()：设置缓冲区的大小</p>
<p>setRepository()：设置临时文件存放的路径</p>
<p>举例代码：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps37.jpg" alt="img"> </p>
<p>上传的文件如果没有超过缓冲区的大小，会直接在上传的目标文件夹下上传成功；如果超过了缓冲区的大小，会在你设定的临时文件下有一个TMP文件，当上传成功时，目标文件夹下会有一个文件，这个TMP文件也不会消失，用来续传或者其他操作。</p>
<p>2.ServletFileUpload：核心解析类</p>
<p>构造方法：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps38.jpg" alt="img"> </p>
<p>方法：</p>
<p>判断表单的enctype属性是否正确：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps39.jpg" alt="img"> </p>
<p>解析Request对象，返回一个List集合（每个部分的对象FileItem）：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps40.jpg" alt="img"> </p>
<p>设置单个文件的大小：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps41.jpg" alt="img"> </p>
<p>设置上传的文件的总大小：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps42.jpg" alt="img"> </p>
<p>设置中文文件名上传的乱码的问题（一般不会出现）：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps43.jpg" alt="img"> </p>
<p>设置监听文件上传的进度：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps44.jpg" alt="img"> </p>
<p>3.FileItem文件项</p>
<p>方法：</p>
<p>判断表单项是普通项还是文件上传项。如果为true代表是普通项：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps45.jpg" alt="img"> </p>
<p>普通项的方法：</p>
<p>获得普通项的名称：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps46.jpg" alt="img"> </p>
<p>获得普通项的值：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps47.jpg" alt="img"> </p>
<p>文件上传项的方法：</p>
<p>获得文件上传的文件名的方法：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps48.jpg" alt="img"> </p>
<p>获得文件上传的文件内容的方法：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps49.jpg" alt="img"> </p>
<p>获得文件上传的文件的大小：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps50.jpg" alt="img"> </p>
<p>删除文件上传过程中的临时文件：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps51.jpg" alt="img"> </p>
<p>JS控制多文件上传：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps52.jpg" alt="img"> </p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps53.jpg" alt="img"> </p>
<p>文件上传兼容浏览器问题：如果使用IE老版本的浏览器会出现一个文件名称获取错误问题。IE老版本获取文件名称的时候，会带有路径。</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps54.jpg" alt="img"> </p>
<p>一般的浏览器获得的filename都是aa.txt，但是老版本的IE浏览器是会获得全路径的文件名，会造成报错。</p>
<p>解决：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps55.jpg" alt="img"> </p>
<p>//检索\最后出现的坐标，当这个坐标存在的时候，截取这个左边开始到结束的内容</p>
<p>文件上传同一个目录下文件同名问题：张三向服务器上传了一个文件aa.txt内容是hello world。李四向服务器上传了一个文件aa.txt内容hello Java。后上传的文件将先上传的文件覆盖了。</p>
<p>使用唯一文件名进行解决：</p>
<p>UUID的randomUUID方法toString后得到的是一个包含-的字符串（由数字，字母和-组成）</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps56.jpg" alt="img"> </p>
<p>文件上传同一个目录下文件过多的问题：现在所有的用户都上传文件，如果网站访问量比较大，如果都上传到同一个目录下，在同一个目录下存放的文件太多了，也会对程序有影响（其实打开该目录的时候，都会很卡，更别说读写操作）。</p>
<p>解决方法：</p>
<p>进行目录分离：</p>
<p>按时间分离        ：按月、周、天、小时。</p>
<p>按用户分离        ：按张三、李四。</p>
<p>按个数分离        ：一个目录下存放3000个文件。</p>
<p><em><strong>*按目录分离算法*</strong>***</em>*分离****    <em><strong>*：按照某种特定算法进行分离。*</strong></em></p>
<p><em><strong>*上传一个文件，得到一个唯一的文件名。*</strong></em></p>
<p><em><strong>*唯一文件名获取其hashCode值。—–int类型的值（32位*</strong>***</em>*，*<strong><strong><strong>*无论正负*</strong></strong></strong>*）****</p>
<p><em><strong>*让hashCode的值 &amp; 0xf;—–得出的这个值作为一级目录。*</strong></em></p>
<p><em><strong>*让hashCode右移4位  &amp; 0xf;—-得出的这个值作为二级目录。*</strong></em></p>
<p><em><strong>*以此类推。*</strong></em></p>
<p><em><strong>*分析算法：*</strong></em></p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps57.jpg" alt="img"> </p>
<p>每级目录下又可以划分为：0000-1111有16个子目录</p>
<p>代码实现：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps58.jpg" alt="img"> </p>
<p>一般情况下，服务器是不会关闭的。因为服务器关闭后，会发现存放的上传文件都不见了，所以一般不关闭服务器，或者直接将上传的文件存入到本地磁盘中。</p>
<h1 id="文件下载"><a href="#文件下载" class="headerlink" title="*文件下载*"></a><em><strong>*文件下载*</strong></em></h1><p>文件下载：将服务器上的一个文件，通过流写入到客户端上。</p>
<p>文件下载的方式：</p>
<p>1.使用超链接的方式实现文件的下载：</p>
<p>在<a href=”文件的路径”>超链接</a></p>
<p><em><strong>*注意：超链接的方式，如果浏览器不能识别这种格式的文件，*</strong>***</em>*就会*<strong><strong><strong>*提示下载，*</strong></strong></strong>*点击确定，就会下载。*<strong><strong><strong>*如果支持该格式的文件，*</strong></strong></strong>*就会****<em><strong>*直接打开。*</strong></em></p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps59.jpg" alt="img"> </p>
<p><em><strong>*2.*</strong>***</em>*通过手动编写代码的方式实现文件的下载*<strong><strong><strong>*（*</strong></strong></strong>*无论浏览器支持不支持该格式的文件，都会询问是否下载，点击确定后就是下载****<em><strong>*）*</strong></em></p>
<p><em><strong>*设置两个头和一个流*</strong>***</em>*：****</p>
<p><em><strong>*Content-Type*</strong></em>            <em><strong>*:文件的MIME的类型*</strong>***</em>*（*<strong><strong><strong>*可以获取到*</strong></strong></strong>*）****</p>
<p><em><strong>*Content-Disposition*</strong></em>    <em><strong>*:浏览器支持该格式的文件，提示下载*</strong>***</em>*（*<strong><strong><strong>*固定的格式*</strong></strong></strong>*）****</p>
<p><em><strong>*设置代表该文件的输入流*</strong>***</em>*(输出流是固定*<strong><strong><strong>*的是**</strong> *<strong>*response.getOutputStream()*</strong></strong></strong>*)****</p>
<p>文件下载的页面</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps60.jpg" alt="img"> </p>
<p>文件下载的Servlet</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps61.jpg" alt="img"> </p>
<p>中文文件的下载：（出现乱码问题）</p>
<p>因为不同的浏览器对中文文件的下载的编码不一样的：</p>
<p>IE浏览器采用的是URL编码</p>
<p>Firefox浏览器采用的是Base64编码</p>
<p>所以需要判断客户端使用的浏览器的类型：User-Agent请求头可以获得客户端浏览器信息。</p>
<p>写一个工具类的base64编码方法，再调用这个方法进行转换，因为这个编码方法进行了加密。</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps62.jpg" alt="img"> </p>
<p>案例：给定目录下的文件下载</p>
<p>需求：给定一个目录（这个目录可以是任意盘符下的任意路径—这个路径下有多少级目录，每级目录中有多少个文件都是未知的）。将这个路径中的文件显示到页面上，在页面上给每个文件都提供相应的下载的链接，当点击这个链接的时候，对该文件进行下载。</p>
<p>分析：</p>
<p>树形结构的遍历，使用队列：根节点都入队然后出队，最后剩余的是叶节点：6 7 8 9 10</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps63.jpg" alt="img"> </p>
<p>文件列表显示的代码实现：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps64.jpg" alt="img"> </p>
<p>下载代码的实现：</p>
<p><img src="/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/wps65.jpg" alt="img"> </p>
<p>中文名字的文件经过IE浏览器编码时，会将其中的空格转换为加号，所以在这里需要将其中的加号再转换为空格。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/" data-id="ckno8ff5n0034swwdackb5xod" data-title="WEB之上传和下载" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9.8.WEB之listener和filter" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:30:44.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/">WEB之listener和filter</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="监听器"><a href="#监听器" class="headerlink" title="*监听器*"></a><em><strong>*监听器*</strong></em></h1><p>监听器就是一个实现了特定接口的Java类，这个Java类用于监听另一个Java类的方法调用或者属性的改变。当被监听对象发生上述事件后，监听器某个方法将会立即被执行。</p>
<p>用途：用来监听其他对象的变化的。主要应用在图形化界面开发上。Java中GUI，Android</p>
<p>监听器的术语：</p>
<p>事件源：指的是被监听对象（汽车）</p>
<p>监听器：指的是监听的对象（报警器）</p>
<p>事件源和监听器绑定：在汽车上安装报警器</p>
<p>事件：指的是事件源对象的改变（踹了汽车一脚）—-主要功能获得事件源对象。</p>
<p>例子：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps1.jpg" alt="img"> </p>
<p>执行过程：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps2.jpg" alt="img"> </p>
<p>（这里的WindowEvent e就是事件对象，e.getSource可以得到MyFrame的对象）</p>
<p>Servlet中的监听器：</p>
<p>在Servlet中定义了多种类型的监听器，它们用于监听的事件源分别是ServletContext、HttpSession和ServletRequest这三个域对象。</p>
<p>分类：</p>
<p>1.监听三个域对象的创建和销毁 的监听器（三个）</p>
<p>2.监听三个域对象的属性变更（属性添加、移除、替换）的监听器（三个）</p>
<p>3.监听HttpSession中JavaBean的状态改变（钝化、活化、绑定、解除绑定）的监听（两个）</p>
<p>ServletContextListener监听器：用来监听ServletContext域对象的创建和销毁的监听器。</p>
<p>ServletContext创建：在服务器启动的时候，为每个web应用创建单独的ServletContext对象。</p>
<p>ServletContext销毁：在服务器关闭的时候，或者项目从web服务器中移除的时候。</p>
<p>ServletContextListener监听器的方法：</p>
<p>监听ServletContext对象的创建：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps3.jpg" alt="img"> </p>
<p>监听ServletContext对象的销毁：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps4.jpg" alt="img"> </p>
<p>编写一个监听器：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps5.jpg" alt="img"> </p>
<p>对监听器进行配置（在web.xml中添加，将这个类的全路径复制）：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps6.jpg" alt="img"> </p>
<p>ServletContextListener的企业用途：</p>
<p>1.加载框架的配置文件：Spring框架提供了一个核心监听器ContextLoaderListener。（服务器启动时执行方法，这个方法里的内容就是加载配置文件）</p>
<p>2.定时任务调度：（服务器启动后进行计时，到点后进行定时任务执行）</p>
<p>HttpSessionListener监听器：用来监听HttpSession对象的创建和销毁。</p>
<p>HttpSession的创建：服务器端第一次调用getSession()方法时候。</p>
<p>HttpSession的销毁：1.非正常关闭服务器（正常关闭服务器session会被序列化，再次启动时会被反序列化，序列化文件可以在work下的localhost中找到）。</p>
<p>2.Session过期（默认过期时间30分钟，不操作30分钟）。</p>
<p>3.手动调用session.invalidate()方法。</p>
<p>HttpSessionListener监听器的方法：</p>
<p>监听HttpSession对象创建：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps7.jpg" alt="img"> </p>
<p>监听HttpSession对象销毁：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps8.jpg" alt="img"> </p>
<p>编写一个监听器：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps9.jpg" alt="img"> </p>
<p>监听器的配置：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps10.jpg" alt="img"> </p>
<p>注意：访问HTML是否会创建Session：不会</p>
<p>访问JSP是否会创建Session：会（会被转化为servlet，默认调用了getSession方法）</p>
<p>访问Servlet是否会创建Session    ：不会（默认没有调用getSession方法）</p>
<p>ServletRequestListener监听器：用来监听ServletRequest对象的创建和销毁</p>
<p>ServletRequest对象的创建：从客户端向服务器发送一次请求，服务器就会创建request对象。</p>
<p>ServletRequest对象的销毁：服务器对这次请求作出了响应之后，request对象就销毁了。</p>
<p>ServletRequestListener监听器的方法：</p>
<p>监听ServletRequest对象的创建：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps11.jpg" alt="img"> </p>
<p>监听ServletRequest对象的销毁：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps12.jpg" alt="img"> </p>
<p>编写一个监听器：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps13.jpg" alt="img"> </p>
<p>监听器配置：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps14.jpg" alt="img"> </p>
<p>注意：</p>
<p>访问HTML页面是否创建请求对象    ：会</p>
<p>访问JSP页面是否创建请求对象：会</p>
<p>访问Servlet是否创建请求对象：会</p>
<p>实现一个统计当前在线人数的案例：可以用ServletContextListener记录一个count值，这个count值整个项目都能取到。用HttpSessionListene记录count值的变化，当创建一个session时+1，销毁时-1。配置监听器。最后通过${count}输出。</p>
<p>监听三个域对象的属性变更的监听器：</p>
<p>1.ServletContextAttributeListener监听ServletContext对象中的属性变更（属性添加，移除，替换）的监听器</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps15.jpg" alt="img"> </p>
<p>2.HttpSessionAttributeListener监听HttpSession对象中的属性变更（属性添加，移除，替换）的监听器</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps16.jpg" alt="img"> </p>
<p>3.ServletRequestAttributeListener监听ServletRequest对象中的属性变更（属性添加，移除，替换）的监听器</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps17.jpg" alt="img"> </p>
<p>演示HttpSessionAttributeListener监听器：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps18.jpg" alt="img"> </p>
<p>配置监听器：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps19.jpg" alt="img"> </p>
<p>编写实例JSP：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps20.jpg" alt="img"> </p>
<p>监听HttpSession中Java类状态改变的监听器</p>
<p>保存在Session域中的Java类可以有多种状态：绑定到session中；从session中解除绑定；随session对象持久化到一个存储设备中（钝化）；随session对象从一个存储设备中恢复（活化）。</p>
<p>Servlet规范中定义了两个特殊的监听的接口****来帮助Java类了解自己在Session域中的状态****：</p>
<p>HttpSessionBindingListener接口</p>
<p>HttpSessionActivationListener接口</p>
<p><em><strong>*实现这两个接口的类不需要在web.xml中进行配置。*</strong></em></p>
<p>HttpSessionBindingListener监听器：监听Java类在HttpSession中的绑定和解除绑定的状态的监听器</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps21.jpg" alt="img"> </p>
<p>先新建一个bean1类，这个类中有属性name，get和set方法。再让它实现HttpSessionBindingListener接口：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps22.jpg" alt="img"> </p>
<p>新建一个jsp页面，在里面新建一个bean1对象，set方法设置这个对象的名字，调用session的setAttribute方法进行绑定（java类写入session）。removeAttribute方法就可以解除绑定。</p>
<p>HttpSessionActivationListener监听器：监听HttpSession中Java类的钝化和活化监听器。</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps23.jpg" alt="img"> </p>
<p>（钝化相当于序列化，被写入硬盘）不仅要实现HttpSessionActivationListener接口，还要实现Serializable接口</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps24.jpg" alt="img"> </p>
<p>应用：节省内存空间，如果有大量的session同时存在，会很耗费空间。可以将其中的一部分序列化保存在硬盘中，当需要用到的时候再反序列化从内存中取到。</p>
<p>而在正常的开发中，服务器一般不关闭，所以需要手动将一部分的session进行序列化。（正常情况下，只有关闭了服务器，session才会被序列化）所以手动配置完成session的序列化和反序列化：</p>
<p>配置代码是：</p>
<Context>

<Manager className="org.apache.catalina.session.PersistentManager" maxIdleSwap="1">

<p>​    <Store className="org.apache.catalina.session.FileStore" directory="itheima"/></p>
</Manager>

</Context>

<p>//  1分钟不操作，就会序列化到itheima中</p>
<p>这个Context标签代码可以配置在：</p>
<p><em><strong>*tomcat/conf/context.xml*</strong></em>    <em><strong>*:所有tomcat下虚拟主机和虚拟目录下的工程都会序列化session*</strong></em></p>
<p><em><strong>*tomcat/conf/Catalina/localhost/context.xml:localhost虚拟主机下的所有项目会序列化session*</strong></em></p>
<p><em><strong>*工程/META-INF/context.xml:当前工程才会序列化session。*</strong></em></p>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="*过滤器*"></a><em><strong>*过滤器*</strong></em></h1><p>Filter称为过滤器，它是Servlet技术中最实用的技术，web开发人员通过Filter技术，对web服务器所管理的资源（JSP，Servlet，静态图片或静态html文件）进行拦截，从而实现一些特殊的功能。</p>
<p>Filter就是过滤从客户端向服务器发送的请求。</p>
<p>可以进行敏感词汇的禁止，动态页面的缓存等</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps25.jpg" alt="img"> </p>
<p>Filter将其中的敏感词汇改为**，再继续进行传输</p>
<p>编写一个Filter：编写一个类实现Filter接口</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps26.jpg" alt="img"> </p>
<p>对过滤器进行配置：</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps27.jpg" alt="img"> </p>
<p>/*指全部请求都要执行FilterDemo1。chain.doFilter（request,response）；指放行（没有这个的话什么内容都不会在后面显示）</p>
<p>FilterChain对象</p>
<p>FilterChain过滤器链：在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称为是一个过滤器链。</p>
<p>Web服务器根据Filter在web.xml文件中的注册顺序（mapping的配置顺序）决定先调用那个Filter。依次调用后面的过滤器，如果没有下一个过滤器，调用目标资源</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps28.jpg" alt="img"> </p>
<p>//假设Filter1，2，3中都有chain.doFilter（request,response）；方法，先执行Filter1，执行到chain.doFilter（request,response）；方法时在执行Filter2，执行到chain.doFilter（request,response）；方法时在执行Filter3，在执行web资源，然后再执行Filter3中chain.doFilter（request,response）；方法后的内容，在执行Filter2中chain.doFilter（request,response）；方法后的内容，Filter1，返回</p>
<p>Filter的生命周期：Filter的创建和销毁是由web服务器负责。Web应用程序启动的时候，web服务器创建Filter的实例对象。并调用其init方法进行初始化（filter对象只会创建一次，init方法也只会执行一次）。</p>
<p>每次filter进行拦截的时候，都会执行doFilter的方法。</p>
<p>当服务器关闭的时候，应用从服务器中移除的时候，服务器会销毁Filter对象。</p>
<p>FilterConfig对象：用来获得Filter的相关的配置的对象。</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps29.jpg" alt="img"> </p>
<p>在配置文档中配置过滤器的初始化参数</p>
<p><img src="/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/wps30.jpg" alt="img"> </p>
<p>过滤器的相关配置,这些配置都是在maping中配置</p>
<p><url-pattern>的配置</p>
<p>完全路径匹配：以/开始  比如/aaa  /aaa/bbb</p>
<p>目录匹配：以/开始 以<em>结束  比如/</em>  /aaa/*  /aaa/bbb/*</p>
<p>扩展名匹配    ：不能以/开始 以<em>开始 比如</em>.jsp  *.do  *.action</p>
<p><servlet-name>的配置</p>
<p>专门以Servlet的配置的名称拦截Servlet。（不常用，因为如果需要拦截Servlet，可以在maping配置中写出这个Servlet的路径拦截）</p>
<p><dispatcher>的配置</p>
<p>默认的情况下过滤器会拦截请求。如果进行转发（需要拦截这次转发FORWARD）。</p>
<p>dispatcher的取值</p>
<p><em><strong>*REQUEST*</strong></em>    <em><strong>*:默认值。默认过滤器拦截的就是请求。*</strong></em></p>
<p><em><strong>*FORWARD:转发。*</strong></em></p>
<p>INCLUDE    :页面包含的时候进行拦截</p>
<p>ERROR    :页面出现全局错误页面跳转的时候进行拦截</p>
<p>如果想拦截多个，可以多配置几个</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/" data-id="ckno8ff5n0032swwdb4w84sdt" data-title="WEB之listener和filter" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9.7.WEB之cookie和session" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:30:26.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/">WEB之cookie和session</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>用户打开一个浏览器，点击多个超链接访问服务器的web资源，然后关闭浏览器，整个过程称为是一次会话。</p>
<p>会话技术：每个用户与服务器进行交互过程中，产生一些各自的数据，程序想要把这些数据进行保存，就需要使用会话技术。</p>
<p>分类：</p>
<p>1.Cookie技术：Cookie是客户端技术，程序把每个用户的数据以cookie的形式保存到各自浏览器中。当用户使用浏览器再次访问服务器中的web资源的时候，就会带着各自的数据过去。这样，web资源处理的就是用户各自的数据了。</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps1.jpg" alt="img"> </p>
<p>2.Session技术：Session是服务器端技术，利用这个技术，服务器在运行时为每一个用户的浏览器创建一个****独享的session对象。****由于session为用户浏览器独享，所有用户在访问服务器的时候，可以把各自的数据放在各自的session中，当用户再次访问服务器中的web资源的时候，其他web资源再从用户各自的session中取出数据为用户服务。</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps2.jpg" alt="img"> </p>
<p>Cookie的使用：</p>
<p>获得从浏览器带过来的Cookie，通过HttpServletRequest对象中的方法：</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps3.jpg" alt="img"> </p>
<p>向浏览器回写Cookie，通过HttpServletResponse对象中的方法：</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps4.jpg" alt="img"> </p>
<p>cookie的构造方法：</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps5.jpg" alt="img"> </p>
<p>其他方法：</p>
<p>获得Cookie的名称的方法</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps6.jpg" alt="img"> </p>
<p>获得Cookie的值的方法</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps7.jpg" alt="img"> </p>
<p>设置Cookie的有效域名（设置了之后，它之下的域名访问时也会有cookie）</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps8.jpg" alt="img"> </p>
<p>设置Cookie的有效路径（设置之后，它之下的路径也会有cookie，“/”是指整个项目）</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps9.jpg" alt="img"> </p>
<p>设置Cookie的有效时长（0是指删除，以秒为单位）</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps10.jpg" alt="img"> </p>
<p>Cookie的分类：</p>
<p>1.默认级别的Cookie：指的是没有设置有效时间的Cookie，默认的情况下只要关闭了浏览器，Cookie也会被销毁。（Cookie存在于浏览器的内存中，当关闭了浏览器Cookie就销毁了）。</p>
<p>2.持久级别的Cookie：指的是有有效时间的Cookie，这种Cookie的内容不是保存在浏览器的内存中，将Cookie的内容保存（持久化）到硬盘上。这个时候，关闭浏览器，再次打开浏览器就会加载硬盘上的文件，从而Cookie中的数据就不会丢失。</p>
<p>Cookie的使用细节：</p>
<p>一个Cookie只用标识一种信息，至少含有一个标识该信息的名称和值。</p>
<p>一个web站点可以给一个浏览器发送多个Cookie。一个web浏览器可以存储多个web站点的Cookie。</p>
<p>浏览器一般只允许存放300个Cookie，每个站点最多可以存放20个Cookie，每个Cookie的大小限制为4KB（老版本浏览器）。—–<em><strong>*浏览器存放的Cookie的大小和个数是有限制的。*</strong></em></p>
<p>如果创建了一个Cookie，并发送到浏览器，默认情况下它是一个****会话级别的Cookie****。用户退出浏览器就被删除。如果希望将这个Cookie存到磁盘上，需要设置有效时长调用setMaxAge(int maxAge)方法，以秒为单位的。</p>
<p>需要手动删除持久性Cookie，可以将Cookie的有效时长设置为0.必须注意：删除Cookie时候，path必须一致，否则无法删除。</p>
<p>Session：Session称为是一次会话，Cookie将用户产生的私有的数据保存到浏览器端，Session将用户产生的私有的数据保存到服务器端。注意：****一个浏览器独占一个session对象****。因此，在需要保存用户数据时候，服务器程序可以将用户数据写到session对象中，当用户使用浏览器访问其他程序时，其他程序可以从用户的session中取出该用户的数据，为用户服务。</p>
<p>为什么有Cookie还要有Session：</p>
<p>Cookie局限性：Cookie保存的数据是有个数和大小的限制的。数据是保存客户端浏览器上（相对不是很安全）。</p>
<p>Session：Session没有个数和大小限制。数据是保存在服务器上（相对比较安全）。</p>
<p>Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到Session对象。</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps11.jpg" alt="img"> </p>
<p>Session的实现原理：</p>
<p>****基于Cookie的****，响应头基于Cookie的set-cookie回写了一个Session的ID。</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps12.jpg" alt="img"> </p>
<p>向session中存入数据：</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps13.jpg" alt="img"> </p>
<p>从session域中获取数据：</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps14.jpg" alt="img"> </p>
<p>从session域中移除数据：</p>
<p><img src="/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/wps15.jpg" alt="img"> </p>
<p>Session作为域对象，作用范围就是****一次会话****的范围。一次会话，指的是用户打开浏览器点击多个超链接，访问服务器资源，到最后关闭浏览器的过程。（一般保存私有信息，验证码）</p>
<p>Servlet的域对象的总结：</p>
<p>1.请求范围（ServletRequest）</p>
<p>创建：当用户向服务器发送一次请求，服务器创建一个request对象。</p>
<p>销毁：当服务器对这次请求作出了响应，服务器就会销毁这个request对象。</p>
<p>存数据：void setAttribute(String name,Object value);</p>
<p>取数据：Object getAttribute(String name);</p>
<p>作用范围：一次请求。（转发就是一次请求）。</p>
<p>2.会话范围（HttpSession）</p>
<p>创建：服务器端****第一次调用getSession()****方法的时候。</p>
<p>销毁：三种情况：</p>
<p>Session过期，默认的过期时间30分钟(web.xml中配置)。</p>
<p>非正常关闭服务器（直接点击控制台的Terminate就是非正常关闭服务器，点击Servers的stop就是正常关闭）。（正常关闭服务器—session会被序列化到Tomcat的work下的localhost的工程下找到）。</p>
<p>手动调用session.invalidate();</p>
<p>存数据：void setAttribute(String name,Object value);</p>
<p>取数据：Object getAttribute(String name);</p>
<p>作用范围：一次会话（多次请求）</p>
<p>3.应用范围（ServletContext）</p>
<p>创建：服务器启动的时候创建，为每个web项目创建一个单独ServletContext对象。</p>
<p>销毁：服务器关闭的时候，或者项目从服务器中移除的时候。</p>
<p>存数据：void setAttribute(String name,Object value);</p>
<p>取数据：Object getAttribute(String name);</p>
<p>作用范围：整个应用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/" data-id="ckno8ff5m0031swwddc4chfys" data-title="WEB之cookie和session" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9.6.WEB之ajax" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.6.WEB%E4%B9%8Bajax/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:30:09.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.6.WEB%E4%B9%8Bajax/">WEB之ajax</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>AJAX 是一种用于创建快速动态网页的技术。</p>
<p>AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/828.htm">网页</a>应用的网页开发技术。</p>
<p>AJAX = 异步 <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/16168.htm">JavaScript</a>和<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/63.htm">XML</a>（<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/5286041.htm">标准通用标记语言</a>的子集）。</p>
<p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p>传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。</p>
<p>AJAX 的核心是 JavaScript 对象 XMLHttpRequest。该对象在 Internet Explorer 5 中首次引入，它是一种支持异步请求的技术。简而言之，XMLHttpRequest使您可以使用 JavaScript 向服务器提出请求并处理响应，而不阻塞用户。</p>
<p>AJAX不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术</p>
<p>ajax的优点：</p>
<p>使用Javascript向服务器提出请求并处理响应而不阻塞用户！核心对象XMLHTTPRequest。通过这个对象，您的 JavaScript 可在不重载页面的情况与Web服务器交换数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。</p>
<p>AJAX 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面。</p>
<p>AJAX 可使因特网应用程序更小、更快，更友好</p>
<p>工作原理：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="/9.6.WEB%E4%B9%8Bajax/wps1.jpg" alt="img"></td>
</tr>
</tbody></table>
<p>AJAX应用</p>
<p>1.创建一个demo1.html</p>
<p>2.发送一个ajax请求<img src="/9.6.WEB%E4%B9%8Bajax/wps2.jpg" alt="img">：</p>
<p>2.1：获取一个XMLHttpRequest对象</p>
<p>对于大部分浏览器可以直接通过 new XMLHttpRequest();</p>
<p>对于IE5  IE6 new ActiveXObject(“Microsoft.XMLHTTP”)</p>
<p><img src="/9.6.WEB%E4%B9%8Bajax/wps3.jpg" alt="img">2.2：设置一个回调函数</p>
<p>回调函数它的作用就是用于处理服务器响应的数据</p>
<p>通过XMLHttpRequest对象的onreadystatechange设置回调函数</p>
<p>onreadystatechange 事件句柄，它是用于绑定回调函数，当服务器响应数据回来后，我们可以在指定的回调函数中进行数据处理</p>
<p>readyState 它描述的http请求的状态</p>
<p><img src="/9.6.WEB%E4%B9%8Bajax/wps4.jpg" alt="img"> </p>
<p>status 它描述的http状态码  200 404  405 500…</p>
<p>2.3：设置请求方式GET/POST及请求的URL等</p>
<p>通过XMLHttpRequest对象的open方法</p>
<p>open它是用于设置请求方式，url及是否异步，初始化HTTP请求参数，例如URL和HTTP方法，但是并不发送请求</p>
<p>参数1：HTTP 请求方式  POST/GET。</p>
<p>参数2:url路径</p>
<p>参数3:true/false 代表是否异步 （一般不用写，只写前两个参数）</p>
<p>2.4：真正向服务器发送请求</p>
<p>通过XMLHttpRequest对象的send方法</p>
<p>send它是真正向服务器发送请求</p>
<p>如果请求方式是get，那么我们使用send(null) 原因:get请求方式是没有http请求体</p>
<p>只有post请求方式时，才有请求体,所以send的参数只是在post请求时使用例如</p>
<p>Xmlhttp.send(“username=xxx&amp;password=xxx”);</p>
<p>setRequestHeader</p>
<p><img src="/9.6.WEB%E4%B9%8Bajax/wps5.jpg" alt="img">注意：如果请求方式是POST,那么我们在使用时，必须设置一个请求头，就需要使用setRequestHeader方法来完成</p>
<p>第二个参数是form表单标签的enctype的默认值</p>
<p>2.5：在回调函数中获取服务器响应的数据</p>
<p>通过XMLHttpRequest对象的responseText</p>
<p>responesText或responseXML来获取服务器响应数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.6.WEB%E4%B9%8Bajax/" data-id="ckno8ff5m002zswwdaeu7ahcb" data-title="WEB之ajax" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9.5.WEB之JQuery" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.5.WEB%E4%B9%8BJQuery/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:29:56.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.5.WEB%E4%B9%8BJQuery/">WEB之JQuery</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>jQuery是一个快速、简洁的****JavaScript框架*<em><strong>，是继Prototype之后又一个优秀的JavaScript代码库（</strong>或JavaScript框架</em>*）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p>
<p>使用jquery可以更好完成以下操作：</p>
<p>\1. html文档操作，对于dom相关操作优化</p>
<p>\2. jquery提供更加方便与丰富事件处理</p>
<p>\3. jquery提供简单动画特效</p>
<p>\4. jquery提供ajax交互</p>
<p>要使用任何一个js框架，都是需要导入相关的js文件。</p>
<p>jquery的插件机制特别丰富,在开发中可以选择非常多的相关插件，例如，表单校验插件，树型结构等</p>
<p>其它常用js框架:</p>
<p>1.dojo 面向对象的js框架</p>
<p>2.extjs 学习成本比较高 它提供大量的丰富组件，它的效果展示（动画）非常好</p>
<p>3.prototype 早期比较流行js框架</p>
<p>4.angularJS 它是一个mvc js框架，它提供双向数据绑定</p>
<p><a target="_blank" rel="noopener" href="http://jquery.com/">http://jquery.com/</a> jquery官网</p>
<p>jquery最新版本3.5.1 现在学习的版本1.8.3</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps1.jpg" alt="img"> </p>
<p>因为jquery从jquery2.x以后对浏览器支持不是特别好，在pc端开发使用比较主流的是1.x版本</p>
<p>对于开发中， 我们需要导入的是min.js文件，在学习阶段我们导入 jquery-1.8.3.js</p>
<p>完成操作:页面加载完成后，弹出一个框显示hello jquery</p>
<p>第一步:新建一个web工程，2.5版本。将jquery复制到项目的webcontent中</p>
<p>导入js文件</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps2.jpg" alt="img"> </p>
<p>第二步：完成操作</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps3.jpg" alt="img"> </p>
<p>注意:源生的js绑定，它只能绑定一次（第二次绑定时会将第一次的覆盖掉），而jquery允许绑定多次（都可以显示出来）</p>
<p>源生的js绑定：</p>
<script type=”text/javascript”>

window.onload=function(){

alert(“hello jquery”);

}

</script>

<p>jQuery的核心函数</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps4.jpg" alt="img"> </p>
<p>jQuery.holdReady（hold）暂时不讲</p>
<p>1.jQuery(callback)</p>
<p>jQuery(callback)是$(document).ready()的简写</p>
<p>$(document).ready(function(){});页面加载完成后，指定的函数执行</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps5.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps6.jpg" alt="img"> </p>
<p>2.jQuery(html,<strong>[ownerDocument]</strong>)</p>
<p>jQuery(html代码)它的作用是将一个dom对象包装成jquery对象</p>
<p>jquery对象：jquery中定义的方法与属性，只有jquery对象可以调用</p>
<p>这个核心函数的作用是将一个dom对象包装成了jquery对象，它的第一个参数是html代码，第二个参数是可选，它用于设置dom的相关属性</p>
<p>3.jQuery([selector,[context]])</p>
<p>这个核心函数的主要作用是用于在页面上查找，根据css选择器。参数1就是css选择器  jquery中提供了九种选择器；参数2 context 就是指定要查找的dom集</p>
<p>4.关于jquery对象与dom对象转换</p>
<p>dom对象—–àjquery对象  $(dom)</p>
<p>jquery对象—-àdom对象   jquery对象[0] 或  jquery对象.get(0)</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps7.jpg" alt="img"> </p>
<h1 id="jQuery选择器-（-重要-）"><a href="#jQuery选择器-（-重要-）" class="headerlink" title="*jQuery选择器*****（**重要**）****"></a><em><strong>*jQuery选择器*</strong>***</em>*（*<strong><strong><strong>*重要*</strong></strong></strong>*）****</h1><p>一、基本选择器</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps8.jpg" alt="img"> </p>
<p>#id 根据 id属性查找一个元素</p>
<p>element 根据元素的标签名称查找元素</p>
<p>.class 根据元素的class属性查找元素</p>
<p>*匹配所有元素（通配符）</p>
<p>selector1,selector2…将每一个选择器匹配到元素合并后一起返回</p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps9.jpg" alt="img"> </p>
<p>1.得到id=d1的元素中的内容显示出：</p>
<p>var html =$(“#d1”).html();  //获取所有html</p>
<p>alert(html);</p>
<p>var html =$(“#d1”).text();  //获取所有文本</p>
<p>alert(text);</p>
<p>2.将class=d元素中的内容后面添加XXX：</p>
<p>$(“.d”).each(function(i){</p>
<p>$(this).html($(this).html()+”XXX”);</p>
<p>}</p>
<p>3.得到id=d1这个div在整个页面上的div是第几个.：</p>
<p>var index =$(“this”).index($(“#d1”));  //序号是从0开始</p>
<p>alert(index);</p>
<p>4.得到class=d的元素有几个：</p>
<p>var size =$(.d).size();</p>
<p>alert(size);</p>
<p>5.将所有的class=d或id=d1元素中的内容设置为java:</p>
<p>$(“.d,#d1”).html(“java”);</p>
<p>$(“.d,#d1”).text(“java”);</p>
<p>方法总结：</p>
<p>1.html ()方法，无参数代表获取元素中的<strong>html代码</strong>，如果有参数代表设置元素的html信息</p>
<p>2.text()方法，无参数代表获取元素中的<strong>文本信息</strong>，如果有参数代表设置元素的文本信息</p>
<p>3.each()方法，它的使用可以帮助我们遍历元素，可以传递一个函数 each(function(n)),n就代表的是每一个元素的序号，在函数中可以通过this来获取其dom对象（注意dom对象和jQuery对象的转换）</p>
<p>4.index()方法，它可以判断元素的序号</p>
<p>二、层级选择器</p>
<p>层级选择器是根据元素的关系来获取。关系是指父子关系，兄弟关系(可以看tab键的位置确定，同级的关系，父子的关系)</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps10.jpg" alt="img"> </p>
<p>1.空格 得到元素下的所有子元素(包含直接子元素与间接子元素（子元素的子元素）)</p>
<p>2.大于号&gt;  只获取直接的子元素</p>
<p>3.加号+  只获取直接的下一个兄弟元素</p>
<p>4.波浪线~ 所有的后边的兄弟元素</p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps11.jpg" alt="img"> </p>
<p>\1. 获取id=d的所有<a>子元素：$(“#d a”)  //3个</p>
<p>\2. 获取id=d 的直接<a>子元素:$(“#d&gt;a”)  //2个</p>
<p>\3. 获取id=d第一个<p>兄弟元素:$(“#d+p”)  //1个</p>
<p>\4. 获取id=d的所有<p>兄弟元素:$(“#d~p”)  //2个</p>
<p>5.将id=d下的所有子元素<a>的文字颜色设置成红色</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps12.jpg" alt="img"> </p>
<p>方法总结：</p>
<p>css()方法，它可以设置元素的样式,如果只有一个值  css(name,value),如果有多个值,css({name:value,name:value})</p>
<p>三、过滤器</p>
<p>过滤器它是在基本选择器与层次选择器获取到一批元素后，在进行过滤操作，使用过滤选择器基本都是”:”开头，除了属性过滤选择器[]</p>
<p>1.基本过滤选择器</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps13.jpg" alt="img"> </p>
<p>odd是奇数，even是偶数</p>
<p>可以查文档使用</p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps14.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps15.jpg" alt="img"> </p>
<p>2.内容过滤选择器</p>
<p>内容过滤选择器它是根据元素内部文本内容进行选中</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps16.jpg" alt="img"> </p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps17.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps18.jpg" alt="img"> </p>
<p>可以先创建一个css样式的divColor，然后这里可以用addClass()方法调取。</p>
<p>3.可见性过滤选择器</p>
<p>可见性过滤选择器它匹配display:none或表单中input hidden这样的元素</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps19.jpg" alt="img"> </p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps20.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps21.jpg" alt="img"> </p>
<p>方法总结：</p>
<p>1.val() 获取元素当前的值  就是value值</p>
<p>2.show() 让元素显示出来</p>
<p>3.hide() 让元素隐藏起来</p>
<p>4.属性过滤选择器：根据元素的属性来过滤</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps22.jpg" alt="img"> </p>
<p>^=匹配开始</p>
<p>$=匹配结尾</p>
<p>*=匹配包含</p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps23.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps24.jpg" alt="img"> </p>
<p>方法总结：</p>
<p>attr()设置或返回被选元素的属性值</p>
<p>5.子元素过滤选择器</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps25.jpg" alt="img"> </p>
<p>根据子元素顺序来获取。</p>
<p>nth-child根据序号来选择，<em><strong>*序号是从1开始*</strong></em> <em><strong>*（2）*</strong></em>  也可以设置odd even 根据奇偶来设置（odd）（even） 也可以通过倍数来设置（3n）</p>
<p>first-child 获取第一个</p>
<p>last-child 获取最后一个</p>
<p>only-child 获取只有一个子元素</p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps26.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps27.jpg" alt="img"> </p>
<p>6.表单过滤选择器：表单过滤选择器是用于选取表单中的元素</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps28.jpg" alt="img"> </p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps29.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps30.jpg" alt="img"> </p>
<p>方法总结：</p>
<p>1.trim()它是去掉字符串左右空格 $.trim(value)</p>
<p>常用事件处理：</p>
<p>2.失去焦点事件 blur(function(){})</p>
<p>3.click(function(){}) 点击事件</p>
<p>4.submit() 表单提交</p>
<p>7.表单对象属性过滤选择器</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps31.jpg" alt="img"> </p>
<p>checked是用于radio,checkbox 判断选中</p>
<p>selected是用于select下拉框选中</p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps32.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps33.jpg" alt="img"> </p>
<p>在开发中，使用比较多的选择器有:</p>
<p>\1. 基本选择器  class id  element</p>
<p>\2. 层次选择器  父子关系  兄弟关系</p>
<p>3.过滤选择器  属性过滤   基本过滤  内容过滤  关于表单过滤</p>
<h1 id="jQuery-DOM操作"><a href="#jQuery-DOM操作" class="headerlink" title="*jQuery DOM操作*"></a><em><strong>*jQuery DOM操作*</strong></em></h1><p>一、文档处理</p>
<p>1.插入操作</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps34.jpg" alt="img"> </p>
<p>内部插入是在该标签的内部的最开始（prepend）和最后（append）插入</p>
<p>外部插入是在该标签某一项的前面（before）或者后面（after）插入</p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps35.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps36.jpg" alt="img"> </p>
<p>2.删除</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps37.jpg" alt="img"> </p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps38.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps39.jpg" alt="img"> </p>
<p>3.替换与克隆</p>
<p>替换：<img src="/9.5.WEB%E4%B9%8BJQuery/wps40.jpg" alt="img"></p>
<p>克隆：<img src="/9.5.WEB%E4%B9%8BJQuery/wps41.jpg" alt="img"></p>
<p>第二个参数生效的情况下，第一个参数必须为true</p>
<p>举例：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps42.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps43.jpg" alt="img"> </p>
<p>综合练习：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps44.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps45.jpg" alt="img"> </p>
<p>二、筛选</p>
<p>1.过滤</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps46.jpg" alt="img"> </p>
<p>过滤操作它相当于是我们在jquery中使用的过滤选择器，</p>
<p>例如 eq可以根据序号来获取元素（从0开始计数） first与last来获取第一个元素与最后一个元素</p>
<p>2.查找</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps47.jpg" alt="img"> </p>
<p>是通过当前元素，获取祖先元素，父元素子元素等。</p>
<p>find方法，它可以直接来查找指定的元素.</p>
<h1 id="jQuery事件机制"><a href="#jQuery事件机制" class="headerlink" title="*jQuery事件机制*"></a><em><strong>*jQuery事件机制*</strong></em></h1><p>一、jQuery事件介绍</p>
<p>Jquery中的事件与传统的javascript中事件区别:Jquery中事件允许绑定多个函数，而javascript中一个事件只能绑定一个函数.</p>
<p>事件中的方法：javascript是onblur，而jquery中是blur</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps48.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps49.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps50.jpg" alt="img"> </p>
<p>二、事件绑定</p>
<p>1.传统的javascript中事件绑定操作</p>
<p>写法1：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps51.jpg" alt="img"> </p>
<p>写法2：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps52.jpg" alt="img"> </p>
<p>2.Jquery事件绑定操作</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps53.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps54.jpg" alt="img"> </p>
<p>bind与live它们的区别：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps55.jpg" alt="img"> </p>
<p>三、一次性事件和自动触发</p>
<p>1.一次性事件</p>
<p>one()为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps56.jpg" alt="img"> </p>
<p>2.事件触发</p>
<p>trigger()在每一个匹配的元素上触发某类事件</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps57.jpg" alt="img"> </p>
<p>四、事件切换</p>
<p>1.hover：这个操作它可以绑定两个函数，当触发mouseover时第一个函数执行，当触发mouseout时第二个函数执行</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps58.jpg" alt="img"> </p>
<p>2000是一个时间，2000ms</p>
<p>2.toggle：用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps59.jpg" alt="img"> </p>
<h1 id="jQueryAjax编程"><a href="#jQueryAjax编程" class="headerlink" title="*jQueryAjax编程*"></a><em><strong>*jQueryAjax编程*</strong></em></h1><p>一、jquery ajax开发介绍</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps60.jpg" alt="img"> </p>
<p>1.$.ajax()它是jquery提供的最基本的ajax编程方式。它的功能比较强大，但是使用比较麻烦，一般不使用，它是将远程数据加载到XMLHttpRequest对象中。</p>
<p>2.load  get  post 它们简化了$.ajax操作，get post针对get与post请求的，它们是开发中使用的比较多。</p>
<p>3.getScript  getJSON 它们是用于解决ajax跨域问题的</p>
<p>二、load（仅了解，用的不多）</p>
<p>载入远程 HTML 文件代码并插入至 DOM 中</p>
<p>load(url,参数，回调函数)</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps61.jpg" alt="img"> </p>
<p>服务器端的load对应的servlet下的get方法下的代码：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps62.jpg" alt="img"> </p>
<p>load方法是将服务器响应的数据直接插入到指定的dom元素中。jquery中的load方法如果有参数请求方式是post，如果没有参数请求方式是get</p>
<p>三、$.ajax（了解）</p>
<p>$.ajax它是jquery中最基本的ajax操作，load  get  post都简化了$.ajax操作</p>
<p>上述的代码不使用load操作，使用原始的$.ajax操作</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps63.jpg" alt="img"> </p>
<p>四、$.post与$.get（重要）</p>
<p>$.get与$.post它们针对于get与post请求</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps64.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps65.jpg" alt="img"> </p>
<p>五、$.getJSON和$.getScript</p>
<p>jQuery ajax开发基于json（重点）</p>
<p>json介绍：</p>
<p><a target="_blank" rel="noopener" href="http://baike.baidu.com/view/136475.htm">JSON</a>(<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/16168.htm">JavaScript</a> Object Notation) 是一种轻量级的数据交换格式，是javascript的一个子集.</p>
<p>json简单说就是javascript中的对象和数组.</p>
<p>对象: {key：value,key：value,…}</p>
<p>数组: [“java”,”javascript”,”vb”,…]</p>
<p>注意:在json中它的两种结构可以互相嵌套</p>
<p>{key:[value1,value2],key:value}</p>
<p>[{name:xxx},{key:value},{key:value}]</p>
<p>Fastjson介绍：</p>
<p>将java的对象转换成json数据,也可以将一个json转换成java对象(不常用)</p>
<p>Fastjson是阿里提供的一个开源json插件（工具）</p>
<p>对于json处理的插件有很多：  fastjson  jsonlib  flexjson  Jackson</p>
<p>Fastjson的使用介绍：</p>
<p>\1. 导入相应的jar包</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps66.jpg" alt="img"> </p>
<p>\2. 演示fastjson将java对象转换成json数据：</p>
<p>String  json=JSONObject.toJsonString(java对象);</p>
<p>问题1:将java对象转换成json时，名称是否可以自己来指定?</p>
<p>用注解@JSONField(name=”xxx”)，下面那个属性的名字就会变成xxx</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps67.jpg" alt="img"> </p>
<p>问题2:如果java对象中存在日期类型属性java.util.Date,是否可以用指定的格式来转换成json</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps68.jpg" alt="img"> </p>
<p>问题3:如果java类中的某些属性不想生成json中</p>
<p>String  json=JSONObject.toJsonString(java对象，fiter); 添加一个过滤器</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps69.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps70.jpg" alt="img"> </p>
<p>问题4:关于fastjson将java对象转换成json时的循环引用问题</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps71.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps72.jpg" alt="img"> </p>
<p>这里的后面重复元素会显示为引用，但我们不想这样，所以可以通过以下设置可以取消循环引用</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps73.jpg" alt="img"> </p>
<p>jQuery ajax开发基于xml(了解)</p>
<p>XStream介绍：可以使用XStream工具来完成xml与java对象之间的转换。它也可以完成java对象与json之间的转换</p>
<p>XStream使用时需要导入的jar包：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps74.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps75.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps76.jpg" alt="img"> </p>
<p>XStream怎样将java对象转换成xml：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps77.jpg" alt="img"> </p>
<p>XStream相关的常用方法</p>
<p>1.设置别名（在转换前设置，在new后设置）</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps78.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps79.jpg" alt="img"> </p>
<p>2.忽略属性（在转换前设置，在new后设置）</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps80.jpg" alt="img"> </p>
<p>3.将类的属性设置成xml中字段的属性</p>
<p>​    <img src="/9.5.WEB%E4%B9%8BJQuery/wps81.jpg" alt="img"></p>
<p>上述的操作都可以用注解使用</p>
<p>要想使用XStream的注解，必须开启注解扫描.（在转换前设置，在new后设置）</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps82.jpg" alt="img"> </p>
<p>在java类中的上面加注解</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps83.jpg" alt="img"> </p>
<h1 id="Ajax跨域问题"><a href="#Ajax跨域问题" class="headerlink" title="*Ajax跨域问题*"></a><em><strong>*Ajax跨域问题*</strong></em></h1><p>跨域它是不同的域名(服务器)之间的相互的资源的访问</p>
<p>当协议，域名，端口号任意一个不相同，它们就是不同的域。</p>
<p>正常情况下，因为浏览器安全问题，不同域的资源是不可以访问的</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps84.jpg" alt="img"> </p>
<p>跨域解决方案</p>
<p>什么情况下会使用到跨域？</p>
<p>一般情况是在自己的内部的工程中会出现跨域情况。</p>
<p>有三种解决方案:</p>
<p>1.代理方案 前端页面访问本地的服务器，本地服务器访问其它域的资源，它是服务器端的跨域问题解决。<br>2.jsonp JSONP(JSON with Padding)是<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/136475.htm">JSON</a>的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server2.example.com的服务器沟通，而 HTML 的<script> 元素是一个例外。利用 <script> 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。（其实就是利用script标签可以跨域的特性）</p>
<p>3.XHR2全称XMLHttpRequest Level2它是HTML5提供的方法，一般是在移动开发中使用</p>
<p>jQuery解决跨域操作</p>
<p>在jquery中我们可以使用$.ajax,$.getJSON,$.getScript来解跨域问题</p>
<p>1.$.ajax解决跨域问题</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps85.jpg" alt="img"> </p>
<p>关于json与jsonp格式的区别</p>
<p>Json格式 :[value1,value],{name:value}</p>
<p>Jsonp格式: callback(json)</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps86.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps87.jpg" alt="img"> </p>
<p>2.Jquery中如何使用jsonp完成跨域问题</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps88.jpg" alt="img"> </p>
<p>3.$.getJSON解决跨域问题</p>
<p>$.getJSON它就是$.ajax解决跨域问题的简化操作</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps89.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps90.jpg" alt="img"> </p>
<h1 id="jQuery-的分页操作"><a href="#jQuery-的分页操作" class="headerlink" title="*jQuery*****的分页操作****"></a><em><strong>*jQuery*</strong>***</em>*的分页操作****</h1><p>1.前端使用bootstrap的分页组件来完成数据分页显示。</p>
<p>2.服务器端使用javaee经典三层架构</p>
<p>3.使用c3p0连接池，dbutils来完成数据库操作。</p>
<p>分页的意义：因为数据量比较大，为了用户有更好的体验。一般情况下，数据在展示时都会进行分页操作</p>
<p>分页的种类：</p>
<p>1.物理分页 :使用数据库本身提供的分页操作来完成数据查询，查询到的就是当前页的信息。例如mysql可以使用limit  oracle数据库可以使用rownum来完成。这种方案的优点是性能比较好，但是它存在不通用问题。</p>
<p>2.逻辑分页 ：它是利用数据库的游标（absolute光标）来操作 （将数据库所有数据都查询出来，存储在内存中），性能比较低，但是它通用。</p>
<p>​    现在开发中一般使用的比较多的是物理分页</p>
<p>分页基本原理：分页实现可以使用ajax分页，也可以使用服务器端分页，它们原理是一样的，现在主要用ajax分页</p>
<p>Mysql中的limit如何完成分页数据查询操作：</p>
<p>Select * from 表名  limit num1,num2;</p>
<p>Num1代表的是从第几行开始查询，起始值是0</p>
<p>Num2代表的是要查询几条记录</p>
<p>例如查询第二页数据(每页显示5条)</p>
<p>Select * from product limit (页码-1)*每页条数,(每页条数);</p>
<p>完成分页操作必备条件:</p>
<p>\1. 页码pageNo  默认是1 会根据上一页，下一页，首页尾页选择变化，我们通过js来控制。</p>
<p>\2. 每页显示条数pageSize 人为设置。</p>
<p>\3. 总条数</p>
<p>\4. 总页数=总条数/每页显示条数 (在js中要取整)</p>
<p>5.封装的当前页的数据</p>
<p>JAVAEE三层架构</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps91.jpg" alt="img"> </p>
<p>采用三层架构优点:利于开发与复用 结构清晰，利用标准化</p>
<p>三层:</p>
<p>Web层：它主要包含的关于javaweb相关操作，例如request,response,session对象操作，它调用业务层来实现具体的功能。</p>
<p>业务层(service层):它主要是业务逻辑操作，它不包含web常用对象，它只是java代码。</p>
<p>数据访问层(dao层):它主要是与数据库进行交互，完成crud操作。</p>
<p>缺点:开发难度加大，性能得到一定的消耗（调用时候）</p>
<p>Bootstrap分布组件使用介绍</p>
<p>注意：在使用bootstrap的分页组件时，需要导入相关的css文件与js文件，并且bootstrap它依赖于jquery,在导入bootstrap的js文件前要导入jquery的js文件，并且它的版本要求必须是1.9.1以上版本</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps92.jpg" alt="img"> </p>
<p>（css、jQuery、js文件）</p>
<p>查bootstrap的相关代码复制修改一些参数就可以实现效果</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps93.jpg" alt="img"> </p>
<p>代码实现：</p>
<p>创建工程</p>
<p>1.完成前期准备工作：</p>
<p>相关的jar包的导入：C3p0连接池jar 、Dbutils、json处理的相关jar包、mysql的驱动jar</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps94.jpg" alt="img"> </p>
<p>创建服务器端的结构：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps95.jpg" alt="img"> </p>
<p>创建实体类Product在domain包下：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps96.jpg" alt="img">get、set方法</p>
<p>需要c3p0连接池：在src下配置C3p0的配置文件.properties。我们创建一个JdbcUtils 工具类在util包下，在使用dbutils的QueryRunner时需要Connection对象或DataSource对象</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps97.jpg" alt="img"> </p>
<p>2.完成所有产品的查询操作</p>
<p>创建产品页面，向服务器发送请求（获取所有产品信息）</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps98.jpg" alt="img"> </p>
<p>在web层下创建一个ProductServlet来接收请求，获取所有的产品信息。配置信息的名字为/product</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps99.jpg" alt="img"> </p>
<p>在Service（业务）层下创建业务层ProductService（实际开发中代码很繁杂）</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps100.jpg" alt="img"> </p>
<p>创建DAO持久化层ProductDAO</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps101.jpg" alt="img"> </p>
<p>3.完成产品的分页显示</p>
<p>在浏览器端提供pageNo与pageSize,将它们作为参数传递到服务器</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps102.jpg" alt="img"> </p>
<p>服务器来处理分页</p>
<p>Web：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps103.jpg" alt="img"> </p>
<p>Service：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps104.jpg" alt="img"> </p>
<p>Dao：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps105.jpg" alt="img"> </p>
<p>怎样在浏览器端展示分页条：在分页条中需要总页数据，也就是说，总页数我们需要在服务器端查询获得到，需要服务器端返回它。我们可以定义一个PageBean这样一个对象，在这个PageBean中我们封装分页需要的数据，将它在服务器端生成，服务器端就不需要直接返回List<Product>,.面是返回一个PageBean的json数据</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps106.jpg" alt="img">get、set方法</p>
<p>我们可以在service中来对PageBean进行数据封装，servlet最终是将PageBean转换成json响应到浏览器</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps107.jpg" alt="img"> </p>
<p>响应到浏览器的json数据</p>
<p>{“content”:[{“count”:100,”id”:1,”name”:”电视机”,”price”:2000},{“count”:200,”id”:2,”name”:”洗衣机”,”price”:1000},{“count”:300,”id”:3,”name”:”空调”,”price”:3000},{“count”:50,”id”:4,”name”:”投影仪”,”price”:2000},{“count”:100,”id”:5,”name”:”HP电脑”,”price”:4000}],”pageNo”:1,”pageSize”:5,”totalCount”:11,”totalPage”:3}</p>
<p>在浏览器端展示分页信息：</p>
<p>关于数据展示：</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps108.jpg" alt="img"> </p>
<p>pageNo=json.pageNo；</p>
<p>pageSize=json.pageSize；</p>
<p>totalCount=json.totalCount；</p>
<p>totalPage=json.totalPage；</p>
<p>也可以设置一个css的style样式</p>
<p>关于分页条码：</p>
<p>它是一个动态生成的数据，我们需要拼接html代码来完成</p>
<p>a.处理当前页高亮显示</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps109.jpg" alt="img"> </p>
<p>b.点击页码，可以跳转到指定的页</p>
<p>将跳转的页码代码进行抽取成一个带页码参数的方法，然后$(function(){这个方法})；</p>
<p>会出现问题，进行修复操作:</p>
<p>​    1.在真正生成数据与分页条前将数据清空并恢复成原始状态</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps110.jpg" alt="img"> </p>
<p>2.处理参数pageNum，将pageNo，pageSize，totalCount，totalPage设置为全局变量</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps111.jpg" alt="img"> </p>
<p>c.处理上一页操作</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps112.jpg" alt="img"> </p>
<p>d.处理下一页操作</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps113.jpg" alt="img"> </p>
<h1 id="jQuery扩展-了解"><a href="#jQuery扩展-了解" class="headerlink" title="*jQuery扩展(了解)*"></a><em><strong>*jQuery扩展(了解)*</strong></em></h1><p>1.serialize与serializeArray</p>
<p>serialize:它的作用是将表单的数据序列化（用的比较多）</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps114.jpg" alt="img"> </p>
<p>serializeArray:将表单序列化，返回的是json数据格式（需要进行处理才能得到我们想要的格式）</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps115.jpg" alt="img"> </p>
<p>2.插件机制与自定义插件</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps116.jpg" alt="img"> </p>
<p>在开发中使用jquery,除了它本身提供的API,我们更多的还会使用jquery的插件。例如jquery easyui….</p>
<p>2.1 jQuery.extend();</p>
<p>上面这个是扩展jquery全局对象本身  $.post  $.ajax  $.get</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps117.jpg" alt="img"> </p>
<p>2.2 jQuery.fn.extend();</p>
<p>这个是扩展jquery元素集（对象）  $(“#f”).find()  $(“abc”).val()</p>
<p>通过创建一个插件完成表单数据转换成json操作</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps118.jpg" alt="img"> </p>
<p>如果表单中出现一个名称对应多个值的元素，会出现后面的会把前面的覆盖掉，怎样处理?</p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps119.jpg" alt="img"> </p>
<p><img src="/9.5.WEB%E4%B9%8BJQuery/wps120.jpg" alt="img"> </p>
<p>在js逻辑运算中，0、”“、null、false、undefined、NaN都会判为false，其他都为true</p>
<p>只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。</p>
<p>只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。</p>
<p>只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值</p>
<p>只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.5.WEB%E4%B9%8BJQuery/" data-id="ckno8ff6a004iswwdd60404w4" data-title="WEB之JQuery" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9.4.WEB之JSP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.4.WEB%E4%B9%8BJSP/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:29:46.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.4.WEB%E4%B9%8BJSP/">WEB之JSP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JSP：Java Server Pages (Java服务器端页面)，其实就在HTML中嵌入Java代码。</p>
<p>JSP将Java代码和特定变动内容嵌入到静态的页面中，实现以静态页面为模板，动态生成其中的部分内容。JSP引入了被称为“JSP动作”的XML标签，用来调用内建功能。另外，可以创建JSP标签库，然后像使用标准HTML或XML标签一样使用它们。标签库能增强功能和服务器性能，而且不受<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台</a>问题的限制。JSP文件在运行时会被其编译器转换成更原始的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Servlet">Servlet</a>代码。JSP编译器可以把JSP文件编译成用Java代码写的Servlet，然后再由Java编译器来编译成能快速执行的二进制<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E7%A0%81">机器码</a>，也可以直接编译成二进制码。</p>
<p>SUN公司提供了动态网页开发技术：Servlet。Servlet技术生成动态网页的时候很麻烦，需要通过response获得输出流，调用print方法进行打印的。这种编程方式很麻烦，而且美工也不容易处理，SUN公司发现了这些问题，推出了一个新的动态网页开发技术JSP。</p>
<p>缺点：Servlet需要进行配置，不方便维护；Servlet很难向网页中输出HTML页面内容</p>
<p>JSP的简单使用：</p>
<p>创建一个web项目，2.5版本，finish。在WebContent下新建一个包，新建一个JSPfile。将其中的编码改为UTF-8</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps1.jpg" alt="img"> </p>
<p>JSP需要发布到服务器中才可以运行：</p>
<p>在services中添加这个web项目，finish。启动服务器。浏览器输入访问。</p>
<p>运行原理：JSP文件翻译成Java文件，将这个Java文件编译生成class文件，运行class文件。JSP在执行时，会被服务器翻译为Servlet编译执行，JSP就是一个Servlet。</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps2.jpg" alt="img"> </p>
<p>JSP = HTML + Java代码 + JSP自身东西</p>
<p>JSP的脚本元素就是在JSP中嵌入Java代码。</p>
<p>分类：</p>
<p>1.声明标签：写在这个脚本中的代码，翻译成Servlet内部的成员变量或成员方法（JSP声明 翻译成 Servlet成员部分的内容。声明变量，方法，内部类）</p>
<p>语法：&lt;%! 变量或方法声明 %&gt;</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps3.jpg" alt="img"> </p>
<p>2.表达式标签：写在这个脚本中的代码，翻译成方法内部的out.print();当中的内容（翻译out.print(),在service方法内部。用于生成HTML页面源码）</p>
<p>语法：&lt;%= 表达式 %&gt;</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps4.jpg" alt="img"> </p>
<p>3.程序代码标签：写在这个脚本中的代码，翻译成方法内部的局部变量或方法内部代码片段（嵌入Java代码 翻译成service方法内部的代码块。声明变量，内部类）</p>
<p>语法：&lt;% 程序代码 %&gt;</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps5.jpg" alt="img"> </p>
<p>因为Servlet被认为是线程不安全的，所以用声明标签来定义局部变量不合适，一般都会用程序代码标签来定义变量。</p>
<p>JSP的开发模式：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps6.jpg" alt="img"> </p>
<p>以后开发一般都用MVC开发模式</p>
<p>开发中的路径问题：</p>
<p>提供一些页面，在页面中会提供链接或者表单，当点击链接或者表单的时候需要进行提交，提交到Servlet中。从页面向Servlet发送请求的地址（路径）应该如何编写。</p>
<p>路径的分类：</p>
<p>1.相对路径：相对路径不是以 / 开头的</p>
<p>比如：</p>
<p>在根路径下的页面访问Servlet：</p>
<p>假如demo2.jsp的访问路径：<a target="_blank" rel="noopener" href="http://localhost:8080/web02/demo2.jsp">http://localhost:8080/web02/demo2.jsp</a></p>
<p>ServletDemo1的访问路径：<a target="_blank" rel="noopener" href="http://localhost:8080/web02/ServletDemo1">http://localhost:8080/web02/ServletDemo1</a></p>
<p>则：<img src="/9.4.WEB%E4%B9%8BJSP/wps7.jpg" alt="img"></p>
<p>加不加./都可以</p>
<p>在某个目录下的页面访问Servlet：</p>
<p>假如demo2.jsp的访问路径：<a target="_blank" rel="noopener" href="http://localhost:8080/web02/demo2/demo2.jsp">http://localhost:8080/web02/demo2/demo2.jsp</a></p>
<p>ServletDemo1的访问路径：<a target="_blank" rel="noopener" href="http://localhost:8080/web02/ServletDemo1">http://localhost:8080/web02/ServletDemo1</a></p>
<p>则：<img src="/9.4.WEB%E4%B9%8BJSP/wps8.jpg" alt="img"></p>
<p>需要先返回上一级再去访问</p>
<p>2.绝对路径（通常用这个）：通常以 / 开始的路径</p>
<p><em><strong>*使用绝对路径，不需要关心当前文件和要请求的文件的相对位置的关系*</strong></em></p>
<p><em><strong>*绝对路径分成服务器端路径和客户端路径*</strong>***</em>*：****</p>
<p><em><strong>*客户端路径  需要带工程名*</strong></em></p>
<p><em><strong>*服务器端路径 不需要带工程名*</strong></em></p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps9.jpg" alt="img"> </p>
<p>这个例子的工程名是web02</p>
<p>JSP的模板修改JSP的字符集编码：在window下的Preferences中找到jsp</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps10.jpg" alt="img"> </p>
<p>JSP的注释：</p>
<p>1.HTML的注释：</p>
<p>写法：<!--HTML的注释 --></p>
<p>存在时机：存在JSP的源码中，翻译成Servlet后这个注释也存在，在生成HTML响应到页面的时候这个注释也会存在。</p>
<p>2.JAVA代码的注释：</p>
<p>写法：&lt;% // 单行注释 </p>
<p>/* 多行注释 */ </p>
<p>/*<em>文档注释</em>/</p>
<p> %&gt;</p>
<p>存在时机：存在JSP的源码中，翻译成Servlet后Java代码的注释也会存在，但是生成HTML响应到页面后，这种注释就消失了。</p>
<p>3.JSP自身的注释：</p>
<p>写法：&lt;%– JSP的注释 –%&gt;</p>
<p>存在时机：存在JSP的源码中，翻译Servlet后注释就没有了。</p>
<p>注意：HTML的注释只能注释一些元素，不能注释java代码</p>
<h1 id="JSP的指令元素"><a href="#JSP的指令元素" class="headerlink" title="*JSP的指令元素*"></a><em><strong>*JSP的指令元素*</strong></em></h1><p>作用：用于指示JSP执行的某些步骤；用于指示JSP变现特定行为</p>
<p>语法：&lt;%@ 指令名称 属性名称=属性的值 属性名称=属性的值 %&gt;</p>
<p>分类：page指令：指示JSP的页面设置属性和行为</p>
<p>include指令：指示JSP包含哪些其他页面</p>
<p>taglib指令：指示JSP页面包含哪些标签库</p>
<p>page指令：</p>
<p>写法：&lt;%@ page 属性名=属性值 属性名=属性值 属性名=属性值 %&gt;</p>
<p>Page指令用来定义JSP文件的全局属性。</p>
<p>这些属性可以单独使用，也可以几个或多个同时使用。</p>
<p>在JSP页面中，只有import属性可以出现多次，其他属性都只能出现一次。</p>
<p>language属性：声明使用脚本的语言。只能是java。</p>
<p>extends属性：标明JSP编译成Servlet的时候继承的类。默认值：HttpJspBase。</p>
<p>session属性：标明JSP中是否可以直接使用session对象。默认值是true。</p>
<p>buffer属性：标明JSP对客户端输出缓冲区大小。默认值8kb。</p>
<p>autoFlush属性：如果缓冲区大小溢出，是否自动刷出。默认true。</p>
<p><em><strong>*import属性：用于导入Java包或类。*</strong>***</em>*（*<strong><strong><strong>*写完java代码后alt+/自动导入*</strong></strong></strong>*）****</p>
<p><em><strong>*contentType属性：标明JSP被浏览器解析和打开的时候采用的默认的字符集。*</strong></em></p>
<p><em><strong>*pageEncoding属性：JSP文件及JSP翻译后的Servlet保存到硬盘上采用字符集。*</strong></em></p>
<p>isErrorPage属性：处理JSP页面异常。默认为false，改为true后，可以&lt;%= exception.getMessage&gt;就可以输出异常信息</p>
<p>errorPage属性：处理JSP页面异常。(后面可以跟一个jsp的页面地址，当出现异常时，就可以跳转到)</p>
<p>isELIgnored属性：通知JSP是否忽略EL表达式。默认是false。改为true后，EL内的信息会直接输出，EL写进标签就会报错。</p>
<p>include指令：</p>
<p>写法：&lt;%@ include 属性名=属性值%&gt;</p>
<p>作用：在JSP页面中****静态包含****一个文件，同时由该JSP解析包含的文件内容。</p>
<p>file属性：指示JSP页面包含页面路径。</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps11.jpg" alt="img"> </p>
<p>注意：应该将被包含的页面的结构去掉（会有重复的HTML标签，被包含的去掉）。在被包含的页面中定义变量，在包含的页面中还可以使用。</p>
<p>taglib指令:</p>
<p>写法：&lt;%@ taglib 属性名=属性值%&gt;</p>
<p>作用：用于在JSP页面中引入标签库。</p>
<p>uri属性：引入的标签库的路径</p>
<p>prefix属性：引入标签库的别名（前缀）</p>
<p>JSP的内置对象：指的是可以直接在JSP页面中使用的对象。</p>
<p>JSP当中有9大内置对象（具体类型）：</p>
<p>l request（HttpServletRequest）：从客户端向服务器发送的请求对象</p>
<p>l response    （HttpServletResponse）：从服务器端向客户端作出响应对象</p>
<p>l session    （HttpSession）：服务器为客户端创建会话对象</p>
<p>l application（ServletContext）：代表应用。获得的ServletContext对象。</p>
<p>l out    （JspWriter）：向输出流写入内容的对象。</p>
<p>l page（Object）：当前的JSP翻译成Servlet后的对象的引用。</p>
<p>l pageContext    （PageContext）：本JSP的页面的上下文对象。</p>
<p>l config（ServletConfig）：本JSP的ServletConfig对象。</p>
<p>l exception（Throwable）：表示JSP页面运行时产生的异常对象。</p>
<p>pageContext对象：pageContext对象直接翻译为“页面上下文”对象，代表的是当前页面运行的一些属性。</p>
<p>它是javax.servlet.jsp.PageContext类的实例对象。</p>
<p>1.提供了page范围的数据存取的方法：</p>
<p>向page范围中存入数据：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps12.jpg" alt="img"> </p>
<p>从page范围获取数据</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps13.jpg" alt="img"> </p>
<p>从page范围移除数据</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps14.jpg" alt="img"> </p>
<p>查找属性的方法：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps15.jpg" alt="img"> </p>
<p>2.通过这个对象获得其他的8个内置对象：</p>
<p>获得其他8个内置对象的方法</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps16.jpg" alt="img"> </p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps17.jpg" alt="img"> </p>
<p>JSP的四个作用范围</p>
<p>PageScope：页面范围。</p>
<p>页面范围指的是在当前的页面内有效，出了这个页面，用pageContext保存的数据就无效了。</p>
<p>RequestScope：请求范围。</p>
<p>从客户端向服务器发送一次请求，服务器对这次请求作出了响应之后，用request保存的数据就无效了。</p>
<p>SessionScope：会话范围。</p>
<p>每个浏览器向服务器发送请求（多次请求）。将该会话结束，用session保存的数据就无效了。</p>
<p>ApplicationScope：应用范围。</p>
<p>在整个应用中任意的地方都可以获取。用application保存。</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps18.jpg" alt="img"> </p>
<p>调取的时候使用重载方法：</p>
<p>pageContext.getAttribute(“name”,PageContext.SESSION_SCOPE)</p>
<p>findAttribute方法：查找属性方法，先根据小范围的名称进行查找，如果找到了就返回，如果没有找到就会去比其大一个域的范围进行查找。（page–request–session–application）</p>
<p>JSP的动作标签：用于在JSP页面中提供业务逻辑功能，避免在JSP页面中直接编写Java代码（会有大量的&lt;%  &gt;），造成jsp页面难以维护。</p>
<p>常用的动作标签：</p>
<p><em><strong>*&lt;jsp:forward**** ****page=“”********&gt;*</strong></em> <em><strong>*&lt;********/********jsp:forward********&gt;*</strong></em>    <em><strong>*：请求转发。*</strong></em></p>
<p><em><strong>*&lt;jsp:include**** ****page=********””********&gt;*</strong></em> <em><strong>*&lt;/********jsp:include********&gt;*</strong>***</em>*：包含（*<strong><strong><strong>*是一种*</strong></strong></strong>*动态包含）。****</p>
<p>&lt;jsp:param value=“” name=“” /&gt;：传递参数。（很少使用，因为可以用set/getAttribute来设置获取参数）</p>
<p>动态包含的原理：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps19.jpg" alt="img"> </p>
<p>查看Tomcat的work下的localhost下的项目下会找到被包含的jsp都被编译成了java和clss文件。</p>
<h1 id="EL"><a href="#EL" class="headerlink" title="*EL*"></a><em><strong>*EL*</strong></em></h1><p>EL（Expression Language） 是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。</p>
<p>EL：Expression Language表达式语言。</p>
<p>EL和JSTL一起使用取代JSP页面中嵌入Java代码写法。（去掉&lt;&gt;和%）</p>
<p>EL的语法：${ EL表达式 }</p>
<p>EL的功能：</p>
<p><em><strong>*1.*</strong>***</em>*EL获取数据*<strong><strong><strong>*（*</strong></strong></strong>*域对象中****<em><strong>*）*</strong></em></p>
<p>EL表达式语句在执行的时候，会调用pageContext.findAttribute()方法。分别从page、request、session、application范围查找相应对象，找到就会返回相应对象，找不到返回””(不是null，是空的字符串)。EL所获取的数据需要在四个作用范围中。</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps20.jpg" alt="img"> </p>
<p>这两种方式的区别：如果没有存入数据，前者获取输出的是null，后者输出的是“”。直接写${name}会先从最小范围查找，找不到的话会向上一级域查找（其实相当于调用了pageContext.findAttribute()方法）。</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps21.jpg" alt="img"> </p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps22.jpg" alt="img"> </p>
<p>（需要引包：alt+/）</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps23.jpg" alt="img"> </p>
<p>如果map的key中包含了特殊字符，不能使用.必须使用[]。</p>
<p>因为：  .用来获取对象的属性的  []用来获得下标</p>
<p>例如，包含特殊字符.</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps24.jpg" alt="img"> </p>
<p><em><strong>*2.*</strong>***</em>*EL执行运算****</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps25.jpg" alt="img"> </p>
<p>会自动类型转换，即使是字符串，也会转换成算数运算</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps26.jpg" alt="img"> </p>
<p>lt：less than   gt：great than   ne：not equal</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps27.jpg" alt="img"> </p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps28.jpg" alt="img"> </p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps29.jpg" alt="img"> </p>
<p>判断一个对象是否为空 也可以${not empty user}</p>
<p>不支持位运算</p>
<p><em><strong>*3.*</strong>***</em>*EL获取web开发常用的对象****</p>
<p>EL表达式定义了11个web开发常用对象。使用这些对象可以很方便获取web开发中的一些常见对象，并可以读取这些对象中的数据。</p>
<p><em><strong>*pageContext*</strong></em>    ：相当于JSP内置对象中pageContext（可以通过这个获取其他八个对象）</p>
<p>pageScope：获取指定域下的名称的数据</p>
<p>requestScope：获取指定域下的名称的数据</p>
<p>sessionScope：获取指定域下的名称的数据</p>
<p>applicationScope    ：获取指定域下的名称的数据</p>
<p>param：在页面中接收请求参数（接收一个名称对应一个值参数）。相当于requset.getParam</p>
<p>paramValues    ：在页面中接收请求参数（接收一个名称对应多个值参数）。</p>
<p>header：在页面上获取请求头（获取一个key对应一个value 头）</p>
<p>headerValues：在页面上获取请求头（获取一个key对应多个value 头）</p>
<p>cookie：访问cookie的名称和值（${cookie.key.name} ${cookie.key.value}）</p>
<p>initParam：获取全局初始化参数的值</p>
<p>4.EL调用Java方法（基本不用）</p>
<h1 id="JSTL"><a href="#JSTL" class="headerlink" title="*JSTL*"></a><em><strong>*JSTL*</strong></em></h1><p>JSTL（Java server pages standarded tag library，即JSP标准标签库）是由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JCP/2679009">JCP</a>（Java community Proces）所制定的标准规范，它主要提供给Java Web开发人员一个标准通用的标签库，并由Apache的Jakarta小组来维护。开发人员可以利用这些标签取代JSP页面上的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Java/85979">Java</a>代码，从而提高程序的可读性，降低程序的维护难度。</p>
<p>JSTL：JSP的标准标签库。</p>
<p>JSTL主要是和EL来取代传统页面上直接嵌入Java代码写法。提升程序可读性、维护性和方便性。</p>
<p>版本：JSTL1.0、JSTL1.1和JSTL1.2版本</p>
<p>1.0版本不支持EL表达式。<em><strong>*1.1和1.2支持了EL表达式。*</strong></em></p>
<p>标签库：</p>
<p><em><strong>*c标签（core标签库*</strong>***</em>*，*<strong><strong><strong>*核心标签库*</strong></strong></strong>*）****</p>
<p>fmt标签（国际化标签库）</p>
<p>xml标签（后台编写，前台标签不怎么用）</p>
<p>sql标签（后台编写，前台标签不怎么用）</p>
<p><em><strong>*jstl函数库（EL函数）*</strong></em></p>
<p>使用：先导入JSTL的jar包到lib中</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps30.jpg" alt="img"> </p>
<p>新建一个jsp页面：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps31.jpg" alt="img"> </p>
<p>在上面导入标签库：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps32.jpg" alt="img"> </p>
<p>可以直接使用：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps33.jpg" alt="img"> </p>
<p>value相当于是值，var相当于是name，scope是域对象的范围</p>
<p>JSTL有很多标签，可以查看文档使用，用的较多的是：</p>
<p>JSTL的if标签使用：只有if没有else</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps34.jpg" alt="img"> </p>
<p>test属性：条件</p>
<p>var属性：将test中的条件的值赋给一个变量，在var中定义变量</p>
<p>scope属性：作用范围</p>
<p>&lt;c:if  var=”flag” test=”${ i&lt;10 }” scope =”page”&gt;  </c:if> </p>
<p>后面可以直接使用flag  </p>
<p>&lt;c:if  test=”${flag }” &gt;  </c:if></p>
<p>JSTL的forEach标签使用：</p>
<p><img src="/9.4.WEB%E4%B9%8BJSP/wps35.jpg" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.4.WEB%E4%B9%8BJSP/" data-id="ckno8ff5l002yswwdfe4udkft" data-title="WEB之JSP" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9.3.WEB之servlet" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.3.WEB%E4%B9%8Bservlet/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:29:35.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.3.WEB%E4%B9%8Bservlet/">WEB之servlet</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>动态网页的开发：Servlet和JSP</p>
<p>Servlet其实就一个运行在web服务器上的小的Java程序，用于处理从web客户端发送的请求，并且对请求作出响应。</p>
<p>静态页面不能写循环，判断，SQL等语句。而Servlet就可以写。</p>
<p>使用Servlet：编写一个Java类实现Servlet的接口；配置Servlet</p>
<p>相关内容可以查JAVAEE的API中的Servlet</p>
<p>1.创建一个项目，在<img src="/9.3.WEB%E4%B9%8Bservlet/wps1.jpg" alt="img">中建包建类</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps2.jpg" alt="img"> </p>
<p>其他方法保持不变</p>
<p>2.配置这个类，在WEB-INF下的web.xml中配置</p>
<p>双击类名，右击copy全路径</p>
<p>前后的servlet-name必须要一致</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps3.jpg" alt="img"> </p>
<p>启动服务器，打开浏览器：<a target="_blank" rel="noopener" href="http://localhost:8080/web_test/hello">http://localhost:8080/web_test/hello</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/web_test/+%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84">http://localhost:8080/web_test/+访问路径</a></p>
<p>执行流程：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps4.jpg" alt="img"> </p>
<p>Servlet的实现关系：</p>
<p>Servlet接口            </p>
<p>​    |</p>
<p>​    |</p>
<p>GenericServlet类        通用的Servlet，是一个与协议无关的Servlet</p>
<p>​    |</p>
<p>​    |</p>
<p>HttpServlet类            Http专用的Servlet</p>
<p>SUN设计之初，是有野心，以后的互联网不仅仅只使用http协议，其他协议就可以通过GenericServlet实现。HttpServlet是一个与协议相关的Servlet是专门用来处理HTTP协议的请求。通常编写一个Servlet一般都会让这个Servlet<em><strong>*继承HttpServlet重写service方法*</strong>***</em>*（*<strong><strong><strong>*不用再实现Servlet接口，因为会有很多用不到的方法也要重写*</strong></strong></strong>*）****<em><strong>*。*</strong></em></p>
<p><em><strong>*查看源码可以知道，*</strong>***</em>*在service方法内部根据请求方式不同执行不同的doXXX的方法（get请求执行doGet方法，如果是post请求就会执行doPost方法）。****</p>
<p><em><strong>*所以*</strong>***</em>*一般*<strong><strong><strong>*继承了HttpServlet之后不需要重写service方法，只需要重写doGet和doPost方法即可。往往请求要处理的内容的代码都是一致的，所以需要让doGet和doPost相互调用可以简化编程*</strong></strong></strong>*（*<strong><strong><strong>*编码一次，另一个方法调用这个方法即可*</strong></strong></strong>*）****<em><strong>*。*</strong></em></p>
<p>Eclipse中使用Servlet模版：（不用在web.xml中修改完成配置，这样是自动完成了Servlet的配置）</p>
<p>右击new的时候选择新建Servlet；输入name（默认继承了HttpServlet）后，点击next；对Servlet进行配置：name和前面一致（一般不用改），URL mapping就是访问名字（右边edit可以修改），点击next；构造方法可以不用选，重写方法选择doGet和doPost方法。点击finish</p>
<p>生命周期：一个对象从创建到销毁过程</p>
<p>Servlet生命周期：Servlet对象从创建到销毁的过程</p>
<p>Servlet中有****init,service,destroy****方法，这几个方法称为是Servlet生命周期相关的方法</p>
<p>Servlet是在第一次被访问的时候会被实例化，只要Servlet一被实例化那么Servlet中的init方法就会执行（init只会执行一次，Servlet是单例的）。</p>
<p>任何一次从客户端发送来的请求，那么Servlet中的service方法就会执行（在service方法的内部根据请求的方式不同调用不同doXXX方法）。</p>
<p>当Servlet从服务器中移除或者服务器关闭的时候Servlet对象被销毁，里面的destroy方法就会执行，然后垃圾回收就会将其回收掉（在servers下点红色方框关闭服务器，在控制台下的红色方框是强制退出，不是服务器）</p>
<p>Servlet的启动时加载：Servlet对象是第一次被访问的时候会被创建的，init方法就会执行。假设在init方法中做了一些比较耗时的操作（比如：加载了一些配置文件并且解析可能需要花费3秒钟）。第一个用户第一次访问这个Servlet的时候，需要等待3秒钟，这样会使体验感很差，所以要改为启动时加载。</p>
<p>Servlet默认是在第一次访问的时候创建的对象，现在通过一个配置将Servlet的实例化的过程放在服务器启动的时候（****让服务器启动的时候创建Servlet的对象****）。如果现在这样做那么之前花费的时间就会在服务器启动的时候一起花费掉了。对于用户来讲就不需要额外花费这个时间。</p>
<p>在web.xml中配置。值越小，优先级越高。有一个默认的Servlet启动优先级为1，所以配置的最高为2。（可以在Tomcat的conf下的web.xml中查看文档）</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps5.jpg" alt="img"> </p>
<p>Servlet的访问路径的配置：<url-pattern>的配置方式</p>
<p>1.完全路径匹配：以 / 开始   比如：/ServletDemo1    /aaa/ServletDemo2</p>
<p>2.目录匹配：以 / 开始，以 /<em>结束  比如：/</em>    /aaa/*    /aaa/bbb/*</p>
<p>3.扩展名匹配：不能以 / 开始，以<em>开始        比如：</em>.action    *.do    *.jsp</p>
<p>（*代表的是任意字符）</p>
<p>访问的优先级：完全路径匹配  &gt;  目录匹配  &gt;  扩展名匹配</p>
<p>如果输入的三个都匹配，比如：/aaa/ServletDemo2.do  实际会先进行完全路径的匹配，再进行目录匹配，最后是扩展名匹配。</p>
<p>ServletConfig对象：</p>
<p>ServletConfig用来获得Servlet的相关的配置的对象。（init方法中可以传递这个对象）</p>
<p>获得ServletConfig对象：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps6.jpg" alt="img"> </p>
<p>ServletConfig对象的API：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps7.jpg" alt="img"> </p>
<p>获得Servlet的初始化参数（值和名字） <param-name><param-value></p>
<p>获得ServletContext对象</p>
<p>获得Servlet的名称<servlet-name></servlet-name></p>
<p>配置初始化参数的例子：在web.xml中添加配置：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps8.jpg" alt="img"> </p>
<p>实现：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps9.jpg" alt="img"> </p>
<p>ServletContext对象：</p>
<p>ServletContext：Servlet的上下文对象。ServletContext对象对Servlet之前和之后的内容都知道。这个对象一个web项目只有一个。在服务器启动的时候为每个web项目创建一个单独的ServletContext对象。</p>
<p>作用：</p>
<p>1.用来获取web项目信息：因为一个web项目只有一个ServletContext对象，所以这个对象对整个项目的相关内容都是了解的</p>
<p>获取文件的MIME类型：文件上传和下载的时候会用到这个方法（这些类型都可以在conf下的web.xml中找到）</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps10.jpg" alt="img"> </p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps11.jpg" alt="img"> </p>
<p>获取web项目请求工程名：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps12.jpg" alt="img"> </p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps13.jpg" alt="img"> </p>
<p>获取web项目的初始化参数：全局的参数</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps14.jpg" alt="img"> </p>
<p>可以在前面配置全局的初始化参数（原来的局部配置参数是在Servlet标签内部配置的，现在配置全局的话在最前面配置）</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps15.jpg" alt="img"> </p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps16.jpg" alt="img"> </p>
<p>2.读取web项目下的文件：之前使用IO流就可以读取文件（java项目中）。现在是一个web项目，web项目需要发布到tomcat下才能访问的。获取web项目下的文件如果使用传统的IO就会出现问题（原因：路径中使用的是相对路径，相对的是JRE环境，是Tomcat的bin路径）。</p>
<p>使用getServletContext的getResourceAsStream方法或者getServletContext的getRealPath方法</p>
<p>以/开头的都是相对路径。</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps17.jpg" alt="img"> </p>
<p>3.作为域对象存取数据：</p>
<p>域对象：指的是将数据存入到域对象中，这个数据就会有一定的作用范围。域指的是一定的作用范围。</p>
<p>作为域对象的API：</p>
<p>存入数据的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps18.jpg" alt="img"> </p>
<p>获取数据的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps19.jpg" alt="img"> </p>
<p>移除数据的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps20.jpg" alt="img"> </p>
<p>作用范围：</p>
<p>ServletContext是在服务器启动的时候为每个web项目单独创建一个ServletContext对象。当web项目从服务器中移除，或者是关闭服务器的时候ServletContext对象会被销毁。向ServletContext中保存的数据一直存在（当服务器关闭的时候ServletContext对象被销毁，然后里面数据才会失效）。<em><strong>*范围：整个web应用。*</strong></em></p>
<p>例子：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps21.jpg" alt="img"> </p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps22.jpg" alt="img"> </p>
<p>在demo7中初始化的时候存入数据，发现访问demo7和8的时候都能访问到name的值，所以ServletContext的域对象是整个web应用。</p>
<p>开发的软件是B/S结构的软件，可以通过浏览器访问服务器的软件。</p>
<p>从浏览器输入一个地址访问服务器（将这个过程称为是请求：将浏览器向服务器发送的数据的封装）。服务器接收到请求，需要进行处理，处理以后需要将处理结果显示回浏览器端（将这个过程称为是响应：将服务器向浏览器发送数据的封装）。</p>
<p>Response对象：</p>
<p>Response关于响应行的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps23.jpg" alt="img"> </p>
<p>设置响应的状态码：</p>
<p>200 正确</p>
<p>302 重定向</p>
<p>304 查找本地缓存</p>
<p>404 请求资源不存在</p>
<p>500 服务器内部错误</p>
<p>Response关于响应头的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps24.jpg" alt="img"> </p>
<p>set开头的方法：针对一个key对应一个value的情况</p>
<p>举例：比如有一个头 </p>
<p>content-Type:text/html  setHeader(“content-Type”,”text/plain”);</p>
<p>最终得到头的结果：content-Type:text/plain</p>
<p>add开头的方法：针对一个key对应多个value的情况</p>
<p>举例：比如有一个</p>
<p>content-Type:text/html     addHeader(“content-Type”,”text/plain”);</p>
<p>最终得到头的结果：content-Type:text/html,text/plain</p>
<p>Response关于响应体的方法：</p>
<p>向页面输出内容：字节和字符</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps25.jpg" alt="img"> </p>
<p>Response其他的API：</p>
<p>重定向的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps26.jpg" alt="img"> </p>
<p>设置浏览器打开页面时候采用的字符集：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps27.jpg" alt="img"> </p>
<p>设置响应字符流的缓冲区字符集：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps28.jpg" alt="img"> </p>
<p>服务器向浏览器回写Cookie的方法：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps29.jpg" alt="img"> </p>
<p>// 一般由服务器向浏览器的方法都能在response中找到</p>
<p>完成重定向：302状态码和Location响应头结合使用的效果</p>
<p>Demo1跳转到了Demo2</p>
<p>也可以使用response.sendRedirect(“/web01/ResponseDemo2”);替换重定向两句写法（实际开发中常用）</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps30.jpg" alt="img"> </p>
<p>定时刷新效果：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps31.jpg" alt="img"> </p>
<p>在HTML中完成页面跳转：使用<meata>标签的http-quiv设置。url的路径在后面介绍</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps32.jpg" alt="img"> </p>
<p>这里的n秒后跳转的n是我们人为输入的定值，不能变化，所以我们可以用JS来完成读秒的效果：</p>
<p>需要n变化，先要对这个n加标签：<span id=”span1”>i</span>,再对<body></body>加方法onload=“load()”，然后编写scrip语句：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps33.jpg" alt="img"> </p>
<p>Response向页面响应中文（可能会出现乱码）</p>
<p>1.使用字节流响应中文</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps34.jpg" alt="img"> </p>
<p>这里的“中文”这两个字可能会产生乱码：因为这个乱码的产生与中文转成字节数组及浏览器打开方式（打开的时候采用的默认字符集）有关</p>
<p>解决办法：将中文转成字节数组的时候和浏览器默认打开的时候采用的字符集一致即可</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps35.jpg" alt="img"> </p>
<p><em><strong>*2.使用字符流相应中文*</strong></em></p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps36.jpg" alt="img"> </p>
<p>这里一定会产生乱码：字符流是有缓冲区的，response获得字符流，response设计默认的缓冲区编码是ISO-8859-1。这个字符集不支持中文的。</p>
<p>解决办法：设置response获得字符流缓冲区的编码和设置浏览器默认打开时候采用的字符集一致即可</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps37.jpg" alt="img"> </p>
<p>字符流向页面响应中文，有一种简化的方式：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps38.jpg" alt="img"> </p>
<p>Request对象：开发的软件都是B/S结构软件，从浏览器向服务器提交一些数据，将这些内容进行封装就封装成了一个请求对象（Request对象）</p>
<p>1.获得客户机信息：</p>
<p>****获得请求的方式****：get还是post</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps39.jpg" alt="img"> </p>
<p>获得请求路径后的提交参数的字符串：？xx=xxx&amp;xxx=xxxxx</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps40.jpg" alt="img"> </p>
<p>获得请求路径的URL和URI：URI范围比URL大（URI，统一资源标识符。URL，统一资源定位符。URI包括URL和URN。URL是全写，URI是名字）</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps41.jpg" alt="img"> </p>
<p>****获得客户机的ip地址****：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps42.jpg" alt="img"> </p>
<p>2.获得请求头的方法：</p>
<p>获得一个key对应一个value的请求头：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps43.jpg" alt="img"> </p>
<p>获得一个key对应多个value的请求头：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps44.jpg" alt="img"> </p>
<p>3****.获得请求参数的方法****：</p>
<p>获得提交的参数（一个name对应一个value）：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps45.jpg" alt="img"> </p>
<p>获得提交的参数（一个name对应多个value）：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps46.jpg" alt="img"> </p>
<p>获得提交的参数，将提交的参数的名称和对应的值存入到一个Map集合中：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps47.jpg" alt="img"> </p>
<p>4.****作为域对象存取数据的方法****：</p>
<p>向request域中存数据：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps48.jpg" alt="img"> </p>
<p>从request域中获取数据：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps49.jpg" alt="img"> </p>
<p>从request域中移除数据：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps50.jpg" alt="img"> </p>
<p>Request对象其实就是从客户端浏览器向服务器发送的一次请求信息的封装。那么实质上向Request中所保存的数据有效期也是<em><strong>*一次请求范围。*</strong></em></p>
<p><em><strong>*一次请求范围：从客户端浏览器向服务器发送一次请求，服务器针对这次请求对浏览器作出响应。当服务器作出响应之后，请求对象就销毁了，保存在其中的数据就无效了。*</strong></em></p>
<p>代码演示：</p>
<p>Request对象获取客户机信息：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps51.jpg" alt="img"> </p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps52.jpg" alt="img"> </p>
<p>Request对象接收表单请求参数：</p>
<p>编写一个静态页面：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps53.jpg" alt="img"> </p>
<p>在RequestDemo2中接收参数：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps54.jpg" alt="img"> </p>
<p>（数组无法直接输出，需要调用Arrays.toString（）方法输出）</p>
<p>Request对象接收表单请求参数的中文乱码处理：</p>
<p>POST方式接收中文：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps55.jpg" alt="img"> </p>
<p>GET方式接收中文：(基本不用，因为一般表单提交都是用post方法)</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps56.jpg" alt="img"> </p>
<p>从Servlet向JSP中跳转的方法：请求转发和重定向</p>
<p>1.请求转发：</p>
<p>通过ServletRequest对象获得RequestDispatcher对象</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps57.jpg" alt="img"> </p>
<p>再根据RequestDispatcher中的方法进行请求转发</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps58.jpg" alt="img"> </p>
<p>代码实现：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps59.jpg" alt="img"> </p>
<p>请求转发后访问Servlet的页面：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps60.jpg" alt="img"> </p>
<p>重定向：</p>
<p>通过HttpServletResponse对象中的以下方法实现重定向</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps61.jpg" alt="img"> </p>
<p>代码实现：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps62.jpg" alt="img"> </p>
<p>重定向后访问Servlet的效果：</p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps63.jpg" alt="img"> </p>
<p>请求转发和重定向的区别：</p>
<p>请求转发是一次请求一次响应，而重定向是两次请求两次响应。</p>
<p>请求转发地址栏不会变化的，重定向地址栏发生变化。</p>
<p>请求转发路径不带工程名，重定向需要带工程名路径。</p>
<p>请求转发只能在本网站内部，重定向可以定向到任何网站。</p>
<p><em><strong>*如果需要使用request进行值传递，需要通过请求转发完成。如果页面需要跳转到其他网站上必须使用重定向。*</strong></em></p>
<p><img src="/9.3.WEB%E4%B9%8Bservlet/wps64.jpg" alt="img"> </p>
<p>因为request对象作为域对象的范围是一次请求，所以如果JSP需要获取request中的数据的话，只能用请求转发；如果用重定向的话，存入的值会获取不到，为null。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.3.WEB%E4%B9%8Bservlet/" data-id="ckno8ff5l002wswwdd0ei9nfj" data-title="WEB之servlet" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9.2.WEB之http协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:29:20.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/">WEB之http协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>HTTP协议：规定了浏览器和服务器端的数据交互的格式</p>
<p>http是一个简单的请求-响应协议，它通常运行在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/TCP/33012">TCP</a>之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。HTTP是应用层协议。</p>
<p>特性：</p>
<p>1.基于请求和响应模型：必须要先有请求，后有响应；请求和响应必须成对出现</p>
<p>2.简单快捷：因为发送请求的时候只需要发送请求方式和请求路径即可</p>
<p>版本：</p>
<p>HTTP1.0：该协议对每一次请求和相应进行一次建立连接和拆除（每进行一次请求建立连接，相应完毕后拆除连接）</p>
<p>HTTP1.1：该协议相当于TCP，双方规定了连接方式和连接类型，会一直进行请求相应</p>
<p>分析HTTP协议：</p>
<p>可以用HTTPWatch（只能在ie浏览器上使用），也可以用浏览器自带的查看HTTP协议的工具（F12就可进入）</p>
<p>创建一个html页面：</p>
<p>demo1.html</p>
<p><img src="/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/wps1.jpg" alt="img"> </p>
<p>method默认为get方式，可以手动修改为post方式</p>
<p>demo2.html</p>
<p><img src="/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/wps2.jpg" alt="img"> </p>
<p>在浏览器中输入<a target="_blank" rel="noopener" href="http://localhost:8080/web_set/demo1.html">http://localhost:8080/web_set/demo1.html</a></p>
<p>打开HTTPWatch工具，点击record。输入表单内容，提交。点击项目下的Stream查看：</p>
<p>GET方式的请求部分：</p>
<p>GET /web_test/demo2.html?name=aaa&amp;name=man HTTP/1.1</p>
<p>Accept: text/html, application/xhtml+xml, <em>/</em></p>
<p>X-HttpWatch-RID: 9561-10011</p>
<p>Referer: <a target="_blank" rel="noopener" href="http://localhost:8080/web_test/demo1.html">http://localhost:8080/web_test/demo1.html</a></p>
<p>Accept-Language: zh-CN</p>
<p>User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</p>
<p>Accept-Encoding: gzip, deflate</p>
<p>Host: localhost:8080</p>
<p>DNT: 1</p>
<p>Connection: Keep-Alive</p>
<p>POST请求：</p>
<p>POST /web_test/demo2.html HTTP/1.1</p>
<p>Accept: text/html, application/xhtml+xml, <em>/</em></p>
<p>X-HttpWatch-RID: 9561-10041</p>
<p>Referer: <a target="_blank" rel="noopener" href="http://localhost:8080/web_test/demo1.html">http://localhost:8080/web_test/demo1.html</a></p>
<p>Accept-Language: zh-CN</p>
<p>User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</p>
<p>Content-Type: application/x-www-form-urlencoded</p>
<p>Accept-Encoding: gzip, deflate</p>
<p>Host: localhost:8080</p>
<p>Content-Length: 19</p>
<p>DNT: 1</p>
<p>Connection: Keep-Alive</p>
<p>Cache-Control: no-cache</p>
<p>name=bbb&amp;name=woman</p>
<p>请求部分内容：3部分</p>
<p>请求行：</p>
<p>请求方式：有很多种，GET和POST最常见</p>
<p><em><strong>*GET：请求的参数会显示到地址栏。通常是有大小的限制。没有请求体*</strong></em></p>
<p><em><strong>*POST：请求的参数不会显示到地址栏（在请求体中）。POST没有大小的限制。有请求体（请求参数）。只有表单设置method=*</strong>***</em>*”*<strong><strong><strong>*post*</strong></strong></strong>*”****<em><strong>*才是post请求。*</strong></em></p>
<p>请求路径：一般都是固定的</p>
<p>协议版本：一般都是固定的</p>
<p>请求头:请求头的格式一般都是一个key对应一个value的，也有一个key对应多个value的情况</p>
<p>一些常见的请求头：</p>
<p>Referer    ：代表网页的来源。（防盗链）</p>
<p>User-Agent    ：获得客户端浏览器类型</p>
<p>请求体：只有POST请求方式才有请求体，而且请求体是POST方式请求参数</p>
<p>响应部分：</p>
<p>HTTP/1.1 200 OK</p>
<p>Server: Apache-Coyote/1.1</p>
<p>Accept-Ranges: bytes</p>
<p>ETag: W/“151-1484111223984”</p>
<p>Last-Modified: Wed, 11 Jan 2017 05:07:03 GMT</p>
<p>Content-Type: text/html</p>
<p>Content-Length: 151</p>
<p>Date: Wed, 11 Jan 2017 05:14:00 GMT</p>
<!DOCTYPE html>

<html>

<head>

<meta charset="UTF-8">

<title>Insert title here</title>

</head>

<body>

<h1>Success锛侊紒锛?/h1>

</body>

</html>

<p>响应部分的内容：3部分</p>
<p>响应行：</p>
<p>协议版本</p>
<p>状态码：</p>
<p><em><strong>*200*</strong></em>    <em><strong>*：代表响应成功*</strong></em></p>
<p><em><strong>*302*</strong></em>    <em><strong>*：需要进行重定向操作*</strong></em></p>
<p><em><strong>*304*</strong></em>    <em><strong>*：需要查找本地缓存*</strong></em></p>
<p><em><strong>*404*</strong></em>    <em><strong>*：请求资源不存在*</strong></em></p>
<p><em><strong>*405：请求的方式不对*</strong></em></p>
<p><em><strong>*500*</strong></em>    <em><strong>*：服务器内部错误*</strong></em></p>
<p>状态码描述</p>
<p>响应头:通常一个key对应一个value，也有一个key对应多个value</p>
<p>一些常见的响应头：</p>
<p>Location    ：重定向的路径</p>
<p>Refresh    ：定时刷新</p>
<p>Content-Disposition：文件下载的时候使用</p>
<p>响应体：就是显示到浏览器上页面的代码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.2.WEB%E4%B9%8Bhttp%E5%8D%8F%E8%AE%AE/" data-id="ckno8ff5k002tswwd9h44e77l" data-title="WEB之http协议" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9.1.WEB之概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/9.1.WEB%E4%B9%8B%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T06:29:06.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/9.1.WEB%E4%B9%8B%E6%A6%82%E8%BF%B0/">WEB之概述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>WEB</p>
<p>web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超链接将Internet上的信息节点组织成一个互为关联的网状结构。</p>
<p>javaWEB：使用Java语言进行WEB的开发。</p>
<p>软件架构：</p>
<p>CS架构的软件：Client/Server 客户端和服务器，这种软件往往需要安装。</p>
<p>优点：界面很美观；可以减轻服务器端压力，将部分代码写到客户端。</p>
<p>缺点：一旦服务器更新了，客户端也需要更新；分布式开发比较弱。</p>
<p>****BS架构的软件****：Browser/Server 浏览器和服务器，这种软件不需要安装，只需要通过浏览器就可以访问。</p>
<p>优点：服务器一旦更新，不需要更新客户端，因为客户端就是浏览器；比较强的分布式能力</p>
<p>缺点：界面效果不如CS结构软件（可以用前端技术美化）；服务器端压力会比较大(会搭一些集群减轻压力，也会用Ajax异步交互)</p>
<p>WEB服务器：</p>
<p>硬件：其实就是一台电脑（这台电脑配置要求很高）</p>
<p>软件：需要在这台电脑上安装web服务器的软件</p>
<p>常见的WEB服务器：</p>
<p>Tomcat        ：Apache组织提供的一个开源的免费的web服务器。满足EE的Servlet和JSP的规范。</p>
<p>WebSphere    ：IBM公司开发的一个收费的大型web服务器。满足了EE开发的所有规范。</p>
<p>WebLogic        ：BEA公司开发的一个收费的大型web服务器。满足了EE开发的所有规范。</p>
<p>IIS            ：应用在.NET平台上。</p>
<p>Apache        ：应用在PHP平台上。</p>
<p>WEB开发中的资源：</p>
<p>静态web资源：HTML   /   CSS   /   JS</p>
<p>动态web资源：Servlet、JSP  （java的） /  PHP  /  ASP</p>
<p><img src="/9.1.WEB%E4%B9%8B%E6%A6%82%E8%BF%B0/wps1.jpg" alt="img"> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/04/19/9.1.WEB%E4%B9%8B%E6%A6%82%E8%BF%B0/" data-id="ckno8ff5k002rswwdf84z2l85" data-title="WEB之概述" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E8%BF%B0/" rel="tag">概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%88%E6%9C%AC/" rel="tag">版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%84%E8%8C%83/" rel="tag">规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">概述</a> <a href="/tags/%E7%89%88%E6%9C%AC/" style="font-size: 10px;">版本</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E8%A7%84%E8%8C%83/" style="font-size: 10px;">规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/19/19.4.SVN/">SVN</a>
          </li>
        
          <li>
            <a href="/2021/04/19/9.9.WEB%E4%B9%8B%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/">WEB之上传和下载</a>
          </li>
        
          <li>
            <a href="/2021/04/19/9.8.WEB%E4%B9%8Blistener%E5%92%8Cfilter/">WEB之listener和filter</a>
          </li>
        
          <li>
            <a href="/2021/04/19/9.7.WEB%E4%B9%8Bcookie%E5%92%8Csession/">WEB之cookie和session</a>
          </li>
        
          <li>
            <a href="/2021/04/19/9.6.WEB%E4%B9%8Bajax/">WEB之ajax</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>