<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>swx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="swx">
<meta property="og:url" content="https://s-qwer.github.io/index.html">
<meta property="og:site_name" content="swx">
<meta property="og:description" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="swx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="swx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swx</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://s-qwer.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-8.7.vite" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/17/8.7.vite/" class="article-date">
  <time class="dt-published" datetime="2021-09-17T09:26:30.000Z" itemprop="datePublished">2021-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/17/8.7.vite/">vite</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>vite默认端口号为3000</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/09/17/8.7.vite/" data-id="ckw61sdvi002hoswd6hcjg8nc" data-title="vite" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vite/" rel="tag">vite</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-工具类代码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2021-09-03T02:44:26.000Z" itemprop="datePublished">2021-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="mybatis-plus的查询语句"><a href="#mybatis-plus的查询语句" class="headerlink" title="mybatis plus的查询语句"></a>mybatis plus的查询语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user &#x3D; userMapper.selectOne(new QueryWrapper &lt;User&gt;().lambda().eq(User::getId, id));</span><br></pre></td></tr></table></figure>



<h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new Date()    得到Date类型</span></span><br><span class="line">SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="comment">//设置日期格式</span></span><br><span class="line">System.out.println(df.format(<span class="keyword">new</span> Date()));<span class="comment">// new Date()为获取当前系统时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Calendar.getInstance().getTime()  得到Date类型</span></span><br><span class="line">SimpleDateFormat df= <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd &#x27;at&#x27; HH:mm:ss z&quot;</span>);</span><br><span class="line">Date date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">System.out.println(df.format(date));</span><br><span class="line">注：此方法会根据我们的系统时间返回当前值，因为世界各地的时区是不一样的</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.currentTimeMillis()   得到long类型</span></span><br><span class="line">Calendar calendar = Calendar.getInstance(); <span class="comment">// gets current instance of the calendar    </span></span><br><span class="line">SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;dd-MM-yyyy HH:mm:ss&quot;</span>); </span><br><span class="line">System.out.println(formatter.format(calendar.getTime()));</span><br><span class="line"></span><br><span class="line">java8之后</span><br><span class="line"><span class="comment">//LocalDate.now()     得到LocalDate类型 只有年月日，没有具体时间</span></span><br><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;dd-MM-yyyy&quot;</span>); </span><br><span class="line">System.out.println(date.format(formatter));</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalTime.now()  得到LocalTime类型，只有具体时间，没有年月日</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDateTime.now() 得到LocalDateTime类型。是Java中最常用的Date / Time类</span></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.now(); <span class="comment">// gets the current date and time</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;dd-MM-yyyy HH:mm:ss&quot;</span>); </span><br><span class="line">System.out.println(dateTime.format(formatter));</span><br><span class="line"></span><br><span class="line">hutool工具</span><br><span class="line"><span class="comment">//DateUtil.now() 得到String类型</span></span><br><span class="line">String time = DateUtil.now();</span><br></pre></td></tr></table></figure>

<h3 id="关于时间的转换"><a href="#关于时间的转换" class="headerlink" title="关于时间的转换"></a>关于时间的转换</h3><p>1、LocalDateTime可以做日期的加减很方便<br> 2、OffsetDateTime计算00:00:00及23:59:59很方便</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Date转LocalDateTime</span></span><br><span class="line">		<span class="comment">// 方法一</span></span><br><span class="line">        LocalDateTime localDateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">        <span class="comment">// 方法二</span></span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());</span><br><span class="line">        </span><br><span class="line"><span class="comment">//LocalDateTime转Date</span></span><br><span class="line">		<span class="keyword">return</span> Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间字符串String转LocalDateTime</span></span><br><span class="line">		<span class="keyword">return</span> LocalDateTime.parse(dateStr, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Date转OffsetDateTime</span></span><br><span class="line">		<span class="comment">// 方法一</span></span><br><span class="line">        OffsetDateTime offsetDateTime = date.toInstant().atZone(ZoneId.systemDefault()).toOffsetDateTime();</span><br><span class="line">        <span class="comment">// 方法二</span></span><br><span class="line">        <span class="keyword">return</span> ZonedDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()).toOffsetDateTime();</span><br><span class="line"></span><br><span class="line">		OffsetDateTime offsetDateTime = ZonedDateTime.ofInstant</span><br><span class="line">            (<span class="keyword">new</span> Date().toInstant(), ZoneId.systemDefault()).toOffsetDateTime();</span><br><span class="line">		<span class="comment">//2021-09-05T11:43:09.697+08:00</span></span><br><span class="line">        OffsetDateTime with = offsetDateTime.with(LocalTime.MAX);</span><br><span class="line">		<span class="comment">//2021-09-05T23:59:59.999999999+08:00</span></span><br><span class="line">        OffsetDateTime  endDateTime = offsetDateTime.with(LocalTime.MIN);</span><br><span class="line">		<span class="comment">//2021-09-05T00:00+08:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//OffsetDateTime转Date</span></span><br><span class="line">		<span class="keyword">return</span> Date.from(offsetDateTime.atZoneSameInstant(ZoneId.systemDefault()).toInstant());</span><br><span class="line"></span><br><span class="line"><span class="comment">//OffsetDateTime转LocalDateTime</span></span><br><span class="line">		<span class="keyword">return</span> LocalDateTime.ofInstant(offsetDateTime.atZoneSameInstant(ZoneId.systemDefault()).toInstant(), ZoneId.systemDefault());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取整点时间  10点48返回10点</span></span><br><span class="line">		LocalDateTime dateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());</span><br><span class="line">        <span class="keyword">return</span> Date.from(LocalDateTime.of(dateTime.toLocalDate(), LocalTime.of(dateTime.getHour(), <span class="number">0</span>, <span class="number">0</span>)).atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDateTime 转 时间戳（秒级）</span></span><br><span class="line">		 <span class="number">1.</span><span class="comment">// 获得当前时间</span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 将当前时间转为时间戳</span></span><br><span class="line">        <span class="keyword">long</span> second = localDateTime.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        System.out.println(second);</span><br><span class="line">		</span><br><span class="line">		<span class="number">2.</span><span class="comment">// 获得当前时间</span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 将当前时间转为时间戳</span></span><br><span class="line">        <span class="keyword">long</span> second = localDateTime.toInstant(ZoneOffset.ofHours(<span class="number">8</span>)).getEpochSecond();</span><br><span class="line">        System.out.println(second);</span><br><span class="line"></span><br><span class="line">		<span class="number">3.</span> <span class="comment">// 获得当前时间</span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 将当前时间转为时间戳（毫秒级）</span></span><br><span class="line">        <span class="keyword">long</span> milliseconds = localDateTime.toInstant(ZoneOffset.ofHours(<span class="number">8</span>)).toEpochMilli();</span><br><span class="line">        System.out.println(milliseconds / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳 转LocalDateTime</span></span><br><span class="line">		<span class="number">1.</span><span class="comment">//获得时间戳</span></span><br><span class="line">        <span class="keyword">long</span> second = LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).getEpochSecond();</span><br><span class="line">        <span class="comment">// 将时间戳转为当前时间</span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(second, <span class="number">0</span>, ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="number">2.</span><span class="comment">//获得时间戳</span></span><br><span class="line">        <span class="keyword">long</span> milliseconds = LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line">        <span class="comment">// 将时间戳转为当前时间</span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(milliseconds / <span class="number">1000</span>, <span class="number">0</span>, ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="number">3.</span><span class="comment">//获得时间戳</span></span><br><span class="line">        <span class="keyword">long</span> milliseconds = LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line">        <span class="comment">// 将时间戳转为当前时间</span></span><br><span class="line">        LocalDateTime localDateTime = Instant.ofEpochMilli(milliseconds).atZone(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳转LocalDate</span></span><br><span class="line">		<span class="comment">//获得时间戳</span></span><br><span class="line">        <span class="keyword">long</span> milliseconds = LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br><span class="line">        <span class="comment">// 将时间戳转为当前时间</span></span><br><span class="line">        LocalDate localDate = Instant.ofEpochMilli(milliseconds).atZone(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDate();</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//获得时间戳</span></span><br><span class="line">        <span class="keyword">long</span> seconds = LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).getEpochSecond();</span><br><span class="line">        <span class="comment">// 将时间戳转为当前时间</span></span><br><span class="line">        LocalDate localDate = Instant.ofEpochSecond(seconds).atZone(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDate();</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDate 转 时间戳</span></span><br><span class="line">		LocalDate localDate = LocalDate.now();</span><br><span class="line">        <span class="comment">//获得时间戳</span></span><br><span class="line">        <span class="keyword">long</span> seconds = localDate.atStartOfDay(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant().getEpochSecond();</span><br><span class="line">        System.out.println(seconds);</span><br><span class="line"></span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        <span class="comment">//获得时间戳</span></span><br><span class="line">        <span class="keyword">long</span> seconds = localDate.atStartOfDay(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant().toEpochMilli();</span><br><span class="line">        System.out.println(seconds);</span><br></pre></td></tr></table></figure>

<h1 id="两个List集合求交集、并集和差集"><a href="#两个List集合求交集、并集和差集" class="headerlink" title="两个List集合求交集、并集和差集"></a>两个List集合求交集、并集和差集</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        stringList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        stringList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        stringList.add(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">        stringList.add(<span class="string">&quot;j&quot;</span>);</span><br><span class="line">        stringList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//一、求交集</span></span><br><span class="line">        <span class="comment">//方法1：直接通过retainAll直接过滤</span></span><br><span class="line">        List&lt;String&gt; stringList1 =  <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a,b,c,d,e,f,g,h&quot;</span>.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        stringList1.retainAll(stringList);</span><br><span class="line">        System.out.println(<span class="string">&quot;交集1: &quot;</span> + stringList1);</span><br><span class="line">        <span class="comment">//交集1: [a, b, c]</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//方法2：通过过滤掉存在于stringList的数据</span></span><br><span class="line">        List&lt;String&gt; stringList1_2 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a,b,c,d,e,f,g,h&quot;</span>.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        List&lt;String&gt; strings = stringList1_2.stream()</span><br><span class="line">                .filter(item -&gt; stringList.contains(item))</span><br><span class="line">                .collect(toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;交集2：&quot;</span> + strings);</span><br><span class="line"> 		<span class="comment">//交集2：[a, b, c]</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//二、并集</span></span><br><span class="line">        <span class="comment">//有重并集 addAll</span></span><br><span class="line">        List&lt;String&gt; stringList2 =  <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a,b,c,d,e,f,g,h&quot;</span>.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        stringList2.addAll(stringList);</span><br><span class="line">        System.out.println(<span class="string">&quot;并集: &quot;</span> + stringList2);</span><br><span class="line"> 		<span class="comment">//并集: [a, b, c, d, e, f, g, h, a, b, c, i, j, a]</span></span><br><span class="line"> 		</span><br><span class="line">        <span class="comment">//无重并集 removeAll和addAll</span></span><br><span class="line">        List&lt;String&gt; stringList2_2 =  <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a,b,c,d,e,f,g,h&quot;</span>.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        List&lt;String&gt; stringList_1 =  <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a,b,c,i,j,a&quot;</span>.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        stringList2_2.removeAll(stringList_1);</span><br><span class="line">        stringList_1.addAll(stringList2_2);</span><br><span class="line">        System.out.println(<span class="string">&quot;无重并集: &quot;</span> + stringList_1);</span><br><span class="line">        <span class="comment">//无重并集: [a, b, c, i, j, a, d, e, f, g, h]</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//三、求差集</span></span><br><span class="line">        <span class="comment">//方法1：直接使用removeAll()方法</span></span><br><span class="line">        List&lt;String&gt; stringList3 =  <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a,b,c,d,e,f,g,h&quot;</span>.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        stringList3.removeAll(stringList);</span><br><span class="line">        System.out.println(<span class="string">&quot;差集1: &quot;</span> + stringList3);</span><br><span class="line">        <span class="comment">//差集1: [d, e, f, g, h]</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//方法2：通过过滤掉不存在于stringList的数据，然后和本数组进行交集处理</span></span><br><span class="line">        List&lt;String&gt; stringList3_2 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a,b,c,d,e,f,g,h&quot;</span>.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        stringList3_2.retainAll(stringList3_2.stream()</span><br><span class="line">                .filter(item -&gt; !stringList.contains(item))</span><br><span class="line">                .collect(toList()));</span><br><span class="line">        System.out.println(<span class="string">&quot;差集2：&quot;</span> + stringList3_2);</span><br><span class="line"> 		<span class="comment">//差集2：[d, e, f, g, h]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="list赋值问题"><a href="#list赋值问题" class="headerlink" title="list赋值问题"></a><strong>list赋值问题</strong></h4><p>如果使用了赋值方式，如 list1 = list0 ，然后 list1.retainAll(list2) 或者 list1.removeAll(list2)其实list0的值也变化了。因为lis1和list0指向了同一个地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; s1 &#x3D; new ArrayList&lt;&gt;(Arrays.asList(&quot;a,b,c,d,e,f,g,h&quot;.split(&quot;,&quot;)));</span><br><span class="line">        List&lt;String&gt; s2 &#x3D; s1;</span><br><span class="line">        System.out.println(&quot;s1地址和s2是否相等（是否为同一个对象）: &quot; + (s1 &#x3D;&#x3D; s2));</span><br><span class="line">        s2.remove(&quot;g&quot;);</span><br><span class="line">        s2.remove(&quot;h&quot;);</span><br><span class="line">        System.out.println(&quot;s1: &quot; + s1);</span><br><span class="line">        System.out.println(&quot;s2: &quot; + s2);</span><br><span class="line">        </span><br><span class="line">s1地址和s2是否相等（是否为同一个对象）: true</span><br><span class="line">s1: [a, b, c, d, e, f]</span><br><span class="line">s2: [a, b, c, d, e, f]        </span><br></pre></td></tr></table></figure>

<p>而如果使用 List<String> list1= new ArrayList&lt;&gt;(list0);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; s1 &#x3D; new ArrayList&lt;&gt;(Arrays.asList(&quot;a,b,c,d,e,f,g,h&quot;.split(&quot;,&quot;)));</span><br><span class="line">        List&lt;String&gt; s2 &#x3D; new ArrayList&lt;&gt;(s1);</span><br><span class="line">        System.out.println(&quot;s1地址和s2是否相等（是否为同一个对象）: &quot; + (s1 &#x3D;&#x3D; s2));</span><br><span class="line">        s2.remove(&quot;g&quot;);</span><br><span class="line">        s2.remove(&quot;h&quot;);</span><br><span class="line">        System.out.println(&quot;s1: &quot; + s1);</span><br><span class="line">        System.out.println(&quot;s2: &quot; + s2);</span><br><span class="line">        s1地址和s2是否相等（是否为同一个对象）: false</span><br><span class="line">        </span><br><span class="line">s1地址和s2是否相等（是否为同一个对象）: false</span><br><span class="line">s1: [a, b, c, d, e, f, g, h]</span><br><span class="line">s2: [a, b, c, d, e, f]</span><br></pre></td></tr></table></figure>

<p>我们在使用 removeAll() 方法时，有时候会遇到报错或者失效的情形，比如List中是一个一个对象类，且没有重写过equals和hashCode方法，就会带来这种不相等的情况，从而导致失效</p>
<p>addAll</p>
<p>arraycopy</p>
<p>clone  </p>
<p>Arrays.copyOf  </p>
<p>for</p>
<h1 id="前后端接口（带参数）"><a href="#前后端接口（带参数）" class="headerlink" title="前后端接口（带参数）"></a>前后端接口（带参数）</h1><p>GET</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">前端：</span><br><span class="line">this.$request.get(&#39;&#x2F;gatewayInfo&#x2F;&#39; + this.form.gatewayNum)</span><br><span class="line">后端：</span><br><span class="line">	@GetMapping(&quot;&#x2F;gatewayInfo&#x2F;&#123;gatewayNum&#125;&quot;)</span><br><span class="line">	public R getGatewayInfo(@PathVariable String gatewayNum) throws UserNotExistException &#123;</span><br><span class="line">    	return deviceInfoService.getGatewayByGatewayNum(gatewayNum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">前端：</span><br><span class="line">let tel &#x3D;this.myform.tel;</span><br><span class="line">this.$request.get(&#96;&#x2F;login&#x2F;$&#123;tel&#125;&#96;)</span><br><span class="line">后端：</span><br><span class="line">    @GetMapping(&quot;&#x2F;login&#x2F;&#123;tel&#125;&quot;)</span><br><span class="line">    public R loginVerifycode(@PathVariable(value &#x3D; &quot;tel&quot;) String tel) throws ClientException &#123;</span><br><span class="line">        return loginService.getLoginVerifyCode(tel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">前端：</span><br><span class="line">this.$request.get(&quot;&#x2F;ticket?url&#x3D;&quot; + url)</span><br><span class="line">后端：</span><br><span class="line">	@GetMapping(&quot;&#x2F;ticket&quot;)</span><br><span class="line">    public R getTicket(String url) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">前端：    </span><br><span class="line">this.$request.get(&#96;&#x2F;shop&#x2F;order&#x2F;buy?productId&#x3D;&#96; + this.productId)</span><br><span class="line">后端：</span><br><span class="line"> 	@GetMapping(&quot;&#x2F;buy&quot;)</span><br><span class="line">    public R getOrderProductDTO(@RequestParam Integer productId) &#123;</span><br><span class="line">        return productOrderDetailService.getOneOrderProductDTO(productId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>POST</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">前端：</span><br><span class="line">this.$request.post(&quot;&#x2F;login&quot;, this.myform)</span><br><span class="line">后端：</span><br><span class="line">    @PostMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">    public R doLogin(@RequestBody LoginDTO loginDTO) throws UserNotExistException &#123;</span><br><span class="line">        return loginService.loginAdmin(loginDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">前端：</span><br><span class="line">this.$request.post(&#39;&#x2F;gateway&#x2F;addGateway&#39;, &#123;gatewayName: this.virtualGatewayName,orderSn: this.orderSn&#125;)</span><br><span class="line">后端：</span><br><span class="line"> @PostMapping(&quot;&#x2F;addGateway&quot;)</span><br><span class="line"> public R addGateway(@RequestBody GatewayDTO gatewayDTO) throws UserNotExistException &#123;</span><br><span class="line">        return gatewayService.addGateway(gatewayDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="工具类的GET和POST"><a href="#工具类的GET和POST" class="headerlink" title="工具类的GET和POST"></a>工具类的GET和POST</h1><h3 id="发送post请求的工具方法"><a href="#发送post请求的工具方法" class="headerlink" title="发送post请求的工具方法"></a>发送post请求的工具方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sendPost</span><span class="params">(String url, String data)</span> </span>&#123;</span><br><span class="line">        String response = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpPost post = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">            <span class="comment">//设置请求头</span></span><br><span class="line">            post.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            post.setHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&quot;</span>);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//设置请求体</span></span><br><span class="line">            StringEntity s = <span class="keyword">new</span> StringEntity(data, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            s.setContentEncoding(<span class="keyword">new</span> BasicHeader(HTTP.CONTENT_TYPE, <span class="string">&quot;application/json&quot;</span>));</span><br><span class="line">            post.setEntity(s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();</span><br><span class="line">            CloseableHttpClient closeableHttpClient = httpClientBuilder.build();</span><br><span class="line">            CloseableHttpResponse closeableHttpResponse = closeableHttpClient.execute(post);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取响应输入流</span></span><br><span class="line">            InputStream contentInputStream = closeableHttpResponse.getEntity().getContent();</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(contentInputStream, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != (line = reader.readLine())) &#123;</span><br><span class="line">                stringBuilder.append(line).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            contentInputStream.close();</span><br><span class="line"></span><br><span class="line">            response = stringBuilder.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;后端发送POST出错：&#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//发送带head的post请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sendPost</span><span class="params">(String url, String data, String authorization)</span> </span>&#123;</span><br><span class="line">        String response = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String contentType = <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置参数</span></span><br><span class="line">            HttpPost post = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">            post.setHeader(<span class="string">&quot;Content-Type&quot;</span>, contentType);</span><br><span class="line">            post.setHeader(<span class="string">&quot;Authorization&quot;</span>, authorization);</span><br><span class="line">            post.setHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&quot;</span>);</span><br><span class="line">            post.setEntity(<span class="keyword">new</span> StringEntity(data, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();</span><br><span class="line">            CloseableHttpClient closeableHttpClient = httpClientBuilder.build();</span><br><span class="line">            CloseableHttpResponse closeableHttpResponse = closeableHttpClient.execute(post);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取响应输入流</span></span><br><span class="line">            InputStream contentInputStream = closeableHttpResponse.getEntity().getContent();</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(contentInputStream, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != (line = reader.readLine())) &#123;</span><br><span class="line">                stringBuilder.append(line).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            contentInputStream.close();</span><br><span class="line"></span><br><span class="line">            response = stringBuilder.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;后端发送POST出错：&#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送GET请求的工具方法"><a href="#发送GET请求的工具方法" class="headerlink" title="发送GET请求的工具方法"></a>发送GET请求的工具方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder json = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String lines;</span><br><span class="line">        URL getUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">        HttpURLConnection connection = (HttpURLConnection) getUrl.openConnection();</span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = connection.getInputStream();</span><br><span class="line">             InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">             BufferedReader reader = <span class="keyword">new</span> BufferedReader(inputStreamReader)) &#123;</span><br><span class="line">            connection.connect();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != (lines = reader.readLine())) &#123;</span><br><span class="line">                json.append(lines);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != connection) &#123;</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> json.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送带head的get请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, String authorization)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder json = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String lines;</span><br><span class="line">        URL getUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">        HttpURLConnection connection = (HttpURLConnection) getUrl.openConnection();</span><br><span class="line">        connection.setRequestProperty(<span class="string">&quot;Authorization&quot;</span>, authorization);</span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = connection.getInputStream();</span><br><span class="line">             InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">             BufferedReader reader = <span class="keyword">new</span> BufferedReader(inputStreamReader)) &#123;</span><br><span class="line">            connection.connect();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != (lines = reader.readLine())) &#123;</span><br><span class="line">                json.append(lines);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != connection) &#123;</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> json.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取请求者ip的工具方法"><a href="#获取请求者ip的工具方法" class="headerlink" title="获取请求者ip的工具方法"></a>获取请求者ip的工具方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpAddr</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String ip = request.getHeader(<span class="string">&quot;x-forwarded-for&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="keyword">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="keyword">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="keyword">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="keyword">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="keyword">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>对非法字符校验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(new RegExp(&quot;[^a-zA-Z0-9\_\u4e00-\u9fa5]&quot;,&quot;i&quot;).test(this.name))&#123;</span><br><span class="line">          this.$toast.fail(&#39;用户名中包含非法字符&#39;);</span><br><span class="line">          this.name&#x3D;&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" data-id="ckw61sdwg0059oswd46lg4pzy" data-title="工具类代码" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-RPC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/03/RPC/" class="article-date">
  <time class="dt-published" datetime="2021-09-03T01:32:58.000Z" itemprop="datePublished">2021-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/03/RPC/">RPC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>什么是 RPC 框架<br>RPC 框架—– 远程过程调用协议RPC（Remote Procedure Call Protocol)—–允许像调用本地服务一样调用远程服务。</p>
<p>RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。比如说，一个方法可能是这样定义的：<br>Employee getEmployeeByName(String fullName)那么：</p>
<p>第一，首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接（socket），远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</p>
<p>第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。</p>
<p>第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。</p>
<p>第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。</p>
<p>第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用</p>
<p><img src="/RPC/1034798-20190803235907571-1963669765.png" alt="img"></p>
<p>总的来说可以归纳为以下几步：<br> 1，远程服务之间建立通讯协议</p>
<p>2，寻址：服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么</p>
<p>3，通过序列化和反序列化进行数据传递</p>
<p>4，将传递过来的数据通过java反射原理定位接口方法和参数</p>
<p>5，暴露服务：用map将寻址的信息暴露给远方服务（提供一个endpoint URI或者一个前端展示页面）</p>
<p> 6，多线程并发请求业务</p>
<p>什么是RPC<br>提到RPC（Remote Procedure Call），就躲不开提到分布式，这个促使RPC诞生的领域。</p>
<p>假设你有一个Calculator，以及它的实现类CalculatorImpl，那么单体应用时，要调用Calculator的add方法来执行一个加运算，你可以方法中直接使用，因为在同一个地址空间，或者说在同一块内存，这个称为本地函数调用。</p>
<p> <img src="/RPC/1034798-20190804010343800-2034350979.png" alt="img"></p>
<p>现在，将系统改造为分布式应用，接口调用和实现分别在两个子系统内，</p>
<p>服务A里头并没有CalculatorImpl这个类，那它要怎样调用服务B的CalculatorImpl的add方法呢？可以模仿B/S架构的调用方式，在B服务暴露一个Restful接口，然后A服务通过调用这个Restful接口来间接调用CalculatorImpl的add方法。</p>
<p>这样，已经很接近RPC了，不过，像这种每次调用时，是不是都需要写一串发起http请求的代码呢？比如httpClient.sendRequest…之类的，能不能简单一下，像本地方法调用一样，去发起远程调用，让使用者感知不到远程调用的过程。</p>
<p> <img src="/RPC/1034798-20190804010427019-732322413.png" alt="img"></p>
<p>屏蔽的工作，可以使用代理模式解决，生成一个代理对象，而这个代理对象的内部，就是通过httpClient来实现RPC远程过程调用的。</p>
<p>这就是很多RPC框架要解决的问题和解决的思路，比如阿里的Dubbo。</p>
<p>总结一下，RPC要解决的两个问题：</p>
<ol>
<li><p>解决分布式系统中，服务之间的调用问题。</p>
</li>
<li><p>远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。</p>
</li>
</ol>
<p>RPC是一种技术的概念名词</p>
<p>RPC=Remote Produce Call 是一种技术的概念名词，HTTP是一种协议,RPC可以通过 HTTP 来实现,也可以通过Socket自己实现一套协议来实现.所以题目可以换一种理解,为何 RPC 还有除 HTTP 之外的实现法,有何必要，毕竟除了HTTP实现外,私有协议不具备通用性.</p>
<p>RPC框架好处<br>http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；</p>
<p>优点就是简单、直接、开发方便。</p>
<p>如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了：</p>
<p>首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；</p>
<p>其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。</p>
<p>最后是安全性。</p>
<p>rpc是一种概念，http也是rpc实现的一种方式。</p>
<p>论复杂度，dubbo/hessian用起来是超级简单的。</p>
<p>至于为什么用dubbo/hessian，有几点：</p>
<p>一是调用简单，真正提供了类似于调用本地方法一样调用接口的功能 。</p>
<p>二是参数返回值简单明了 参数和返回值都是直接定义在jar包里的，不需要二次解析。</p>
<p>三是 轻量，没有多余的信息。</p>
<p>四是便于管理，基于dubbo的注册中心。</p>
<p>RPC能解耦服务</p>
<p>RPC:远程过程调用。RPC的核心并不在于使用什么协议。RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这个调用的方法是部署哪里。</p>
<p>通过RPC能解耦服务，这才是使用RPC的真正目的。RPC的原理主要用到了动态代理模式，至于http协议，只是传输协议而已。简单的实现可以参考spring remoting，复杂的实现可以参考dubbo。</p>
<p>rpc=socket + 动态代理</p>
<p>服务器通讯原理就是一台socket服务器A,另一台socket客户端B,现在如果要通讯的话直接以流方式写入或读出。这样能实现通讯，但有个问题。如何知道更多信息？</p>
<p>比如需要发送流大小，编码，Ip等。这样就有了协议，协议就是规范，就是发送的流中携带了很多的内容。那回到刚刚的问题。发送的内容就是文本类型，客户端就得序列化，那么常用的就有json，xml之类，如果想把内容变得更小，那就有二进制了。把文本变成二进制传递。</p>
<p>说到 rpc 与http接口，不要太复杂了。rpc 协议更简单内容更小，那么来说效率是要高一点</p>
<p>rpc 是什么？就是socket 加动态代理。</p>
<p>总结</p>
<p>学技术应该是知其然知其所以然，我们得明白什么场景，或者什么业务需要它，它能解决其他技术不能解决或者不方便解决的问题。</p>
<p>RPC是一个软件结构概念，是构建分布式应用的理论基础。就好比为啥你家可以用到发电厂发出来的电？是因为电是可以传输的。至于用铜线还是用铁丝还是其他种类的导线，也就是用http还是用其他协议的问题了。这个要看什么场景，对性能要求怎么样。</p>
<p>在java中的最基本的就是RMI技术，它是java原生的应用层分布式技术。我们可以肯定的是在传输性能方面，RMI的性能是优于HTTP的。</p>
<p>那为啥很少用到这个技术？那是因为用这个有很多局限性，首先它要保证传输的两端都要要用java实现，且两边需要有相同的对象类型和代理接口，不需要容器，但是加大了编程的难度，在应用内部的各个子系统之间还是会看到他的身影，比如EJB就是基于rmi技术的。</p>
<p>这就与目前的bs架构的软件大相径庭。用http必须要服务端位于http容器里面，这样减少了网络传输方面的开发，只需要关注业务开发即可。所以在架构一个软件的时候，不能一定根据需求选定技术。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/09/03/RPC/" data-id="ckw61sdvn002zoswd8rukae1g" data-title="RPC" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-日志" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/02/%E6%97%A5%E5%BF%97/" class="article-date">
  <time class="dt-published" datetime="2021-09-02T06:55:26.000Z" itemprop="datePublished">2021-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="常用日志框架"><a href="#常用日志框架" class="headerlink" title="常用日志框架"></a>常用日志框架</h2><h3 id="j-u-l"><a href="#j-u-l" class="headerlink" title="j.u.l"></a>j.u.l</h3><p>￼j.u.l是java.util.logging包的简称，是JDK在1.4版本中引入的Java原生日志框架。</p>
<p>Java Logging API提供了七个日志级别用来控制输出。这七个级别分别是：SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST。</p>
<h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p>Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；</p>
<p>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。Log4也有七种日志级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG和TRACE。</p>
<p>最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>
<h3 id="LogBack（用的比较多）"><a href="#LogBack（用的比较多）" class="headerlink" title="LogBack（用的比较多）"></a>LogBack（用的比较多）</h3><p>LogBack也是一个很成熟的日志框架，其实LogBack和Log4j出自一个人之手，这个人就是Ceki Gülcü。</p>
<p>logback当前分成三个模块：logback-core,logback- classic和logback-access。</p>
<p>logback-core是其它两个模块的基础模块。</p>
<p>logback-classic是Log4j的一个改良版本，此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日记系统如Log4j或j.u.l。</p>
<p>logback-access访问模块与Servlet容器集成提供通过Http来访问日记的功能</p>
<h3 id="Log4j2（新王）"><a href="#Log4j2（新王）" class="headerlink" title="Log4j2（新王）"></a>Log4j2（新王）</h3><p>Log4j2不仅仅是Log4j的一个升级版本了，而是从头到尾被重写的，可以认为这其实就是完全不同的两个框架。</p>
<p><strong>注</strong>：</p>
<p>logback是直接实现了slf4j的接口，不消耗内存和计算开销的。</p>
<p>slf4j的api在调用log4j时需要一个适配层（所以maven配置里slf4j+logback只需要两个依赖，而log4j需要3个依赖）</p>
<p>我们想要在应用中打印日志的时候，可以使用以上四种类库中的任意一种。比如想要使用Log4j，那么只要依赖Log4j的jar包，配置好配置文件并且在代码中使用其API打印日志就可以了</p>
<p>但是阿里巴巴开发文档规定：</p>
<p><img src="/%E6%97%A5%E5%BF%97/640" alt="图片"></p>
<p>所以我们一般使用都是门面框架slf4j和上述四种之一的API结合。</p>
<h2 id="日志门面"><a href="#日志门面" class="headerlink" title="日志门面"></a><strong>日志门面</strong></h2><h3 id="什么是日志门面"><a href="#什么是日志门面" class="headerlink" title="什么是日志门面"></a>什么是日志门面</h3><p>日志门面，是门面模式的一个典型的应用。</p>
<p>门面模式（Facade Pattern），也称之为外观模式，其核心为：外部与一个子系统的通信必须通过一个统一的外观对象进行，使得子系统更易于使用。</p>
<p><img src="/%E6%97%A5%E5%BF%97/image-20210902150149819.png" alt="image-20210902150149819"></p>
<p><img src="/%E6%97%A5%E5%BF%97/20160909182117391" alt="这里写图片描述"></p>
<p>就像前面介绍的几种日志框架一样，每一种日志框架都有自己单独的API，要使用对应的框架就要使用其对应的API，这就大大的增加应用程序代码对于日志框架的耦合性。</p>
<p>为了解决这个问题，就是在日志框架和应用程序之间架设一个沟通的桥梁，对于应用程序来说，无论底层的日志框架如何变，都不需要有任何感知。只要门面服务做的足够好，随意换另外一个日志框架，应用程序不需要修改任意一行代码，就可以直接上线。</p>
<p>在软件开发领域有这样一句话：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。而门面模式就是对于这句话的典型实践</p>
<h3 id="为什么要使用日志门面"><a href="#为什么要使用日志门面" class="headerlink" title="为什么要使用日志门面"></a>为什么要使用日志门面</h3><p><strong>解耦</strong></p>
<p>为了在应用中屏蔽掉底层日志框架的具体实现：即使有一天要更换代码的日志框架，只需要修改jar包，最多再改改日志输出相关的配置文件就可以了。这就是解除了应用和日志框架之间的耦合。</p>
<h3 id="常用日志门面"><a href="#常用日志门面" class="headerlink" title="常用日志门面"></a><strong>常用日志门面</strong></h3><h4 id="SLF4J（用的比较多）"><a href="#SLF4J（用的比较多）" class="headerlink" title="SLF4J（用的比较多）"></a>SLF4J（用的比较多）</h4><p>Java简易日志门面（Simple Logging Facade for Java，缩写SLF4J），是一套包装Logging 框架的界面程式，以外观模式实现。可以在软件部署的时候决定要使用的 Logging 框架，目前主要支援的有Java Logging API、Log4j及logback等框架。以MIT 授权方式发布。</p>
<p>SLF4J 的作者就是 Log4j和Logback 的作者 Ceki Gülcü，他宣称 SLF4J 比 Log4j 更有效率，而且比 Apache Commons Logging (JCL) 简单、稳定。</p>
<p>其实，<strong>SLF4J其实只是一个门面服务而已，他并不是真正的日志框架，真正的日志的输出相关的实现还是要依赖Log4j、logback等日志框架的</strong> 。</p>
<p>由于SLF4J比较常用，这里多用一些篇幅，再来简单分析一下SLF4J，主要和Log4J做一下对比。相比较于Log4J的API，SLF4J有以下几点优势：</p>
<ul>
<li>Log4j 提供 TRACE, DEBUG, INFO, WARN, ERROR 及 FATAL 六种纪录等级，但是 SLF4J 认为 ERROR 与 FATAL 并没有实质上的差别，所以拿掉了 FATAL 等级，只剩下其他五种。</li>
<li>大部分人在程序里面会去写logger.error(exception),其实这个时候Log4j会去把这个exception tostring。真正的写法应该是logger(message.exception);而SLF4J就不会使得程序员犯这个错误。</li>
<li>Log4j间接的在鼓励程序员使用string相加的写法（这种写法是有性能问题的），而SLF4J就不会有这个问题 ,你可以使用<code>logger.error(“&#123;&#125;is+serviceid”,serviceid);</code></li>
<li>使用SLF4J可以方便的使用其提供的各种集体的实现的jar。（类似commons-logger）</li>
<li>从commons–logger和Log4j merge非常方便，SLF4J也提供了一个swing的tools来帮助大家完成这个merge。</li>
<li>SLF4J 只支持 MDC，不支持 NDC。</li>
<li>提供字串内容替换的功能，会比较有效率，说明如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传统的字符串产生方式，如果没有要记录Debug等级的信息，就会浪费时间在产生不必要的信息上</span><br><span class="line">logger.debug(&quot;There are now &quot; + count + &quot; user accounts: &quot; + userAccountList);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为了避免上述问题，我们可以先检查是不是开启了Debug信息记录功能，只是程序的编码会比较复杂</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">   logger.debug(&quot;There are now &quot; + count + &quot; user accounts: &quot; + userAccountList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果Debug等级没有开启，则不会产生不必要的字符串，同时也能保持程序编码的简洁</span><br><span class="line">logger.debug(&quot;There are now &#123;&#125; user accounts: &#123;&#125;&quot;, count, userAccountList);</span><br></pre></td></tr></table></figure>

<h3 id="commons-logging"><a href="#commons-logging" class="headerlink" title="commons-logging"></a>commons-logging</h3><p>Apache Commons Logging是一个基于Java的日志记录实用程序，是用于日志记录和其他工具包的编程模型。它通过其他一些工具提供API，日志实现和包装器实现。</p>
<p>commons-logging和SLF4J的功能是类似的，主要是用来做日志 门面的。提供更加好友的API工具。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Java生态体系中，围绕着日志，有很多成熟的解决方案。关于日志输出，主要有两类工具。</p>
<p>一类是日志框架，主要用来进行日志的输出的，比如输出到哪个文件，日志格式如何等。</p>
<p>另外一类是日志门面，主要一套通用的API，用来屏蔽各个日志框架之间的差异的。</p>
<p>所以，对于Java工程师来说，关于日志工具的使用，最佳实践就是在应用中使用如Log4j + SLF4J 这样的组合来进行日志输出。</p>
<p>这样做的最大好处，就是业务层的开发不需要关心底层日志框架的实现及细节，在编码的时候也不需要考虑日后更换框架所带来的成本。这也是门面模式所带来的好处。</p>
<p>综上，请不要在你的Java代码中出现任何Log4j等日志框架的API的使用，而是应该直接使用SLF4J这种日志门面。</p>
<h2 id="Slf4j-Logback"><a href="#Slf4j-Logback" class="headerlink" title="Slf4j+Logback"></a>Slf4j+Logback</h2><h4 id="默认日志-Logback："><a href="#默认日志-Logback：" class="headerlink" title="默认日志 Logback："></a>默认日志 Logback：</h4><p>springboot推荐的日志类库是slf4j、日志系统为logback</p>
<p>默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台</p>
<p><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktZjE3ZjFmNDYwNjkwYmMxMy5qcGc" alt="img"></p>
<ul>
<li><p>时间日期：精确到毫秒</p>
</li>
<li><p>日志级别：ERROR, WARN, INFO, DEBUG or TRACE</p>
</li>
<li><p>进程ID</p>
</li>
<li><p>分隔符：— 标识实际日志的开始</p>
</li>
<li><p>线程名：方括号括起来（可能会截断控制台输出）</p>
</li>
<li><p>Logger名：通常使用源代码的类名</p>
</li>
<li><p>日志内容</p>
</li>
</ul>
<h4 id="添加日志依赖"><a href="#添加日志依赖" class="headerlink" title="添加日志依赖"></a>添加日志依赖</h4><p>假如maven依赖中添加spring-boot-starter-logging：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>但是呢，实际开发中我们不需要直接添加该依赖。<br>你会发现spring-boot-starter其中包含了 spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。</p>
<p>如果工程中有用到了Thymeleaf，而Thymeleaf依赖包含了spring-boot-starter，最终我只要引入Thymeleaf即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>实际上使用只要指定了spring-boot-starter，就不用再添加依赖，使用默认的依赖logback</p>
<h4 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h4><p>日志级别从低到高分为：</p>
<p>TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL。</p>
<p>如果设置为 WARN ，则低于 WARN 的信息都不会输出。<br>Spring Boot中默认配置ERROR、WARN和INFO级别的日志输出到控制台。<br>您还可以通过启动您的应用程序 –debug 标志来启用“调试”模式（开发的时候推荐开启）,以下两种方式皆可：</p>
<ul>
<li>在运行命令后加入–debug标志，如：<code>$ java -jar springTest.jar --debug</code></li>
<li>在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。</li>
</ul>
<p><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktMGEzZGE3YmM2ZTcwOGEzNC5qcGc" alt="img"></p>
<p>如果每次都写这行代码会很麻烦，可以使用注解，但是需要使用<code>lombok</code>：</p>
<p>允许注解处理，Settings -&gt; Compiler -&gt; Annotation Processors</p>
<p><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktOWJjNWQ0MzRkNTIzMzJiNy5qcGc" alt="img"></p>
<p>可以使用<code>&#123;&#125;</code> 占位符来拼接字符串，而不需要使用<code>““+””</code>来连接字符串。</p>
<h4 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h4><p>默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。</p>
<p>使用Spring Boot喜欢在application.properties或application.yml配置，这样只能配置简单的场景：保存路径、日志格式等，复杂的场景（区分 info 和 error 的日志、每天产生一个日志文件等）满足不了，只能自定义配置。</p>
<p><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktZjYxZGY0MDk4NDk1YWMxZi5qcGc" alt="img"><br><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktZmFlMmZlODQ1OWVhMzU0ZS5qcGc" alt="img"><br><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktYmE5NWI1NzFlYzQyNzA1Mi5qcGc" alt="img"></p>
<p>默认会在设置的 <code>path</code> 生成一个<code>spring.log</code> 文件。</p>
<p><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktZjdiNjFkNTkwNDE2ZmMyOC5qcGc" alt="img"></p>
<p>如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。</p>
<p>logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log<br>logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log<br>如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。<br>如果只配置 logging.path，在 /var/log文件夹生成一个日志文件为 spring.log<br>注：二者不能同时使用，如若同时使用，则只有logging.file生效（没有logback-spring.xml配置文件，系统只认识logging.file，不认识logging.path）<br>默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO</p>
<h4 id="级别控制"><a href="#级别控制" class="headerlink" title="级别控制"></a>级别控制</h4><p>所有支持的日志记录系统都可以在Spring环境中设置记录级别（例如在application.properties中）<br>格式为：logging.level.* = LEVEL</p>
<p>logging.level：日志级别控制前缀，*为包名或Logger名<br>LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF</p>
<p>每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：<br>A：off         最高等级，用于关闭所有日志记录。<br>B：fatal       指出每个严重的错误事件将会导致应用程序的退出。<br>C：error      指出虽然发生错误事件，但仍然不影响系统的继续运行。<br>D：warn     表明会出现潜在的错误情形。<br>E：info         一般和在粗粒度级别上，强调应用程序的运行全程（对用户有用）。<br>F：debug     一般用于细粒度级别上，对调试应用程序非常有帮助（对程序调试有利）。<br>G：all           最低等级，用于打开所有日志记录。</p>
<p>例：如果设置了级别为info，则debug级别就不会被打印出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">logging.level.com.dudu&#x3D;DEBUG：com.dudu包下所有class以DEBUG级别输出</span><br><span class="line">logging.level.root&#x3D;WARN：root日志以WARN级别输出</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktYzdlZjkyODZjMzhkMWUxZC5qcGc" alt="img"></p>
<h4 id="自定义日志配置（适合复杂的日志需求）"><a href="#自定义日志配置（适合复杂的日志需求）" class="headerlink" title="自定义日志配置（适合复杂的日志需求）"></a>自定义日志配置（适合复杂的日志需求）</h4><p>根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：</p>
<p>Logback：<strong>logback-spring.xml</strong>, logback-spring.groovy, logback.xml, logback.groovy<br>Log4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml<br>Log4j2：log4j2-spring.xml, log4j2.xml<br>JDK (Java Util Logging)：logging.properties</p>
<p>Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项（下面会提到）。<br>默认的命名规则，并且放在 src/main/resources 下面即可</p>
<p>如果你即想完全掌控日志配置，但又不想用logback.xml作为Logback配置的名字，application.yml可以通过logging.config属性指定自定义的名字：</p>
<p>logging.config=classpath:logging-config.xml</p>
<p>虽然一般并不需要改变配置文件的名字，但是如果你想针对不同运行时Profile使用不同的日志配置，这个功能会很有用。<br>一般不需要这个属性，而是直接在logback-spring.xml中使用springProfile配置，不需要logging.config指定不同环境使用不同配置文件。</p>
<h2 id="springProfile配置："><a href="#springProfile配置：" class="headerlink" title="springProfile配置："></a>springProfile配置：</h2><h3 id="根节点包含的属性"><a href="#根节点包含的属性" class="headerlink" title="根节点包含的属性"></a>根节点包含的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration  scan&#x3D;&quot;true&quot; scanPeriod&#x3D;&quot;10 seconds&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。<br>scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。<br>debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</p>
<p>根节点<code>&lt;configuration&gt;</code>有5个子节点</p>
<h4 id="子节点一-lt-root-gt"><a href="#子节点一-lt-root-gt" class="headerlink" title="子节点一 &lt;root&gt;"></a>子节点一 <code>&lt;root&gt;</code></h4><p>root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;root level&#x3D;&quot;debug&quot;&gt;</span><br><span class="line">  &lt;appender-ref ref&#x3D;&quot;console&quot; &#x2F;&gt;</span><br><span class="line">  &lt;appender-ref ref&#x3D;&quot;file&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure>

<p>level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。默认是DEBUG。<br>可以包含零个或多个元素，标识这个appender将会添加到这个loger。上述的console和file是已经指定的appender的name</p>
<h4 id="子节点二：-lt-contextName-gt-设置上下文名称"><a href="#子节点二：-lt-contextName-gt-设置上下文名称" class="headerlink" title="子节点二：&lt;contextName&gt; 设置上下文名称"></a>子节点二：<code>&lt;contextName&gt;</code> 设置上下文名称</h4><p>每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改,可以通过%contextName来打印日志上下文名称，一般来说我们不用这个属性，可有可无。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;contextName&gt;logback&lt;&#x2F;contextName&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktYTlkNmJlMWMyY2FhNDQ0MC5qcGc" alt="img"></p>
<h4 id="子节点三：-lt-property-gt-设置变量"><a href="#子节点三：-lt-property-gt-设置变量" class="headerlink" title="子节点三：&lt;property&gt; 设置变量"></a>子节点三：<code>&lt;property&gt;</code> 设置变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;logback.logdir&quot; value&#x3D;&quot;&#x2F;Users&#x2F;inke&#x2F;dev&#x2F;log&#x2F;tomcat&quot;&#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;logback.appname&quot; value&#x3D;&quot;app&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>用来定义变量值的标签， 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使<code>$&#123;&#125;</code>来使用变量。</p>
<p>这里可以通过 application.yml 传递参数过来。</p>
<p>多环境配置下，通过 application.yml 传递参数过来，&lt; property &gt;取不到环境参数，得用&lt; springProperty &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;appname&quot; source&#x3D;&quot;logback.appname&quot;&#x2F;&gt;</span><br><span class="line">&lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;logdir&quot; source&#x3D;&quot;logback.logdir&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h4 id="子节点四：-lt-appender-gt"><a href="#子节点四：-lt-appender-gt" class="headerlink" title="子节点四：&lt;appender&gt;"></a>子节点四：<code>&lt;appender&gt;</code></h4><p>appender用来格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。</p>
<h5 id="控制台输出ConsoleAppender："><a href="#控制台输出ConsoleAppender：" class="headerlink" title="控制台输出ConsoleAppender："></a>控制台输出<code>ConsoleAppender</code>：</h5><p><code>&lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</code></p>
<p>例子1：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback-demo<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出到控制台1 ConsoleAppender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;consoleLog1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--展示格式 layout--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d -1 %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出到控制台2 ConsoleAppender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;consoleLog2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d -2 %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定最基础的日志输出级别--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--appender将会添加到这个loger--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consoleLog1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consoleLog2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktMWM2ZDQxMWVhOGFhN2JmMC5qcGc" alt="img"></p>
<p>可以看到<code>layout</code>和<code>encoder</code>，都可以将事件转换为格式化后的日志记录.</p>
<p>但是控制台输出使用<code>layout</code>，文件输出使用<code>encoder</code>，具体原因可参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/cw_hello1/article/details/51969554">http://blog.csdn.net/cw_hello1/article/details/51969554</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout：将一个event事件转换成一个字符串，不能控制将字符串写出到文件</span><br><span class="line">encoder：①将一个event事件转换成一组byte数组，②将转换后的字节数据输出到文件中</span><br></pre></td></tr></table></figure>



<p>例子2：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback-demo<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出到控制台 ConsoleAppender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;consoleLog1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--展示格式 layout--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span></span><br><span class="line"><span class="comment">             &lt;level&gt;ERROR&lt;/level&gt;</span></span><br><span class="line"><span class="comment">        &lt;/filter&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定最基础的日志输出级别--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--appender将会添加到这个loger--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consoleLog1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consoleLog2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18:15:22.148 logback-demo [http-nio-9010-exec-1] INFO  c.e.demo.controller.UserContorller - 日志输出 info</span><br><span class="line">18:15:22.148 logback-demo [http-nio-9010-exec-1] WARN  c.e.demo.controller.UserContorller - 日志输出 warn</span><br><span class="line">18:15:22.148 logback-demo [http-nio-9010-exec-1] ERROR c.e.demo.controller.UserContorller - 日志输出 error</span><br><span class="line">18:15:22.148 logback-demo [http-nio-9010-exec-1] INFO  c.e.demo.controller.UserContorller - name:inke , age:33</span><br><span class="line">18:15:22.149 logback-demo [http-nio-9010-exec-1] INFO  c.e.demo.controller.UserContorller - name:inke , age:33</span><br></pre></td></tr></table></figure>

<h6 id="输出到文件-RollingFileAppender"><a href="#输出到文件-RollingFileAppender" class="headerlink" title="输出到文件 RollingFileAppender"></a>输出到文件 <code>RollingFileAppender</code></h6><p><code>&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</code></p>
<p>另一种常见的日志输出到文件，随着应用的运行时间越来越长，日志也会增长的越来越多，将他们输出到同一个文件并非一个好办法。</p>
<p>RollingFileAppender用于切分文件日志：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;fileInfoLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--如果只是想要 Info 级别的日志，只是过滤 info 还是会输出 Error 日志，因为 Error 的级别高，</span></span><br><span class="line"><span class="comment">    所以我们使用下面的策略，可以避免输出 Error 的日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--过滤 Error--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--匹配到就禁止--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--没有匹配到就允许--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则</span></span><br><span class="line"><span class="comment">        如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天</span></span><br><span class="line"><span class="comment">        的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logback.logdir&#125;/info.$&#123;logback.appname&#125;.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logback.logdir&#125;/info.$&#123;logback.appname&#125;.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--只保留最近90天的日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>90<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--日志输出编码格式化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%thread] %-5level %logger&#123;36&#125; %line - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;encoder&gt;</code>表示对日志进行编码：</p>
<p>%d{HH: mm:ss.SSS}——日志输出时间<br>%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用<br>%-5level——日志级别，并且使用5个字符靠左对齐<br>%logger{36}——日志输出者的名字<br>%msg——日志消息<br>%n——平台的换行符</p>
<p>ThresholdFilter为系统定义的拦截器，例如我们用ThresholdFilter来过滤掉ERROR级别以下的日志不输出到文件中。如果不用记得注释掉，不然你控制台会发现没日志~</p>
<p>如果同时有<code>&lt;File&gt;</code>和<code>&lt;FileNamePattern&gt;</code>，根据日期分割日志</p>
<p><img src="/%E6%97%A5%E5%BF%97/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzI4ODA2OTktOWU0YTBlMDJhNWVlMTE3Ny5qcGc" alt="img"></p>
<p>如果要区分 <code>Info</code> 和 <code>Error</code> 级别的日志，那么需要使用过滤规则的策略</p>
<h5 id="子节点五-lt-loger-gt"><a href="#子节点五-lt-loger-gt" class="headerlink" title="子节点五&lt;loger&gt;"></a>子节点五<code>&lt;loger&gt;</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;logger name&#x3D;&quot;com.swx&quot; additivity&#x3D;&quot;false&quot; level&#x3D;&quot;DEBUG&quot;&gt;</span><br><span class="line">	&lt;appender-ref ref&#x3D;&quot;CONSOLE&quot;&#x2F;&gt;</span><br><span class="line">	&lt;appender-ref ref&#x3D;&quot;FILE&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;logger&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;loger&gt;</code>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定<code>&lt;appender&gt;</code>。</p>
<p><code>&lt;loger&gt;</code>仅有一个name属性，一个可选的level和一个可选的addtivity属性。</p>
<p>name:用来指定受此loger约束的某一个包或者具体的某一个类。<br>level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前loger将会继承上级的级别。<br>addtivity:是否向上级loger传递打印信息。默认是true。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dudu.controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">login</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。</span></span><br><span class="line">        logger.trace(<span class="string">&quot;日志输出 trace&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;日志输出 debug&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;日志输出 info&quot;</span>);</span><br><span class="line">        logger.warn(<span class="string">&quot;日志输出 warn&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;日志输出 error&quot;</span>);</span><br><span class="line">        Map&lt;String,Object&gt; map =<span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">        String userName=request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        String password=request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!userName.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; password!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            User user =<span class="keyword">new</span> User(userName,password);</span><br><span class="line">            request.getSession().setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">            map.put(<span class="string">&quot;result&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(<span class="string">&quot;result&quot;</span>,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这是一个登录的判断的方法，我们引入日志，并且打印不同级别的日志，然后根据logback-spring.xml中的配置来看看打印了哪几种级别日志</span><br></pre></td></tr></table></figure>

<p>第一种：带有loger的配置，不指定级别，不指定appender<br>logback-spring.xml增加 loger 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;logger name&#x3D;&quot;com.dudu.controller&quot; &#x2F;&gt;</span><br><span class="line">将控制controller包下的所有类的日志的打印，但是并没用设置打印级别，所以继承他的上级的日志级别“info”；</span><br><span class="line">没有设置addtivity，默认为true，将此loger的打印信息向上级传递；</span><br><span class="line">没有设置appender，此loger本身不打印任何信息。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;root level&#x3D;&quot;info&quot;&gt;</span><br><span class="line">	&lt;appender-ref ref&#x3D;&quot;console&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;root&gt;</span><br><span class="line">将root的打印级别设置为“info”，指定了名字为“console”的appender。</span><br></pre></td></tr></table></figure>

<p>当执行com.dudu.controller.LearnController类的login方法时，LearnController 在包com.dudu.controller中，所以首先执行<logger name="com.dudu.controller"/>，将级别为“info”及大于“info”的日志信息传递给root，本身并不打印；<br>root接到下级传递的信息，交给已经配置好的名为“console”的appender处理，“console” appender 将信息打印到控制台；</p>
<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16:00:17.407 logback [http-nio-8080-exec-8] INFO  com.dudu.controller.LearnController - 日志输出 info</span><br><span class="line">16:00:17.408 logback [http-nio-8080-exec-8] WARN  com.dudu.controller.LearnController - 日志输出 warn</span><br><span class="line">16:00:17.408 logback [http-nio-8080-exec-8] ERROR com.dudu.controller.LearnController - 日志输出 error</span><br></pre></td></tr></table></figure>



<p>第二种：带有多个loger的配置，指定级别，指定appender<br>logback-spring.xml增加 loger 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	&lt;!--logback.LogbackDemo：类的全路径 --&gt;</span><br><span class="line">	&lt;logger name&#x3D;&quot;com.dudu.controller.LearnController&quot; level&#x3D;&quot;WARN&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">    	&lt;appender-ref ref&#x3D;&quot;console&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;logger&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>


<p>控制com.dudu.controller.LearnController类的日志打印，打印级别为“WARN”;<br>additivity属性为false，表示此loger的打印信息不再向上级传递;<br>指定了名字为“console”的appender;</p>
<p>这时候执行com.dudu.controller.LearnController类的login方法时，先执行<logger name="com.dudu.controller.LearnController" level="WARN" additivity="false">,将级别为“WARN”及大于“WARN”的日志信息交给此loger指定的名为“console”的appender处理，在控制台中打出日志，不再向上级root传递打印信息。</p>
<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16:00:17.408 logback [http-nio-8080-exec-8] WARN  com.dudu.controller.LearnController - 日志输出 warn</span><br><span class="line">16:00:17.408 logback [http-nio-8080-exec-8] ERROR com.dudu.controller.LearnController - 日志输出 error</span><br></pre></td></tr></table></figure>


<p>当然如果你把additivity=”false”改成additivity=”true”的话，就会打印两次，因为打印信息向上级传递，logger本身打印一次，root接到后又打印一次。</p>
<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	&lt;logger name&#x3D;&quot;com.example.demo.controller&quot; level&#x3D;&quot;WARN&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">		&lt;appender-ref ref&#x3D;&quot;consoleLog&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;logger&gt;</span><br><span class="line"></span><br><span class="line">	&lt;logger name&#x3D;&quot;com.example.demo.controller&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;logger name&#x3D;&quot;com.example.demo&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p>范围有重叠的话，范围小的有效。</p>
<h4 id="配置多个环境日志输出"><a href="#配置多个环境日志输出" class="headerlink" title="配置多个环境日志输出"></a>配置多个环境日志输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;</span><br><span class="line">    &lt;springProfile name&#x3D;&quot;test,dev&quot;&gt;</span><br><span class="line">        &lt;logger name&#x3D;&quot;com.example.demo.controller&quot; level&#x3D;&quot;DEBUG&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;consoleLog&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;logger&gt;</span><br><span class="line">    &lt;&#x2F;springProfile&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 生产环境. --&gt;</span><br><span class="line">    &lt;springProfile name&#x3D;&quot;prod&quot;&gt;</span><br><span class="line">        &lt;logger name&#x3D;&quot;com.example.demo.controller&quot; level&#x3D;&quot;INFO&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;consoleLog&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;logger&gt;</span><br><span class="line">    &lt;&#x2F;springProfile&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p>application.yml增加环境选择的配置active: dev</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9010</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev  ##</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?characterEncoding&#x3D;utf8</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">    type-aliases-package: org.larry.springboot.entity</span><br><span class="line">    mapper-locations: classpath:mapper&#x2F;**&#x2F;*.xml</span><br><span class="line">    check-config-location: true</span><br></pre></td></tr></table></figure>

<p><code>active: 【test、dev、prod】</code>，根据 <code>active</code> 的环境，自动采用上面配置的<code>springProfile</code>的 <code>logger</code> 日志</p>
<h4 id="自定义日志路径（application-yml）"><a href="#自定义日志路径（application-yml）" class="headerlink" title="自定义日志路径（application.yml）"></a>自定义日志路径（application.yml）</h4><p>application.yml增加日志相关自定义配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logback:</span><br><span class="line">  logdir: &#x2F;Users&#x2F;inke&#x2F;dev&#x2F;log&#x2F;tomcat&#x2F;sell</span><br><span class="line">  appname: sell</span><br></pre></td></tr></table></figure>

<p>在<code>logback-spring.xml</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration scan&#x3D;&quot;true&quot; scanPeriod&#x3D;&quot;60 seconds&quot; debug&#x3D;&quot;false&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--application.yml 传递参数，不能使用logback 自带的&lt;property&gt;标签 --&gt;</span><br><span class="line">    &lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;appname&quot; source&#x3D;&quot;logback.appname&quot;&#x2F;&gt;</span><br><span class="line">    &lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;logdir&quot; source&#x3D;&quot;logback.logdir&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;contextName&gt;$&#123;appname&#125;&lt;&#x2F;contextName&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--输出到控制台 ConsoleAppender--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;consoleLog&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;!--展示格式 layout--&gt;</span><br><span class="line">        &lt;layout class&#x3D;&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;pattern&gt;</span><br><span class="line">                &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">            &lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;layout&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>



<h2 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h2><p>Log4j2中，分为 API(log4j-api）和实现(log4j-core) 两个模块。API 和slf4j 是一个类型，属于日志抽象/门面，而实现部分，才是Log4j 2的核心</p>
<p>org.apache.logging.log4j » log4j-api<br>org.apache.logging.log4j » log4j-core</p>
<h3 id="最强的异步性能"><a href="#最强的异步性能" class="headerlink" title="最强的异步性能"></a>最强的异步性能</h3><p>这个特性，算是Log4j2最强之处了。log4j2 在目前JAVA中的日志框架里，异步日志的性能是最高的，没有之一。</p>
<p>先来看一下，几种日志框架benchmark对比结果（log4j2官方测试结果）：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbud04zKMfzAHZpZVJUjlYHYeL1BnibI4oKRDJsacJHsBliczJexYqib0HeQdkj60C2XKyuMg3jEHXWhrA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>从图上可以看出，log4j2的异步（全异步，非混合模式）下的性能，远超log4j1和logback，简直吊打。压力越大的情况下，吞吐上的差距就越大。在64线程测试下，log4j2的吞吐达到了180w+/s，而logback/log4j1只有不到20w，相差近十倍</p>
<h3 id="零GC（Garbage-free）"><a href="#零GC（Garbage-free）" class="headerlink" title="零GC（Garbage-free）"></a>零GC（Garbage-free）</h3><p>从2.6版本开始（2016年），log4j2 默认就以零GC模式运行了。什么叫零GC呢？就是不会由于log4j2而导致GC。</p>
<p>log4j2 中各种Message对象，字符串数组，字节数组等全部复用，不重复创建，大大减少了无用对象的创建，从而做到“零GC”。</p>
<h3 id="更高性能-I-O-写入的支持"><a href="#更高性能-I-O-写入的支持" class="headerlink" title="更高性能 I/O 写入的支持"></a>更高性能 I/O 写入的支持</h3><p>log4j 还提供了一个MemoryMappedFileAppender，I/O 部分使用MemoryMappedFile来实现，可以得到极高的I/O性能。不过在使用MemoryMappedFileAppender之前，得确定你足够了解MemoryMappedFile的相关知识，否则不要轻易使用呦。</p>
<h3 id="更强大的参数格式化"><a href="#更强大的参数格式化" class="headerlink" title="更强大的参数格式化"></a>更强大的参数格式化</h3><p>API模块和slf4j相比，提供了更丰富的参数格式化功能。</p>
<p>使用{}占位符格式化参数</p>
<p>在slf4j里，我们可以用{}的方式来实现“format”的功能（参数会直接toString替换占位符），像下面这样：</p>
<p>logger.debug(“Logging in user {} with birthday {}”, user.getName(), user.getBirthdayCalendar());</p>
<h3 id="使用String-format的形式格式化参数"><a href="#使用String-format的形式格式化参数" class="headerlink" title="使用String.format的形式格式化参数"></a>使用String.format的形式格式化参数</h3><p>log4j2 中除了支持<code>&#123;&#125;</code>的参数占位符，还支持<code>String.format</code>的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Logger logger &#x3D; LogManager.getFormatterLogger(&quot;Foo&quot;);</span><br><span class="line"> </span><br><span class="line">logger.debug(&quot;Logging in user %s with birthday %s&quot;, user.getName(), user.getBirthdayCalendar());</span><br><span class="line">logger.debug(&quot;Logging in user %1$s with birthday %2$tm %2$te,%2$tY&quot;, user.getName(), user.getBirthdayCalendar());</span><br><span class="line">logger.debug(&quot;Integer.MAX_VALUE &#x3D; %,d&quot;, Integer.MAX_VALUE);</span><br><span class="line">logger.debug(&quot;Long.MAX_VALUE &#x3D; %,d&quot;, Long.MAX_VALUE);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果想使用<code>String.format</code>的形式，需要使用<code>LogManager.getFormatterLogger</code>而不是<code>LogManager.getLogger</code></p>
</blockquote>
<h3 id="使用logger-printf格式化参数"><a href="#使用logger-printf格式化参数" class="headerlink" title="使用logger.printf格式化参数"></a>使用logger.printf格式化参数</h3><p>log4j2 的 Logger接口中，还有一个printf方法，无需创建LogManager.getFormatterLogger，就可以使用String.format的形式</p>
<p>logger.printf(Level.INFO, “Logging in user %1$s with birthday %2$tm %2$te,%2$tY”, user.getName(), user.getBirthdayCalendar());</p>
<p>logger.debug(“Opening connection to {}…”, someDataSource);</p>
<h3 id="“惰性”打日志（lazy-logging）"><a href="#“惰性”打日志（lazy-logging）" class="headerlink" title="“惰性”打日志（lazy logging）"></a>“惰性”打日志（lazy logging）</h3><p>这个功能虽然小，但非常实用。</p>
<p>在某些业务流程里，为了留根或追溯问题，需要完整的打印入参，一般是把入参给用JSON/XML序列化后用debug级别打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(&quot;入参报文：&#123;&#125;&quot;,JSON.toJSONString(policyDTO));</span><br></pre></td></tr></table></figure>

<p>如果需要追溯问题时，会将系统的日志级别调到debug/trace，这样就可以打印。但是这里有个问题，虽然在info级别下debug不会输出内容，但<code>JSON.toJSONString()</code>这个序列化的代码一定会执行，严重影响正常流程下的执行效率。</p>
<p>我们期望的结果是info级别下，连序列化都不执行。这里可以通过isDebugEnable来判断当前配置下debug级别是否可以输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(logger.isDebugEnabled())&#123;</span><br><span class="line">    logger.debug(&quot;入参报文：&#123;&#125;&quot;,JSON.toJSONString(policyDTO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然可以避免不必要的序列化，但每个地方都这么写还是有点难受的，一行变成了三行。</p>
<p>log4j2 的 logger 对象，提供了一系列lambda的支持，通过这些接口可以实现“惰性”打日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void debug(String message, Supplier&lt;?&gt;... paramSuppliers);</span><br><span class="line">void info(String message, Supplier&lt;?&gt;... paramSuppliers);</span><br><span class="line">void trace(String message, Supplier&lt;?&gt;... paramSuppliers);</span><br><span class="line">void error(String message, Supplier&lt;?&gt;... paramSuppliers);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等同于下面的先判断，后打印</span><br><span class="line">logger.debug(&quot;入参报文：&#123;&#125;&quot;,() -&gt; JSON.toJSONString(policyDTO));</span><br><span class="line"></span><br><span class="line">if(logger.isDebugEnabled())&#123;</span><br><span class="line">    logger.debug(&quot;入参报文：&#123;&#125;&quot;,JSON.toJSONString(policyDTO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种 Supplier + Lambda 的形式，等同于上面的先判断 isDebugEnable 然后打印，三行的代码变成了一行。嗯，真香。</p>
<h3 id="更简化的配置"><a href="#更简化的配置" class="headerlink" title="更简化的配置"></a><strong>更简化的配置</strong></h3><p>Log4j2 同时支持XML/JSON/YML/Properties 四种形式的配置文件，不过最主流的还是XML的方式，最直观。</p>
<p>来看一下logback和log4j2的配置文件对比，同样功能的配置下：</p>
<p>logback.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"> &lt;appender name &#x3D; &quot;File&quot; class&#x3D; &quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;file&gt;logs&#x2F;app.log&lt;&#x2F;file&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;logs&#x2F;archives&#x2F;app-%d&#123;yyyy-MM-dd&#125;.log.gz&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">      &lt;!--一天内大于size就单独分隔--&gt;</span><br><span class="line">           &lt;maxFileSize&gt;1 GB&lt;&#x2F;maxFileSize&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line">    &lt;root level&#x3D;&quot;info&quot;&gt;</span><br><span class="line">      &lt;appender-ref ref&#x3D;&quot;File&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p>log4j2.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Configuration xmlns:xi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XInclude&quot;</span><br><span class="line">               status&#x3D;&quot;warn&quot; name&#x3D;&quot;XInclude&quot;&gt;</span><br><span class="line">    &lt;Appenders&gt;</span><br><span class="line">          &lt;RollingFile name&#x3D;&quot;File&quot; fileName&#x3D;&quot;logs&#x2F;app.log&quot; filePattern&#x3D;&quot;logs&#x2F;archives&#x2F;app-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;</span><br><span class="line">              &lt;PatternLayout pattern&#x3D;&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %5p [%t] %-40.40c&#123;1.&#125; : %m%n&quot;&#x2F;&gt;</span><br><span class="line">              &lt;Policies&gt;</span><br><span class="line">                  &lt;TimeBasedTriggeringPolicy &#x2F;&gt;</span><br><span class="line">                  &lt;!--一天内大于size就单独分隔--&gt;</span><br><span class="line">                  &lt;SizeBasedTriggeringPolicy size&#x3D;&quot;1 GB&quot;&#x2F;&gt;</span><br><span class="line">              &lt;&#x2F;Policies&gt;</span><br><span class="line">          &lt;&#x2F;RollingFile&gt;</span><br><span class="line">    &lt;&#x2F;Appenders&gt;</span><br><span class="line">    &lt;Loggers&gt;</span><br><span class="line">        &lt;Root level&#x3D;&quot;INFO&quot;&gt;</span><br><span class="line">            &lt;AppenderRef ref&#x3D;&quot;File&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Root&gt;</span><br><span class="line">    &lt;&#x2F;Loggers&gt;</span><br><span class="line">&lt;&#x2F;Configuration&gt;</span><br></pre></td></tr></table></figure>

<p>在log4j2中，appender的配置从使用 Appender 实现名即标签名的形式，语法上更简洁一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;RollingFile name&#x3D;&quot;File&quot;&gt;</span><br><span class="line">  &lt;!-- 等同于logback中的 --&gt;</span><br><span class="line">&lt;appender name &#x3D; &quot;File&quot; class&#x3D; &quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="与其他日志抽象-门面适配"><a href="#与其他日志抽象-门面适配" class="headerlink" title="与其他日志抽象/门面适配"></a><strong>与其他日志抽象/门面适配</strong></h3><p>log4j2 由于拆分为 API 和 实现两部分，所以可能也需要和其他日志框架进行适配</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbud04zKMfzAHZpZVJUjlYHYeicWMrJDe43KZIncMK9iaEibKN9AiaaFN2tmORjvibDdzq19sZ3ibv3Kiahlew/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="其他的特点"><a href="#其他的特点" class="headerlink" title="其他的特点"></a><strong>其他的特点</strong></h3><ul>
<li>异步队列使用高性能队列 - LMAX Disruptor</li>
<li>Appender丰富，有JMS/JPA/KAFKA/Http/MONGODB/CouchDB/Socket/Script等各种Appender的支持</li>
<li>支持自定义日志级别 ……</li>
</ul>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><p>终于介绍完了Log4j2的强大，现在来介绍下Log4j2的基本使用。</p>
<h3 id="引用log4j2的maven依赖"><a href="#引用log4j2的maven依赖" class="headerlink" title="引用log4j2的maven依赖"></a>引用log4j2的maven依赖</h3><p>log4j-api在log4j-core中已经有依赖了，直接依赖core即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.14.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>注意，引用log4j2时，需要注意项目中是否有多套日志框架共存/冲突，需要适配的问题。细节请参考上面的与其他日志抽象/门面适配</p>
<h3 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h3><p>首先是配置文件，默认的配置文件路径为：<code>classpath:log4j2.xml</code>（推荐使用xml）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Configuration xmlns:xi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XInclude&quot;</span><br><span class="line">               status&#x3D;&quot;warn&quot; name&#x3D;&quot;XInclude&quot;&gt;</span><br><span class="line">    &lt;Properties&gt;</span><br><span class="line">      &lt;Property name&#x3D;&quot;PATTERN&quot; value&#x3D;&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %5p [%t] %-40.40c&#123;1.&#125; : %m%n&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Properties&gt;</span><br><span class="line">    &lt;Appenders&gt;</span><br><span class="line">        &lt;!-- 输出到控制台，仅在本地开发环境使用 --&gt;</span><br><span class="line">          &lt;Console name&#x3D;&quot;Console&quot; target&#x3D;&quot;SYSTEM_OUT&quot;&gt;</span><br><span class="line">            &lt;PatternLayout pattern&#x3D;&quot;$&#123;PATTERN&#125;&quot;&#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;Console&gt;</span><br><span class="line">        &lt;!--输出到日志文件，滚动分割日志文件，自动打包gz--&gt;</span><br><span class="line">          &lt;RollingFile name&#x3D;&quot;File&quot; fileName&#x3D;&quot;logs&#x2F;app.log&quot; filePattern&#x3D;&quot;logs&#x2F;archives&#x2F;app-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;</span><br><span class="line">              &lt;PatternLayout pattern&#x3D;&quot;$&#123;PATTERN&#125;&quot;&#x2F;&gt;</span><br><span class="line">              &lt;Policies&gt;</span><br><span class="line">                 &lt;!--默认一天一个文件--&gt;</span><br><span class="line">                  &lt;TimeBasedTriggeringPolicy &#x2F;&gt;</span><br><span class="line">                  &lt;!--一天内大于size就单独分隔--&gt;</span><br><span class="line">                  &lt;SizeBasedTriggeringPolicy size&#x3D;&quot;1 GB&quot;&#x2F;&gt;</span><br><span class="line">              &lt;&#x2F;Policies&gt;</span><br><span class="line">          &lt;&#x2F;RollingFile&gt;</span><br><span class="line">    &lt;&#x2F;Appenders&gt;</span><br><span class="line">    &lt;Loggers&gt;</span><br><span class="line">       &lt;!-- 添加你的自定义logger，一般用于区分包名的日志，不同包名不同的级别&#x2F;appender --&gt;</span><br><span class="line">       &lt;!-- additivity 意思是，调用完当前appender，是否继续调用parent logger appender，默认true--&gt;</span><br><span class="line">       &lt;Logger name&#x3D;&quot;your logger&#x2F;package name&quot; level&#x3D;&quot;debug&quot; additivity&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">       &lt;!--默认的Root Logger 级别--&gt;</span><br><span class="line">        &lt;Root level&#x3D;&quot;INFO&quot;&gt;</span><br><span class="line">           &lt;!--这里需要区分下环境（配合maven profile之类的）--&gt;</span><br><span class="line">           &lt;!-- 开发环境使用Console Appender，生产环境使用File Appender --&gt;</span><br><span class="line">            &lt;AppenderRef ref&#x3D;&quot;Console&quot;&#x2F;&gt;</span><br><span class="line">           &lt;AppenderRef ref&#x3D;&quot;File&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Root&gt;</span><br><span class="line">    &lt;&#x2F;Loggers&gt;</span><br><span class="line">&lt;&#x2F;Configuration&gt;</span><br></pre></td></tr></table></figure>

<h3 id="XML配置文件语法"><a href="#XML配置文件语法" class="headerlink" title="XML配置文件语法"></a>XML配置文件语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;;</span><br><span class="line">&lt;Configuration&gt;</span><br><span class="line">  &lt;Properties&gt;</span><br><span class="line">    &lt;Property name&#x3D;&quot;name1&quot;&gt;value&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;Property name&#x3D;&quot;name2&quot; value&#x3D;&quot;value2&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Properties&gt;</span><br><span class="line">  &lt;filter  ... &#x2F;&gt;</span><br><span class="line">  &lt;Appenders&gt;</span><br><span class="line">    &lt;appender ... &gt;</span><br><span class="line">      &lt;filter  ... &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;&#x2F;Appenders&gt;</span><br><span class="line">  &lt;Loggers&gt;</span><br><span class="line">    &lt;Logger name&#x3D;&quot;name1&quot;&gt;</span><br><span class="line">      &lt;filter  ... &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Logger&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;Root level&#x3D;&quot;level&quot;&gt;</span><br><span class="line">      &lt;AppenderRef ref&#x3D;&quot;name&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Root&gt;</span><br><span class="line">  &lt;&#x2F;Loggers&gt;</span><br><span class="line">&lt;&#x2F;Configuration&gt;</span><br></pre></td></tr></table></figure>

<h3 id="创建Logger"><a href="#创建Logger" class="headerlink" title="创建Logger"></a>创建Logger</h3><p>直接使用log4j2的api：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line">Logger logger &#x3D; LogManager.getLogger(Log4j2Test.class);</span><br><span class="line">logger.error(...);</span><br><span class="line">logger.warn(...);</span><br><span class="line">logger.info(...);</span><br><span class="line">logger.debug(...);</span><br><span class="line">logger.trace(...);</span><br></pre></td></tr></table></figure>

<p>如果是配合slf4j使用也是可以的，只需要按照前面说的，提前做好适配，然后使用slf4j的api即可。不过如果是新系统的话，建议直接上log4j2的api吧，可以享受所有log4j2的功能，使用slf4j之类的api时，上面说的参数格式化之类的功能就无法使用了。</p>
<h3 id="全异步配置（重要！！）"><a href="#全异步配置（重要！！）" class="headerlink" title="全异步配置（重要！！）"></a>全异步配置（重要！！）</h3><p>推荐配置log4j2 全异步（all async），在你的启动脚本中增加一个系统变量的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dlog4j2.contextSelector&#x3D;org.apache.logging.log4j.core.async.AsyncLoggerContextSelector  </span><br></pre></td></tr></table></figure>





<h2 id="日志记录的思考"><a href="#日志记录的思考" class="headerlink" title="日志记录的思考"></a>日志记录的思考</h2><p>1.用spring aop的方式记录：只需要配置，但是不能区分方法</p>
<p>2.在每个方法种都写上记录日志的语句：针对性强，但是重复性代码多</p>
<p>最后项目里采用：</p>
<p>1.自定义一个注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface PrintlnLog &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自定义日志描述信息文案</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String description() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.设置springboot的切面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">//切面注解</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;&#125;)</span> <span class="comment">//指定打印日志的环境为本地</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.lineSeparator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以自定义 <span class="doctag">@PrintlnLog</span> 注解作为切面入口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@annotation</span> 是指定方法的具体日志信息</span></span><br><span class="line"><span class="comment">     * execution 是对连接点的所有方法进行日志打印，没有具体信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.swx.business.util.annotation.PrintlnLog)&quot;)</span></span><br><span class="line">    <span class="comment">//@Pointcut(&quot;execution(* com.swx.business.service.impl.*.*( .. ) )&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintlnLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 切面方法入参日志打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;PrintlnLog()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;------------------------------- start --------------------------&quot;</span>);</span><br><span class="line">        String methodDetailDescription = <span class="keyword">this</span>.getAspectMethodLogDescJP(joinPoint);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印自定义方法描述</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        log.info(<span class="string">&quot;方法描述: &#123;&#125;&quot;</span>, methodDetailDescription);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印请求入参</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        log.info(<span class="string">&quot;请求的参数: &#123;&#125;&quot;</span>, joinPoint.getArgs());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//AOP代理类的信息  </span></span><br><span class="line">        <span class="comment">//joinPoint.getThis();  </span></span><br><span class="line">        <span class="comment">//代理的目标对象  </span></span><br><span class="line">        <span class="comment">//joinPoint.getTarget(); </span></span><br><span class="line"></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != attributes) &#123;</span><br><span class="line">        <span class="comment">//防止出现</span></span><br><span class="line">            HttpServletRequest request = attributes.getRequest();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 打印请求方式</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            log.info(<span class="string">&quot;请求的类型: &#123;&#125;&quot;</span>, request.getMethod());</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 打印请求 url</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            log.info(<span class="string">&quot;请求的接口: &#123;&#125;&quot;</span>, request.getRequestURL().toString());</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//获取RequestAttributes  </span></span><br><span class="line">        <span class="comment">//RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();  </span></span><br><span class="line">        <span class="comment">//从获取RequestAttributes中获取HttpServletRequest的信息  </span></span><br><span class="line">        <span class="comment">//HttpServletRequest request = (HttpServletRequest) requestAttributes.resolveReference(RequestAttributes.REFERENCE_REQUEST);  </span></span><br><span class="line">        log.info(<span class="string">&quot;请求者的IP：&#123;&#125;&quot;</span>,request.getRemoteAddr());</span><br><span class="line">        <span class="comment">//如果要获取Session信息的话：  </span></span><br><span class="line">        <span class="comment">//HttpSession session = (HttpSession) requestAttributes.resolveReference(RequestAttributes.REFERENCE_SESSION); </span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印调用方法全路径以及执行方法</span></span><br><span class="line"><span class="comment">         */</span>       </span><br><span class="line">        <span class="comment">//AOP代理类的类（class）信息  </span></span><br><span class="line">        <span class="comment">//signature.getDeclaringType(); </span></span><br><span class="line">        log.info(<span class="string">&quot;请求的具体方法: &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proceedingJoinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 切面方法返回结果日志打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;PrintlnLog()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        String aspectMethodLogDescPJ = getAspectMethodLogDescPJ(proceedingJoinPoint);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Object result = proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        log.info(<span class="string">&quot;方法名为&#123;&#125;的返回结果 : &#123;&#125;&quot;</span>, aspectMethodLogDescPJ, JSON.toJSONString(result));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 方法执行耗时</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        log.info(<span class="string">&quot;该方法耗时: &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - startTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 切面方法执行后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;PrintlnLog()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;------------------------------- End --------------------------&quot;</span> + LINE_SEPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> <span class="doctag">@printlnLog</span> 注解作用的切面方法详细细信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAspectMethodLogDescJP</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String targetName = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        Object[] arguments = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">return</span> getAspectMethodLogDesc(targetName, methodName, arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proceedingJoinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> <span class="doctag">@printlnLog</span> 注解作用的切面方法详细细信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAspectMethodLogDescPJ</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String targetName = proceedingJoinPoint.getTarget().getClass().getName();</span><br><span class="line">        String methodName = proceedingJoinPoint.getSignature().getName();</span><br><span class="line">        Object[] arguments = proceedingJoinPoint.getArgs();</span><br><span class="line">        <span class="keyword">return</span> getAspectMethodLogDesc(targetName, methodName, arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 自定义注解参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAspectMethodLogDesc</span><span class="params">(String targetName, String methodName, Object[] arguments)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class targetClass = Class.forName(targetName);</span><br><span class="line">        Method[] methods = targetClass.getMethods();</span><br><span class="line">        StringBuilder description = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(methodName)) &#123;</span><br><span class="line">                Class[] clazzs = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (clazzs.length == arguments.length) &#123;</span><br><span class="line">                    description.append(method.getAnnotation(PrintlnLog.class).description());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> description.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.在项目里的方法上加(最好加在controller层)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PrintlnLog(description &#x3D; &quot;方法说明&quot;)</span><br></pre></td></tr></table></figure>

<p>4.实现效果</p>
<p><img src="/%E6%97%A5%E5%BF%97/image-20210918172933788.png" alt="image-20210918172933788"></p>
<p>注：这种Aop打印日志的方式一般只在测试、开发环境使用，因为会<strong>损耗一定的性能而延缓接口返回时间</strong>。所以如果需要在返回时间要求很高的生产环境使用的话，最好少在切点执行损耗性能的方法</p>
<p>aop切面的执行正常顺序为：@Before ，@Around，@After，@AfterReturning，@AfterThrowing</p>
<p>从Spring5.2.7开始，在相同@Aspect类中，通知方法将根据其类型按照从高到低的优先级进行执行：@Around，@Before ，@After，@AfterReturning，@AfterThrowing</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/09/02/%E6%97%A5%E5%BF%97/" data-id="ckw61sdx1006noswdc9er3mgl" data-title="日志" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-开源软件许可协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2021-08-27T01:48:03.000Z" itemprop="datePublished">2021-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/640" alt="图片"></p>
<p>MIT许可范围比较大</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/" data-id="ckw61sdvo0033oswd4mkhhoxl" data-title="开源软件许可协议" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-3.3.java开发工具之草稿本" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/23/3.3.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8B%E8%8D%89%E7%A8%BF%E6%9C%AC/" class="article-date">
  <time class="dt-published" datetime="2021-08-23T03:44:43.000Z" itemprop="datePublished">2021-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/23/3.3.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8B%E8%8D%89%E7%A8%BF%E6%9C%AC/">java开发工具之草稿本</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><p>需要下载扩展<strong>Language Support for Java™ by Red Hat</strong>，这个拓展更新到0.65.0之后，不再支持java8</p>
<p>Eclipse平台决定将JDK11作为9月发布的最低要求，而vscode是依赖eclipsejdt.ls服务器的，所以需要更新到JDK11</p>
<p>1.如果不是必须使用JDK8，可以选择更换为JDK11或更新</p>
<p>2.在<strong>settings.json</strong>中配置<strong>java.configuration.runtimes</strong>，这个配置仍然支持Java1.5到14<br>不过依旧需要安装JDK11，用来启动Java语言服务器，具体的编译版本则可以自行选择</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;java.home&quot;: &quot;&#x2F;path&#x2F;to&#x2F;jdk-11&quot;,</span><br><span class="line">&quot;java.configuration.runtimes&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;JavaSE-1.8&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;&#x2F;path&#x2F;to&#x2F;jdk-8&quot;,</span><br><span class="line">    &quot;default&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;JavaSE-11&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;&#x2F;path&#x2F;to&#x2F;jdk-11&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>3.照常使用以前版本，直接选中该拓展的设置–&gt;安装另一个版本–&gt;选择安装的版本：0.64.1</p>
<p>然后关闭拓展更新：<br>在设置中关闭<strong>Extensions: Auto Update</strong></p>
<p>VSCode打开并配置settings.json</p>
<p>1、直接打开 settings.json 文件</p>
<p>“C:\Users\Administrator\AppData\Roaming\Code\User”，默认在此路径下可以找到 settings.json 文件，直接打开即可。</p>
<p>或者</p>
<p>2、VSCode 中点击“设置”按钮</p>
<p>打开 VSCode 编辑器后，点击左下角“设置”按钮。</p>
<p>3、打开命令面板</p>
<p>在弹出的选择框中，选择“Command Palette”</p>
<p>也可以使用快捷键“Ctrl + Shift + P”打开命令面板</p>
<p>4、打开 settings.json 文件</p>
<p>在选择框的下拉列表中选择“Preferences: Open Settings (JSON)”</p>
<p>如果没有的话，可以在输入框中输入“settings”，这时就可以看到了</p>
<p>文件内容需要以逗号结尾</p>
<h2 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a>Sublime Text 3</h2><ol>
<li>首先找到Sublime Text 3 安装目录下的<code>Java.sublime-package</code>文件。</li>
<li>使用WinRAR或者其他解压软件打开上一步中说的文件</li>
<li>找到<code>JavaC.sublime-build</code>文件并且使用Sublime Text 3 打开，修改内容为下文给出的内容</li>
<li>然后保存，WinRAR会提示是否保存修改的文件到压缩文件，当然选是</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cmd&quot;: [&quot;javac&quot;, &quot;$file_name&quot;, &quot;&amp;&amp;&quot;, &quot;java&quot;, &quot;$file_base_name&quot;], </span><br><span class="line">    &quot;working_dir&quot;: &quot;$&#123;project_path:$&#123;folder&#125;&#125;&quot;, </span><br><span class="line">    &quot;selector&quot;: &quot;source.java&quot;, </span><br><span class="line">    &quot;shell&quot;: true, </span><br><span class="line">    &quot;encoding&quot;:&quot;utf-8&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.在文件里用快捷键：<code>ctrl+shift+b</code>或者<code>ctrl+b</code>运行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/08/23/3.3.java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8B%E8%8D%89%E7%A8%BF%E6%9C%AC/" data-id="ckw61sdv10017oswd758xeqm4" data-title="java开发工具之草稿本" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-消息中间件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2021-08-17T01:12:05.000Z" itemprop="datePublished">2021-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">消息中间件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发RocketMQ等。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><strong>Broker</strong></p>
<p>消息服务器，作为server提供消息核心服务</p>
<p><strong>Producer</strong></p>
<p>消息生产者，业务的发起方，负责生产消息传输给broker，</p>
<p><strong>Consumer</strong></p>
<p>消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</p>
<p><strong>Topic</strong></p>
<p>主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播</p>
<p><strong>Queue</strong></p>
<p>队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</p>
<p><strong>Message</strong></p>
<p>消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</p>
<h2 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h2><p><strong>点对点</strong></p>
<p>PTP点对点:使用queue作为通信载体</p>
<p><img src="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/getImage1" alt="img"></p>
<p>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。<br>消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p>
<p><strong>发布/订阅</strong></p>
<p>Pub/Sub发布订阅（广播）：使用topic作为通信载体</p>
<p><img src="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/getImage2" alt="img"></p>
<p>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。</p>
<p>queue实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。<br>topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到一个消息的拷贝。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p><strong>系统解耦</strong></p>
<p>交互系统之间没有直接的调用关系，只是通过消息传输，故系统侵入性不强，耦合度低。</p>
<p>   <strong>提高系统响应时间</strong></p>
<p>例如原来的一套逻辑，完成支付可能涉及先修改订单状态、计算会员积分、通知物流配送几个逻辑才能完成；通过MQ架构设计，就可将紧急重要（需要立刻响应）的业务放到该调用方法中，响应要求不高的使用消息队列，放到MQ队列中，供消费者处理。</p>
<p>   <strong>为大数据处理架构提供服务</strong></p>
<p>通过消息作为整合，大数据的背景下，消息队列还与实时处理架构整合，为数据处理提供性能支持。</p>
<p>   <strong>Java消息服务——JMS</strong></p>
<p>Java消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。<br>JMS中的P2P和Pub/Sub消息模式：点对点（point to point， queue）与发布订阅（publish/subscribe，topic）最初是由JMS定义的。这两种模式主要区别或解决的问题就是发送到队列的消息能否重复消费(多订阅)。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>异步通信</strong></p>
<p>有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p>
<p><strong>解耦</strong></p>
<p>降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p>
<p><strong>冗余</strong></p>
<p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p>
<p><strong>扩展性</strong></p>
<p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容。</p>
<p><strong>过载保护</strong></p>
<p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
<p><strong>可恢复性</strong></p>
<p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p>
<p><strong>顺序保证</strong></p>
<p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。</p>
<p><strong>缓冲</strong></p>
<p>在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。</p>
<p><strong>数据流处理</strong></p>
<p>分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择。</p>
<h2 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h2><p> <strong>AMQP协议</strong></p>
<p>AMQP即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。<br>优点：可靠、通用</p>
<p> <strong>MQTT协议</strong></p>
<p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。<br>优点：格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统</p>
<p><strong>STOMP协议</strong></p>
<p>STOMP（Streaming Text Orientated Message Protocol）是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。<br>优点：命令模式（非topic\queue模式）</p>
<p><strong>XMPP协议</strong></p>
<p>XMPP（可扩展消息处理现场协议，Extensible Messaging and Presence Protocol）是基于可扩展标记语言（XML）的协议，多用于即时消息（IM）以及在线现场探测。适用于服务器之间的准即时操作。核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。<br>优点：通用公开、兼容性强、可扩展、安全性高，但XML编码格式占用带宽大</p>
<p><strong>其他基于TCP/IP自定义的协议</strong></p>
<p>有些特殊框架（如：redis、kafka、zeroMq等）根据自身需要未严格遵循MQ规范，而是基于TCP\IP自行封装了一套协议，通过网络socket接口进行传输，实现了MQ的功能。</p>
<h2 id="常见消息中间件MQ介绍"><a href="#常见消息中间件MQ介绍" class="headerlink" title="常见消息中间件MQ介绍"></a>常见消息中间件MQ介绍</h2><p><strong>RocketMQ</strong></p>
<p>阿里系下开源的一款分布式、队列模型的消息中间件，原名Metaq，3.0版本名称改为RocketMQ，是阿里参照kafka设计思想使用java实现的一套mq。同时将阿里系内部多款mq产品（Notify、metaq）进行整合，只维护核心功能，去除了所有其他运行时依赖，保证核心功能最简化，在此基础上配合阿里上述其他开源产品实现不同场景下mq的架构，目前主要多用于订单交易系统。</p>
<p>具有以下特点：</p>
<ul>
<li>能够保证严格的消息顺序</li>
<li>提供针对消息的过滤功能</li>
<li>提供丰富的消息拉取模式</li>
<li>高效的订阅者水平扩展能力</li>
<li>实时的消息订阅机制</li>
<li>亿级消息堆积能力</li>
</ul>
<p>官方提供了一些不同于kafka的对比差异：<br><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/motivation/">https://rocketmq.apache.org/docs/motivation/</a></p>
<p>   <strong>RabbitMQ</strong></p>
<p>使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。</p>
<p>   <strong>ActiveMQ</strong></p>
<p>Apache下的一个子项目。使用Java完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，少量代码就可以高效地实现高级应用场景。可插拔的传输协议支持，比如：in-VM, TCP, SSL, NIO, UDP, multicast, JGroups and JXTA transports。RabbitMQ、ZeroMQ、ActiveMQ均支持常用的多种语言客户端 C++、Java、.Net,、Python、 Php、 Ruby等。</p>
<p>   <strong>Redis</strong></p>
<p>使用C语言开发的一个Key-Value的NoSQL数据库，开发维护很活跃，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p>
<p>   <strong>Kafka</strong></p>
<p>Apache下的一个子项目，使用scala实现的一个高性能分布式Publish/Subscribe消息队列系统，具有以下特性：</p>
<ul>
<li><p>快速持久化：通过磁盘顺序读写与零拷贝机制，可以在O(1)的系统开销下进行消息持久化；</p>
</li>
<li><p>高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；</p>
</li>
<li><p>高堆积：支持topic下消费者较长时间离线，消息堆积量大；</p>
</li>
<li><p>完全的分布式系统：Broker、Producer、Consumer都原生自动支持分布式，依赖zookeeper自动实现复杂均衡；</p>
</li>
<li><p>支持Hadoop数据并行加载：对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。</p>
<p> <strong>ZeroMQ</strong></p>
</li>
</ul>
<p>号称最快的消息队列系统，专门为高吞吐量/低延迟的场景开发，在金融界的应用中经常使用，偏重于实时数据通信场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，开发成本高。因此ZeroMQ具有一个独特的非中间件的模式，更像一个socket library，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序本身就是使用ZeroMQ API完成逻辑服务的角色。但是ZeroMQ仅提供非持久性的队列，如果down机，数据将会丢失。如：Twitter的Storm中使用ZeroMQ作为数据流的传输。</p>
<p>ZeroMQ套接字是与传输层无关的：ZeroMQ套接字对所有传输层协议定义了统一的API接口。默认支持 进程内(inproc) ，进程间(IPC) ，多播，TCP协议，在不同的协议之间切换只要简单的改变连接字符串的前缀。可以在任何时候以最小的代价从进程间的本地通信切换到分布式下的TCP通信。ZeroMQ在背后处理连接建立，断开和重连逻辑。</p>
<p>特性：</p>
<ul>
<li>无锁的队列模型：对于跨线程间的交互（用户端和session）之间的数据交换通道pipe，采用无锁的队列算法CAS；在pipe的两端注册有异步事件，在读或者写消息到pipe的时，会自动触发读写事件。</li>
<li>批量处理的算法：对于批量的消息，进行了适应性的优化，可以批量的接收和发送消息。</li>
<li>多核下的线程绑定，无须CPU切换：区别于传统的多线程并发模式，信号量或者临界区，zeroMQ充分利用多核的优势，每个核绑定运行一个工作者线程，避免多线程之间的CPU切换开销。</li>
</ul>
<p>比较图</p>
<p><img src="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/20170816171523564" alt="img"></p>
<p>一般使用rabbitmq和kafka居多。一般RocketMQ可以的，Kafka偏向日志采集</p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>RabbitMQ是由Erlang语言编写的实现了高级消息队列协议（AMQP）的开源消息代理软件（也可称为 面向消息的中间件）。支持Windows、Linux/Unix、MAC OS X操作系统和包括JAVA在内的多种编程语言。</p>
<p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受 客户端/中间件 不同产品，不同的开发语言等条件的限制</p>
<h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p><img src="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/20171227105213712" alt="img"></p>
<p>（1）Broker：经纪人。提供一种传输服务，维护一条从生产者到消费者的传输线路，保证消息数据能按照指定的方式传输。粗略的可以将图中的RabbitMQ Server当作Broker。</p>
<p>（2）Exchange：消息交换机。指定消息按照什么规则路由到哪个队列Queue。</p>
<p>（3）Queue：消息队列。消息的载体，每条消息都会被投送到一个或多个队列中。</p>
<p>（4）Binding：绑定。作用就是将Exchange和Queue按照某种路由规则绑定起来。</p>
<p>（5）RoutingKey：路由关键字。Exchange根据RoutingKey进行消息投递。</p>
<p>（6）Vhost：虚拟主机。一个Broker可以有多个虚拟主机，用作不同用户的权限分离。一个虚拟主机持有一组Exchange、Queue和Binding。</p>
<p>（7）Producer：消息生产者。主要将消息投递到对应的Exchange上面。一般是独立的程序。</p>
<p>（8）Consumer：消息消费者。消息的接收者，一般是独立的程序。</p>
<p>（9）Channel：消息通道，也称信道。在客户端的每个连接里可以建立多个Channel，每个Channel代表一个会话任务。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>AMQP模型中，消息在producer中产生，发送到MQ的exchange上，exchange根据配置的路由方式投递到相应的Queue上，Queue又将消息发送给已经在此Queue上注册的consumer，消息从queue到consumer有push和pull两种方式。</p>
<p>消息队列的使用过程大概如下：</p>
<p>（1）客户端连接到消息队列服务器，打开一个channel。</p>
<p>（2）客户端声明一个exchange，并设置相关属性。</p>
<p>（3）客户端声明一个queue，并设置相关属性。</p>
<p>（4）客户端使用routing key，在exchange和queue之间建立好Binding关系。</p>
<p>（5）生产者客户端投递消息到exchange。</p>
<p>（6）exchange接收到消息后，就根据消息的RoutingKey和已经设置的binding，进行消息路由（投递），将消息投递到一个或多个队列里。</p>
<p>（7）消费者客户端从对应的队列中获取并处理消息。</p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>生产者客户端：<br>客户端连接到RabbitMQ服务器上，打开一个消息通道（channel）；<br>客户端声明一个消息交换机（exchange），并设置相关属性。<br>客户端声明一个消息队列（queue），并设置相关属性。<br>客户端使用routing key在消息交换机（exchange）和消息队列（queue）中建立好绑定关系。<br>客户端投递消息都消息交换机（exchange）上<br>客户端关闭消息通道（channel）以及和服务器的连接。<br>服务器端：<br>exchange接收到消息后，根据消息的key和以及设置的binding，进行消息路由，将消息投递到一个或多个消息队列中。</p>
<p>关于exchange也有几个类型：</p>
<p>(1). Direct交换机：完全根据key进行投递。例如，绑定时设置了routing key为abc，客户端提交信息提交信息时只有设置了key为abc的才会投递到队列；</p>
<p>(2).Topic交换机：在key进行模式匹配后进行投递。例如：符号<code>#</code>匹配一个或多个字符，符号<code>*</code>匹配一串连续的字母字符，例如<code>abc.#</code>可以匹配<code>abc.def.ghi</code>，而<code>abc.*</code>只可以匹配<code>abc.def</code>。</p>
<p>(3).Fanout交换机：它采取广播模式，消息进来时，将会被投递到与改交换机绑定的所有队列中。</p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>RabbitMQ支持数据持久化，也就是把数据写在磁盘上，可以增加数据的安全性。消息队列持久化包括三个部分：</p>
<p>1.消息交换机（exchange）持久化，在声明时指定durable为1<br>2.消息队列（queue）持久化，在声明时指定durable为1<br>3.消息持久化，在投递时指定delivery_mode为2（1是非持久化）<br>如果消息交换机（exchange）和消息队列（queue）都是持久化的话，那么他们之间的绑定（Binding）也是持久化的。如果消息交换机和消息队列之间一个持久化、一个非持久化，那么就不允许绑定。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><p>适用场景：比较适合异步传输。</p>
<p>异步：发送方不关心消息有没有发送成功，只发送消息，不去获取消息是否发送成功。</p>
<p>同步：发送方关心消息是否发送成功，发送消息后，会等待接收方返回状态码，根据状态码来判断是否发送成功，然后执行相对于的动作。</p>
<p>下边以Http中的同步和异步为例：</p>
<p>如：普通的B/S架构客户端和服务器端之间的通信就是同步的，即提交请求 —&gt; 等待服务器处理完毕返回消息 —&gt; 拿到服务器返回的消息，处理完毕。</p>
<p>如：Ajax技术就是异步的，请求通过事件触发 —&gt; 服务器处理（浏览器不用等待，仍可以做其他的事情） —&gt; 处理完毕。</p>
<p>有人可能会好奇说应用场景怎么说到了同步和异步，那说明你还不是很理解技术和应用场景之间的紧密联系。</p>
<p>优点：</p>
<p>（1）由Erlang语言开发，支持大量协议：AMQP、XMPP、SMTP、STOMP。</p>
<p>（2）支持消息的持久化、负载均衡和集群，且集群易扩展。</p>
<p>（3）具有一个Web监控界面，易于管理。</p>
<p>（4）安装部署简单，上手容易，功能丰富，强大的社区支持。</p>
<p>（5）支持消息确认机制、灵活的消息分发机制。</p>
<p>缺点：</p>
<p>（1）由于牺牲了部分性能来换取稳定性，比如消息的持久化功能，使得RabbitMQ在大吞吐量性能方面不及Kafka和ZeroMQ。</p>
<p>（2）由于支持多种协议，使RabbitMQ非常重量级，比较适合企业级开发。</p>
<p>因此当需要一个稳定的、高可靠性的、功能强大且易于管理的消息队列可以选择RabbitMQ。如果对消息吞吐量需求较大，且不在乎消息偶尔丢失的情况可以使用Kafka。</p>
<h3 id="Exchange类型"><a href="#Exchange类型" class="headerlink" title="Exchange类型"></a>Exchange类型</h3><h4 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h4><p>（1）名称：直接交换器类型</p>
<p>（2）默认的预先定义exchange名字：空字符串或者amq.direct</p>
<p>（3）作用描述：根据Binding指定的Routing Key，将符合Key的消息发送到Binding的Queue。可以构建点对点消息传输模型。</p>
<p> <img src="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/20171227105349845" alt="img"></p>
<p>如图中RoutingKey分别是error、info、warning，其中error被Binding（绑定）到queue1和queue2上，info和warning被Binding到queue2上。当消息的RoutingKey是error，这条消息将被投递到queue1和queue2中（相当于消息被复制成两个分别投放到两个queue中），然后分别被Consumer1和Consumer2处理。如果消息的RoutingKey是info或者warning，这条消息只会被投递到queue2中，然后被Consumer2处理。如果消息的RoutingKey是其他的字符串，这条消息则会被丢弃。</p>
<h4 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h4><p>（1）名称：广播式交换器类型</p>
<p>（2）默认的预先定义exchange名字：amq.fanout</p>
<p>（3）作用描述：将同一个message发送到所有同该Exchange 绑定的queue。不论RoutingKey是什么，这条消息都会被投递到所有与此Exchange绑定的queue中。</p>
<p><img src="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/20171227105444277" alt="img"> </p>
<p>广播式交换器类型的工作方式：不使用任何参数将queue和Exchange进行Binding，发布者publisher向Exchange发送一条消息（注意：直接交换器类型中的producer变成了publisher，其中隐含了两种交换器的区别），然后这条消息被无条件的投递给所有和这个Exchange绑定的queue中。</p>
<p>如图中，没有RoutingKey的限制，只要消息到达Exchange，都会被投递到queue1和queue2中，然后被对应的Consumer处理。</p>
<h4 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h4><p>（1）名称：主题交换器类型</p>
<p>（2）默认的预先定义exchange名字：amq.topic</p>
<p>（3）作用描述：根据Binding指定的RoutingKey，Exchange对key进行模式匹配后投递到相应的Queue，模式匹配时符号“#”匹配一个或多个词，符号“*”匹配正好一个词，而且单词与单词之间必须要用“.”符号进行分隔。此模式可以用来支持经典的发布/订阅消息传输模型-使用主题名字空间作为消息寻址模式，将消息传递给那些部分或者全部匹配主题模式的queue。</p>
<p><img src="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/20171227105530591" alt="img"></p>
<p>如图中，假如消息的RoutingKey是American.action.13，这条消息将被投递到Q1和Q2中。假如RoutingKey是American.action.13.test（注意：此处是四个词），这条消息将会被丢弃，因为没有routingkey与之匹配。假如RoutingKey是Chinese.action.13，这条消息将被投递到Q2和Q3中。假如RoutingKey是Chinese.action.13.test，这条消息只会被投递到Q3中，#可以匹配一个或者多个单词，而*只能匹配一个词。</p>
<h4 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h4><p>（1）名称：标题交换器类型</p>
<p>（2）默认的预先定义exchange名字：amq.match和amq.headers</p>
<p>（3）作用描述：同direct exchange类似，不同之处是不再使用Routing Key路由，而是使用headers（Message attributes）进行匹配路由到指定Queue。</p>
<p>Headers类型的exchange使用的比较少，它也是忽略routingKey的一种路由方式。是使用Headers来匹配的。Headers是一个键值对，可以定义成HashTable。发送者在发送的时候定义一些键值对，接收者也可以再绑定时候传入一些键值对，两者匹配的话，则对应的队列就可以收到消息。匹配有两种方式all和any。这两种方式是在接收端必须要用键值”x-mactch”来定义。all代表定义的多个键值对都要满足，而any则代码只要满足一个就可以了。fanout，direct，topic exchange的routingKey都需要要字符串形式的，而headers exchange则没有这个要求，因为键值对的值可以是任何类型。</p>
<h1 id="ACK机制"><a href="#ACK机制" class="headerlink" title="ACK机制"></a>ACK机制</h1><p><img src="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/20191201130415769.png" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" data-id="ckw61sdwo0064oswd4wqk7c2n" data-title="消息中间件" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JPA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/26/JPA/" class="article-date">
  <time class="dt-published" datetime="2021-07-26T01:56:34.000Z" itemprop="datePublished">2021-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/26/JPA/">JPA</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JPA全称Java Persistence API，用于对象持久化的 API，可以通过注解或者XML描述【对象-关系表】之间的映射关系，并将实体对象持久化到数据库中。</p>
<p>操作数据库：</p>
<p>​    首先是 JDBC 阶段，初学 JDBC 可能会使用原生的 JDBC 的 API，再然后可能会使用数据库连接池，比如：c3p0、dbcp，还有一些第三方工具，比如 dbutils 等 JDBC 是贯穿始终的，即使到了框架部分，也会对 JDBC 进行整合，此阶段还是自己手写 SQL 语句。</p>
<p>​    然后就是 Hibernate，操作数据库可以不用自己手动编写 SQL，调用 Hibernate 提供的 API 即可。</p>
<p>​    现在用JPA，即 Java 持久层的 API，JPA 与 SpringData 结合起来会事半功倍。</p>
<p>JPA为我们提供了：</p>
<p>1）ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中；</p>
<p>如：@Entity、@Table、@Column、@Transient等注解。</p>
<p> 2）JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。</p>
<p>如：entityManager.merge(T t)；</p>
<p> 3）JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</p>
<p>如：from Student s where s.name = ?</p>
<p>但是：</p>
<p>JPA仅仅是一种规范，也就是说JPA仅仅定义了一些接口，而接口是需要实现才能工作的。所以底层需要某种实现，而Hibernate就是实现了JPA接口的ORM框架。</p>
<p>JPA是一套ORM规范，Hibernate实现了JPA规范，JPA 是 Hibernate 的一个抽象，就像 JDBC 和 JDBC 驱动的关系</p>
<p><img src="/JPA/fd5e9c1f88bcdb6c41f6685998b44e0f068.jpg" alt="img"></p>
<p>spirng data jpa是spring提供的一套简化JPA开发的框架，按照约定好的【方法命名规则】写dao层接口，就可以在不写接口实现的情况下，实现对数据库的访问和操作。同时提供了很多除了CRUD之外的功能，如分页、排序、复杂查询等等。</p>
<p>Spring Data JPA 可以理解为 JPA 规范的再次封装抽象，底层还是使用了 Hibernate 的 JPA 技术实现。如图：</p>
<p><img src="/JPA/3169065e3f44e0994f9a01e0df7ed38fe7a.jpg" alt="img"></p>
<p>接口约定命名规则：</p>
<p><img src="/JPA/2da91405d2138b4ddedb7b148f0d43bc219.jpg" alt="img"></p>
<p>例子：</p>
<p><img src="/JPA/719f690bc8bc60365371478aa84fa014ab7.jpg" alt="img"></p>
<p><img src="/JPA/eddc9d37ac7656fd90a2e5093441775905f.jpg" alt="img"></p>
<p>springboot集成spring data jpa只需两步：</p>
<p>第一步：导入maven坐标</p>
<p><img src="/JPA/2bac153bb2147283bb1b9dd0c7937e47ff7.jpg" alt="img"></p>
<p>第二步：yml配置文件中配置jpa信息</p>
<p><img src="/JPA/334e8961dbfee889d19cd2febfdf6d68153.jpg" alt="img"></p>
<p>JPA的基本注解</p>
<p>\1. <strong>@Entity</strong> ：修饰实体类，指明该类将映射到指定的数据表，例如：Customer 类默认的数据表名为 customer</p>
<p>\2. <strong>@Table</strong> ：当实体类与映射的数据库表名不同名时需要使用 @Table 注解，该注解与 @Entity 注解并列使用，使用其 <strong>name 属性</strong>指明数据库的表名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 @Table(name &#x3D; &quot;JPA_CUSTOMER&quot;)</span><br><span class="line">2 @Entity</span><br><span class="line">3 public class Customer &#123;</span><br></pre></td></tr></table></figure>

<p>\3. <strong>@Id</strong> ：标识该属性为<strong>主键</strong>，<strong>一般标注在该属性的 getter 方法上</strong></p>
<p>\4. <strong>@GeneratedValue</strong> ：标注<strong>主键的生成策略</strong>，通过其 <strong>strategy 属性</strong>。通常与 @Id 注解一起使用。默认情况下 JPA 会自动选择一个最适合底层数据库的主键生成策略，MySQL 默认为 AUTO，常用策略有：</p>
<p>–IDENTITY：采用数据库 ID自增长的方式来自增主键字段，Oracle 不支持这种方式；</p>
<p>–<strong>AUTO</strong>： <strong>JPA自动选择合适的策略，是默认选项；</strong></p>
<p>–SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式</p>
<p>–TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植</p>
<p><img src="/JPA/1105175-20171021112827318-172117315.png" alt="img"></p>
<p>\5. <strong>@Basic</strong> ：用于<strong>没有任何标注的 getXxx() 方法</strong>，默认即为 @Basic,所以若一个 getter 方法无任何注解，可以使用 @Basic 注解，也可以不使用</p>
<p>\6. <strong>@Column</strong> ：当<strong>实体的属性与其映射的数据表的列不同名时使用</strong>，一般用于 getter 方法上。其 <strong>name 属性用来指明此属性在数据表中对应的列名</strong>；<strong>unique 属性</strong>指明<strong>是否为唯一约束</strong>；<strong>nullable 属性</strong>用来<strong>指明是否可以为空，false 为不能为空</strong>；<strong>length 属性</strong>指明<strong>此列的长度</strong>。</p>
<p> <img src="/JPA/1105175-20171021112851349-1276707637.png" alt="img"></p>
<p>\7. <strong>@Transient</strong> ：<strong>标注此注解后在创建数据表的时候将会忽略该属性</strong> Customer 类并没有 info 这个属性，所以数据库中也不应该有 info 这个字段</p>
<p><strong><img src="/JPA/1105175-20171021112909631-794791158.png" alt="img"></strong></p>
<p>\8. <strong>@Temporal</strong> ：向数据库<strong>映射日期（Date）属性时用来调整映射的精度</strong>。Date 类型的数据有 DATE, TIME, 和 TIMESTAMP 三种精度(即单纯的日期,时间,或者两者兼备).</p>
<p>Birth 属性应该使用 DATE 类型(生日只具体到日即可，如：2015-10-22)，而 CreateTime 应该使用 TIMESTAMP 类型(创建时间应该具体到秒，如：2017-10-11 22:39:13)</p>
<p><img src="/JPA/1105175-20171021112937068-389580636.png" alt="img"></p>
<p>补冲：使用 <strong>TABLE 生成主键</strong>详解</p>
<p>1.创建一个数据表 jpa_id_generators，并添加几条数据</p>
<p> <img src="/JPA/1105175-20171021113033381-394453727.png" alt="img"></p>
<p>\2. 配置使用 TABLE 主键生成策略</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 1 　　 &#x2F;&#x2F;使用 TABLE 主键生成策略</span><br><span class="line"> 2     @TableGenerator(name&#x3D;&quot;ID_GENERATOR&quot;, &#x2F;&#x2F;该主键生成策略的名称，与 @GeneratedValue 的 generator 属性值对应</span><br><span class="line"> 3     table&#x3D;&quot;jpa_id_generators&quot;, &#x2F;&#x2F; 指明根据哪个表生成主键</span><br><span class="line"> 4     pkColumnName&#x3D;&quot;PK_NAME&quot;, &#x2F;&#x2F; 使用 pkColumnName pkColumnValue valueColumnName 三个属性唯一的定位一个点</span><br><span class="line"> 5     pkColumnValue&#x3D;&quot;CUSTOMER_ID&quot;,</span><br><span class="line"> 6     valueColumnName&#x3D;&quot;PK_VALUE&quot;,</span><br><span class="line"> 7     allocationSize&#x3D;100) &#x2F;&#x2F;指定每次增加的数量</span><br><span class="line"> 8     @GeneratedValue(strategy&#x3D;GenerationType.TABLE, generator&#x3D;&quot;ID_GENERATOR&quot;)</span><br><span class="line"> 9     @Id</span><br><span class="line">10     public Integer getId() &#123;</span><br><span class="line">11         return id;</span><br><span class="line">12     &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>附一张表说明：</p>
<p><img src="/JPA/1105175-20171021113500099-1494273921.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/07/26/JPA/" data-id="ckw61sdvm002yoswd3b6mgq0q" data-title="JPA" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4.27.序列化与反序列化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/30/4.27.%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2021-06-30T00:55:09.000Z" itemprop="datePublished">2021-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/30/4.27.%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">序列化与反序列化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>实现Serializable接口的目的是为类可持久化，比如在网络传输或本地存储，为系统的分布和异构部署提供先决条件。serialVersionUID其实是验证版本一致性的</p>
<p>若没有序列化，现在我们所熟悉的远程调用，对象数据库都不可能存在，serialVersionUID适用于java序列化机制。简单来说，JAVA序列化的机制是通过 判断类的serialVersionUID来验证的版本一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID于本地相应实体类的serialVersionUID进行比较。如果相同说明是一致的，可以进行反序列化，否则会出现反序列化版本一致的异常，即是InvalidClassException</p>
<p><strong>具体序列化的过程是这样的：</strong>序列化操作时会把系统当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会自动检测文件中的serialVersionUID，判断它是否与当前类中的serialVersionUID一致。如果一致说明序列化文件的版本与当前类的版本是一样的，可以反序列化成功，否则就失败；</p>
<p><strong>serialVersionUID有两种显示的生成方式：</strong><br>一是默认的1L，比如：private static final long serialVersionUID = 1L;    </p>
<p>二是根据包名，类名，继承关系，非私有的方法和属性，以及参数，返回值等诸多因子计算得出的，极度复杂生成的一个64位的哈希字段。基本上计算出来的这个值是唯一的。比如：private static final long serialVersionUID = xxxxL;<br>注意：显示声明serialVersionUID可以避免对象不一致，</p>
<p>当一个类实现类Serializable接口，如果没有显示定义serialVersionUID，Eclipse会自动给出相应的提醒；面对这种情况，我们只需要在Eclipse中点击类的warning图标，Eclipse就会自动给出两种生成方式。如果不想定义，在Eclipse的设置中也可以把它关掉的，设置如下：<br>Window ==&gt; Preferences ==&gt; Java ==&gt; Compiler ==&gt; Error/Warnings ==&gt; Potential programming problems</p>
<p>将Serializable class without serialVersionUID的warning改成ignore即可。</p>
<p>当实现java.io.Serializable接口中没有显示的定义serialVersionUID变量的时候，JAVA序列化机制会根据Class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，如果Class文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，serialVersionUID也不会变化的。</p>
<p>如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，就需要显示的定义一个serialVersionUID，类型为long的变量。不修改这个变量值的序列化实体，都可以相互进行序列化和反序列化。</p>
<p>下面用代码说明一下serialVersionUID在应用中常见的几种情况。<br>（1）序列化实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.entity.serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4359709211352400087L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Long id, String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        userName = <span class="string">&quot;dddbbb&quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.toString() + <span class="string">&quot;--&quot;</span> + name.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）序列化功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.entity.serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Persion p = <span class="keyword">new</span> Person(<span class="number">1L</span>, <span class="string">&quot;陈俊生&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person Seria:&quot;</span> + p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Persion.txt&quot;</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(p);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）反序列化功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.entity.serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserialTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Person p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Persion.txt&quot;</span>);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            p = (Persion) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            System.out.println(p.toString());</span><br><span class="line">            System.out.println(p.userName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况一：Person类序列化之后，从A端传到B端，然后在B端进行反序列化，在序列化Persion和反序列化Persion的时候A和B端都需要一个相同的类。如果两处的serialVersionUID不一致，会产生什么样的效果呢。<br>【答案】可以利用上面的代码做个试验来验证：</p>
<p>先执行测试类SerialTest，生成序列化文件，代表A端序列化后的文件，然后修改serialVersion值，再执行测试类DeserialTest，代表B端使用不同serialVersion的类去反序列化，结果报错:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.example.demo.entity.serializable.Persion; local class incompatible: stream classdesc serialVersionUID = 4359709211352400087, local class serialVersionUID = 4359709211352400082</span><br><span class="line">	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="number">616</span>)</span><br><span class="line">	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="number">1843</span>)</span><br><span class="line">	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1713</span>)</span><br><span class="line">	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2000</span>)</span><br><span class="line">	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1535</span>)</span><br><span class="line">	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">422</span>)</span><br><span class="line">	at com.example.demo.entity.serializable.DeserialTest.main(DeserialTest.java:<span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>情况二：假设两处serialVersionUID一致，如果A端增加一个字段，然后序列化，而B端不变，然后反序列化，会是什么情况呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.entity.serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4359709211352400082L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Long id, String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.toString() + <span class="string">&quot;--&quot;</span> + name.toString() + <span class="string">&quot;age:&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.entity.serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="number">1L</span>, <span class="string">&quot;陈俊生&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person Seria:&quot;</span> + p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Persion.txt&quot;</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(p);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person DeserialPerson:1–陈俊生</p>
<p><strong>【答案】</strong>新增 public int age; 执行SerialTest，生成序列化文件，代表A端。删除 public int age，反序列化，代表B端，最后的结果为：执行序列化，反序列化正常，但是A端增加的字段丢失(被B端忽略)。</p>
<p>情况三：假设两处serialVersionUID一致，如果B端减少一个字段，A端不变，会是什么情况呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.entity.serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4359709211352400082L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"><span class="comment">//    public int age;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(Long id, String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="comment">//        this.age = age;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Persion:&quot;</span>+id.toString() + <span class="string">&quot;name:&quot;</span> + name.toString() ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person DeserialPerson: 1234,age:0</p>
<p>【答案】序列化，反序列化正常，B端字段少于A端，A端多的字段值丢失(被B端忽略)。</p>
<p>情况四： 假设两处serialVersionUID一致，如果B端增加一个字段，A端不变，会是什么情况呢?<br>验证过程如下：<br>先执行SerialTest，然后在实体类Person增加一个字段age，如下所示，再执行测试类DeserialTest.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sf.code.serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1234567890L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public Person(int id, String name, int age) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        this.id = id;</span></span><br><span class="line"><span class="comment">        this.name = name;</span></span><br><span class="line"><span class="comment">        this.age = age;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person: &quot;</span> + id </span><br><span class="line">                + <span class="string">&quot;,name:&quot;</span> + name </span><br><span class="line">                + <span class="string">&quot;,age:&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：Person DeserialPerson: 1234,name:wang,age:0<br>说明序列化，反序列化正常，B端新增加的int字段被赋予了默认值0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.entity.serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.weaver.ast.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> staticVar = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 初始时staticVar为5</span></span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;result.obj&quot;</span>));</span><br><span class="line">            out.writeObject(<span class="keyword">new</span> TestStatic());</span><br><span class="line">            out.close();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 序列化后修改为10</span></span><br><span class="line">            TestStatic.staticVar = <span class="number">10</span>;</span><br><span class="line">            ObjectInputStream oin = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;result.obj&quot;</span>));</span><br><span class="line">            TestStatic t = (TestStatic) oin.readObject();</span><br><span class="line">            oin.close();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 再读取，通过t.staticVar打印新的值</span></span><br><span class="line">            System.out.println(t.staticVar);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清单 2 中的 main 方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单 2，这个 System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？</p>
<p>最后的输出是 10，对于无法理解的读者认为，打印的 staticVar 是从读取的对象里获得的，应该是保存时的状态才对。之所以打印 10 的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。</p>
<h3 id="父类的序列化与-Transient-关键字"><a href="#父类的序列化与-Transient-关键字" class="headerlink" title="父类的序列化与 Transient 关键字"></a>父类的序列化与 Transient 关键字</h3><p>情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。</p>
<p>解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就 需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。</p>
<p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<p>特性使用案例</p>
<p>我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化。</p>
<h3 id="static-final-修饰的serialVersionUID如何被写入到序列化文件中的，看下面的源码："><a href="#static-final-修饰的serialVersionUID如何被写入到序列化文件中的，看下面的源码：" class="headerlink" title="static final 修饰的serialVersionUID如何被写入到序列化文件中的，看下面的源码："></a>static final 修饰的serialVersionUID如何被写入到序列化文件中的，看下面的源码：</h3><p>序列化写入时的ObjectStreamClass.java中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void writeNonProxy(ObjectOutputStream out) throws IOException &#123;</span><br><span class="line">        out.writeUTF(name);</span><br><span class="line">        out.writeLong(getSerialVersionUID());</span><br><span class="line"></span><br><span class="line">        byte flags &#x3D; 0;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public long getSerialVersionUID() &#123;</span><br><span class="line">    &#x2F;&#x2F; REMIND: synchronize instead of relying on volatile?</span><br><span class="line">    if (suid &#x3D;&#x3D; null) &#123;</span><br><span class="line">        suid &#x3D; AccessController.doPrivileged(</span><br><span class="line">            new PrivilegedAction&lt;Long&gt;() &#123;</span><br><span class="line">                public Long run() &#123;</span><br><span class="line">                    return computeDefaultSUID(cl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    return suid.longValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/285763/201704/285763-20170405104723582-736173583.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/06/30/4.27.%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" data-id="ckw61sdv90021oswdb6d721xo" data-title="序列化与反序列化" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-电商项目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T08:50:13.000Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/28/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/">电商项目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>商品、单品、SPU、SKU</p>
<h3 id="SPU"><a href="#SPU" class="headerlink" title="SPU"></a>SPU</h3><p>SPU是(Standard Product Unit)标准化产品单元，区分品种,该集合描述了一个产品的特性。属性值、特性相同的商品就可以称为一个SPU。</p>
<p>例如，iphone4就是一个SPU，N97也是一个SPU，这个与商家无关，与颜色、款式、套餐也无关。</p>
<h3 id="SKU"><a href="#SKU" class="headerlink" title="SKU"></a>SKU</h3><p>SKU是（stock keeping unit）库存量单位，区分单品，库存进出计量的单位， 可以是以件、盒、托盘等为单位。在服装、鞋类商品中使用最多最普遍。 </p>
<p>例如纺织品中一个SKU通常表示：规格、颜色、款式。 SKU是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。比如一香烟是50条，一条里有十盒，一盒中有20支，这些单位就要根据不同的需要来设定SKU</p>
<p>商品特指与商家有关的商品，可对应多个SKU</p>
<p>sku通常在电商项目里代表库存。可以放在product表里，也可以拆出来放在库存表里，看你们自己的表结构设计了。</p>
<h3 id="订单"><a href="#订单" class="headerlink" title="订单"></a>订单</h3><table>
<thead>
<tr>
<th>订单状态</th>
<th>状态说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>待付款</strong></td>
<td>成功创建订单，但还未支付</td>
</tr>
<tr>
<td>已付款</td>
<td>订单成功支付</td>
</tr>
<tr>
<td><strong>待发货</strong></td>
<td>订单货物已完成配货，正在等待快递发出</td>
</tr>
<tr>
<td>已发货（<strong>待收货</strong>）</td>
<td>订单货物已发出，可以根据物流号在本站或相关物流公司网站查询订单配送状态</td>
</tr>
<tr>
<td>已收货</td>
<td>订单商品已经到了下单时选择的收货地址，手动确认收货或者系统自动收货</td>
</tr>
<tr>
<td>已完成*</td>
<td>已核对并签收订单商品30天（可配置）</td>
</tr>
<tr>
<td><strong>已取消</strong></td>
<td>表示由您自己或委托客服取消的订单</td>
</tr>
<tr>
<td>已确认（货到付款）</td>
<td>货到付款的订单需要本商城人员确认</td>
</tr>
</tbody></table>
<h4 id="前端（VUE）"><a href="#前端（VUE）" class="headerlink" title="前端（VUE）"></a>前端（VUE）</h4><p>实现1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;recomTime&quot; v-show&#x3D;&quot;orderinfo.orderState&#x3D;&#x3D;&#39;1&#39;&quot;&gt;剩余支付时间 &#123;&#123;rocallTime&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当 this.orderinfo.orderState&#x3D;&#x3D;&#39;1&#39; 调 this.ComputetTime(data) 即可</span><br><span class="line">&#x2F;&#x2F;支付倒计时</span><br><span class="line">    ComputetTime(data) &#123;</span><br><span class="line">      let st &#x3D; data.currentTime.replace(&#x2F;\-&#x2F;g, &quot;&#x2F;&quot;),&#x2F;&#x2F;当前服务器时间</span><br><span class="line">        ct &#x3D; data.formatCreateTime.replace(&#x2F;\-&#x2F;g, &quot;&#x2F;&quot;);&#x2F;&#x2F;创建订单时间</span><br><span class="line">      let ts &#x3D; new Date(st).getTime(),</span><br><span class="line">        tc &#x3D; new Date(ct).getTime();</span><br><span class="line">      let cm &#x3D; 15 * 60 * 1000 - (ts - tc);</span><br><span class="line">      this.runBack(cm);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    runBack(cm) &#123;</span><br><span class="line">      if (cm &gt; 0) &#123;</span><br><span class="line">        cm &gt; 60000 ? (</span><br><span class="line">                this.rocallTime &#x3D;</span><br><span class="line">                    (new Date(cm).getMinutes() &lt; 10 ? &quot;0&quot; + new Date(cm).getMinutes() : new Date(cm).getMinutes())</span><br><span class="line">                    + &quot;:&quot; +</span><br><span class="line">                    (new Date(cm).getSeconds() &lt; 10 ? &quot;0&quot; + new Date(cm).getSeconds() : new Date(cm).getSeconds())</span><br><span class="line">            )</span><br><span class="line">            :</span><br><span class="line">            (this.rocallTime &#x3D; &quot;00:&quot; + (new Date(cm).getSeconds() &lt; 10 ? &quot;0&quot; + new Date(cm).getSeconds() : new Date(cm).getSeconds()));</span><br><span class="line">        let _msThis &#x3D; this;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">          cm -&#x3D; 1000;</span><br><span class="line">          _msThis.runBack(cm);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.changeOrderState();&#x2F;&#x2F;调用改变订单状态接口</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>实现2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">countDown() &#123;</span><br><span class="line">  this.time &#x3D; this.time.replace(&#x2F;-&#x2F;g, &quot;&#x2F;&quot;);</span><br><span class="line">  let currentTime &#x3D; new Date().getTime();</span><br><span class="line">  let createTime &#x3D; new Date(this.time).getTime();</span><br><span class="line">  let difference &#x3D; (currentTime - createTime) &#x2F; 1000;</span><br><span class="line">  if (difference &gt; 600) &#123;</span><br><span class="line">    this.showCountDown &#x3D; false;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  let _minute &#x3D; 9 - Math.floor((currentTime - createTime) &#x2F; 1000 &#x2F; 60);</span><br><span class="line">  let _second &#x3D; 60 - Math.floor((currentTime - createTime) &#x2F; 1000 % 60);</span><br><span class="line">  let timer &#x3D; window.setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    _second--;</span><br><span class="line">    if (_second &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      if (_minute &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        const res &#x3D; this.$request.post(&#39;&#x2F;queryorder&#39;, &#123;orderSn: this.orderSn&#125;);</span><br><span class="line">        if (res.data.code !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          this.showCountDown &#x3D; false;</span><br><span class="line">          window.clearInterval(timer);</span><br><span class="line">          window.location.reload();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      _second &#x3D; 59;</span><br><span class="line">      _minute &#x3D; _minute - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    this.second &#x3D; _second &lt; 10 ? &#39;0&#39; + _second : _second;</span><br><span class="line">    this.minute &#x3D; &#39;0&#39; + _minute;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h4 id="订单超时未支付自动关闭实现（后端java）"><a href="#订单超时未支付自动关闭实现（后端java）" class="headerlink" title="订单超时未支付自动关闭实现（后端java）"></a><strong>订单超时未支付自动关闭实现</strong>（后端java）</h4><p>思路：</p>
<p>1.采用定时轮询（数据库消耗大）</p>
<p>2.前端访问时再更新（用户体验差）</p>
<p>3.采用延时任务</p>
<p>​    1）java自带的DelayQueue</p>
<p>​    2）redis实现延时队列: zset的score实现，redis的过期属性实现</p>
<p>​    3）时间轮（netty，kafka等都有）</p>
<p>​    4）消息中间件（Rabbit MQ,Rocket MQ ）</p>
<p>4.可以在数据里加一个过期字段（或者根据创建时间字段来判断是否过期），等查询订单时判断是否过期来是否进行更新操作，返回结果。</p>
<p><strong>定时任务</strong></p>
<p>实现思路比较简单。启动一个计划任务，每隔一定时间处理一次，这种处理方式只是适用比较小而简单的项目。</p>
<p>假设订单表的结构为：</p>
<p>t_order(oid, finish_time, stars, status, …)</p>
<p>然后，定时任务每隔一个 5 分钟（时间自己设定）等会这么做一次：</p>
<p>select oid from t_order where finish_time &gt; 30分钟 and status=0;</p>
<p>update t_order set status=1 where oid in(超时订单id);</p>
<p>如果数据量很大，需要分页查询，分页 update，这将会是一个 for 循环。</p>
<p>但是，这种设计方案有一种明显的不足。</p>
<ol>
<li>时效性差，会有一定的延迟，这个延迟时间最大就是每隔一定时间的大小，如果你设置每分钟定时轮询一次，那么理论上订单取消时间的最大误差就有一分钟，当然也可能更大，比如一分钟之内有大量数据，但是一分钟没处理完，那么下一分钟的就会顺延。</li>
<li>效率低。</li>
<li>对数据库的压力比较大。</li>
</ol>
<p>但是，也有优势。</p>
<ol>
<li>定时任务，实现起来简单。</li>
<li>也能很好的做分布式集群。</li>
</ol>
<p>可以用quartz来实现，也可以用java的schedule实现</p>
<p>应该采用延时任务</p>
<p>​    定时任务有明确的触发时间，延时任务没有</p>
<p>​    定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期</p>
<p>​    定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务</p>
<p><strong>被动取消</strong></p>
<p>这种实现方案和懒加载的思想一致，就是被动的取消订单。只有当用户或商户查询订单信息时，再判断该订单是否超时，如果超时再进行超时逻辑的处理。</p>
<p>但是这种方式依赖于用户的查询操作触发，这也就是说如果用户不进行查询订单的操作，该订单就永远不会被取消。不会取消的订单，也就可能意味着库存可能被占用。</p>
<p>所以，在实际实现上，可能是被动取消 + 定时任务的这种组合实现方式。这种情况下定时任务的时间可以设置的稍微“长“一点。</p>
<p>缺点：</p>
<ol>
<li>会产生额外影响，比如统计，订单数，库存等产生影响。</li>
<li>影响用户体验，用户打开订单列表可能要处理大量数据，影响显示的实时性。</li>
</ol>
<p>优点，同样是实现起来简单。</p>
<p><strong>延时消息</strong>（可见redis部分的延时队列实现）</p>
<p>这种方式是目前比较普遍的实现方式。</p>
<p>延时消息的这种实现方式，包含两个重要的数据结构：</p>
<ol>
<li>环形队列，例如可以创建一个包含 2400 个 slot 的环形队列（本质是个数组）。</li>
<li>任务集合，环上每一个 slot 是一个 Set。</li>
</ol>
<p>本质上，就是一个时间轮算法的一个实现。</p>
<p><img src="/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/558c8cbd9a02e2a923ee5081dc388e44.png" alt="订单超时未支付自动关闭的几种实现方案_Java"></p>
<p>如果公司允许，可以在此基础上，扩展成一个分布式的，支持集群的延时队列。但是缺点是，难度较高，小公司根本没有这个机会来做。</p>
<p><strong>Redis 缓存</strong></p>
<p>利用 redis 的 zset。zset是一个有序集合，每一个元素(member)都关联了一个 score，通过 score 排序来取集合中的值。</p>
<p>我们将订单超时时间戳与订单号分别设置为 score 和 member。系统扫描第一个元素判断是否超时，具体如下图所示。</p>
<p><img src="/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/107be688a9140c5b4ecf06e09370e2f4.png" alt="img"></p>
<p>但是，这种实现方式，在高并发条件下，多消费者可能会取到同一个订单号。多个线程消费同一个资源的情况。</p>
<p>解决方案：1.加一个分布式锁来处理。但是，性能下降严重。2.采用对ZREM的返回值进行判断，只有大于0的时候，才消费数据</p>
<p>使用redis的Keyspace Notifications，中文翻译就是键空间机制，就是利用该机制可以在key失效之后，提供一个回调，实际上是redis会给客户端发送一个消息。是需要redis版本2.8以上。</p>
<p>注：Redis的发布/订阅目前是即发即弃(fire and forget)模式的，因此无法实现事件的可靠通知。也就是说，如果发布/订阅的客户端断链之后又重连，则在客户端断链期间的所有事件都丢失了。因此，方案二不是太推荐。当然，如果你对可靠性要求不高，可以使用。</p>
<p>优点:(1)由于使用Redis作为消息通道，消息都存储在Redis中。如果发送程序或者任务处理程序挂了，重启之后，还有重新处理数据的可能性。(2)做集群扩展相当方便 (3)时间准确度高</p>
<p>缺点:(1)需要额外进行redis维护</p>
<p><strong>JDK的延迟队列</strong></p>
<p>利用JDK自带的DelayQueue来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入DelayQueue中的对象，是必须实现Delayed接口的。</p>
<p><img src="/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/558c8cbd9a02e2a923ee5081dc388e44.png" alt="订单超时未支付自动关闭的几种实现方案_Java"></p>
<p>Poll():获取并移除队列的超时元素，没有则返回空</p>
<p>take():获取并移除队列的超时元素，如果没有则wait当前线程，直到有元素满足超时条件，返回结果。</p>
<p>优点:效率高,任务触发时间延迟低。</p>
<p>缺点:</p>
<p>(1)服务器重启后，数据全部消失，怕宕机 </p>
<p>(2)集群扩展相当麻烦 </p>
<p>(3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM（out of memory）内存溢出异常 </p>
<p>(4)代码复杂度较高</p>
<p><strong>时间轮算法</strong></p>
<p><img src="/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/640" alt="图片"></p>
<p>时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick。这样可以看出定时轮由个3个重要的属性参数，ticksPerWheel（一轮的tick数），tickDuration（一个tick的持续时间）以及 timeUnit（时间单位），例如当ticksPerWheel=60，tickDuration=1，timeUnit=秒，这就和现实中的始终的秒针走动完全类似了。</p>
<p>如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈。位置是在2圈之后的5上面（20 % 8 + 1）</p>
<p>可以用Netty的HashedWheelTimer来实现</p>
<p>优点:效率高,任务触发时间延迟时间比delayQueue低，代码复杂度比delayQueue低。</p>
<p>缺点:</p>
<p>(1)服务器重启后，数据全部消失，怕宕机</p>
<p>(2)集群扩展相当麻烦</p>
<p>(3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常</p>
<p><strong>消息队列</strong></p>
<p>可以采用rabbitMQ的延时队列。</p>
<p>RabbitMQ具有以下两个特性，可以实现延迟队列：</p>
<p>1.RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter</p>
<p>2.lRabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了deadletter，则按照这两个参数重新路由。</p>
<p>结合以上两个特性，就可以模拟出延迟消息的功能</p>
<p>优点: 高效,可以利用rabbitmq的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。</p>
<p>缺点：本身的易用度要依赖于rabbitMq的运维.因为要引用rabbitMq,所以复杂度和成本变高</p>
<h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><p>最后选择采用redis+delayqueue实现</p>
<p>springboot项目中引入redis可以参考这篇文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/164608337">https://zhuanlan.zhihu.com/p/164608337</a></p>
<p>具体流程：</p>
<p>（1）用户下单完成以后，把订单ID插入到DelayQueue中，同时插入到Redis中。</p>
<p>（2）30分钟之内，用户付款完成，则从DelayQueue中删除，从Redis中删除。</p>
<p>（3）超过30分钟，DelayQueue中的订单ID出队，查询数据库，改状态为取消，删除redis。</p>
<p>（4）如果30分钟之类，服务器重启，则服务器重新启动以后，从redis中读取待订单，重新插入到DelayQueue。</p>
<p>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。</p>
<p>Delayed，用来标记那些应该在给定延迟时间之后执行的对象。此接口的实现必须定义一个 compareTo 方法，该方法提供与此接口的 getDelay 方法一致的排序。</p>
<p>我们首先实现一个BaseDelayed，所有的DelayQueue中的元素必须要实现Delayed接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDelayed</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> startTime;  </span><br><span class="line">  <span class="keyword">private</span> T value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BaseDelayed</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BaseDelayed</span><span class="params">(<span class="keyword">int</span> timeout, T value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置超时出队的时间点</span></span><br><span class="line">    <span class="keyword">this</span>.startTime = System.currentTimeMillis() + timeout*<span class="number">1000L</span>;  </span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**离出队还有多长时间**/</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unit.convert(<span class="keyword">this</span>.getStartTime() - System.currentTimeMillis(), TimeUnit.MILLISECONDS);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**设置队列中元素出队的先后顺序**/</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (other == <span class="keyword">this</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(other <span class="keyword">instanceof</span> BaseDelayed)&#123;  </span><br><span class="line">          BaseDelayed&lt;?&gt; otherRequest = (BaseDelayed&lt;?&gt;)other;  </span><br><span class="line">          <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="keyword">this</span>.getStartTime() - otherRequest.getStartTime());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个超时出队的监听：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnDelayedListener</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseDelayed</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDelayedArrived</span><span class="params">(T delayed)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个DelayedService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在DelayedService加载以后，会回调InitializingBean接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedService</span> <span class="keyword">implements</span>  <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(DelayedService.class);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> DelayQueue&lt;BaseDelayed&lt;?&gt;&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;BaseDelayed&lt;?&gt;&gt;();</span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">static</span> ConcurrentHashMap&lt;Class&lt;? extends BaseDelayed&gt;, OnDelayedListener&gt; listeners = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;? extends BaseDelayed&gt;, OnDelayedListener&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean start = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T extends BaseDelayed&lt;?&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(Class&lt;T&gt; clazz, OnDelayedListener&lt;T&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(clazz == <span class="keyword">null</span> || listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listeners.put(clazz, listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里启动从DelayQueue中读数据的线程</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.get()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    start.set(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 启动读DelayQueue的线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;DelayedService start&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//从DelayQueue中出队</span></span><br><span class="line">            BaseDelayed&lt;?&gt; baseDelayed = delayQueue.take();</span><br><span class="line">            <span class="comment">//所以，需要注册一下监听，该什么时候注册呢？</span></span><br><span class="line">            OnDelayedListener  onDelayedListener = listeners.get(baseDelayed.getClass());</span><br><span class="line">            <span class="keyword">if</span> (onDelayedListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ThreadPoolUtil.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  onDelayedListener.onDelayedArrived(baseDelayed);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//TODO</span></span><br><span class="line">              log.warn(<span class="string">&quot;没有找到监听，丢弃：&#123;&#125;&quot;</span>, baseDelayed.toString());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;DelayedService&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BaseDelayed&lt;?&gt; baseDelayed)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>  &lt;T extends BaseDelayed, K&gt;<span class="function">T <span class="title">getDelayed</span><span class="params">(Class&lt;T&gt; clazz, K key)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T, D extends BaseDelayed&lt;?&gt;&gt; <span class="function">D <span class="title">remove</span><span class="params">(Class&lt;T&gt; clazz , T value)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DelayedService在系统启动完成以后，会回调InitializingBean接口的afterPropertiesSet（），这里我们启动从DelayQueue中读数据的线程，如果读到数据，需要把数据返回出去，所以就需要注册一些等待数据的监听，该什么时候注册呢？</p>
<p>我们本例中是需要一个OrderService的，可以在OrderService加载完成以后来注册监听：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>   </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DelayedService delayedService;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  RedisService redisService;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//系统启动，注册监听</span></span><br><span class="line">    delayedService.registerListener(DelayedOrder.class, <span class="keyword">new</span> OnDelayedListener&lt;DelayedOrder&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDelayedArrived</span><span class="params">(DelayedOrder order)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;onDelayedArrived:&#123;&#125;&quot;</span>, order.toString());</span><br><span class="line">        <span class="comment">//查询订单的状态</span></span><br><span class="line">        <span class="keyword">int</span> status = <span class="number">0</span>;<span class="comment">//0代表未支付</span></span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//自动取消订单</span></span><br><span class="line">          autoCancelOrder(order);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="number">1</span>)&#123;<span class="comment">//1代表已经支付</span></span><br><span class="line">          <span class="comment">//do nothing</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="number">2</span>)&#123;<span class="comment">//已经取消</span></span><br><span class="line">          <span class="comment">//do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//把redis中的订单重新插入队列</span></span><br><span class="line">    ThreadPoolUtil.execute(()-&gt;&#123;</span><br><span class="line">      List&lt;DelayedOrder&gt; orders = redisService.getFromSet(ORDER_KEY, DelayedOrder.class);</span><br><span class="line">      <span class="keyword">if</span>(orders != <span class="keyword">null</span> &amp;&amp; orders.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(DelayedOrder order : orders) &#123;</span><br><span class="line">          delayedService.add(order);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**创建订单**/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DelayedOrder <span class="title">createOrder</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**支付订单**/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">payOrder</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**自动取消订单**/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">autoCancelOrder</span><span class="params">(DelayedOrder order)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，如果服务器重启过，OrderService加载完成以后，还要去redis中把那些订单查出来，插入到DelayQueue中。</p>
<p>DelayedOrder定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedOrder</span> <span class="keyword">extends</span> <span class="title">BaseDelayed</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">/**默认过期时间是30分钟*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> timeout = <span class="number">30</span> * <span class="number">60</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DelayedOrder</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DelayedOrder</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(timeout, orderId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DelayedOrder</span><span class="params">(<span class="keyword">int</span> timeoutSeconds, String orderId)</span> </span>&#123;<span class="comment">//TODO 测试用</span></span><br><span class="line">    <span class="keyword">super</span>(timeoutSeconds, orderId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果系统中还有别的这种任务，还可以继续继承BaseDelayed来进行添加。</p>
<p>controller就没什么好说的了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  OrderService orderService;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/create&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">createOrder</span><span class="params">(<span class="meta">@RequestParam(&quot;orderId&quot;)</span>String orderId)</span> </span>&#123;</span><br><span class="line">    DelayedOrder order = orderService.createOrder(orderId);</span><br><span class="line">    <span class="keyword">return</span> order.getValue();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/pay&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">payOrder</span><span class="params">(<span class="meta">@RequestParam(&quot;orderId&quot;)</span>String orderId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ret = orderService.payOrder(orderId);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<p>浏览器执行：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/order/create?orderId=order1">http://localhost:8080/order/create?orderId=order1</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/order/create?orderId=order2">http://localhost:8080/order/create?orderId=order2</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/order/create?orderId=order3">http://localhost:8080/order/create?orderId=order3</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/order/pay?orderId=order1">http://localhost:8080/order/pay?orderId=order1</a></p>
<p>然后关闭服务器。</p>
<p>此时查看redis中的数据有order2和order3两条。</p>
<p>重启开启服务器：</p>
<p>redis中的order2和order3被重新插入到DelayQueue，超时以后，出队，订单置为自动取消，同时从redis中删除掉。</p>
<p>实际项目里引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RedisConfig类重新设置redisTemplate</span><br><span class="line">新建RedisService类，装饰redisTemplate的方法</span><br><span class="line">新建BaseDelayed抽象类提供设置 超时出队的时间点，离出队还有多长时间，队列中元素出队的先后顺序 的方法</span><br><span class="line">新建DelayedOrder类继承BaseDelayed设置超时时间</span><br><span class="line">新建DelayedService实现InitializingBean接口（这个接口里只有唯一的方法afterPropertiesSet），照搬方法</span><br><span class="line">新建OnDelayedListener的接口来提供注册监听器的方法</span><br><span class="line"></span><br><span class="line">业务逻辑使用：</span><br><span class="line">1.controller层写接口</span><br><span class="line">2.service层写业务逻辑：</span><br><span class="line">	首先这个类要继承InitializingBean接口</span><br><span class="line">	在生成订单时：</span><br><span class="line">		DelayedOrder delayedOrder &#x3D; new DelayedOrder(orderSn);</span><br><span class="line">        &#x2F;&#x2F; 插入内存队列</span><br><span class="line">        delayedService.add(delayedOrder);</span><br><span class="line">        &#x2F;&#x2F; 插入redis</span><br><span class="line">        redisService.addToSet(ORDER_KEY, delayedOrder);</span><br><span class="line">	在service层的实现类重写afterPropertiesSet方法：（相当于是重新启动项目后执行的方法，将redis中的数据重新插入延时队列）</span><br><span class="line">		系统启动，注册监听，重写onDelayedArrived方法：查询订单状态做处理，将订单号从延迟队列和reids删除。再将剩余未删除的插入延迟队列（通过线程池的ThreadPoolUtil.execute方法实现）</span><br></pre></td></tr></table></figure>

<p>InitializingBean接口是实现注入bean的初始化（<strong>在任意地方注入bean（比如需要调用service时，会自动装填bean），都会直接执行重写的afterPropertiesSet方法，不用主动调用</strong>）</p>
<p>1、Spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中通过init-method指定，两种方式可以同时使用。</p>
<p>2、实现InitializingBean接口是直接调用afterPropertiesSet方法，比通过反射调用init-method指定的方法效率要高一点，但是init-method方式消除了对spring的依赖。</p>
<p>3、如果调用afterPropertiesSet方法时出错，则不调用init-method指定的方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://s-qwer.github.io/2021/06/28/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/" data-id="ckw61sdwp0065oswd2ktift4h" data-title="电商项目" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitee/" rel="tag">Gitee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HATEOAS/" rel="tag">HATEOAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/" rel="tag">JSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis-Plus/" rel="tag">MyBatis-Plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">MySQL基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Navicat/" rel="tag">Navicat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBOOTCMS/" rel="tag">PBOOTCMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" rel="tag">PO-BO-VO，DTO-DAO与POJO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Portainer-io/" rel="tag">Portainer.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/" rel="tag">WEB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/" rel="tag">WebRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/for%E5%BE%AA%E7%8E%AF/" rel="tag">for循环</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if/" rel="tag">if</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E6%A6%82%E8%BF%B0/" rel="tag">java概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/" rel="tag">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngnix/" rel="tag">ngnix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/" rel="tag">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/" rel="tag">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springfox/" rel="tag">springfox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swagger/" rel="tag">swagger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vite/" rel="tag">vite</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" rel="tag">与人沟通</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6/" rel="tag">书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" rel="tag">内部类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" rel="tag">历史版本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" rel="tag">压缩算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="tag">基础概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" rel="tag">小科普</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" rel="tag">工具类代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85/" rel="tag">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" rel="tag">搜索技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" rel="tag">新环境</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">消息中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%99%BE%E5%BA%A6/" rel="tag">百度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%8E%86/" rel="tag">经历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" rel="tag">编程规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" rel="tag">设计规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C/" rel="tag">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AE%E5%AD%90/" rel="tag">轮子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" rel="tag">软件说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" rel="tag">逻辑判断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" rel="tag">项目合作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/ElasticSearch/" style="font-size: 10px;">ElasticSearch</a> <a href="/tags/Gitee/" style="font-size: 10px;">Gitee</a> <a href="/tags/HATEOAS/" style="font-size: 10px;">HATEOAS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/MyBatis-Plus/" style="font-size: 10px;">MyBatis-Plus</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">MySQL基础概念</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/PBOOTCMS/" style="font-size: 10px;">PBOOTCMS</a> <a href="/tags/PO-BO-VO%EF%BC%8CDTO-DAO%E4%B8%8EPOJO/" style="font-size: 10px;">PO-BO-VO，DTO-DAO与POJO</a> <a href="/tags/Portainer-io/" style="font-size: 10px;">Portainer.io</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/WebRTC/" style="font-size: 10px;">WebRTC</a> <a href="/tags/for%E5%BE%AA%E7%8E%AF/" style="font-size: 10px;">for循环</a> <a href="/tags/git/" style="font-size: 20px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/java%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">java概述</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/ngnix/" style="font-size: 10px;">ngnix</a> <a href="/tags/node-js/" style="font-size: 20px;">node.js</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springfox/" style="font-size: 10px;">springfox</a> <a href="/tags/swagger/" style="font-size: 10px;">swagger</a> <a href="/tags/vite/" style="font-size: 10px;">vite</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%B8%8E%E4%BA%BA%E6%B2%9F%E9%80%9A/" style="font-size: 10px;">与人沟通</a> <a href="/tags/%E4%B9%A6/" style="font-size: 10px;">书</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/" style="font-size: 10px;">内部类</a> <a href="/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/" style="font-size: 10px;">历史版本</a> <a href="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">压缩算法</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">基础概念</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E5%B0%8F%E7%A7%91%E6%99%AE/" style="font-size: 10px;">小科普</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/" style="font-size: 10px;">工具类代码</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 20px;">快捷键</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 10px;">打包</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" style="font-size: 10px;">抽象类</a> <a href="/tags/%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">接口</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">搜索技巧</a> <a href="/tags/%E6%94%B6%E8%97%8F/" style="font-size: 10px;">收藏</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%96%B0%E7%8E%AF%E5%A2%83/" style="font-size: 10px;">新环境</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">消息中间件</a> <a href="/tags/%E7%99%BE%E5%BA%A6/" style="font-size: 10px;">百度</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">类型转换</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%8F%E5%8E%86/" style="font-size: 10px;">经历</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" style="font-size: 10px;">编程规范</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" style="font-size: 10px;">设计规范</a> <a href="/tags/%E8%B0%B7%E6%AD%8C/" style="font-size: 10px;">谷歌</a> <a href="/tags/%E8%BD%AE%E5%AD%90/" style="font-size: 10px;">轮子</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">软件说明</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/" style="font-size: 10px;">逻辑判断</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%90%88%E4%BD%9C/" style="font-size: 10px;">项目合作</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/17/8.7.vite/">vite</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/">工具类代码</a>
          </li>
        
          <li>
            <a href="/2021/09/03/RPC/">RPC</a>
          </li>
        
          <li>
            <a href="/2021/09/02/%E6%97%A5%E5%BF%97/">日志</a>
          </li>
        
          <li>
            <a href="/2021/08/27/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/">开源软件许可协议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 swx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>